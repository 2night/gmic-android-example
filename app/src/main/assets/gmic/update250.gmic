#@gmic
#
#  File        : gmic_stdlib.gmic
#                ( G'MIC command file )
#
#  Description : GREYC's Magic for Image Computing - Standard library
#                ( https://gmic.eu )
#
#  Copyright   : David Tschumperle
#                ( https://tschumperle.users.greyc.fr/ )
#
#  Licenses    : This file is 'dual-licensed', you have to choose one
#                of the two licenses below to apply.
#
#                CeCILL-C
#                The CeCILL-C license is close to the GNU LGPL.
#                ( http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html )
#
#            or  CeCILL v2.1
#                The CeCILL license is compatible with the GNU GPL.
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html )
#
#  This software is governed either by the CeCILL or the CeCILL-C license
#  under French law and abiding by the rules of distribution of free software.
#  You can  use, modify and or redistribute the software under the terms of
#  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
#  at the following URL: "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
#

#------ Syntax rules for a G'MIC command file :
#
#*** General syntax :
#
# - Each line starting with 'command_name :' starts a new definition of the G'MIC custom command 'command_name'.
# - Each line starting with '#' is a comment line.
# - Any other line is considered as the continuation of a previously started G'MIC custom command.
#
#*** Specific rules for the command-line interface 'gmic':
#
# - A comment line starting with '#@cli' will be parsed by 'gmic' to display help for
#    G'MIC custom commands (when invoked with option 'h'). More precisely :
#
#      _ '#@cli :: subsection' defines a new command subsection in the displayed help.
#      _ '#@cli command_name : arguments_format1 : arguments_format2 : ... : (qualifier)'
#        starts a new command description.
#      _ '#@cli : description' add a new description line to the current command description.
#
#*** Specific rules for the universal plug-in :
#
# - A comment line starting with '#@gui' will be parsed by the plug-in to define the filters tree.
# - A comment line starting with '#@gui_xx' will define a filter only for a specific language 'xx'
#    (e.g. 'en','fr'...).
# - A comment line starting with '#@gui_xx hide(/Filter or folder name)' will hide the existing
#    filter of folder for the locale 'xx'.
# - More precisely, the syntax of a '#@gui' comment line is :
#
#    '#@gui Folder name'
#
# or
#
#    '#@gui Command name : command, preview_command, parameter = typedef, parameter2 = typedef'
#    '#@gui : parameter3 = typedef, parameter4 = typedef ...., parameterN = typedef'
#
#   where :
#
#      'command' is the G'MIC command name called to process the image.
#
#      'preview_command' is the G'MIC command name called to process the preview.
#
#           Note that you can optionally specify a float-valued factor>=0 between parentheses at the end of
#           the 'preview_command' to force the default zoom factor used by the preview for this filter.
#           Use (0) for a 1:1 preview, (1) for previewing the whole image, (2) for 1/2 image and so on...
#           You can also put an additional '+' sign after the parenthesis to specify the rendered preview
#           is still accurate for different zoom factors.
#
#      'parameter = typedef' tells about the names, types and default values of the filter parameters.
#
#           'typedef' can be :
#
#      _ 'bool(default_value={ 0 | 1 | false | true })'                           : Add a boolean parameter (0 or 1) (as a checkbutton).
#      _ 'button(_alignment)'                                                     : Add a boolean parameter (0 or 1) (as a button).
#      _ 'choice(_default_index,Choice0,..,ChoiceN)'                             : Add a integer parameter (as a combobox).
#      _ 'color(R,_G,_B,_A)'                                                      : Add R,G,B[,A] parameters (as a colorchooser).
#      _ 'point(_X,_Y,_removable={ -1 | 0 | 1 },_burst={ 0 | 1 },_R,_G,_B,_[-]A,_radius%,_is_visible={ 0 | 1 })' :
#          Add X,Y parameters (as a moveable point over the preview).
#      _ 'value(value)'                                                           : Add a pre-defined value parameter (not displayed).
#      _ 'file[_in,_out](_default_filename)'                                      : Add a filename parameter (as a filechooser).
#      _ 'float(default_value,min_value,max_value)'                               : Add a float-valued parameter (as a float slider).
#      _ 'folder(_default_foldername)'                                            : Add a foldername parameter (as a folderchooser).
#      _ 'int(default_value,min_value,max_value)'                                 : Add a integer parameter (as an integer slider).
#      _ 'link(_alignment,_label,URL)'                                            : Display a URL (do not add a parameter).
#      _ 'note(_label)'                                                           : Display a label (do not add a parameter).
#      _ 'text(_is_multiline={ 0 | 1 },_default text)'                            : Add a single or multi-line text parameter (as a text entry).
#      _ 'separator()'                                                            : Display an horizontal separator (do not add a parameter).
#
#   Type separators '()' can be replaced by '[]' or '{}' if necessary (for instance if parentheses are required in
#   an argument of the typedef, e.g in a text). You can also replace 'typedef' by '_typedef' to tell the plug-in not
#   to update the image preview when the corresponding parameter is modified.
#   After the closing separator, you may specify a 'visibility state' suffix for the parameter, which can be
#    { _0: Hidden | _1: Grayed-out | _2: Visible (default) }.
#
#   Use '_none_' as a special command or preview_command to tell the plug-in that the entry requires no G'MIC call.
#
#   A G'MIC command can return new values for each parameter of the filter, into the status (see command 'status').
#   To do so, the returned status must follow the syntax : {params1}{params2}{..}{paramsN} where N must be exactly
#   equal to the number of parameters for the current filter. Optionnally, you can append to each {param}
#   its visibility state suffix ( e.g: {param}_1 ).
#
#   A G'MIC command can also specify the blending mode, the opacity and the position of each of the output image
#   (i.e. layer in the plug-in). To do so, set the image name to something like 'mode(grainmerge),opacity(50),pos(30,50),name(name)'.
#     - Blending mode name should be the same as the argument of the 'blend' command.
#     - Opacity is a float number in [0,100].
#     - X and Y positions are integers.
#     - 'name' is the layer name.
#
#-----------------------------------------------------------------------------------------------------------------------

#---------------------------------
#
#@cli :: Global Options
#
#---------------------------------

# This command is run when the cli tool 'gmic' is invoked without arguments on the command line.
cli_noarg :
  use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r version
  v + e[] "\n[gmic] No commands, options or data provided (type "${c}"'gmic help'"$n" to get help)." v -
  if {{*,u}>0}
    v + e[] "[gmic] "${c}"Running in demo mode."$n v - parallel 0,"demo ," e[] ""
  else
    v + e[] "\n" v -
  fi
  file_update=${_path_rc}update$_version.gmic
  need_update={"Y = date(0); M = date(1); D = date(2); date_current = Y*365 + M*31 + D;
                Y = date(0,'"$file_update"'); M = date(1,'"$file_update"'); D = date(2,'"$file_update"'); date_file = Y*365 + M*31 + D;
                date_current - date_file>=7"}
  if $need_update
    v + e[] "[gmic] Update commands..." v -
    l[] update
      v + e[] "\r[gmic] Update commands: "${g}"Succeeded!"$n v -
    onfail
      v + e[] "\r[gmic] Update commands: "${r}"Failed!"$n v -
    endl
  fi

# This command is called each time the cli interface 'gmic' starts.
# Overload it in your local user command file if necessary.
cli_start :

#@cli debug : (+)
#@cli : Activate debug mode.
#@cli : When activated, the G'MIC interpreter becomes very verbose and outputs additional log
#@cli : messages about its internal state on the standard output (stdout).
#@cli : This option is useful for developers or to report possible bugs of the interpreter.

#@cli h : eq. to 'help'.
h :
  help $*

#@cli help : command : (no arg)
#@cli : Display help (optionally for specified command only) and exit.
#@cli : (eq. to 'h').
help : skip ${1=""},${2=1}
  if {!$!} return fi
  y a y
  +_help $1,$2 k[0]
  if {narg(${})} _help[0] ${},0 fi # In case of shortcut, display also help for shortcut command.
  rm

_help : skip ${1=""}
  v -1 use_vt100
  if {!narg("$1")} _is_example=0 __help ascii v + e[] "" v - rm u "" return fi # Global help.

  ({'"$1"'}) autocrop. {'-'}
  if {{@100%}==_']'" && "i!=_'['} l. s -,{'['} k[0] endl fi
  command={t} rm.

  # Help requested for a specific command.
  ks0="0" ks1="k[0]"
  if $2 e[] "" __help_header_ascii[] fi
  r 1,{h+1},1,1,0,0,0,1
  s +,{'"#@cli "$command" :"'} s +,{'"#@cli "$command":"'} s +,{'"#@cli "$command"\n"'}
  if {$!==1}
    l[] m "foo : "$command # Detect command misspelling.
      repeat 16 uncommand $command done # Be sure the specified command does not exist anymore !
      foo uncommand foo
    onfail ({'${}'}) s -,{'" (did you mean "'} if {$!>1} s[1] -,39 k[1] misspelling={t} fi rm
    endl
    if {narg($misspelling)} misspelling=" (did you mean '"$misspelling"' ?)" fi
    v + e[] "\n[gmic] Command '"$command"' has no description"$misspelling". Try 'gmic -h' for global help.\n\n" v -
    rm u "" return
  fi
  rm[0] a y s -,10
  stopflag=0
  _is_example=0
  _document_gmic_header_ascii[] 0
  repeat $! l[$>] if {h>6" && "same([{^}],'#@cli',5)}
    rows 6,100% autocrop {'" "'}  # Discard '#@cli'.
    if {i!=_':'} # Command declaration.
      s -,{'": "'} autocrop {'" "'} autocrop {':'} autocrop {'" "'}
      if {['{0,t}']==['$command']}
        _document_gmic_declaration_ascii
        if $_shortcut  # Found shortcut command.
          v + e[] "\n    "$_gmic_m${_gmic_b}$command":"$_gmic_n" Shortcut for command '"$_gmic_m$_gmic_b$_shortcutlink0$_gmic_n"'." v -
          u $_shortcutlink0 return
        fi
        else stopflag=1
      fi
    else
      rows 1,100% # Discard ':' char.
      if {i==_':'} stopflag=1 # Subsection
      else
        _is_tutorial=
        autocrop {'" "'}
        if {i==_'$'} # Example of use.
          rows 1,100% autocrop {'" "'} # Discard '$' character.
          if {i==_'$'} # Tutorial page.
             v + e[] "" v -
             if {h==1" && "i==_'$'} tuturl=https://gmic.eu/tutorial/_$command.shtml
             else autocrop {'$'} autocrop {'" "'} tuturl=https://gmic.eu/tutorial/{0,t}.shtml
             fi
             rm ({'$_gmic_n${_gmic_b}"Tutorial:"$_gmic_n$_gmic_r" "$tuturl'}) y
             _is_tutorial=1
          else # Regular example.
            if $_is_example i[0] ({'"\n               "'})
            else i[0] ({'"\n      "$_gmic_n${_gmic_b}"Example: "$_gmic_n'}) _nb_example=0
            fi
            _is_example=1 _nb_example+=1
            i[1] ({'$_gmic_n[#$_nb_example]"  "$_gmic_g'})
            y a y
          fi
        fi
        _document_gmic_description_ascii
      fi
    fi
  else stopflag=1 fi ${ks{$!!=0}} endl if $stopflag break fi done
  v + e[] $_gmic_n"\n" v - rm
  u ""

# Display global help.
__help :
  m "_help_section : _help_section_$1 \"$""1\""
  m "_help_paragraph : _help_paragraph_$1 \"$""1\""
  _help_header_$1[]
  _help_usage[]
  s -,{'__help_end\ :'} k[0] # Avoid parsing code for GUI filters.
  document_gmic $1,"img/",0
  _help_examples[]
  _help_footer_$1[]

# Command to write general usage (used by all types of output).
_help_usage :
  m "GMIC : u ${_gmic_g}G\47MIC$_gmic_n"
  g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r

  _help_paragraph "    "${c}${b}"gmic [command1 [arg1_1,arg1_2,..]] .. [commandN [argN_1,argN_2,..]]"$n"
\n
\n    '"${g}"gmic"$n"' is the open-source interpreter of the "${-GMIC}" language, a script-based programming
\n    language dedicated to the design of possibly complex image processing pipelines and operators.
\n    It can be used to convert, manipulate, filter and visualize image datasets made of one
\n    or several 1D/2D or 3D multi-spectral images.
\n
\n    This reference documentation describes all the technical rules governing the "${-GMIC}" language.
\n    As a starting point, you may want to visit our detailed tutorial pages, at:
\n     "${r}"https://gmic.eu/tutorial/"$n

  _help_section "Overall context"

  _help_paragraph "  - At any time, "${-GMIC}" manages one list of numbered (and optionally named) pixel-based images,
\n     entirely stored in computer memory (uncompressed).
\n
\n  - The first image of the list has index '"${g}"0"$n"' and is denoted by '"${c}"[0]"$n"'. The second image of the
\n     list is denoted by '"${c}"[1]"$n"', the third by '"${c}"[2]"$n"' and so on.
\n
\n  - Negative indices are treated in a periodic way: '"${c}"[-1]"$n"' refers to the last image of the list,
\n     '"${c}"[-2]"$n"' to the penultimate one, etc. Thus, if the list has 4 images, '"${c}"[1]"$n"' and '"${c}"[-3]"$n"' both
\n     designate the second image of the list.
\n
\n  - A named image may be also indicated by '"${c}"[name]"$n"', if '"${g}"name"$n"' uses the character set "${g}"[a-zA-Z0-9_]"$n"
\n     and does not start with a number. Image names can be set or reassigned at any moment during
\n     the processing pipeline (see command '"${c}"name"$n"' for this purpose).
\n
\n  - "${-GMIC}" defines a set of various commands and substitution mechanisms to allow the design of
\n     complex pipelines and operators managing this list of images, in a very flexible way:
\n     You can insert or remove images in the list, rearrange image order, process images
\n     (individually or grouped), merge image data together, display and output image files, etc.
\n
\n  - Such a pipeline can be then added as a new custom "${-GMIC}" command (stored in a user
\n     command file), so it can be re-used afterwards in a larger pipeline if necessary."

  _help_section "Image definition and terminology"

  _help_paragraph "  - In "${-GMIC}", each image is modeled as a 1D, 2D, 3D or 4D array of scalar values, uniformly
\n     discretized on a rectangular/parallelepipedic domain.
\n
\n  - The four dimensions of this array are respectively denoted by:
\n
\n    . '"${g}"width"$n"', the number of image columns (size along the "${g}"'x'-axis"$n").
\n    . '"${g}"height"$n"', the number of image rows (size along the "${g}"'y'-axis"$n").
\n    . '"${g}"depth"$n"', the number of image slices (size along the "${g}"'z'-axis"$n").
\n        (the depth is equal to "${g}"1"$n" for usual color or grayscale 2D images).
\n    . '"${g}"spectrum"$n"', the number of image channels (size along the "${g}"'c'-axis"$n").
\n        (the spectrum is respectively equal to "${g}"3"$n" and "${g}"4"$n" for usual "${g}"RGB"$n" and "${g}"RGBA"$n" color images).
\n
\n  - There are no hard limitations on the size of the image along each dimension. For instance,
\n     the number of image slices or channels can be of arbitrary size within the limits of
\n     the available memory.
\n
\n  - The "${g}"width, height"$n" and "${g}"depth"$n" of an image are considered as spatial dimensions, while the
\n     "${g}"spectrum"$n" has a multi-spectral meaning. Thus, a 4D image in "${-GMIC}" should be most often
\n     regarded as a 3D dataset of multi-spectral voxels. Most of the "${-GMIC}" commands will stick with
\n     this idea (e.g. command '"${c}"blur"$n"' blurs images only along the spatial '"${g}"xyz"$n"'-axes).
\n
\n  - "${-GMIC}" stores all the image data as buffers of '"${g}"float"$n"' values (32 bits, value range
\n     "${g}"[-3.4E38,+3.4E38]"$n"). It performs all its image processing operations with floating point
\n     numbers. Each image pixel takes then 32bits/channel (except if double-precision buffers have
\n     been enabled during the compilation of the software, in which case 64bits/channel can be the
\n     default).
\n
\n  - Considering '"${g}"float"$n"'-valued pixels ensure to keep the numerical precision when executing
\n     image processing pipelines. For image input/output operations, you may want to prescribe the
\n     image datatype to be different than '"${g}"float"$n"' (like '"${g}"bool"$n"', '"${g}"char"$n"', '"${g}"int"$n"', etc...).
\n     This is possible by specifying it as a file option when using I/O commands.
\n     (see section '"${c}"Input/output properties"$n"' to learn more about file options)."

  _help_section "Items of a processing pipeline"

  _help_paragraph "  - In "${-GMIC}", an image processing pipeline is described as a sequence of items separated by the
\n     space character ' '. Such items are interpreted and executed from the left to the right.
\n     For instance, the expression:
\n
\n       "${c}"filename.jpg blur 3,0 sharpen 10 resize 200%,200% output file_out.jpg"$n"
\n
\n     defines a valid pipeline composed of nine "${-GMIC}" items.
\n
\n  - Each "${-GMIC}" item is a string that is either a "${g}"command"$n", a list of command "${g}"arguments"$n",
\n     a "${g}"filename"$n", or a special "${g}"input string"$n".
\n
\n  - Escape characters '"${g}"\\"$n"' and double quotes '"${g}"\""$n"' can be used to define items containing spaces or
\n     other special characters. For instance, the two strings '"${c}"single\\ item"$n"' and '"${c}"\"single item\""$n"'
\n     both define the same single item, with a space in it."

  _help_section "Input data items"

  _help_paragraph "  - If a specified "${-GMIC}" item appears to be an existing filename, the corresponding image data
\n     are loaded and inserted at the end of the image list (which is equivalent to the use of
\n     '"${c}"input filename"$n"').
\n
\n  - Special filenames '"${c}"-"$n"' and '"${c}"-.ext"$n"' stand for the standard input/output streams, optionally
\n     forced to be in a specific '"${g}"ext"$n"' file format (e.g. '"${c}"-.jpg"$n"' or '"${c}"-.png"$n"').
\n
\n  - The following special input strings may be used as "${-GMIC}" items to create and insert new
\n     images with prescribed values, at the end of the image list:
\n
\n    . '"${c}"[selection]"$n"' or '"${c}"[selection]xN"$n"': Insert 1 or N copies of already existing images.
\n       '"${g}"selection"$n"' may represent one or several images
\n       (see section '"${c}"Command items and selections"$n"' to learn more about selections).
\n
\n    . '"${c}"width[%],_height[%],_depth[%],_spectrum[%],_values"$n"': Insert a new image with specified
\n       size and values (adding '"${g}"%"$n"' to a dimension means 'percentage of the size along the same
\n       axis, taken from the last image '"${g}"[-1]"$n"''). Any specified dimension can be also written as
\n       '"${c}"[image]"$n"', and is then set to the size (along the same axis) of the existing specified image
\n       "${g}"[image]"$n". '"${g}"values"$n"' can be either a sequence of numbers separated by commas '"${g}","$n"', or a
\n       mathematical expression, as e.g. in input item '"${c}"256,256,1,3,[x,y,128]"$n"' which
\n       creates a 256x256 RGB color image with a spatial shading on the red and green channels.
\n       (see section '"${c}"Mathematical expressions"$n"' to learn more about mathematical expressions).
\n
\n    . '"${c}"(v1,v2,..)"$n"': Insert a new image from specified prescribed values. Value separator inside
\n       parentheses can be '"${g}","$n"' (column separator), '"${g}";"$n"' (row separator), '"${g}"/"$n"' (slice separator) or
\n       '"${g}"^"$n"' (channel separator). For instance, expression '"${c}"(1,2,3;4,5,6;7,8,9)"$n"' creates a 3x3 matrix
\n       (scalar image), with values running from 1 to 9.
\n
\n    . '"${c}"0"$n"': Insert a new '"${g}"empty"$n"' image, containing no pixel data. Empty images are used only in rare
\n       occasions.
\n
\n  - Input item '"${c}"name=value"$n"' declares a new variable '"${g}"name"$n"', or assign a new value
\n     to an existing variable. Variable names must use the character set "${g}"[a-zA-Z0-9_]"$n" and cannot
\n     start with a number.
\n
\n  - A variable definition is always local to the current command except when it starts by the
\n     underscore character '"${g}"_"$n"'. In that case, it becomes also accessible by any command invoked
\n     outside the current command scope (global variable).
\n
\n  - If a variable name starts with two underscores '"${g}"__"$n"', the global variable is also shared among
\n     different threads and can be read/set by commands running in parallel (see command '"${c}"parallel"$n"'
\n     for this purpose). Otherwise, it remains local to the thread that defined it.
\n
\n  - Numerical variables can be updated with the use of these special operators:
\n     '"${g}"+="$n"' (addition), '"${g}"-="$n"' (subtraction), '"${g}"*="$n"' (multiplication), '"${g}"/="$n"' (division), '"${g}"%="$n"' (modulo),
\n     '"${g}"&="$n"' (bitwise and), '"${g}"|="$n"' (bitwise or), '"${g}"^="$n"' (power), '"${g}"<<="$n"' and '"${g}">>="$n"' (bitwise left and right
\n     shifts). For instance, '"${c}"foo=1 foo+=3"$n"'.
\n
\n  - Input item '"${c}"name.=string"$n"' concatenates specified '"${g}"string"$n"' to the end of variable '"${g}"name"$n"'.
\n
\n  - Multiple variable assignments and updates are allowed, with expressions:
\n     '"${c}"name1,name2,...,nameN=value"$n"' or '"${c}"name1,name2,...,nameN=value1,value2,...,valueN"$n"'
\n     where assignment operator '"${g}"="$n"' can be replaced by one of the allowed operators
\n     (e.g. '"${g}"+="$n"').
"

  _help_section "Command items and selections"

  _help_paragraph "  - A "${-GMIC}" item that is not a filename nor a special input string designates a "${g}"command"$n",
\n     most of the time. Generally, commands perform image processing operations on one or several
\n     available images of the list.
\n
\n  - Reccurent commands have two equivalent names ("${g}"regular"$n" and "${g}"short"$n"). For instance, command names
\n     '"${c}"resize"$n"' and '"${c}"r"$n"' refer to the same image resizing action.
\n
\n  - A "${-GMIC}" command may have mandatory or optional "${g}"arguments"$n". Command arguments must be specified
\n     in the next item on the command line. Commas '"${g}","$n"' are used to separate multiple arguments of a
\n     single command, when required.
\n
\n  - The execution of a "${-GMIC}" command may be restricted only to a "${g}"subset"$n" of the image list, by
\n     appending '"${c}"[selection]"$n"' to the command name. Examples of valid syntaxes for '"${g}"selection"$n"' are:
\n
\n    . '"${c}"command[-2]"$n"': Apply command only on the penultimate image "${g}"[-2]"$n" of the list.
\n    . '"${c}"command[0,1,3]"$n"': Apply command only on images "${g}"[0],[1]"$n" and "${g}"[3]"$n".
\n    . '"${c}"command[3-6]"$n"': Apply command only on images "${g}"[3]"$n" to "${g}"[6]"$n" (i.e, "${g}"[3],[4],[5]"$n" and "${g}"[6]"$n").
\n    . '"${c}"command[50%-100%]"$n"': Apply command only on the second half of the image list.
\n    . '"${c}"command[0,-4--1]"$n"': Apply command only on the first image and the last four images.
\n    . '"${c}"command[0-9:3]"$n"': Apply command only on images "${g}"[0]"$n" to "${g}"[9]"$n", with a step of 3
\n                          (i.e. on images "${g}"[0], [3], [6]"$n" and "${g}"[9]"$n").
\n    . '"${c}"command[0-9:25%]"$n"': Apply command only on images "${g}"[0]"$n" to "${g}"[9]"$n", with a step of 25%
\n                          (i.e. on images "${g}"[0], [3], [6]"$n" and "${g}"[9]"$n").
\n    . '"${c}"command[0--1:2]"$n"': Apply command only on images of the list with even indices.
\n    . '"${c}"command[0,2-4,50%--1]"$n"': Apply command on images "${g}"[0],[2],[3],[4]"$n" and on the second half of
\n                                 the image list.
\n    . '"${c}"command[^0,1]"$n"': Apply command on all images except the first two.
\n    . '"${c}"command[name1,name2]"$n"': Apply command on named images '"${g}"name1"$n"' and '"${g}"name2"$n"'.
\n
\n  - indices in selections are always sorted in increasing order, and duplicate indices are
\n     discarded. For instance, selections '"${c}"[3-1,1-3]"$n"' and '"${c}"[1,1,1,3,2]"$n"' are both equivalent to
\n     '"${c}"[1-3]"$n"'. If you want to repeat a single command multiple times on an image, use a
\n     '"${c}"repeat..done"$n"' loop instead. Inverting the order of images for a command is achieved by
\n     explicitly inverting the order of the images in the list, with command '"${c}"reverse[selection]"$n"'.
\n
\n  - Command selections '"${c}"[-1]"$n"','"${c}"[-2]"$n"' and '"${c}"[-3]"$n"' are so often used that they have their own
\n     shortcuts, respectively '"${c}"."$n"', '"${c}".."$n"' and '"${c}"..."$n"'. For instance, command '"${c}"blur.."$n"' is equivalent to
\n     '"${c}"blur[-2]"$n"'. These shortcuts work also when specifying command arguments.
\n
\n  - "${-GMIC}" commands invoked without '"${c}"[selection]"$n"' are applied on all images of the list, i.e. the
\n     default selection is '"${c}"[0--1]"$n"' (except for command '"${c}"input"$n"' whose default selection is '"${c}"[-1]"$n"').
\n
\n  - Prepending a single hyphen '"${g}"-"$n"' to a "${-GMIC}" command is allowed. This may be useful to recognize
\n     command items more easily in a one-liner pipeline (typically invoked from a shell).
\n
\n  - A "${-GMIC}" command prepended with a plus sign '"${g}"+"$n"' or a double hyphen '"${g}"--"$n"' does not act 'in-place'
\n     but inserts its result as one or several new images at the end of the image list.
\n
\n  - There are two different types of commands that can be run by the "${-GMIC}" interpreter:
\n
\n    . "${g}"Builtin commands"$n", are the hard-coded functionalities in the interpreter core. They are thus
\n       compiled as binary code and run fast, most of the time. Omitting an argument when invoking a
\n       builtin command is not permitted, except if all following arguments are also omitted.
\n       For instance, invoking '"${c}"plasma 10,,5"$n"' is invalid but '"${c}"plasma 10"$n"' is correct.
\n    . "${g}"Custom commands"$n", are defined as "${-GMIC}" pipelines of builtin or other custom commands.
\n       They are interpreted by the "${-GMIC}" interpreter, and thus run a bit slower than builtin commands.
\n       Omitting arguments when invoking a custom command is permitted. For instance, expressions
\n       '"${c}"flower ,,,100,,2"$n"' or '"${c}"flower ,"$n"' are correct.
\n
\n  - Most of the existing commands in "${-GMIC}" are actually defined as "${g}"custom commands"$n".
\n
\n  - A user can easily add its own custom commands to the "${-GMIC}" interpreter (see section
\n     '"${c}"Adding custom commands"$n"' for more details). New builtin commands cannot be added
\n     (unless you modify the "${-GMIC}" interpreter source code and recompile it)."

  _help_section "Input/output properties"

  _help_paragraph "  - "${-GMIC}" is able to read/write most of the classical image file formats, including:
\n
\n    . 2D grayscale/color files: "${c}".png, .jpeg, .gif, .pnm, .tif, .bmp, ..."$n"
\n    . 3D volumetric files: "${c}".dcm, .hdr, .nii, .pan, .inr, .pnk, ..."$n"
\n    . video files: "${c}".mpeg, .avi, .mov, .ogg, .flv, ..."$n"
\n    . Generic ascii or binary data files: "${c}".gmz, .cimg, .cimgz, .dlm, .asc, .pfm, .raw, .txt, .h."$n"
\n    . 3D object files: "${c}".off."$n"
\n
\n  - When dealing with color images, "${-GMIC}" generally reads, writes and displays data using the usual
\n     sRGB color space.
\n
\n  - "${-GMIC}" is able to manage "${g}"3D objects"$n" that may be read from files or generated by "${-GMIC}" commands.
\n     A 3D object is stored as a one-column scalar image containing the object data, in the
\n     following order: "${g}"{ magic_number; sizes; vertices; primitives; colors; opacities }"$n".
\n     These 3D representations can be then processed as regular images.
\n     (see command '"${c}"split3d"$n"' for accessing each of these 3D object data separately).
\n
\n  - Be aware that usual file formats may be sometimes not adapted to store all the available image
\n     data, since "${-GMIC}" uses float-valued image buffers. For instance, saving an image that was
\n     initially loaded as a 16bits/channel image, as a "${c}".jpg"$n" file will result in a loss of
\n     information. Use the "${-GMIC}"-specific file extension "${c}".gmz"$n" to ensure that all data
\n     precision is preserved when saving images.
\n
\n  - Sometimes, file options may/must be set for file formats:
\n
\n    . "${g}"Video files:"$n" Only sub-frames of an image sequence may be loaded, using the input expression
\n       '"${c}"filename.ext,[first_frame[,last_frame[,step]]]"$n"'. Set '"${g}"last_frame==-1"$n"' to tell it must be
\n       the last frame of the video. Set '"${g}"step"$n"' to 0 to force an opened video file to be
\n       opened/closed. Output framerate and codec can be also set by using the output expression
\n       '"${c}"filename.avi,_fps,_codec,_keep_open={ 0 | 1 }"$n"'. '"${g}"codec"$n"' is a 4-char string
\n       (see "${r}"http://www.fourcc.org/codecs.php"$n") or '"${g}"0"$n"' for the default codec. '"${g}"keep_open"$n"' tells if
\n       the output video file must be kept open for appending new frames afterwards.
\n
\n    . "${g}".cimg[z] files:"$n" Only crops and sub-images of .cimg files can be loaded, using the input
\n      expressions '"${c}"filename.cimg,N0,N1"$n"', '"${c}"filename.cimg,N0,N1,x0,x1"$n"',
\n      '"${c}"filename.cimg,N0,N1,x0,y0,x1,y1"$n"', '"${c}"filename.cimg,N0,N1,x0,y0,z0,x1,y1,z1"$n"' or
\n      '"${c}"filename.cimg,N0,N1,x0,y0,z0,c0,x1,y1,z1,c1"$n"'.
\n      Specifying '"${g}"-1"$n"' for one coordinates stands for the maximum possible value. Output expression
\n      '"${c}"filename.cimg[z][,datatype]"$n"' can be used to force the output pixel type. '"${g}"datatype"$n"' can be
\n      "${g}"{ auto | uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }"$n".
\n
\n    . "${g}".raw binary files:"$n" Image dimensions and input pixel type may be specified when loading "${g}".raw"$n"
\n       files with input expression
\n       '"${c}"filename.raw[,datatype][,width][,height[,depth[,dim[,offset]]]]]"$n"'. If no dimensions are
\n       specified, the resulting image is a one-column vector with maximum possible height. Pixel
\n       type can also be specified with the output expression '"${c}"filename.raw[,datatype]"$n"'.
\n       '"${g}"datatype"$n"' can be the same as for "${g}".cimg[z]"$n" files.
\n
\n    . "${g}".yuv files:"$n" Image dimensions must be specified when loading, and only sub-frames of an image sequence
\n       may be loaded, using the input expression
\n       '"${c}"filename.yuv,width,height[,chroma_subsampling[,first_frame[,last_frame[,step]]]"$n"'.
\n       '"${g}"chroma_subsampling"$n"' can be "${g}"{ 420 | 422 | 444 }"$n".
\n       When saving, chroma subsampling mode can be specified with output expression
\n       '"${c}"filename.yuv[,chroma_subsampling]"$n"'.
\n
\n    . "${g}".tiff files:"$n" Only sub-images of multi-pages tiff files can be loaded, using the input
\n       expression '"${c}"filename.tif,_first_frame,_last_frame,_step"$n"'.
\n       Output expression '"${c}"filename.tiff,_datatype,_compression,_force_multipage,_use_bigtiff"$n"' can
\n       be used to specify the output pixel type, as well as the compression method.
\n       '"${g}"datatype"$n"' can be the same as for "${g}".cimg[z]"$n" files. '"${g}"compression"$n"' can be
\n       "${g}"{ none (default) | lzw | jpeg }"$n". '"${g}"force_multipage"$n" can be "${g}"{ 0=no (default) | 1=yes }"$n".
\n       '"${g}"use_bigtiff"$n" can be "${g}"{ 0=no | 1=yes (default) }"$n".
\n
\n    . "${g}".gif files:"$n" Animated gif files can be saved, using the input expression
\n       '"${c}"filename.gif,fps>0,nb_loops"$n"'. Specify '"${g}"nb_loops=0"$n"' to get an infinite number of animation
\n       loops (this is the default behavior).
\n
\n    . "${g}".jpeg files:"$n" The output quality may be specified (in %), using the output expression
\n       '"${c}"filename.jpg,30"$n"' (here, to get a 30% quality output). '"${g}"100"$n"' is the default.
\n
\n    . "${g}".mnc files:"$n" The output header can set from another file, using the output expression
\n       '"${c}"filename.mnc,header_template.mnc"$n"'.
\n
\n    . "${g}".pan, .cpp, .hpp, .c and .h files:"$n" The output datatype can be selected with output expression
\n       '"${c}"filename[,datatype]"$n"'. '"${g}"datatype"$n"' can be the same as for "${g}".cimg[z]"$n" files.
\n
\n    . "${g}".gmic files:"$n" These filenames are assumed to be "${-GMIC}" custom commands files. Loading such a
\n       file will add the commands it defines to the interpreter. Debug information can be
\n       enabled/disabled by the input expression '"${c}"filename.gmic[,add_debug_info={ 0 | 1 }]"$n"'.
\n
\n    . Inserting '"${c}"ext:"$n"' on the beginning of a filename (e.g. '"${c}"jpg:filename"$n"') forces "${-GMIC}" to
\n       read/write the file as it would have been done if it had the specified extension '"${g}".ext"$n"'.
\n
\n  - Some input/output formats and options may not be supported, depending on the configuration
\n     flags that have been set during the build of the "${-GMIC}" software."

  _help_section "Substitution rules"

  _help_paragraph "  - "${-GMIC}" items containing '"${g}"$"$n"' or '"${g}"{}"$n"' are substituted before being interpreted. Use these
\n     substituting expressions to access various data from the interpreter environment.
\n
\n  - '"${c}"$name"$n"' and '"${c}"${name}"$n"' are both substituted by the value of the specified named "${g}"variable"$n"
\n     (set previously by the item '"${c}"name=value"$n"'). If this variable has not been already set, the
\n     expression is substituted by the highest positive "${g}"index"$n" of the named image '"${g}"[name]"$n"'. If no
\n     image has this name, the expression is substituted by the value of the "${g}"OS environment variable"$n"
\n     with same name (it may be thus an empty string).
\n     The following reserved variables are predefined by the "${-GMIC}" interpreter:
\n
\n       . '"${c}"$!"$n"': The current number of images in the list.
\n       . '"${c}"$>"$n"' and '"${c}"$<"$n"': The increasing/decreasing index of the latest (currently running)
\n          '"${c}"repeat...done"$n"' loop. '"${c}"$>"$n"' goes from '"${g}"0"$n"' (first loop iteration) to
\n          '"${g}"nb_iterations - 1"$n"' (last iteration). '"${c}"$>"$n"' does the opposite.
\n       . '"${c}"$/"$n"': The current call stack. Stack items are separated by slashes '"${g}"/"$n"'.
\n       . '"${c}"$|"$n"': The current value (expressed in seconds) of a millisecond precision timer.
\n       . '"${c}"$^"$n"': The current verbosity level.
\n       . '"${c}"$_cpus"$n"': The number of computation cores available on your machine.
\n       . '"${c}"$_pid"$n"': The current process identifier, as an integer.
\n       . '"${c}"$_prerelease"$n"': For pre-releases only, the date of the pre-release as '"${g}"yymmdd"$n"'.
\n          For stable releases, this variable is not defined.
\n       . '"${c}"$_version"$n"': A 3-digits number telling about the current version of the "${-GMIC}" interpreter
\n          (e.g. '"$g$_version$n"').
\n       . '"${c}"$_vt100"$n"': Set to "${g}"1"$n" (default value) if colored text output is allowed on the console.
\n       . '"${c}"$_path_rc"$n"': The path to the "${-GMIC}" folder used to store resources and configuration files
\n         (its value is OS-dependent).
\n       . '"${c}"$_path_user"$n"': The path to the "${-GMIC}" user file "${g}".gmic"$n" or "${g}"user.gmic"$n" (its value is
\n          OS-dependent).
\n
\n  - '"${c}"$$name"$n"' and '"${c}"$${name}"$n"' are both substituted by the G'MIC script code of the specified named
\n     "${g}"custom command"$n", or by an empty string if no custom command with specified name exists.
\n
\n  - '"${c}"${\"-pipeline\"}"$n"' is substituted by the "${g}"status value"$n" after the execution of the specified
\n     "${-GMIC}" pipeline (see command '"${c}"status"$n"'). Expression '"${c}"${}"$n"' thus stands for the
\n     "${g}"current status value"$n".
\n
\n  - '"${c}"{``string}"$n"' (starting with two backquotes) is substituted by a "${g}"double-quoted version"$n" of the
\n     specified string.
\n
\n  - '"${c}"{/string}"$n"' is substituted by the "${g}"escaped version"$n" of the specified string.
\n
\n  - '"${c}"{'string'}"$n"' (between single quotes) is substituted by the "${g}"sequence of ascii codes"$n" that compose
\n     the specified string, separated by commas '"${g}","$n"'. For instance, item '"${c}"{'foo'}"$n"' is substituted
\n     by '"${c}"102,111,111"$n"'.
\n
\n  - '"${c}"{image,feature}"$n"' is substituted by a specific feature of the image "${c}"[image]"$n". '"${g}"image"$n"' can be
\n     either an image number or an image name. It can be also eluded, in which case, the last image
\n     '"${c}"[-1]"$n"' of the list is considered for the requested feature.
\n     Specified '"${g}"feature"$n"' can be one of:
\n
\n       . '"${c}"b"$n"': The image basename (i.e. filename without the folder path nor extension).
\n       . '"${c}"f"$n"': The image folder name.
\n       . '"${c}"n"$n"': The image name or filename (if the image has been read from a file).
\n       . '"${c}"t"$n"': The text string from the image values regarded as ascii codes.
\n       . '"${c}"x"$n"': The image extension (i.e the characters after the last '.' in the image name).
\n       . '"${c}"^"$n" : The sequence of all image values, separated by commas ','.
\n       . '"${c}"@subset"$n"': The sequence of image values corresponding to the specified subset, and
\n          separated by commas ','.
\n       . Any other '"${c}"feature"$n"' is considered as a "${g}"mathematical expression"$n" associated to the image
\n          "${c}"[image]"$n" and is substituted by the result of its evaluation (float value). For instance,
\n          expression '"${c}"{0,w+h}"$n"' is substituted by the sum of the width and height of the first image
\n          (see section '"${c}"Mathematical expressions"$n"' for more details). If a mathematical expression
\n          starts with an underscore '"${g}"_"$n"', the resulting value is truncated to a readable format.
\n          For instance, item '"${c}"{_pi}"$n"' is substituted by '"${g}"3.14159"$n"' (while '"${c}"{pi}"$n"' is substituted by
\n          '"${g}"3.141592653589793"$n"').
\n       . A '"${c}"feature"$n"' delimited by backquotes is replaced by a string whose ascii codes correspond
\n          to the list of values resulting from the evaluation of the specified mathematical
\n          expression. For instance, item '"${c}"{`[102,111,111]`}"$n"' is substituted by '"${c}"foo"$n"' and item
\n          '"${c}"{`vector8(65)`}"$n"' by '"${c}"AAAAAAAA"$n"'.
\n
\n  - '"${c}"{*}"$n"' is substituted by the "${g}"visibility state"$n" of the instant display window "${c}"[0]"$n" (can be
\n     "${g}"{ 0=closed | 1=visible }"$n").
\n
\n  - '"${c}"{*,feature1,...,featureN}"$n"' or '"${c}"{*index,feature1,...,featureN}"$n"' is substituted by a specific
\n      set of features of the instant display window "${c}"#0"$n" (or "${c}"#index"$n", if specified).
\n      Requested '"${g}"features"$n"' can be:
\n
\n       . '"${c}"w"$n"': display width (i.e. width of the display area managed by the window).
\n       . '"${c}"h"$n"': display height (i.e. height of the display area managed by the window).
\n       . '"${c}"wh"$n"': display width x display height.
\n       . '"${c}"d"$n"': window width (i.e. width of the window widget).
\n       . '"${c}"e"$n"': window height (i.e. height of the window widget).
\n       . '"${c}"de"$n"': window width x window height.
\n       . '"${c}"u"$n"': screen width (actually independent on the window size).
\n       . '"${c}"v"$n"': screen height (actually independent on the window size).
\n       . '"${c}"uv"$n"': screen width x screen height.
\n       . '"${c}"n"$n"': current normalization type of the instant display.
\n       . '"${c}"t"$n"': window title of the instant display.
\n       . '"${c}"x"$n"': X-coordinate of the mouse position (or -1, if outside the display area).
\n       . '"${c}"y"$n"': Y-coordinate of the mouse position (or -1, if outside the display area).
\n       . '"${c}"b"$n"': state of the mouse buttons { 1=left-but. | 2=right-but. | 4=middle-but. }.
\n       . '"${c}"o"$n"': state of the mouse wheel.
\n       . '"${c}"k"$n"': decimal code of the pressed key if any, 0 otherwise.
\n       . '"${c}"c"$n"': boolean (0 or 1) telling if the instant display has been closed recently.
\n       . '"${c}"r"$n"': boolean telling if the instant display has been resized recently.
\n       . '"${c}"m"$n"': boolean telling if the instant display has been moved recently.
\n       . Any other '"${c}"feature"$n"' stands for a "${g}"keycode name"$n" (in capital letters), and is substituted by
\n          a boolean describing the current key state "${g}"{ 0=pressed | 1=released }"$n".
\n       . You can also prepend a hyphen '"${c}"-"$n"' to a '"${g}"feature"$n"' (that supports it) to flush the
\n          corresponding event immediately after reading its state (works for keys, mouse and
\n          window events).
\n
\n  - Item substitution is "${g}"never performed in items between double quotes"$n". One must break the quotes
\n    to enable substitution if needed, as in '"${c}"\"3+8 kg = \"{3+8}\" kg\""$n"'. Using double quotes is then
\n    a convenient way to disable the substitutions mechanism in items, when necessary.
\n
\n  - One can also disable the substitution mechanism on items outside double quotes, by escaping the
\n     '"${g}"{"$n"','"${g}"}"$n"' or '"${g}"$"$n"' characters, as in '"${c}"\\{3+4\\}\\ doesn\47t\\ evaluate"$n"'."

  _help_section "Mathematical expressions"

  _help_paragraph "  - "${-GMIC}" has an embedded "${g}"mathematical parser"$n". It is used to evaluate (possibly complex) expressions
\n     inside braces '"${g}"{}"$n"', or formulas in commands that may take one as an argument (e.g. '"${c}"fill"$n"').
\n
\n  - When the context allows it, a formula is evaluated "${g}"for each pixel"$n" of the selected images
\n     (e.g. '"${c}"fill"$n"').
\n
\n  - A math expression may return a "${g}"scalar"$n" or "${g}"vector"$n"-valued result (with a fixed number of
\n     components).
\n
\n  - The mathematical parser understands the following set of functions, operators and variables:
\n
\n    _ "${g}"Usual operators:"$n" "${c}"||"$n" (logical or), "${c}"&&"$n" (logical and), "${c}"|"$n" (bitwise or), "${c}"&"$n" (bitwise and),
\n       "${c}"!=, ==, <=, >=, <, >, <<"$n" (left bitwise shift), "${c}">>"$n" (right bitwise shift), "${c}"-, +, *, /,
\n       %"$n" (modulo), "${c}"^"$n" (power), "${c}"!"$n" (logical not), "${c}"~"$n" (bitwise not),
\n       "${c}"++"$n", "${c}"--"$n", "${c}"+="$n", "${c}"-="$n", "${c}"*="$n", "${c}"/="$n", "${c}"%="$n", "${c}"&="$n", "${c}"|="$n", "${c}"^="$n", "${c}">>="$n", "${c}"<<="$n" (in-place operators).
\n
\n    _ "${g}"Usual math functions:"$n" "${c}"abs(), acos(), acosh(), arg(), argkth(), argmax(), argmin(), asin(),
\n       asinh(), atan(), atan2(), atanh(), avg(), bool(), cbrt(), ceil(), cos(), cosh(), cut(), exp(), fact(),
\n       fibo(), floor(), gauss(), int(), isval(), isnan(), isinf(), isint(), isbool(), isfile(), isdir(), isin(),
\n       kth(), log(), log2(), log10(), max(), med(), min(), narg(), prod(), rol()"$n" (left bit rotation),
\n       "${c}"ror()"$n" (right bit rotation)"${c}", round(), sign(), sin(), sinc(), sinh(), sqrt(), std(),
\n       srand(_seed), sum(), tan(), tanh(), var(), xor()"$n".
\n
\n       . '"${c}"atan2(y,x)"$n"' is the version of '"${c}"atan()"$n"' with two arguments '"${g}"y"$n"' and '"${g}"x"$n"' (as in C/C++).
\n       . '"${c}"permut(k,n,with_order)"$n"' computes the number of permutations of "${g}"k"$n" objects from a set of
\n          "${g}"n"$n" objects.
\n       . '"${c}"gauss(x,_sigma,_is_normalized)"$n"' returns '"${g}"exp(-x^2/(2*s^2))/(is_normalized?sqrt(2*pi*sigma^2):1)"$n"'.
\n       . '"${c}"cut(value,min,max)"$n"' returns value if it is in range "${g}"[min,max]"$n", or "${g}"min"$n" or "${g}"max"$n" otherwise.
\n       . '"${c}"narg(a_1,...,a_N)"$n"' returns the number of specified arguments (here, "${g}"N"$n").
\n       . '"${c}"arg(i,a_1,..,a_N)"$n"' returns the "${g}"ith"$n" argument "${g}"a_i"$n".
\n       . '"${c}"isval()"$n"', '"${c}"isnan()"$n"', '"${c}"isinf()"$n"', '"${c}"isint()"$n"', '"${c}"isbool()"$n"' test the type of the given
\n          number or expression, and return "${g}"0 (false)"$n" or "${g}"1 (true)"$n".
\n       . '"${c}"isfile('path')"$n"' (resp. '"${c}"isdir('path')"$n"') returns "${g}"0 (false)"$n" or "${g}"1 (true)"$n" whether its string argument is a
\n          path to an existing file (resp. to a directory) or not.
\n       . '"${c}"isin(v,a_1,...,a_n)"$n"' returns "${g}"0 (false)"$n" or "${g}"1 (true)"$n" whether the first value '"${g}"v"$n"' appears
\n          in the set of other values 'a_i'.
\n       . '"${c}"argmin()"$n"', '"${c}"argmax()"$n"', '"${c}"avg()"$n"', '"${c}"kth()"$n"', '"${c}"max()"$n"', '"${c}"med()"$n"', '"${c}"min()"$n"', '"${c}"std()"$n"', '"${c}"sum()"$n"'
\n          and '"${c}"var()"$n"' can be called with an arbitrary number of scalar/vector arguments.
\n       . '"${c}"round(value,rounding_value,direction)"$n"' returns a rounded value. '"${g}"direction"$n"' can be
\n          "${g}"{ -1=to-lowest | 0=to-nearest | 1=to-highest }"$n".
\n
\n    _ "${g}"Variable names"$n" below are pre-defined. They can be overridden.
\n
\n       . '"${c}"l"$n"': length of the associated list of images.
\n       . '"${c}"w"$n"': width of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"h"$n"': height of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"d"$n"': depth of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"s"$n"': spectrum of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"r"$n"': shared state of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"wh"$n"': shortcut for width x height.
\n       . '"${c}"whd"$n"': shortcut for width x height x depth.
\n       . '"${c}"whds"$n"': shortcut for width x height x depth x spectrum (i.e. number of image values).
\n       . '"${c}"im"$n"','"${c}"iM"$n"','"${c}"ia"$n"','"${c}"iv"$n"','"${c}"is"$n"','"${c}"ip"$n"','"${c}"ic"$n"': Respectively the minimum, maximum, average,
\n          variance, sum, product and median value of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"xm"$n"','"${c}"ym"$n"','"${c}"zm"$n"','"${c}"cm"$n"': The pixel coordinates of the minimum value in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"xM"$n"','"${c}"yM"$n"','"${c}"zM"$n"','"${c}"cM"$n"': The pixel coordinates of the maximum value in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . All these variables are considered as "${g}"constant values"$n" by the math parser (for optimization
\n          purposes) which is indeed the case most of the time. Anyway, this might not be the case,
\n          if function '"${c}"resize(#ind,..)"$n"' is used in the math expression.
\n          If so, it is safer to invoke functions '"${c}"l()"$n"', '"${c}"w(_#ind)"$n"', '"${c}"h(_#ind)"$n"', ... '"${c}"s(_#ind)"$n"'
\n          and '"${c}"ic(_#ind)"$n"' instead of the corresponding named variables.
\n       . '"${c}"i"$n"': current processed pixel value (i.e. value located at "${g}"(x,y,z,c)"$n") in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"iN"$n"': Nth channel value of current processed pixel (i.e. value located at "${g}"(x,y,z,N)"$n") in
\n          the associated image, if any ("${g}"0"$n" otherwise). '"${g}"N"$n"' must be an integer in range "${g}"[0,9]"$n".
\n       . '"${c}"R"$n"','"${c}"G"$n"','"${c}"B"$n"' and '"${c}"A"$n"' are equivalent to '"${c}"i0"$n"', '"${c}"i1"$n"', '"${c}"i2"$n"' and '"${c}"i3"$n"' respectively.
\n       . '"${c}"I"$n"': current vector-valued processed pixel in the associated image, if any ("${g}"0"$n" otherwise).
\n          The number of vector components is equal to the number of image channels
\n          (e.g. "${g}"I = [ R,G,B ]"$n" for a "${g}"RGB"$n" image).
\n       . You may add '"${c}"#ind"$n"' to any of the variable name above to retrieve the information for any
\n          numbered image "${g}"[ind]"$n" of the list (when this makes sense). For instance '"${c}"ia#0"$n"' denotes the
\n          average value of the first image of the list).
\n       . '"${c}"x"$n"': current processed column of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"y"$n"': current processed row of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"z"$n"': current processed slice of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"c"$n"': current processed channel of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"t"$n"': thread id when an expression is evaluated with multiple threads ("${g}"0"$n" means
\n          'master thread').
\n       . '"${c}"e"$n"': value of e, i.e. "${g}"2.71828..."$n"
\n       . '"${c}"pi"$n"': value of pi, i.e. "${g}"3.1415926..."$n"
\n       . '"${c}"u"$n"': a random value between "${g}"[0,1]"$n", following a uniform distribution.
\n       . '"${c}"g"$n"': a random value, following a gaussian distribution of variance 1
\n          (roughly in "${g}"[-6,6]"$n").
\n       . '"${c}"interpolation"$n"': value of the default interpolation mode used when reading pixel values
\n           with the pixel access operators (i.e. when the interpolation argument is not explicitly
\n           specified, see below for more details on pixel access operators). Its initial default
\n           value is "${g}"0"$n".
\n       . '"${c}"boundary"$n"': value of the default boundary conditions used when reading pixel values with
\n           the pixel access operators (i.e. when the boundary condition argument is not explicitly
\n           specified, see below for more details on pixel access operators). Its initial default
\n           value is "${g}"0"$n".
\n
\n    _ "${g}"Vector calculus:"$n" Most operators are also able to work with vector-valued elements.
\n
\n       . '"${c}"[ a0,a1,...,aN-1 ]"$n"' defines a "${g}"N"$n"-dimensional vector with scalar coefficients "${g}"ak"$n".
\n       . '"${c}"vectorN(a0,a1,,...,aN-1)"$n"' does the same, with the "${g}"ak"$n" being repeated periodically if only a
\n          few are specified.
\n       . In both previous expressions, the "${g}"ak"$n" can be vectors themselves, to be concatenated into a
\n          single vector.
\n       . The scalar element "${g}"ak"$n" of a vector "${g}"X"$n" is retrieved by '"${c}"X[k]"$n"'.
\n       . The sub-vector "${g}"[ X[p]...X[p+q-1] ]"$n" (of size "${g}"q"$n") of a vector "${g}"X"$n" is retrieved by '"${c}"X[p,q]"$n"'.
\n       . Equality/inequality comparisons between two vectors is done with operators '"${c}"=="$n"' and '"${c}"!="$n"'.
\n       . Some vector-specific functions can be used on vector values:
\n         '"${c}"cross(X,Y)"$n"' (cross product), '"${c}"dot(X,Y)"$n"' (dot product), '"${c}"size(X)"$n"' (vector dimension),
\n         '"${c}"sort(X,_is_increasing,_chunk_size)"$n"' (sorting values), '"${c}"reverse(A)"$n"' (reverse order of
\n         components), '"${c}"shift(A,_length,_boundary_conditions)"$n"' and
\n         '"${c}"same(A,B,_nb_vals,_is_case_sensitive)"$n"' (vector equality test).
\n       . Function '"${c}"normP(u1,...,un)"$n"' computes the LP-norm of the specified vector
\n          ("${c}"P"$n" being an "${g}"unsigned integer"$n" constant or '"${g}"inf"$n"'). If "${c}"P"$n" is omitted, the L2 norm is used.
\n       . Function '"${c}"resize(A,size,_interpolation,_boundary_conditions)"$n"' returns a resized version of
\n          a vector '"${g}"A"$n"' with specified interpolation mode. '"${g}"interpolation'"$n" can be "${g}"{ -1=none
\n          (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic |
\n          6=lanczos }"$n", and '"${g}"boundary_conditions'"$n"  can be "${g}"{ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }"$n".
\n       . Function '"${c}"find(A,B,_is_forward,_starting_index)"$n"' returns the index where sub-vector "${g}"B"$n"
\n          appears in vector "${g}"A"$n", (or "${g}"-1"$n" if "${g}"B"$n" is not found in "${g}"A"$n"). Argument "${g}"A"$n" can be also replaced by
\n          an image index "${g}"#ind"$n".
\n       . A "${g}"2"$n"-dimensional vector may be seen as a complex number and used in those particular
\n          functions/operators:
\n          '"${c}"**"$n"' (complex multiplication), '"${c}"//"$n"' (complex division), '"${c}"^^"$n"' (complex exponentiation),
\n          '"${c}"**="$n"' (complex self-multiplication), '"${c}"//="$n"' (complex self-division), '"${c}"^^="$n"' (complex
\n          self-exponentiation), '"${c}"cabs()"$n"' (complex modulus), '"${c}"carg()"$n"' (complex argument), '"${c}"cconj()"$n"'
\n          (complex conjugate), '"${c}"cexp()"$n"' (complex exponential) and '"${c}"clog()"$n"' (complex logarithm).
\n       . A "${g}"MN"$n"-dimensional vector may be seen as a "${g}"M"${n}" x "${g}"N"$n" matrix and used in those particular
\n          functions/operators:
\n          '"${c}"*"$n"' (matrix-vector multiplication), '"${c}"det(A)"$n"' (determinant), '"${c}"diag(V)"$n"' (diagonal matrix
\n          from a vector), '"${c}"eig(A)"$n"' (eigenvalues/eigenvectors), '"${c}"eye(n)"$n"' (n x n identity matrix),
\n          '"${c}"inv(A)"$n"' (matrix inverse), '"${c}"mul(A,B,_nb_colsB)"$n"' (matrix-matrix multiplication),
\n          '"${c}"pseudoinv(A,_nb_colsA)"$n"', '"${c}"rot(u,v,w,angle)"$n"' (3D rotation matrix), '"${c}"rot(angle)"$n"' (2D
\n          rotation matrix), '"${c}"solve(A,B,_nb_colsB)"$n"' (least-square solver of linear system A.X = B),
\n          '"${c}"svd(A,_nb_colsA)"$n"' (singular value decomposition), '"${c}"trace(A)"$n"' (matrix trace) and
\n          '"${c}"transp(A,nb_colsA)"$n"' (matrix transpose). Argument '"${c}"nb_colsB"$n"' may be omitted if it is
\n          equal to "${g}"1"$n".
\n       . Specifying a vector-valued math expression as an argument of a command that operates on
\n          image values (e.g. '"${c}"fill"$n"') modifies the whole spectrum range of the processed image(s),
\n          for each spatial coordinates "${g}"(x,y,z)"$n". The command does not loop over the "${g}"C"$n"-axis in this
\n          case.
\n
\n    _ "${g}"String manipulation:"$n" Character strings are defined and managed as vectors objects.
\n       Dedicated functions and initializers to manage strings are
\n
\n       . "${c}"[ 'string' ]"$n" and "${c}"'string'"$n" define a vector whose values are the ascii codes of the
\n          specified "${g}"character string"$n" (e.g. "${c}"'foo'"$n" is equal to "${g}"[ 102,111,111 ]"$n").
\n       . "${c}"_'character'"$n" returns the (scalar) ascii code of the specified character (e.g. "${c}"_'A'"$n" is
\n          equal to "${g}"65"$n").
\n       . A special case happens for "${g}"empty"$n" strings: Values of both expressions "${c}"[ '' ]"$n" and "${c}"''"$n" are "${g}"0"$n".
\n       . Functions '"${c}"lowercase()"$n"' and '"${c}"uppercase()"$n"' return string with all string characters
\n          lowercased or uppercased.
\n       . Function '"${c}"stov(str,_starting_index,_is_strict)"$n"' parses specified string '"${c}"str"$n"' and returns the value
\n          contained in it.
\n       . Function '"${c}"vtos(expr,_nb_digits,_siz)"$n"' returns a vector of size '"${c}"siz"$n"' which contains
\n          the ascii representation of values described by expression '"${c}"expr"$n"'.
\n          '"${c}"nb_digits"$n"' can be "${g}"{ -1=auto-reduced | 0=all | >0=max number of digits }"$n".
\n       . Function '"${c}"echo(str1,str2,...,strN)"$n"' prints the concatenation of given string arguments
\n          on the console.
\n       . Function '"${c}"cats(str1,str2,...,strN,siz)"$n"' returns the concatenation of given string arguments
\n          as a new vector of size '"${c}"siz"$n"'.
\n
\n    _ "${g}"Special operators"$n" can be used:
\n
\n       . '"${c}";"$n"': expression separator. The returned value is always the last encountered expression.
\n          For instance expression '"${c}"1;2;pi"$n"' is evaluated as '"${c}"pi"$n"'.
\n       . '"${c}"="$n"': variable assignment. Variables in mathematical parser can only refer to numerical
\n          values (vectors or scalars). Variable names are case-sensitive. Use this operator in
\n          conjunction with '"${c}";"$n"' to define more complex evaluable expressions, such as
\n          '"${c}"t=cos(x);3*t^2+2*t+1"$n"'.
\n          These variables remain "${g}"local"$n" to the mathematical parser and cannot be accessed outside
\n           the evaluated expression.
\n       . Variables defined in math parser may have a "${g}"constant"$n" property, by specifying keyword '"${c}"const"$n"'
\n          before the variable name (e.g. '"${c}"const foo = pi/4;"$n"'). The value set to such a variable must
\n          be indeed a "${c}"constant scalar"$n". Constant variables allows certain types of optimizations in
\n          the math JIT compiler.
\n
\n    _ The following "${g}"specific functions"$n" are also defined:
\n
\n       . '"${c}"u(max)"$n"' or '"${c}"u(min,max)"$n"': return a random value between "${g}"[0,max]"$n" or "${g}"[min,max]"$n", following
\n          a uniform distribution.
\n       . '"${c}"i(_a,_b,_c,_d,_interpolation_type,_boundary_conditions)"$n"': return the value of the pixel
\n          located at position "${g}"(a,b,c,d)"$n" in the associated image, if any ("${g}"0"$n" otherwise).
\n          '"${g}"interpolation_type"$n"' can be "${g}"{ 0=nearest neighbor | other=linear }"$n".
\n          '"${g}"boundary_conditions"$n"' can be "${g}"{ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }"$n".
\n          Omitted coordinates are replaced by their default values which are respectively
\n          "${c}"x, y, z, c, interpolation"$n" and "${c}"boundary"$n".
\n          For instance command '"${c}"fill 0.5*(i(x+1)-i(x-1))"$n"' will estimate the X-derivative of an
\n          image with a classical finite difference scheme.
\n       . '"${c}"j(_dx,_dy,_dz,_dc,_interpolation_type,_boundary_conditions)"$n"' does the same for the pixel
\n          located at position "${g}"(x+dx,y+dy,z+dz,c+dc)"$n" (pixel access relative to the current
\n          coordinates).
\n       . '"${c}"i[offset,_boundary_conditions]"$n"' returns the value of the pixel located at specified
\n          '"${g}"offset"$n"' in the associated image buffer (or "${g}"0"$n" if offset is out-of-bounds).
\n       . '"${c}"j[offset,_boundary_conditions]"$n"' does the same for an offset relative to the current pixel
\n          coordinates "${g}"(x,y,z,c)"$n".
\n       . '"${c}"i(#ind,_x,_y,_z,_c,_interpolation,_boundary_conditions)"$n"',
\n          '"${c}"j(#ind,_dx,_dy,_dz,_dc,_interpolation,_boundary_conditions)"$n"',
\n          '"${c}"i[#ind,offset,_boundary_conditions]"$n"' and '"${c}"i[offset,_boundary_conditions]"$n"' are similar expressions used to
\n          access pixel values for any numbered image "${g}"[ind]"$n" of the list.
\n       . '"${c}"I/J[offset,_boundary_conditions]"$n"' and '"${c}"I/J(#ind,_x,_y,_z,_interpolation,_boundary_conditions)"$n"' do
\n          the same as '"${c}"i/j[offset,_boundary_conditions]"$n"' and
\n          '"${c}"i/j(#ind,_x,_y,_z,_c,_interpolation,_boundary_conditions)"$n"' but return a vector instead of a scalar
\n          (e.g. a vector "${g}"[ R,G,B ]"$n" for a pixel at "${g}"(a,b,c)"$n" in a color image).
\n       . '"${c}"sort(#ind,_is_increasing,_axis)"$n"' sorts the values in the specified image "${g}"[ind]"$n".
\n       . '"${c}"crop(_#ind,_x,_y,_z,_c,_dx,_dy,_dz,_dc,_boundary_conditions)"$n"' returns a vector whose values come
\n          from the cropped region of image "${g}"[ind]"$n" (or from default image selected if '"${c}"ind"$n"' is not
\n          specified). Cropped region starts from point "${g}"(x,y,z,c)"$n" and has a size of
\n          "${g}"dx x dy x dz x dc"$n". Arguments for coordinates and sizes can be omitted if they are not
\n          ambiguous (e.g. '"${c}"crop(#ind,x,y,dx,dy)"$n"' is a valid invocation of this function).
\n       . '"${c}"draw(_#ind,S,x,y,z,c,dx,_dy,_dz,_dc,_opacity,_M,_max_M)"$n"' draws a sprite "${g}"S"$n" in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) at coordinates "${g}"(x,y,z,c)"$n".
\n          The size of the sprite "${g}"dx x dy x dz x dc"$n" must be specified. You can also specify a
\n          corresponding opacity mask "${g}"M"$n" if its size matches "${g}"S"$n".
\n       . '"${c}"polygon(_#ind,nb_vertices,coords,_opacity,_color)"$n"' draws a filled polygon in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) at specified coordinates.
\n          It draws a single line if '"${c}"nb_vertices"$n"' is set to 2.
\n       . '"${c}"polygon(_#ind,-nb_vertices,coords,_opacity,_pattern,_color)"$n"' draws a outlined polygon in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) at specified coordinates and with specified
\n          line pattern. It draws a single line if '"${c}"nb_vertices"$n"' is set to 2.
\n       . '"${c}"ellipse(_#ind,xc,yc,radius1,_radius2,_angle,_opacity,_color)"$n"' draws a filled ellipse in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) with specified coordinates.
\n       . '"${c}"ellipse(_#ind,xc,yc,-radius1,-_radius2,_angle,_opacity,_pattern,_color)"$n"' draws an outlined ellipse in
\n          image "${g}"[ind]"$n" (or in default image selected if '"${c}"ind"$n"' is not specified).
\n       . '"${c}"resize(#ind,w,_h,_d,_s,_interp,_boundary_conditions,_cx,_cy,_cz,_cc)"$n"' resizes an image of the
\n          associated list with specified dimension and interpolation method. When using this,
\n          function, you should consider retrieving the (non-constant) image dimensions using the
\n          dynamic functions '"${c}"w(_#ind)"$n"', '"${c}"h(_#ind)"$n"', '"${c}"d(_#ind)"$n"', '"${c}"s(_#ind)"$n"', '"${c}"wh(_#ind)"$n"',
\n          '"${c}"whd(_#ind)"$n"' and '"${c}"whds(_#ind)"$n"' instead of the corresponding constant variables.
\n       . '"${c}"if(condition,expr_then,_expr_else)"$n"': return value of '"${c}"expr_then"$n"' or '"${c}"expr_else"$n"',
\n          depending on the value of '"${c}"condition"$n"' "${g}"(0=false, other=true)"$n". '"${c}"expr_else"$n"' can be omitted
\n          in which case "${g}"0"$n" is returned if the condition does not hold. Using the ternary operator
\n          '"${c}"condition?expr_then[:expr_else]"$n"' gives an equivalent expression.
\n          For instance, "${-GMIC}" commands '"${c}"fill if(x%10==0,255,i)"$n"' and '"${c}"fill x%10?i:255"$n"' both draw
\n          blank vertical lines on every 10th column of an image.
\n       . '"${c}"do(expression,_condition)"$n"' repeats the evaluation of '"${c}"expression"$n"' until '"${c}"condition"$n"'
\n          vanishes (or until '"${c}"expression"$n"' vanishes if no '"${c}"condition"$n"' is specified). For instance,
\n          the expression: '"${c}"if(N<2,N,n=N-1;F0=0;F1=1;do(F2=F0+F1;F0=F1;F1=F2,n=n-1))"$n"' returns
\n          the Nth value of the Fibonacci sequence, for "${g}"N>=0"$n" (e.g., "${g}"46368"$n" for "${g}"N=24"$n").
\n          '"${c}"do(expression,condition)"$n"' always evaluates the specified expression at least once,
\n          then check for the loop condition. When done, it returns the last value of '"${c}"expression"$n"'.
\n       . '"${c}"for(init,condition,_procedure,body)"$n"' first evaluates the expression '"${c}"init"$n"', then
\n          iteratively evaluates '"${c}"body"$n"' (followed by '"${c}"procedure"$n"' if specified) while '"${c}"condition"$n"'
\n          is verified (i.e. not zero). It may happen that no iteration is done, in which case the
\n          function returns "${g}"nan"$n". Otherwise, it returns the last value of '"${c}"body"$n"'.
\n          For instance, the expression: '"${c}"if(N<2,N,for(n=N;F0=0;F1=1,n=n-1,F2=F0+F1;F0=F1;F1=F2))"$n"'
\n          returns the "${g}"Nth"$n" value of the Fibonacci sequence, for "${g}"N>=0"$n" (e.g., "${g}"46368"$n" for "${g}"N=24"$n").
\n       . '"${c}"while(condition,expression)"$n"' is exactly the same as '"${c}"for(init,condition,expression)"$n"'
\n          without the specification of an initializing expression.
\n       . '"${c}"break()"$n"' and '"${c}"continue()"$n"' respectively breaks and continues the current running bloc
\n          (loop, init or main environment).
\n       . '"${c}"fsize('filename')"$n"' returns the size of the specified 'filename' (or '-1' if file does not exist).
\n       . '"${c}"date(attr,'path')"$n"' returns the date attribute for the given 'path' (file or directory),
\n          with '"${g}"attr"$n"' being "${g}"{ 0=year | 1=month | 2=day | 3=day of week | 4=hour | 5=minute |
\n          6=second }"$n", or a vector of those values.
\n       . '"${c}"date(_attr)"$n" returns the specified attribute for the current (locale) date.
\n       . '"${c}"print(expr1,expr2,...)"$n" or '"${c}"print(#ind)"$n" prints the value of the specified expressions
\n          (or image information) on the console, and returns the value of the last expression
\n          (or "${g}"nan"$n" in case of an image). Function '"${c}"prints(expr)"$n"' also prints the string composed
\n          of the ascii characters defined by the vector-valued expression (e.g. '"${c}"prints('Hello')"$n"').
\n       . '"${c}"debug(expression)"$n" prints detailed debug information about the sequence of operations done
\n          by the math parser to evaluate the expression (and returns its value).
\n       . '"${c}"display(_X,_w,_h,_d,_s)"$n" or '"${c}"display(#ind)"$n" display the contents of the vector '"${c}"X"$n"'
\n          (or specified image) and wait for user events. if no arguments are provided, a memory
\n          snapshot of the math parser environment is displayed instead.
\n       . '"${c}"begin(expression)"$n" and '"${c}"end(expression)"$n" evaluates the specified expressions only once,
\n          respectively at the beginning and end of the evaluation procedure, and this,
\n          even when multiple evaluations are required (e.g. in '"${c}"fill \">begin(foo = 0); ++foo\""$n"').
\n       . '"${c}"copy(dest,src,_nb_elts,_inc_d,_inc_s,_opacity)"$n" copies an entire memory block of '"${c}"nb_elts"$n"'
\n          elements starting from a source value '"${c}"src"$n"' to a specified destination '"${c}"dest"$n"', with
\n          increments defined by '"${c}"inc_d"$n"' and '"${c}"inc_s"$n"' respectively for the destination and source
\n          pointers.
\n       . '"${c}"stats(_#ind)"$n" returns the statistics vector of the running image '"${c}"[ind]"$n"', i.e the vector
\n          "${g}"[ im,iM,ia,iv,xm,ym,zm,cm,xM,yM,zM,cM,is,ip ]"$n" (14 values).
\n       . '"${c}"unref(a,b,...)"$n" destroys references to the named variable given as arguments.
\n       . '"${c}"breakpoint()"$n" inserts a possible computation breakpoint (not supported by the cli interface).
\n       . '"${c}"_(expr)"$n" just ignores its arguments (mainly useful for debugging).
\n       . '"${c}"ext('pipeline')"$n" executes the specified "${-GMIC}" pipeline as if it was called outside
\n          the currently evaluated expression.
\n
\n    - "${g}"User-defined macros:"$n"
\n
\n       . Custom macro functions can be defined in a math expression, using the assignment operator
\n          '"${c}"="$n"', e.g. '"${c}"foo(x,y) = cos(x + y); result = foo(1,2) + foo(2,3)"$n"'.
\n       . Trying to override a built-in function (e.g. '"${c}"abs()"$n"') has no effect.
\n       . Overloading macros with different number of arguments is possible. Re-defining a
\n          previously defined macro with the same number of arguments discards its previous
\n          definition.
\n       . Macro functions are indeed processed as "${g}"macros"$n" by the mathematical evaluator. You should
\n          avoid invoking them with arguments that are themselves results of assignments or
\n          self-operations. For instance, '"${c}"foo(x) = x + x; z = 0; foo(++z)"$n"' returns '"${g}"4"$n"' rather
\n          than expected value '"${g}"2"$n"'.
\n       . When substituted, macro arguments are placed inside parentheses, except if a number sign
\n          '"${c}"#"$n"' is located just before or after the argument name. For instance, expression
\n          '"${c}"foo(x,y) = x*y; foo(1+2,3)"$n"' returns '"${g}"9"$n"' (being substituted as '"${c}"(1+2)*(3)"$n"'), while
\n          expression '"${c}"foo(x,y) = x#*y#; foo(1+2,3)"$n"' returns '"${g}"7"$n"' (being substituted as '"${c}"1+2*3"$n"').
\n       . Number signs appearing between macro arguments function actually count for '"${c}"empty"$n"'
\n          separators. They may be used to force the substitution of macro arguments in unusual
\n          places, e.g. as in '"${c}"str(N) = ['I like N#'];"$n"'.
\n
\n    - "${g}"Multi-threaded"$n" and "${g}"in-place"$n" evaluation:
\n
\n       . If your image data are large enough and you have several CPUs available, it is likely that
\n          the math expression passed to a '"${c}"fill"$n"' or '"${c}"input"$n"' command is evaluated in parallel,
\n          using multiple computation threads.
\n       . Starting an expression with '"${c}":"$n"' or '"${c}"*"$n"' forces the evaluations required for an image to be
\n          run in parallel, even if the amount of data to process is small (beware, it may be slower
\n          to evaluate in this case!). Specify '"${c}":"$n"' (instead of '"${c}"*"$n"') to avoid possible image copy
\n          done before evaluating the expression (this saves memory, but do this only if you are
\n          sure this step is not required!)
\n       . If the specified expression starts with '"${c}">"$n"' or '"${c}"<"$n"', the pixel access operators
\n          '"${c}"i(), i[], j()"$n"' and '"${c}"j[]"$n"' return values of the image being currently modified,
\n          in forward ('"${c}">"$n"') or backward ('"${c}"<"$n"') order. The multi-threading evaluation of the
\n          expression is also disabled in this case.
\n       . Function '"${c}"critical(operands)"$n"' forces the execution of the given operands in a single thread at a
\n          time.
\n
\n    _ Expressions '"${c}"i(_#ind,x,_y,_z,_c)=value"$n"', '"${c}"j(_#ind,x,_y,_z,_c)=value"$n"', '"${c}"i[_#ind,offset]=value"$n"'
\n       and '"${c}"j[_#ind,offset]=value"$n"' set a pixel value at a different location than the running one
\n       in the image "${g}"[ind]"$n" (or in the associated image if argument '"${c}"#ind"$n"' is omitted), either with
\n       global coordinates/offsets (with '"${c}"i(...)"$n"' and '"${c}"i[...]"$n"'), or relatively to the current
\n       position "${g}"(x,y,z,c)"$n" (with '"${c}"j(...)"$n"' and '"${c}"j[...]"$n"'). These expressions always return '"${c}"value"$n"'.
\n
\n  - The last image of the list is always associated to the evaluations of '"${c}"{expressions}"$n"',
\n     e.g. "${-GMIC}" sequence '"${c}"256,128 fill {w}"$n"' will create a 256x128 image filled with value 256."

  _help_section "Image and data viewers"

  _help_paragraph "  - "${-GMIC}" has some very handy embedded "${g}"visualization modules"$n", for 1D signals (command '"${c}"plot"$n"'),
\n     1D/2D/3D images (command '"${c}"display"$n"') and 3D objects (command '"${c}"display3d"$n"'). It manages
\n     interactive views of the selected image data.
\n
\n  - The following keyboard shortcuts are available in the interactive viewers:
\n
\n    . "${g}"(mousewheel)"$n": Zoom in/out.
\n    . "${g}"CTRL+D"$n": Increase window size.
\n    . "${g}"CTRL+C"$n": Decrease window size.
\n    . "${g}"CTRL+R"$n": Reset window size.
\n    . "${g}"CTRL+W"$n": Close window.
\n    . "${g}"CTRL+F"$n": Toggle fullscreen mode.
\n    . "${g}"CTRL+S"$n": Save current window snapshot as numbered file 'gmic_xxxx.bmp'.
\n    . "${g}"CTRL+O"$n": Save current instance of the viewed data, as numbered file 'gmic_xxxx.cimgz'.
\n
\n  - Shortcuts specific to the 1D/2D/3D image viewer (command '"${c}"display"$n"') are:
\n
\n    . "${g}"CTRL+A"$n": Switch cursor mode.
\n    . "${g}"CTRL+P"$n": Play z-stack of frames as a movie (for volumetric 3D images).
\n    . "${g}"CTRL+V"$n": Show/hide 3D view (for volumetric 3D images).
\n    . "${g}"CTRL+(mousewheel)"$n": Go up/down.
\n    . "${g}"SHIFT+(mousewheel)"$n": Go left/right.
\n    . "${g}"Numeric PAD"$n": Zoom in/out (+/-) and move through zoomed image (digits).
\n    . "${g}"BACKSPACE"$n": Reset zoom scale.
\n
\n  - Shortcuts specific to the 3D object viewer (command '"${c}"display3d"$n"') are:
\n
\n    . "${g}"(mouse)+(left mouse button)"$n": Rotate 3D object.
\n    . "${g}"(mouse)+(right mouse button)"$n": Zoom 3D object.
\n    . "${g}"(mouse)+(middle mouse button)"$n": Shift 3D object.
\n    . "${g}"CTRL+F1 ... CTRL+F6"$n": Toggle between different 3D rendering modes.
\n    . "${g}"CTRL+Z"$n": Enable/disable z-buffered rendering.
\n    . "${g}"CTRL+A"$n": Show/hide 3D axes.
\n    . "${g}"CTRL+G"$n": Save 3D object, as numbered file 'gmic_xxxx.off'.
\n    . "${g}"CTRL+T"$n": Switch between single/double-sided 3D modes."

  _help_section "Adding custom commands"

  _help_paragraph "  - New custom commands can be added by the user, through the use of "${-GMIC}" "${g}"custom commands files"$n".
\n
\n  - A command file is a simple ascii text file, where each line starts either by
\n     '"${c}"command_name: command_definition"$n"' or '"${c}"command_definition (continuation)"$n"'.
\n
\n  - At startup, "${-GMIC}" automatically includes user's command file "${g}"$HOME/.gmic"$n" (on Unix) or
\n     "${g}"%APPDATA%/user.gmic"$n" (on Windows). The CLI tool '"${g}"gmic"$n"' automatically runs the command
\n     '"${c}"cli_start"$n"' if defined.
\n
\n  - Custom command names must use character set "${g}"[a-zA-Z0-9_]"$n" and cannot start with a number.
\n
\n  - Any '"${c}" ""# comment"$n"' expression found in a custom commands file is discarded by the "${-GMIC}" parser,
\n     wherever it is located in a line.
\n
\n  - In a custom command, the following "${g}"$-expressions"$n" are recognized and substituted:
\n
\n    . '"${c}"$""\*"$n"' is substituted by a copy of the specified string of arguments.
\n    . '"${c}"$\"*\""$n"' is substituted by a copy of the specified string of arguments, each being
\n       double-quoted.
\n    . '"${c}"$""#"$n"' is substituted by the maximum index of known arguments (either specified by the user
\n       or set to a default value in the custom command).
\n    . '"${c}"$""[]"$n"' is substituted by the list of selected image indices that have been specified during the
\n       command invocation.
\n    . '"${c}"$""?"$n"' is substituted by a printable version of '"${c}"$""[]"$n"' to be used in command descriptions.
\n    . '"${c}"$i"$n"' and '"${c}"${i}"$n"' are both substituted by the "${g}"i^th"$n" specified argument. Negative indices such as
\n       '"${c}"${-j}"$n"' are allowed and refer to the "${g}"j^th"$n" latest argument. '"${c}"$""0"$n"' is substituted by the
\n       custom command name.
\n    . '"${c}"${i=default}"$n"' is substituted by the value of "${c}"$i"$n" (if defined) or by its new value set to
\n        '"${g}"default"$n"' otherwise ('"${g}"default"$n"' may be a $-expression as well).
\n    . '"${c}"${subset}"$n"' is substituted by the argument values (separated by commas '"${g}","$n"') of a specified
\n       argument subset. For instance expression '"${c}"$""{2--2}"$n"' is substitued by all specified command
\n       arguments except the first and the last one. Expression '"${c}"$""{^0}"$n"' is then substituted by all
\n       arguments of the invoked command (eq. to '"${c}"$""*"$n"' if all specified arguments have indeed a
\n       value).
\n    . '"${c}"$""=var"$n"' is substituted by the set of instructions that will assign each argument "${c}"$i"$n" to the
\n       named variable '"${c}"var$i"$n"' (for i in "${g}"[0...$""#]"$n"). This is particularly useful when a custom
\n       command want to manage variable numbers of arguments. Variables names must use character set
\n       "${g}"[a-zA-Z0-9_]"$n" and cannot start with a number.
\n
\n  - These particular "${g}"$-expressions"$n" for custom commands are "${g}"always substituted"$n", even in
\n     double-quoted items or when the dollar sign '"${g}"$"$n"' is escaped with a backslash '"${g}"\\"$n"'. To avoid
\n     substitution, place an empty double quoted string just after the '"${g}"$"$n"' (as in '"${c}"$\"\"1"$n"').
\n
\n  - Specifying arguments may be skipped when invoking a custom command, by replacing them by commas
\n     '"${g}","$n"' as in expression '"${c}"flower ,,3"$n"'. Omitted arguments are set to their default values, which
\n     must be thus explicitly defined in the code of the corresponding custom command (using
\n     default argument expressions as '"${c}"$""{1=default}"$n"').
\n
\n  - If one numbered argument required by a custom command misses a value, an error is thrown by the
\n     "${-GMIC}" interpreter."

  _help_section "List of commands"

  _help_paragraph "   All available "${-GMIC}" commands are listed below, classified by themes. When several choices of
\n   command arguments are possible, they appear separated by '"${g}"|"$n"'. An argument specified inside '"${g}"[]"$n"'
\n   or starting by '"${g}"_"$n"' is optional except when standing for an existing image "${c}"[image]"$n", where '"${g}"image"$n"'
\n   can be either an index number or an image name. In this case, the '"${g}"[]"$n"' characters are mandatory
\n   when writing the item. A command marked with '"${g}"(+)"$n"' is one of the "${g}"builtin"$n" commands. Note also that
\n   all images that serve as illustrations in this reference documentation are normalized in "${g}"[0,255]"$n"
\n   before being displayed. You may need to do this explicitly (command '"${c}"normalize 0,255"$n"') if you
\n   want to save and view images with the same aspect than those illustrated in the example codes."

_help_examples :
  g=$_gmic_g c=$_gmic_c n=$_gmic_n
  _help_section "Examples of use"

  _help_paragraph " '"${g}"gmic"$n"' is a generic image processing tool which can be used in a wide variety of situations.
\n The few examples below illustrate possible uses of this tool:
\n
\n  - View a list of images:
\n     "${c}"gmic file1.bmp file2.jpeg"$n"
\n
\n  - Convert an image file:
\n     "${c}"gmic input.bmp output output.jpg"$n"
\n
\n  - Create a volumetric image from a movie sequence:
\n     "${c}"gmic input.mpg append z output output.hdr"$n"
\n
\n  - Compute image gradient norm:
\n     "${c}"gmic input.bmp gradient_norm"$n"
\n
\n  - Denoise a color image:
\n     "${c}"gmic image.jpg denoise 30,10 output denoised.jpg"$n"
\n
\n  - Compose two images using overlay layer blending:
\n     "${c}"gmic image1.jpg image2.jpg blend overlay output blended.jpg"$n"
\n
\n  - Evaluate a mathematical expression:
\n     "${c}"gmic echo \"cos(pi/4)^2+sin(pi/4)^2={cos(pi/4)^2+sin(pi/4)^2}\""$n"
\n
\n  - Plot a 2D function:
\n     "${c}"gmic 1000,1,1,2 fill \"X=3*(x-500)/500;X^2*sin(3*X^2)+if(c==0,u(0,-1),cos(X*10))\" plot"$n"
\n
\n  - Plot a 3D elevated function in random colors:
\n     "${c}"gmic 128,128,1,3,\"u(0,255)\" plasma 10,3 blur 4 sharpen 10000 \\\
\n      elevation3d[-1] \"'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'\""$n"
\n
\n  - Plot the isosurface of a 3D volume:
\n     "${c}"gmic mode3d 5 moded3d 5 double3d 0 isosurface3d \"'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))'\",3"$n"
\n
\n  - Render a "${-GMIC}" 3D logo:
\n     "${c}"gmic 0 text G\\\47MIC,0,0,53,1,1,1,1 expand_xy 10,0 blur 1 normalize 0,100 +plasma 0.4 add \\\
\n      blur 1 elevation3d -0.1 moded3d 4"$n"
\n
\n  - Generate a 3D ring of torii:
\n     "${c}"gmic repeat 20 torus3d 15,2 color3d[-1] \"{u(60,255)},{u(60,255)},{u(60,255)}\" \\\
\n      *3d[-1] 0.5,1 if \"{$>%2}\" rotate3d[-1] 0,1,0,90 fi add3d[-1] 70 add3d \\\
\n      rotate3d 0,0,1,18 done moded3d 3 mode3d 5 double3d 0"$n"
\n
\n  - Create a vase from a 3D isosurface:
\n     "${c}"gmic moded3d 4 isosurface3d \"'x^2+2*abs(y/2)*sin(2*y)^2+z^2-3',0\" sphere3d 1.5 \\\
\n      sub3d[-1] 0,5 plane3d 15,15 rotate3d[-1] 1,0,0,90 center3d[-1] add3d[-1] 0,3.2 \\\
\n      color3d[-1] 180,150,255 color3d[-2] 128,255,0 color3d[-3] 255,128,0 add3d"$n"
\n
\n  - Display filtered webcam stream:
\n     "${c}"gmic apply_camera \\\"+mirror x +mirror y add div 4\\\""$n"
\n
\n  - Launch a set of "${-GMIC}" interactive demos:
\n     "${c}"gmic demo"$n"
\n"

# Commands to output help in ascii format.
_help_header_ascii :
  __help_header_ascii
  _section=0 _space1="" _space2=" "
  _help_section "Usage"

__help_header_ascii :
  if {narg($_prerelease)} strprerelease=" (pre-release ""#"$_prerelease")" else strprerelease="" fi
  str="\n  "${_gmic_b}"gmic: GREYC\'s Magic for Image Computing."$_gmic_n"
\n
\n        "$_gmic_g${_gmic_b}"Version "${-strver}$strprerelease$_gmic_n", Copyright (c) 2008-2019, David Tschumperle.
\n        "$_gmic_g"(https://gmic.eu)"$_gmic_n
  if {['$$_e']==0} m "_e : e[] \"$""*\"" fi
  v + _e[] $str v -

_help_section_ascii :
  _section+=1
  {narg({'"$1"'})},1,1,1,{'-'}
  v +
  e[] "\n "$_gmic_m$_gmic_b$_section". $1"
  e[] "    "${_space{narg({'$_section'})}}{t}$_gmic_n"\n"
  v -
  rm.

_help_paragraph_ascii :
  v +
  e[] "$*"
  v -

_help_footer_ascii :
  v +
  e[] " "$_gmic_r$_gmic_b"** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: https://gmic.eu **"$_gmic_n
  v -

# Commands to output help in html format.
_help_header_html :
  _section=0
  if {narg($_prerelease)} strprerelease=" (pre-release ""#"$_prerelease")" else strprerelease="" fi
  _gmic_n="</span>"
  _gmic_r="<span style=\"color: \#900000\">"
  _gmic_g="<span style=\"color: \#900090\">"
  _gmic_m="<span style=\"color: \#900090\">"
  _gmic_c="<span style=\"color: \#005090\">"
  _gmic_b="<span style=\"font-weight: bold\">"
  _gmic_quotedc="<span class=\"ref_code\">"
  _gmic_quotedg="<span style=\\\"color: \#203090; font-family: monospace\\\">"
  v +
  e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<!--#include file=\"header.html\" -->
\n<div id=\"bloc_option\">
\n<div id=\"top_rouge\"><div id=\"text_top\">Reference</div></div>
\n<div id=\"center\"><div id=\"text_centre_intro\">
\n<h2>Preamble</h2>
\n<ul>
\n<li>This document is distributed under the <a href=\"http://www.gnu.org/licenses/fdl-1.3.txt\">GNU Free Documentation License</a>, version 1.3.</li>
\n<li>A <a href=\"gmic_reference.pdf\">.pdf version</a> of this document is available.</li>
\n<li>We also suggest you read <a href=\"tutorial/index.shtml\">these tutorial pages</a> which provide a more user-friendly explanation of most of the G\47MIC basics.</li>
\n</ul>
\n<h2><a id=\"toc\">Table of contents</a></h2>
\n<ul>
\n<li><a href=\"#section0\">Version</a></li>
\n<li><a href=\"#section1\">Usage</a></li>
\n<ul>
\n<li><a href=\"#section2\">Overall context</a></li>
\n<li><a href=\"#section3\">Image definition and terminology</a></li>
\n<li><a href=\"#section4\">Items of a processing pipeline</a></li>
\n<li><a href=\"#section5\">Input data items</a></li>
\n<li><a href=\"#section6\">Command items and selections</a></li>
\n<li><a href=\"#section7\">Input/output properties</a></li>
\n<li><a href=\"#section8\">Substitution rules</a></li>
\n<li><a href=\"#section9\">Mathematical expressions</a></li>
\n<li><a href=\"#section10\">Image and data viewers</a></li>
\n<li><a href=\"#section11\">Adding custom commands</a></li>
\n</ul>
\n<li><a href=\"#section12\">List of commands</a></li>
\n<ul>
\n<li><a href=\"#subsection1\">Global options</a></li>
\n<li><a href=\"#subsection2\">Input/output</a></li>
\n<li><a href=\"#subsection3\">List manipulation</a></li>
\n<li><a href=\"#subsection4\">Mathematical operators</a></li>
\n<li><a href=\"#subsection5\">Values manipulation</a></li>
\n<li><a href=\"#subsection6\">Colors manipulation</a></li>
\n<li><a href=\"#subsection7\">Geometry manipulation</a></li>
\n<li><a href=\"#subsection8\">Filtering</a></li>
\n<li><a href=\"#subsection9\">Features extraction</a></li>
\n<li><a href=\"#subsection10\">Image drawing</a></li>
\n<li><a href=\"#subsection11\">Matrix computation</a></li>
\n<li><a href=\"#subsection12\">3D rendering</a></li>
\n<li><a href=\"#subsection13\">Control flow</a></li>
\n<li><a href=\"#subsection14\">Arrays,tiles and frames</a></li>
\n<li><a href=\"#subsection15\">Artistic</a></li>
\n<li><a href=\"#subsection16\">Warpings</a></li>
\n<li><a href=\"#subsection17\">Degradations</a></li>
\n<li><a href=\"#subsection18\">Blending and fading</a></li>
\n<li><a href=\"#subsection19\">Image sequences and videos</a></li>
\n<li><a href=\"#subsection20\">Convenience functions</a></li>
\n<li><a href=\"#subsection21\">Other interactive commands</a></li>
\n<li><a href=\"#subsection22\">Command shortcuts</a></li>
\n</ul>
\n<li><a href=\"#section13\">Examples of use</a></li>
\n</ul>
\n<a id=\"section0\"><h2>Version</h2></a>
\n<pre><font color=\"blue\"><b>gmic:</b> GREYC\'s Magic for Image Computing.</font>
\n
\n       Version <font color=\"brown\"><b>"${-strver}$strprerelease"</b></font>, Copyright (c) 2008-2019, David Tschumperl&eacute;
\n       (<a href=\"https://gmic.eu\">https://gmic.eu</a>)
\n</pre>
"
v -
 _help_section "Usage"

_help_section_html :
  _section+=1
  v +
  e[] "<hr style=\"border-top: 1px solid \#ccc;\"/>\n<h2><a href=\"#toc\"><img alt=\"\" border=\"0\" src=\"img/back_top.png\" />&nbsp;&nbsp;</a><a id=\"section"$_section"\">$1</a></h2>"
  v -

_help_paragraph_html :
  ({'{/"$*"}'})
  replace_str. "'"{/$_gmic_c},$_gmic_quotedc
  replace_str. "'"{/$_gmic_g},$_gmic_quotedg
  replace_str. $_gmic_n"'",$_gmic_n
  replace_str. "  - ","  &bull; "
  replace_str. "  . ","  &#9702; "
  replace_str. "  _ ","  &#9654; "
  add_link_html. 1
  v + e[] "<pre>"{t}"</pre>" v -
  rm.

_help_footer_html :
  v +
  e[] "
\n<br/><b><font color=\"brown\">** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: <a href=\"https://gmic.eu\">https://gmic.eu **</a></font></b>
\n</tt>
\n</div>
\n</div>
\n<div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div>
\n</div>
\n<!--#include file=\"copyright.html\" -->
\n<!--#include file=\"footer.html\" -->
"
  v -

# Commands to output help in latex format.
_help_header_latex :
  strver=${-strver}
  if {narg($_prerelease)} strprerelease=" (pre-release \\#"$_prerelease")" else strprerelease="" fi
  _gmic_n="§\\aftergroup\\Ccn§"
  _gmic_b="§\\aftergroup\\Ccb§"
  _gmic_r="§\\aftergroup\\Ccr§"
  _gmic_g="§\\aftergroup\\Ccg§"
  _gmic_c="§\\aftergroup\\Ccb§"
  _gmic_m=""
  v + e[] "\\documentclass[a4paper,10.5pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,listings,color}
\n\\graphicspath{{img/}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{6in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\oddsidemargin}{15.5pt}
\n\\setlength{\\evensidemargin}{15.5pt}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\def\\Ccr{\\color{ca}}
\n\\def\\Ccb{\\color{cb}}
\n\\def\\Ccg{\\color{cc}}
\n\\def\\Ccc{\\color{cd}}
\n\\def\\Ccn{\\color{black}}
\n\\def\\comma{\\discretionary{,}{}{,}}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\title{\\fbox{\\parbox{\\textwidth}{\\begin{center}\\vspace*{2cm}\\includegraphics[width=12cm]{gmic_banner.jpg}\\\\\\vspace*{1cm}{\\Huge \\textbf{The Handbook}\\\\{\\small Version "$strver$strprerelease"}\\\\\\vspace*{1cm}}\\end{center}}}}
\n\\author{\\Large \\bf David Tschumperl\\'e}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\lstset{columns=fullflexible,basicstyle=\\normalfont}
\n\\begin{document}
\n\\maketitle
\n\\tableofcontents
\n\\chapter*{Preamble}
\n\\section*{License}
\n This document is distributed under the \\textbf{GNU Free Documentation License}, version 1.3.\\\\
\n Read the full license terms at \\url{http://www.gnu.org/licenses/fdl-1.3.txt}.\\\\~\\\\
\n An online version of this documentation is available at:\\\\\\url{https://gmic.eu/reference.shtml}.
\n\\section*{Motivations}
\n \\Cc{G\47MIC} is a full-featured open-source framework for image processing, distributed under the CeCILL free software licenses
\n (LGPL-like and/or GPL-compatible). It provides several user interfaces to
\n convert/manipulate/filter/visualize generic image datasets, ranging from 1D scalar signals to 3D+t sequences of multi-spectral
\n volumetric images, hence including 2D color images.
\n~\\\\G'MIC user interfaces are:
\n\\begin{itemize}
\n\\item '\\texttt{gmic}', a command-line tool to use the \\Cc{G\47MIC} image processing features from a shell.
\n In this setting, \\Cc{G\47MIC} may be seen as a friendly companion to the ImageMagick or GraphicsMagick software suites.
\n\\item '\\texttt{libgmic}', a small, portable, thread-safe and multi-threaded, C++ image processing library to be linked to third-party applications.
\n It's simple API allows programmers to add all \\Cc{G\47MIC} features in their own software without much efforts (a C API is available as well).
\n\\item '\\texttt{G'MIC-Qt}', a plug-in to bring \\Cc{G\47MIC} capabilities to the image retouching and painting software GIMP and Krita.
\n More than 500 filters are already available, sorted by category (Artistic, Black \\& white, Colors, Contours, Deformations,
\n Degradations, Details, Color Grading, Frames, Layers, Light \\& shadows, Patterns,
\n Rendering, Repair, Sequences, etc.).
\n\\item '\\texttt{\\Cc{G\47MIC} Online}', a web service to allow users applying image processing algorithms on their images, directly from a web browser.
\n\\item '\\texttt{ZArt}', a Qt-based interface for real-time processing of video streaming coming from webcams or video files.
\n\\end{itemize}
\n \\Cc{G\47MIC} is focused on the design of possibly complex pipelines for converting, manipulating, filtering and visualizing generic 1D/2D/3D multi-spectral image datasets. This includes of course color images, but also more complex data as image sequences or 3D(+t) volumetric float-valued datasets.\\\\
\n
\n \\Cc{G\47MIC} is an open framework: the default language can be extended with custom \\Cc{G\47MIC}-written commands, defining thus new available image filters or effects. By the way, \\Cc{G\47MIC} already contains a substantial set of pre-defined image processing algorithms and pipelines (more than 1000).\\\\
\n
\n \\Cc{G\47MIC} has been designed with portability in mind and runs on different platforms (Windows, Unix, MacOSX). It is distributed partly under the CeCILL licenses (CeCILL-C and/or CeCILL). Since 2008, it is developed in the Image Team of the GREYC laboratory, in Caen/France, by permanent researchers working in the field of image processing on a daily basis.
\n\\section*{Version}
\n
\n \\Ca{\\textbf{gmic:} GREYC\'s Magic for Image Computing.}\\\\
\n
\n        \\Cb{Version \\textbf{"$strver$strprerelease"}, Copyright (c) 2008-2019, David Tschumperl\\'e}\\\\
\n        \\Cb{(\\url{https://gmic.eu})}
\n\\chapter{Usage}
"
  v -

_help_section_latex : skip "$1"
  v +
  e[] "~\\\\\\section{$1}"
  v -

_help_paragraph_latex : skip "$1"
  v +
  e[] "\\small"
  e[] "\\begin{lstlisting}[escapechar=§]"
  e[] "$1"
  e[] "\\end{lstlisting}"
  e[] "\\normalsize"
  v -

_help_footer_latex :
  v +
  e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
  v -

# Commands to output help in man page format.
_help_header_man :
  v + e[] ".TH G\47MIC 1\n\
        .SH NAME\n\
        gmic \\- Perform image processing operations using the G\47MIC framework.\n\
        \n\
       .SH HELP\n" v -
  _gmic_n="\\fR"
  _gmic_b="\\fB"
  _gmic_r=""
  _gmic_g=""
  _gmic_c="\\fB"
  _gmic_m=""
  _prerelease=
  __help_header_ascii
  _gmic_n="__N"
  _gmic_b="__B"
  _gmic_r="__B"
  _gmic_c="__B"
  _section=0 _space1="" _space2=" "
  _help_section "Usage"

_help_section_man :
  _section+=1
  {narg({'"$1"'})},1,1,1,{'-'}
  v +
  e[] "\n \\fB"$_section". $1"
  e[] "    "${_space{narg({'$_section'})}}{t}"\\fR\n"
  v -
  rm.

_help_paragraph_man :
  l[] ({'"$*"'})
  replace_str "\\fR","__N"
  replace_str "\\fB","__B"
  replace_str "\\","\\\\\\\\"
  replace_str "__N","\\\\fR"
  replace_str "__B","\\\\fB"
  v +
  e[] {0,t}
  v -
  rm endl

_help_footer_man :
  _help_footer_ascii $"*"

# use_vt100
# This command defines some global variables used to output colored text on VT100 terminals.
use_vt100 :
  v - if {0$_vt100>0}
    _gmic_n="\33[0;0;0m"
    _gmic_r="\33[0;31;59m"
    _gmic_g="\33[0;32;59m"
    _gmic_m="\33[0;35;59m"
    _gmic_c="\33[0;36;59m"
    _gmic_b="\33[1m"
  fi v +

#@cli version
#@cli : Display current version number on stdout.
version :
  v -
  m "_e : echo_stdout[] \"$""*\""
  if {$^>=-1} _e "" fi
  __help_header_ascii[]
  uncommand _e
  v +

v : # Allow 'gmic +v' to get the version number.
  version

#-------------------------------
#
#@cli :: Input / Output
#
#-------------------------------

#@cli camera : _camera_index>=0,_nb_frames>0,_skip_frames>=0,_capture_width>=0,_capture_height>=0 : (+)
#@cli : Insert one or several frames from specified camera.
#@cli : When 'nb_frames==0', the camera stream is released instead of capturing new images.
#@cli : Default values: 'camera_index=0' (default camera), 'nb_frames=1', 'skip_frames=0' and 'capture_width=capture_height=0' (default size).

#@cli clut : "clut_name",_resolution>0
#@cli : Insert one of the 552 pre-defined CLUTs at the end of the image list.\n
#@cli : 'clut_name' can be { 2-strip-process | 60s | 60s_faded | 60s_faded_alt | agfa_apx_100 | agfa_apx_25 | agfa_precisa_100 | agfa_ultra_color_100 | agfa_vista_200 | alien_green | analogfx_anno_1870_color | analogfx_old_style_i | analogfx_old_style_ii | analogfx_old_style_iii | analogfx_sepia_color | analogfx_soft_sepia_i | analogfx_soft_sepia_ii | anime | apocalypse_this_very_moment | aqua | aqua_and_orange_dark | arabica_12 | ava_614 | azrael_93 | bboyz_2 | berlin_sky | black_and_white | bleach_bypass | bleachbypass_1 | bleachbypass_2 | bleachbypass_3 | bleachbypass_4 | blue_mono | blues | bob_ford | bourbon_64 | bw_1 | bw_10 | bw_2 | bw_3 | bw_4 | bw_5 | bw_6 | bw_7 | bw_8 | bw_9 | byers_11 | candlelight | chemical_168 | chrome_01 | cinematic-1 | cinematic-10 | cinematic-2 | cinematic-3 | cinematic-4 | cinematic-5 | cinematic-6 | cinematic-7 | cinematic-8 | cinematic-9 | classic_teal_and_orange | clayton_33 | clouseau_54 | cobi_3 | color_rich | colornegative | contrail_35 | crispwarm | crispwinter | cubicle_99 | django_25 | domingo_145 | dropblues | earth_tone_boost | edgyember | expired_fade | expired_polaroid | extreme | fade | fade_to_green | faded | faded_47 | faded_alt | faded_analog | faded_extreme | faded_vivid | fallcolors | faux_infrared | fgcinebasic | fgcinebright | fgcinecold | fgcinedrama | fgcinetealorange_1 | fgcinetealorange_2 | fgcinevibrant | fgcinewarm | film_print_01 | film_print_02 | foggynight | folger_50 | french_comedy | fuji_160c | fuji_160c_+ | fuji_160c_++ | fuji_160c_- | fuji_3510_constlclip | fuji_3510_constlmap | fuji_3510_cuspclip | fuji_3513_constlclip | fuji_3513_constlmap | fuji_3513_cuspclip | fuji_400h | fuji_400h_+ | fuji_400h_++ | fuji_400h_- | fuji_800z | fuji_800z_+ | fuji_800z_++ | fuji_800z_- | fuji_astia_100_generic | fuji_astia_100f | fuji_fp-100c | fuji_fp-100c_+ | fuji_fp-100c_++ | fuji_fp-100c_+++ | fuji_fp-100c_++_alt | fuji_fp-100c_- | fuji_fp-100c_-- | fuji_fp-100c_alt | fuji_fp-100c_cool | fuji_fp-100c_cool_+ | fuji_fp-100c_cool_++ | fuji_fp-100c_cool_- | fuji_fp-100c_cool_-- | fuji_fp-100c_negative | fuji_fp-100c_negative_+ | fuji_fp-100c_negative_++ | fuji_fp-100c_negative_+++ | fuji_fp-100c_negative_++_alt | fuji_fp-100c_negative_- | fuji_fp-100c_negative_-- | fuji_fp-3000b | fuji_fp-3000b_+ | fuji_fp-3000b_++ | fuji_fp-3000b_+++ | fuji_fp-3000b_- | fuji_fp-3000b_-- | fuji_fp-3000b_hc | fuji_fp-3000b_negative | fuji_fp-3000b_negative_+ | fuji_fp-3000b_negative_++ | fuji_fp-3000b_negative_+++ | fuji_fp-3000b_negative_- | fuji_fp-3000b_negative_-- | fuji_fp-3000b_negative_early | fuji_fp_100c | fuji_neopan_1600 | fuji_neopan_1600_+ | fuji_neopan_1600_++ | fuji_neopan_1600_- | fuji_neopan_acros_100 | fuji_provia_100_generic | fuji_provia_100f | fuji_provia_400f | fuji_provia_400x | fuji_sensia_100 | fuji_superia_100 | fuji_superia_100_+ | fuji_superia_100_++ | fuji_superia_100_- | fuji_superia_1600 | fuji_superia_1600_+ | fuji_superia_1600_++ | fuji_superia_1600_- | fuji_superia_200 | fuji_superia_200_xpro | fuji_superia_400 | fuji_superia_400_+ | fuji_superia_400_++ | fuji_superia_400_- | fuji_superia_800 | fuji_superia_800_+ | fuji_superia_800_++ | fuji_superia_800_- | fuji_superia_hg_1600 | fuji_superia_reala_100 | fuji_superia_x-tra_800 | fuji_velvia_100_generic | fuji_velvia_50 | fuji_xtrans_iii_acros | fuji_xtrans_iii_acros+g | fuji_xtrans_iii_acros+r | fuji_xtrans_iii_acros+ye | fuji_xtrans_iii_astia | fuji_xtrans_iii_classic_chrome | fuji_xtrans_iii_mono | fuji_xtrans_iii_mono+g | fuji_xtrans_iii_mono+r | fuji_xtrans_iii_mono+ye | fuji_xtrans_iii_pro_neg_hi | fuji_xtrans_iii_pro_neg_std | fuji_xtrans_iii_provia | fuji_xtrans_iii_sepia | fuji_xtrans_iii_velvia | fusion_88 | futuristicbleak_1 | futuristicbleak_2 | futuristicbleak_3 | futuristicbleak_4 | golden | golden_bright | golden_fade | golden_mono | golden_vibrant | goldfx_bright_spring_breeze | goldfx_bright_summer_heat | goldfx_hot_summer_heat | goldfx_perfect_sunset_01min | goldfx_perfect_sunset_05min | goldfx_perfect_sunset_10min | goldfx_spring_breeze | goldfx_summer_heat | green_blues | green_mono | green_yellow | hackmanite | herderite | heulandite | hiddenite | hilutite | hong_kong | horrorblue | howlite | hyla_68 | hypersthene | ilford_delta_100 | ilford_delta_3200 | ilford_delta_3200_+ | ilford_delta_3200_++ | ilford_delta_3200_- | ilford_delta_400 | ilford_fp_4_plus_125 | ilford_hp_5 | ilford_hp_5_+ | ilford_hp_5_++ | ilford_hp_5_- | ilford_hp_5_plus_400 | ilford_hps_800 | ilford_pan_f_plus_50 | ilford_xp_2 | kodak_2383_constlclip | kodak_2383_constlmap | kodak_2383_cuspclip | kodak_2393_constlclip | kodak_2393_constlmap | kodak_2393_cuspclip | kodak_bw_400_cn | kodak_e-100_gx_ektachrome_100 | kodak_ektachrome_100_vs | kodak_ektachrome_100_vs_generic | kodak_ektar_100 | kodak_elite_100_xpro | kodak_elite_chrome_200 | kodak_elite_chrome_400 | kodak_elite_color_200 | kodak_elite_color_400 | kodak_elite_extracolor_100 | kodak_hie_hs_infra | kodak_kodachrome_200 | kodak_kodachrome_25 | kodak_kodachrome_64 | kodak_kodachrome_64_generic | kodak_portra_160 | kodak_portra_160_+ | kodak_portra_160_++ | kodak_portra_160_- | kodak_portra_160_nc | kodak_portra_160_nc_+ | kodak_portra_160_nc_++ | kodak_portra_160_nc_- | kodak_portra_160_vc | kodak_portra_160_vc_+ | kodak_portra_160_vc_++ | kodak_portra_160_vc_- | kodak_portra_400 | kodak_portra_400_+ | kodak_portra_400_++ | kodak_portra_400_- | kodak_portra_400_nc | kodak_portra_400_nc_+ | kodak_portra_400_nc_++ | kodak_portra_400_nc_- | kodak_portra_400_uc | kodak_portra_400_uc_+ | kodak_portra_400_uc_++ | kodak_portra_400_uc_- | kodak_portra_400_vc | kodak_portra_400_vc_+ | kodak_portra_400_vc_++ | kodak_portra_400_vc_- | kodak_portra_800 | kodak_portra_800_+ | kodak_portra_800_++ | kodak_portra_800_- | kodak_portra_800_hc | kodak_t-max_100 | kodak_t-max_3200 | kodak_t-max_400 | kodak_tmax_3200 | kodak_tmax_3200_+ | kodak_tmax_3200_++ | kodak_tmax_3200_- | kodak_tmax_3200_alt | kodak_tri-x_400 | kodak_tri-x_400_+ | kodak_tri-x_400_++ | kodak_tri-x_400_- | kodak_tri-x_400_alt | korben_214 | landscape_1 | landscape_10 | landscape_2 | landscape_3 | landscape_4 | landscape_5 | landscape_6 | landscape_7 | landscape_8 | landscape_9 | latesunset | lc_1 | lc_10 | lc_2 | lc_3 | lc_4 | lc_5 | lc_6 | lc_7 | lc_8 | lc_9 | lenox_340 | life_giving_tree | light_blown | lomo | lomography_redscale_100 | lomography_x-pro_slide_200 | lucky_64 | mckinnon_75 | milo_5 | mono_tinted | moody_1 | moody_10 | moody_2 | moody_3 | moody_4 | moody_5 | moody_6 | moody_7 | moody_8 | moody_9 | moonlight | moonrise | mute_shift | muted_fade | natural_vivid | neon_770 | nightfromday | nostalgic | nw-1 | nw-10 | nw-2 | nw-3 | nw-4 | nw-5 | nw-6 | nw-7 | nw-8 | nw-9 | orange_tone | oranges | paladin_1875 | pasadena_21 | pink_fade | pitaya_15 | polaroid_664 | polaroid_665 | polaroid_665_+ | polaroid_665_++ | polaroid_665_- | polaroid_665_-- | polaroid_665_negative | polaroid_665_negative_+ | polaroid_665_negative_- | polaroid_665_negative_hc | polaroid_667 | polaroid_669 | polaroid_669_+ | polaroid_669_++ | polaroid_669_+++ | polaroid_669_- | polaroid_669_-- | polaroid_669_cold | polaroid_669_cold_+ | polaroid_669_cold_- | polaroid_669_cold_-- | polaroid_672 | polaroid_690 | polaroid_690_+ | polaroid_690_++ | polaroid_690_- | polaroid_690_-- | polaroid_690_cold | polaroid_690_cold_+ | polaroid_690_cold_++ | polaroid_690_cold_- | polaroid_690_cold_-- | polaroid_690_warm | polaroid_690_warm_+ | polaroid_690_warm_++ | polaroid_690_warm_- | polaroid_690_warm_-- | polaroid_polachrome | polaroid_px-100uv+_cold | polaroid_px-100uv+_cold_+ | polaroid_px-100uv+_cold_++ | polaroid_px-100uv+_cold_+++ | polaroid_px-100uv+_cold_- | polaroid_px-100uv+_cold_-- | polaroid_px-100uv+_warm | polaroid_px-100uv+_warm_+ | polaroid_px-100uv+_warm_++ | polaroid_px-100uv+_warm_+++ | polaroid_px-100uv+_warm_- | polaroid_px-100uv+_warm_-- | polaroid_px-680 | polaroid_px-680_+ | polaroid_px-680_++ | polaroid_px-680_- | polaroid_px-680_-- | polaroid_px-680_cold | polaroid_px-680_cold_+ | polaroid_px-680_cold_++ | polaroid_px-680_cold_++_alt | polaroid_px-680_cold_- | polaroid_px-680_cold_-- | polaroid_px-680_warm | polaroid_px-680_warm_+ | polaroid_px-680_warm_++ | polaroid_px-680_warm_- | polaroid_px-680_warm_-- | polaroid_px-70 | polaroid_px-70_+ | polaroid_px-70_++ | polaroid_px-70_+++ | polaroid_px-70_- | polaroid_px-70_-- | polaroid_px-70_cold | polaroid_px-70_cold_+ | polaroid_px-70_cold_++ | polaroid_px-70_cold_- | polaroid_px-70_cold_-- | polaroid_px-70_warm | polaroid_px-70_warm_+ | polaroid_px-70_warm_++ | polaroid_px-70_warm_- | polaroid_px-70_warm_-- | polaroid_time_zero_expired | polaroid_time_zero_expired_+ | polaroid_time_zero_expired_++ | polaroid_time_zero_expired_- | polaroid_time_zero_expired_-- | polaroid_time_zero_expired_--- | polaroid_time_zero_expired_cold | polaroid_time_zero_expired_cold_- | polaroid_time_zero_expired_cold_-- | polaroid_time_zero_expired_cold_--- | portrait_1 | portrait_10 | portrait_2 | portrait_3 | portrait_4 | portrait_5 | portrait_6 | portrait_7 | portrait_8 | portrait_9 | purple | purple_2 | redblueyellow | reds | reds_oranges_yellows | reeve_38 | remy_24 | retro | rollei_ir_400 | rollei_ortho_25 | rollei_retro_100_tonal | rollei_retro_80s | rotate_muted | rotate_vibrant | rotated | rotated_crush | saving_private_damon | smokey | smooth_cromeish | smooth_fade | soft_fade | softwarming | solarized_color | solarized_color_2 | sprocket_231 | studio_skin_tone_shaper | summer | summer_alt | sunny | sunny_alt | sunny_rich | sunny_warm | super_warm | super_warm_rich | sutro_fx | tealmagentagold | tealorange | tealorange_1 | tealorange_2 | tealorange_3 | technicalfx_backlight_filter | teigen_28 | tensiongreen_1 | tensiongreen_2 | tensiongreen_3 | tensiongreen_4 | the_matrices | trent_18 | tweed_71 | vibrant | vibrant_alien | vibrant_contrast | vibrant_cromeish | vintage | vintage_alt | vintage_brighter | vintage_chrome | vireo_37 | warm | warm_highlight | warm_yellow | zed_32 | zeke_39 | zilverfx_bw_solarization | zilverfx_infrared | zilverfx_vintage_bw }
#@cli : $ clut summer

clut : check "isval(${2=48}) && $2>0"
  v - to_clutname "$1" name=${} l[]
  v + e[^-1] "Input CLUT '"$name"' with resolution $2." v -
    if ${_path_rc}clut_$name.cimgz i ${_path_rc}clut_$name.cimgz fi
    if {"!"$!" || w!=$2 || h!=$2 || d!=$2"}
      if {narg($GMIC_SYSTEM_PATH)} g_path_unix=$GMIC_SYSTEM_PATH
      else g_path_unix=/usr/lib/gimp/2.0/plug-ins/
      fi
      rm repeat 2
        if {!$>" && "(\
            isfile('${_path_rc}gmic_cluts.gmz')" || "\
            isfile('${-path_gimp}plug-ins/gmic_cluts.gmz')" || "\
            isfile('${-path_gimp}plug-ins/gmic_gimp_qt/gmic_cluts.gmz')" || "\
            isfile('${g_path_unix}gmic_cluts.gmz'))}
          if {isfile('${_path_rc}gmic_cluts.gmz')} i ${_path_rc}gmic_cluts.gmz
          elif {isfile('${-path_gimp}plug-ins/gmic_cluts.gmz')} i ${-path_gimp}plug-ins/gmic_cluts.gmz
          elif {isfile('${-path_gimp}plug-ins/gmic_gimp_qt/gmic_cluts.gmz')} i ${-path_gimp}plug-ins/gmic_gimp_qt/gmic_cluts.gmz
          elif {isfile('${g_path_unix}gmic_cluts.gmz')} i ${g_path_unix}gmic_cluts.gmz
          fi
        else l[] i https://gmic.eu/gmic_cluts.gmz o ${_path_rc}gmic_cluts.gmz,uchar endl
        fi
        repeat $! if {['{$>,n}']==['$name']} k[$>] break fi done
        if {$!==1} break fi # CLUT found!
        rm
      done
      if {!$!} v + error[0--4] "Command '$0': Unknown CLUT name '"$name"'." fi
      decompress_clut $2,$2,$2 round c 0,255 to_rgb
      o. ${_path_rc}clut_$name.cimgz,uchar
    fi
    nm "[CLUT: "$name"]" k.
  endl v +

# [Internal] Use this command to 'clean' a .gmz file that represents CLUT keypoints.
# What it does is:
#
# - Standardize CLUT name.
# - Convert RGB CLUTs to Grayscale when possible.
# - Remove duplicates and sort by lexicographic order.
# - Display list of CLUTs to ease documentation update of command 'clut'.
#
clean_cluts :
  e[^-1] "Clean CLUT dataset.\n"
  v - round

  # Standardize names.
  repeat $! l[$>]
    nm={n}

    # Standardize names for 'SmallHD MovieLook'.
    if {"str = lowercase(['"$nm"*']);
         find(str,'_-_rec_709*')>=0"} l[]
      ({'$nm'}) z. 0,{w-11}
      nm={t} rm
    endl fi

    # Standardize names for 'SmallHD MovieLook'.
    if {"str = lowercase(['"$nm"']);
         find(str,'smallhd_movielook_')==0"} l[]
      ({'$nm'}) z. 18,100%
      replace_str "apocalypsethisverymoment","apocalypse_this_very_moment"
      replace_str "bobford","bob_ford"
      replace_str "lifegivingtree","life_giving_tree"
      replace_str "savingprivatedamon","saving_private_damon"
      replace_str "thematrices","the_matrices"
      nm={t} rm
    endl fi

    # Standardize names for 'Fuji XTrans III'.
    if {"str = lowercase(['"$nm"']);
         find(str,'fuji_xtrans_iii')==0"} l[]
      ({'$nm'})
      replace_str "_-_","_" nm={t} rm
    endl fi

    # Standardize names for 'RawTherapee'.
    if {"str = lowercase(['"$nm"']);
         find(str,'kodak')==0 ||
         find(str,'polaroid')==0 ||
         find(str,'fuji')==0 ||
         find(str,'ilford')==0"} l[]
      ({'$nm'},{'*'})
      replace_str " ","_"
      replace_str "xp_2","xp2"
      replace_str "hp_5","hp5"
      repeat 8 n={1+$>}
        replace_str "_"${n}"_+","_+"
        replace_str "_"${n}"_-","_-"
        replace_str "_"${n}"_alt","_alt"
        replace_str "_"${n}"_Alt","_alt"
        replace_str "_"${n}"*","*"
      done
      = 0,0,100% nm={t} rm
    endl fi

    to_clutname $nm nm=${}

    # Standardize names for 'PictureFX'.
    if {"str = lowercase(['"$nm"']);
         find(str,'technicalfx')==0 ||
         find(str,'analogfx')==0 ||
         find(str,'goldfx')==0 ||
         find(str,'zilverfx')==0"} l[]
      ({'$nm'})
      replace_str "-","_" nm={t} rm
    endl fi

    # Other name changes.
    l[]
      ({'$nm'},{'*'})
      replace_str "_v_2*","*"
      replace_str "_v_1*","*"
      replace_str "_b_w","_bw"
      replace_str "&",""
      = 0,0,100%  nm={t} rm
    endl
    nm $nm
  endl done

  # Convert RGB CLUTs to Grayscale when possible.
  repeat $! l[$>]
    if {"R = crop(#0,0,0,0,3,1,h,1,1);
         G = crop(#0,0,0,0,4,1,h,1,1);
         B = crop(#0,0,0,0,5,1,h,1,1);
         R==G && G==B?1:0"}
      channels 0,3
    fi
  endl done

  # Search for duplicates and sort.
  p=0 for {$p<$!}
    nm0={$p,n}
    v + e[] "\r- Search duplicates for ["$p"] = '"$nm0"'                        " v -
    q={$p+1} for {$q<$!}
      nm={$q,n}
      if {['$nm0']==['$nm']}
        v + e[] "   > Found duplicate ["$q"] -> Original 1x"{$p,h}", new 1x"{$q,h}"\n" v -
        rv[$p,$q] rm[$q]
      else q+=1
      fi
    done
    p+=1
  done
  sort_list +,n

  # Display all clut names.
  doc="#@cli clut : \"clut_name\",_resolution>0\n"\
      "#@cli : Insert one of the "$!" pre-defined CLUTs at the end of the image list.\\n\n"\
      "#@cli : 'clut_name' can be {" sep="|"
  repeat $! l[$>] if {!$<} sep="}" fi doc=${doc}" "{n}" "$sep endl done
  doc=${doc}"\n"\
      "#@cli : $ clut summer\n"
  v + e[] "\n"$doc

#@cli m : eq. to 'command'. : (+)

#@cli command : _add_debug_info={ 0 | 1 },{ filename | http[s]://URL | "string" } : (+)
#@cli : Import G'MIC custom commands from specified file, URL or string.
#@cli : (eq. to 'm').\n
#@cli : Imported commands are available directly after the 'command' invocation.
#@cli : Default value: 'add_debug_info=1'.
#@cli : $ image.jpg command "foo : mirror y deform $""1" +foo[0] 5 +foo[0] 15

#@cli cursor : _mode = { 0=hide | 1=show } : (+)
#@cli : Show or hide mouse cursor for selected instant display windows.
#@cli : Command selection (if any) stands for instant display window indices instead of image indices.
#@cli : Default value: 'mode=1'.

#@cli d : eq. to 'display'. : (+)

#@cli display : _X[%]>=0,_Y[%]>=0,_Z[%]>=0,_exit_on_anykey={ 0 | 1 } : (+)
#@cli : Display selected images in an interactive viewer (use the instant display window [0] if opened).
#@cli : (eq. to 'd').\n
#@cli : Arguments 'X','Y','Z' determine the initial selection view, for 3D volumetric images.
#@cli : Default value: 'X=Y=Z=0' and 'exit_on_anykey=0'.
#@cli : $$

#@cli d0 : eq. to 'display0'.
d0 :
  _display0

#@cli display0
#@cli : Display selected images without value normalization.
#@cli : (eq. to 'd0').
display0 :
  _$0

_display0 :
  v -
  w=0 h=0 d=0 s=0
  repeat $! l[$>] w+={w} h={max($h,h)} d={max($d,d)} s={max($s,s)} endl done
  if {$!==1} w -1,-1,0,0,-1,-1,{0,n}\ ($wx$hx$dx$s)
  elif {$!==2} w -1,-1,0,0,-1,-1,{0,n},{n}\ ($wx$hx$dx$s)
  else w -1,-1,0,0,-1,-1,{0,n},...,{n}\ ($wx$hx$dx$s)
  fi
  v + d v - w[] 0 v +

#@cli d3d : eq. to 'display3d'. : (+)

#@cli display3d : _[background_image],_exit_on_anykey={ 0 | 1 } : _exit_on_anykey={ 0 | 1 } : (+)
#@cli : Display selected 3D objects in an interactive viewer (use the instant display window [0] if opened).
#@cli : (eq. to 'd3d').
#@cli : Default values: '[background_image]=(default)' and 'exit_on_anykey=0'.

#@cli da : eq. to 'display_array'.
da :
  v - _gmic_s="$?" v +
  _display_array $*

#@cli display_array : _width>0,_height>0
#@cli : Display images in interactive windows where pixel neighborhoods can be explored.
#@cli : Default values: 'width=13' and 'height=width'.
display_array :
  v - _gmic_s="$?" v +
  _$0 $*

_display_array : check ${1=13}>0" && "${2=$1}>0
  e[0--3] "Display $1x$2 array of pixel values for image"$_gmic_s"."
  v -
  dxb={round($1/2,1,1)} dxf={$1-1-$dxb}
  dyb={round($2/2,1,1)} dyf={$2-1-$dyb}

  repeat $! l[$>]
    if {w<128" && "h<128} r 128,128,100%,100%,0,0,0.5,0.5 fi # Manage cases of small and large images.
    x0=0 y0=0 w={w} h={h}
    wmax={0.9*{*,u}} hmax={0.9*{*,v}}
    do
      if {w>=$wmax||h>=$hmax}
        n={n} nm. "Image "'{b}.{x}'" is too large, please select a sub-image."
        +select. 2 x0={i[0]} y0={i[1]} w={1+i[3]-i[0]} h={1+i[4]-i[1]}
        rm. nm. $n
      fi
      +z. $x0,$y0,0,{$x0+$w-1},{$y0+$h-1},0 round. 1 n. 0,255
    while {w>=$wmax||h>=$hmax}

    x1=-1 y1=-1 c1=0 ox1=-1 oy1=-1 oc1=-1
    x2=-1 y2=-1 c2=0 ox2=-1 oy2=-1 oc2=-1
    x3=-1 y3=-1 c3=0 ox3=-1 oy3=-1 oc3=-1
    c0=0 oxm=-1 oym=-1
    w. -1,-1,0,0,-1,-1,{-2,b}.{-2,x}
    do  # Enter event loop.

      # Manage user interactions.
      wait[0-3]
      oc0=$c0
      repeat 4
        if {$>" && "!{*$>}" && "${x$>}>=0} w$> 0 x$>=-1 y$>=-1 c$>=0 fi
        if {*$>,o} c$>={(${c$>}+sign({*$>,o}))%s} wait[$>] -1 fi
        if {{*$>,SPACE}" || "{*$>,ENTER}" || "{*$>,ARROWRIGHT}" || "{*$>,ARROWDOWN}} c$>={(${c$>}+1)%s} wait[$>] -1 fi
        if {{*$>,BACKSPACE}" || "{*$>,ARROWLEFT}" || "{*$>,ARROWUP}} c$>={(${c$>}-1)%s} wait[$>] -1 fi
      done
      if {$oc0!=$c0} c1=$c0 c2=$c0 c3=$c0 fi
      xm={*,x} ym={*,y}
      if {$xm>=0" && "{*,b}&1} x1=$xm y1=$ym fi
      if {$xm>=0" && "{*,b}&2} x2=$xm y2=$ym fi
      if {$xm>=0" && "{*,b}&4} x3=$xm y3=$ym fi

      # Generate main image view.
      if {$xm>=0" && "($oxm!=$xm" || "$oym!=$ym)} w[] -1,-1,-1,-1,-1,-1,{-2,b}.{-2,x}" - ("$xm,$ym")" fi
      if {$x1!=$ox1" || "$y1!=$oy1" || "$x2!=$ox2" || "$y2!=$oy2" || "$x3!=$ox3" || "$y3!=$oy3}
        .
        if {$x1>=0}
          xb={$x1-$dxb} yb={$y1-$dyb} xe={$x1+$dxf} ye={$y1+$dyf}
          rectangle. $xb,$yb,$xe,$ye,0.2,0,255,255
          rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,0,255,255
        fi
        if {$x2>=0}
          xb={$x2-$dxb} yb={$y2-$dyb} xe={$x2+$dxf} ye={$y2+$dyf}
          rectangle. $xb,$yb,$xe,$ye,0.2,255,32,255
          rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,32,255
        fi
        if {$x3>=0}
          xb={$x3-$dxb} yb={$y3-$dyb} xe={$x3+$dxf} ye={$y3+$dyf}
          rectangle. $xb,$yb,$xe,$ye,0.2,255,255,0
          rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,255,0
        fi
        w. {-2,w},{-2,h} rm. oxm=$xm oym=$ym
      fi

      # Generate zoomed views.
      if {$x1>=0" && "($ox1!=$x1" || "$oy1!=$y1" || "$oc1!=$c1)}
        +z.. {$x1-$dxb},{$y1-$dyb},0,$c1,{$x1+$dxf},{$y1+$dyf},0,$c1
        +z.. {$x1-$dxb},{$y1-$dyb},0,{$x1+$dxf},{$y1+$dyf},0
        __display_array[-2,-1] $1,$2,0,255,255
        w1. {w},{h},0,0,-1,-1,{-3,b}" - ("$x1,$y1,c=$c1")"
        rm. ox1=$x1 oy1=$y1 oc1=$c1
      fi
      if {$x2>=0" && "($ox2!=$x2" || "$oy2!=$y2" || "$oc2!=$c2)}
        +z.. {$x2-$dxb},{$y2-$dyb},0,$c2,{$x2+$dxf},{$y2+$dyf},0,$c2
        +z.. {$x2-$dxb},{$y2-$dyb},0,{$x2+$dxf},{$y2+$dyf},0
        __display_array[-2,-1] $1,$2,255,32,255
        w2. {w},{h},0,0,-1,-1,{-3,b}" - ("$x2,$y2,c=$c2")"
        rm. ox2=$x2 oy2=$y2 oc2=$c2
      fi
      if {$x3>=0" && "($ox3!=$x3" || "$oy3!=$y3" || "$oc3!=$c3)}
        +z.. {$x3-$dxb},{$y3-$dyb},0,$c3,{$x3+$dxf},{$y3+$dyf},0,$c3
        +z.. {$x3-$dxb},{$y3-$dyb},0,{$x3+$dxf},{$y3+$dyf},0
        __display_array[-2,-1] $1,$2,255,255,0
        w3. {w},{h},0,0,-1,-1,{-3,b}" - ("$x3,$y3,c=$c3")"
        rm. ox3=$x3 oy3=$y3 oc3=$c3
      fi
    while {{*}" && "\
            !{*,ESC}" && "!{*,Q}" && "\
            !{*1,ESC}" && "!{*1,Q}" && "\
            !{*2,ESC}" && "!{*2,Q}" && "\
            !{*3,ESC}" && "!{*3,Q}}
    k[0] w 0 w1 0 w2 0 w3 0
  endl done v +

__display_array :
  round.. 1 c.. 0,999 r. 100%,100%,1,3,{s==1}
  +luminance. r.. {$1*24},{$2*24} grid.. {100/$1}%,{100/$2}%,0,0,1,0
  xb={24*int($1/2)} yb={24*int($2/2)} xe={$xb+24} ye={$yb+24}
  rectangle.. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,$3,$4,$5
  repeat $2,yg
    repeat $1,xg
      t.. {-3,i($xg,$yg)},{5+$xg*24},{5+$yg*24},13,0.8,{if(i($xg,$yg)>128,0,255)}
    done
  done
  rm[-3,-1]

#@cli dfft : eq. to 'display_fft'.
dfft :
  _display_fft

#@cli display_fft
#@cli : Display fourier transform of selected images, with centered log-module and argument.
#@cli : (eq. to 'dfft').
#@cli : $ image.jpg +display_fft
display_fft :
  _$0

_display_fft :
  e[0--3] "Render fourier transform of image$? with centered log-module and argument."
  v - repeat $! l[$>] fftpolar +.. 1 log.. n 0,255 a x endl done s x,2 v +

#@cli dg : eq. to 'display_graph'.
dg : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  _display_graph ${1-8},"$9","$10"

#@cli display_graph : _width>=0,_height>=0,_plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_xlabel,_ylabel
#@cli : Render graph plot from selected image data.
#@cli : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@cli : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@cli : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@cli : if specified 'width' or 'height' is '0', then image size is set to half the screen size.
#@cli : Default values: 'width=0', 'height=0', 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0 (auto)', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@cli : $ 128,1,1,1,'cos(x/10+u)' +display_graph 400,300,3
display_graph : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  _display_graph ${1-8},"$9","$10"

_display_graph : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  e[0--3] "Render $1x$2 graph plot from data of image$?."
  v - repeat $! l[$>] nm={0,n}

    # Determine output size.
    if {$1>0&&$2>0} w,h=$1,$2 else w,h={{*,u}/2},{{*,v}/2} fi
    w,h={[max($w,33),max($h,33)]}

    # Determine xmin,xmax/ymin,ymax.
    one={$3!=3} siz={w*h*d}
    if {$5==$6} xmin=0 xmax={$siz-$one} else xmin={min($5,$6)} xmax={max($5,$6)} fi
    if {$7==$8} ymin={im-(iM-im)/20} ymax={iM+(iM-im)/20} else ymin={min($7,$8)} ymax={max($7,$8)} fi
    dx={$xmax-$xmin} dy={$ymax-$ymin}

    # Determine number of axes tick marks.
    u=${"_axes[] "$xmin,$xmax",{0.3*"$w"/14}"} offx={arg(1,$u)} deltax={arg(2,$u)}
    u=${"_axes[] "$ymin,$ymax",{0.3*"$h"/14}"} offy={arg(1,$u)} deltay={arg(2,$u)}

    # Create plot canvas.
    gw={$w-32} gh={$h-32} gg={($gw-$one)/($siz-$one)}
    $gw,$gh,1,3,255
    grid. {$deltax*$gw/$dx},{$deltay*$gh/$dy},{($offx-$xmin)*$gw/$dx},{$gh-($offy-$ymin)*$gh/$dy},0.25,0xCCCCCCCC,0

    # Define color palette for curves.
    if {{-2,s}==1} (120,120,200)
    elif {{-2,s}<=3} (220,10,10;10,220,10;10,10,220)
    else
      (0,255) r. 256,1,1,1,3 map. 2 z. 2,100% permute. cxyz r. 3,{-3,max(3,s)},1,1,0,2
      sh. 0,2,0,0 f. 255,0,0,0,255,0,0,0,255 rm.
    fi

    # Draw plot for each channel.
    repeat {-3,s} sh... $> graph... .,$3,$4,$ymax,$ymin,1,{-2,@0-2} rm. shift. 0,-1 done
    rm[-3,-1]
    line. 0,0,100%,0,1,110 line. 100%,0,100%,100%,1,110
    line. 100%,100%,0,100%,1,255 line. 0,100%,0,0,1,255

    100%,100%,1,1,255
    axes. $xmin,$xmax,$ymax,$ymin,14,1,0
    if {$xmin>0} axes. 0,0,$ymax,$ymin,14,1,160 fi
    if {$xmax<0} axes. {w-1},{w-1},$ymax,$ymin,14,1,160 fi
    if {$ymin>0} axes. $xmin,$xmax,{h-1},{h-1},14,1,160 fi
    if {$ymax<0} axes. $xmin,$xmax,0,0,14,1,160 fi
    +erode. 3 !=. 255 r.. 100%,100%,1,3 j... ..,0,0,0,0,1,.,1 rm[-2,-1]
    frame. 16,16,220
    0 t. "$9",0,0,14,1,-220,-220,-220 j.. .,{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 rm.
    0 t. "$10",0,0,14,1,-220,-220,-220 rotate. -90 j.. .,2,{({-2,h}-h)/2},0,0,-1 rm.

  nm $nm endl done c 0,255 v +

#@cli dh : eq. to 'display_histogram'.
dh :
  v - _gmic_s="$?" v +
  _display_histogram $"*"

#@cli display_histogram : _width>=0,_height>=0,_clusters>0,_min_value[%],_max_value[%],_show_axes={ 0 | 1 },_expression.
#@cli : Render a channel-by-channel histogram.
#@cli : If selected images have several slices, the rendering is performed for all input slices.
#@cli : 'expression' is a mathematical expression used to transform the histogram data for visualization purpose.
#@cli : (eq. to 'dh').
#@cli : if specified 'width' or 'height' is '0', then image size is set to half the screen size.
#@cli : Default values: 'width=0', 'height=0', 'clusters=256', 'min_value=0%', 'max_value=100%', 'show_axes=1' and 'expression=i'.
#@cli : $ image.jpg +display_histogram 512,300
display_histogram :
  v - _gmic_s="$?" v +
  _$0 $"*"

_display_histogram : check "${1=0}>=0 && ${2=0}>=0 && ${3=256}>0" skip ${4=0%},${5=100%},${6=1},"${7=i}"
  e[0--3] "Render $1x$2 channel-by-channel histogram of image"$_gmic_s", with $3 clusters, minimum value $4 and maximum value $5."
  v - repeat $! l[$>] nm={0,n}
    if ${is_percent\ $4} m={im+(iM-im)*$4} else m=$4 fi
    if ${is_percent\ $5} M={im+(iM-im)*$5} else M=$5 fi
    s={s} s c
    repeat $s l[{-1-$>}] s z histogram $3,$m,$M a z endl done
    a c f '"${7--1}"' vM={iM} s z
    repeat $! l[$>]
      if {$1>0&&$2>0} wh=$1,$2 else wh={{*,u}/2},{{*,v}/2} fi
      $wh,1,{s},-255
      repeat {s} sh[-2,-1] $> graph. ..,3,0,$vM,0,1,0 rm[-2,-1] done
      rm.. + 255
      if $6
        100%,100%
        axes. $m,$M,$vM,0,14,1,255
        if {$m>0} axes. 0,0,$vM,0,14,1,200 fi
        if {$M<0} axes. {w-1},{w-1},$vM,0,14,1,200 fi
        +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
      fi
    endl done
    a z nm $nm
  endl done v +

#@cli display_parametric : _width>0,_height>0,_outline_opacity,_vertex_radius>=0,_is_antialiased={ 0 | 1 },_is_decorated={ 0 | 1 },_xlabel,_ylabel
#@cli : Render 2D or 3D parametric curve or point clouds from selected image data.
#@cli : Curve points are defined as pixels of a 2 or 3-channel image.
#@cli : If the point image contains more than 3 channels, additional channels define the (R,G,B) color for each vertex.
#@cli : If 'outline_opacity>1', the outline is colored according to the specified vertex colors and 'outline_opacity-1' is used
#@cli : as the actual drawing opacity.
#@cli : Default values: 'width=512', 'height=width', 'outline_opacity=3', 'vertex_radius=0', 'is_antialiased=1', 'is_decorated=1', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@cli : $ 1024,1,1,2,'t=x/40;if(c==0,sin(t),cos(t))*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)' display_parametric 512,512
#@cli : $ 1000,1,1,2,u(-100,100) quantize 4,1 noise 12 channels 0,2 +normalize 0,255 append c display_parametric 512,512,0.1,8
display_parametric : check "${1=512}>0 && ${2=$1}>0 && ${4=0}>=0" skip ${3=3},${5=1},${6=1},"${7=x-axis}","${8=y-axis}"
  v - s0="no " s1="" o0="" o1="colored "
  v + e[^-1] "Render $1x$2 parametric graph plot from data of image$?, with "${o{$3>1}}"outline opacity "{if($3>1,$3-1,$3)}\
               ", vertex radius $4, "${s{$5!=0}}"antialiasing and "${s{$6!=0}}"decoration." v -
  repeat $! l[$>]
    nm={0,n} N={w*h*d}
    i[0] ({'CImg3d'}) +[0] 0.5 i[1] ($N;$N)  # Header + nb of vertices/primitives.

    # Calibrate colors of vertices.
    if {s==4} +channels. 3,3 r. 100%,100%,1,2 a[-2,-1] c is_grayscale=1
    else is_grayscale={s<4} channels. 0,5
    fi

    # Manage coordinates of vertices.
    sh. 0 xm={im} xM={iM} rm.
    sh. 1 ym={im} yM={iM} rm.
    sh. 2 zm={im} zM={iM} rm.
    permute. cxyz s. x,2
    i.. (1,0;1,{$N-1}) r.. 2,$N,1,1,3 round.. 1,$N,1,1,1 # Primitives, colors and opacities.
    y a y c3d n3d *3d 1,-1,1

    {if($6,max(1,$1-32),$1)},{if($6,max(1,$2-32),$2)},1,{if($is_grayscale,1,3)},255
    *3d[0] {0.96*min(w,h)}
    if $6 L={0.1*max($1,$2)} grid[1] $L,$L,0,0,0.25,0xCCCCCCCC,0 fi

    if $5 # Anti-aliased.
      r[1] 200%,200%,1,100%,1 *3d[0] 2
      if $4 +circles3d[0] {2*$4} j3d[1] [2],50%,50%,0,1,3,0,0 rm[2] fi
    elif $4 # Aliased.
      +circles3d[0] $4 j3d[1] [2],50%,50%,0,1,3,0,0 rm[2]
    fi

    if $3 l[0] s3d f[1] 'i-y' rm[3] i[3] (2,0,1;2,{$N-2},{$N-1}) r[3] 3,{$N-1},1,1,3 round[3]  # Convert point cloud to connected segments.
      r[5] 1,{h-1},1,1,0
      if {$3>1} r[4] 3,{4,h/3},1,1,-1 r[4] 3,{4,h-1},1,1,2 else rm[4] i[4] 3,{$N-1} fi
      y a y endl j3d[1] [0],50%,50%,0,{if($3>1,$3-1,$3)},2,0,0
    fi

    rm[0]
    if $5 r. 50%,50%,1,100%,2 fi

    if $6 # Add decoration.
      xc={0.5*($xm+$xM)} yc={0.5*($ym+$yM)} dx={0.5*($xM-$xm)/0.96} dy={0.5*($yM-$ym)/0.96}
      xm={$xc-$dx} xM={$xc+$dx} ym={$yc-$dy} yM={$yc+$dy}
      100%,100%,1,1,255 axes. $xm,$xM,$yM,$ym,14,1,0
      if {$xm>0} axes. 0,0,$yM,$ym,14,1,160 fi
      if {$xM<0} axes. {w-1},{w-1},$yM,$ym,14,1,160 fi
      if {$ym>0} axes. $xm,$xM,{h-1},{h-1},14,1,160 fi
      if {$yM<0} axes. $xm,$xM,0,0,14,1,160 fi
      +erode. 3 !=. 255 r.. 100%,100%,1,3 j... ..,0,0,0,0,1,.,1 rm[-2,-1]
      frame 1,1,128 frame 15,15,220
      0 t. "$7",0,0,14,1,-220,-220,-220 j.. .,{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 rm.
      0 t. "$8",0,0,14,1,-220,-220,-220 rotate. -90 j.. .,2,{({-2,h}-h)/2},0,0,-1 rm.
    fi
    nm. $nm
  endl done v +

#@cli dp : eq. to 'display_parallel'.
dp :
  v - _gmic_s="$?" v +
  _display_parallel

#@cli display_parallel
#@cli : Display each selected image in a separate interactive display window.
#@cli : (eq. to 'dp').
display_parallel :
  v - _gmic_s="$?" v +
  _$0

_display_parallel :
  e[0--3] "Display image$? in parallel."
  print
  v -
  if {$!<=1} d v + return fi
  $!,1,1,1,x ({'{^}'}) rm..
  l.
    s -,{','} y x
    i[0--2] ({'d['})
    i[2--2:2] ({'],'})
    ({']'})
    a x com={t} rm
  endl
  m "__dp : parallel "$com __dp uncommand __dp
  d[] v +

#@cli dp0 : eq. to 'display_parallel0'.
dp0 :
  v - _gmic_s="$?" v +
  _display_parallel0

#@cli display_parallel0
#@cli : Display each selected image in a separate interactive display window, without value normalization.
#@cli : (eq. to 'dp0').
display_parallel0 :
  v - _gmic_s="$?" v +
  _$0

_display_parallel0 :
  e[0--3] "Display image$? in parallel, without value normalization."
  print
  v -
  if {$!<=1} d0 v + return fi
  $!,1,1,1,x ({'{^}'}) rm..
  l.
    s -,{','} y x
    i[0--2] ({'d0['})
    i[2--2:2] ({'],'})
    ({']'})
    a x com={t} rm
  endl
  m "__dp0 : parallel "$com __dp0 uncommand __dp0
  d[] v +

#@cli display_polar : _width>32,_height>32,_outline_type,_fill_R,_fill_G,_fill_B,_theta_start,_theta_end,_xlabel,_ylabel
#@cli : Render polar curve from selected image data.
#@cli : 'outline_type' can be { r<0=dots with radius -r | 0=no outline | r>0=lines+dots with radius r }.
#@cli : 'fill_color' can be { -1=no fill | R,G,B=fill with specified color }.
#@cli : Default values: 'width=500', 'height=width', 'outline_type=1', 'fill_R=fill_G=fill_B=200', 'theta_start=0', 'theta_end=360', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@cli : $ 300,1,1,1,'0.3+abs(cos(10*pi*x/w))+u(0.4)' display_polar 512,512,4,200,255,200
#@cli : $ 3000,1,1,1,'x^3/1e10' display_polar 400,400,1,-1,,,0,{15*360}
display_polar : check "${1=500}>32 && ${2=$1}>32" skip ${3=1},${4=200},${5=$4},${6=$5},${7=0},${8=360},"${9=x-axis}","${10=y-axis}"
  e[^-1] "Render $1x$2 polar graph plot from data of image"$_gmic_s", with outline $4 and fill color ($4,$5,$6)."
  v - repeat $! l[$>] nm={0,n}

    # Compute (x,y) coordinates of the polar curve points.
    M={max(abs(iM),abs(im))}
    * {0.48*min($1,$2)/$M}
    y ({$7*pi/180};{-$8*pi/180}) r. 1,..,1,1,3
    +sin. cos.. *. ... *[-3,-2]
    a[-2,-1] x N={h}
    nm. coords

    # Generate 3D object for curve outline.
    if $3
      ({'CImg3d'}) +. 0.5 ($N,$N)
      +z[coords] 0,2
      1,$N,1,1,2 1,$N,1,1,'y' ++. 1 a[-3--1] x =. 0,2,100%
      3,$N,1,1,0 1,$N,1,1,1 y[-6--1] a[-6--1] y
      nm. _plot_polar_outline
    fi

    # Generate 3D object for filling.
    if {"$4>=0 && $5>=0 && $6>=0"}
      ({'CImg3d'}) +. 0.5 ({$N+1},$N)
      +z[coords] 0,-1,2,100% z. 0,2
      1,$N,1,1,3 1,$N 1,$N,1,1,'1+y' ++. 1 a[-4--1] x =. 1,3,100%
      3,$N,1,1,$4,$5,$6 1,$N,1,1,1
      y[-6--1] a[-6--1] y
      nm. _plot_polar_fill
    fi
    rm[coords]  # Remove original curve coordinates.

    # Render graph image.
    {$1-32},{$2-32},1,3,255
    L={0.1*max($1,$2)} grid. $L,$L,0,0,0.25,0xCCCCCCCC,0  # Draw background grid.
    if {"$4>=0 && $5>=0 && $6>=0"}                        # Draw curve filling.
      j3d. [_plot_polar_fill],50%,50%,0,1,2,1,0
      rm[_plot_polar_fill]
    fi
    if $3
      if {$3>=0}                                          # Draw curve outline.
        j3d. [_plot_polar_outline],50%,50%,0,1,1,0,0
      fi
      if {$3!=0}                                          # Draw curve vertices.
        if {abs($3)>1} circles3d[_plot_polar_outline] {abs($3)} fi
        j3d. [_plot_polar_outline],50%,50%,0,0.2,2,0,0
      fi
      rm[_plot_polar_outline]
    fi

    # Draw axes and frame.
    nM={$M/0.96}
    100%,100%,1,1,255 axes. {-$nM},$nM,$nM,{-$nM},14,1,0
    +erode. 3 !=. 255 r.. 100%,100%,1,3 j... ..,0,0,0,0,1,.,1 rm[-2,-1]
    frame. 1,1,128 frame. 15,15,220
    0 t. "$9",0,0,13,1,-220,-220,-220 j.. .,{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 rm.
    0 t. "$10",0,0,13,1,-220,-220,-220 rotate. -90 j.. .,2,{({-2,h}-h)/2},0,0,-1 rm.

  nm $nm endl done v +

#@cli dq : eq. to 'display_quiver'.
dq :
  v - _gmic_s="$?" v +
  _display_quiver $*

#@cli display_quiver : _size_factor>0,_arrow_size>=0,_color_mode={ 0=monochrome | 1=grayscale | 2=color }
#@cli : Render selected images of 2D vectors as a field of 2D arrows.
#@cli : (eq. to 'dq').
#@cli : Default values: 'size_factor=16', 'arrow_size=1.5' and 'color_mode=1'.
#@cli : $ image.jpg +luminance gradient[-1] xy rv[-2,-1] *[-2] -1 a[-2,-1] c crop 60,10,90,30 +display_quiver[1] ,
display_quiver :
  v - _gmic_s="$?" v +
  _$0 $*

_display_quiver : check "${1=16}>0 && ${2=1.5}>=0 && isint(${3=2}) && $3>=0 && $3<=2"
  e[0--3] "Render field of 2D arrows from image"$_gmic_s", with size factor $1, arrow size $2 in "${arg\ 1+$3,monochrome,grayscale,color}" mode."
  v - repeat $! l[$>]
    +norm. /.. {max(1e-6,iM)} rm. # Normalize vector values.
    {$1*w},{$1*h},1,{"1<<cut($3,0,2)"}
    eval.. "
      begin(C = resize([255],s#1,1));
      "${-math_lib}"
      len = norm2(I(x,y));
      ang = atan2(i(x,y,0,1),i(x,y,0,0))*180/pi;
      P = [ -0.5,-0.05, 0.3,-0.05, 0.2,-0.25, 0.5,0, 0.2,0.25, 0.3,0.05, -0.5,0.05 ];
      P*=$1*$2*len;
      X = resize([(x+0.5)*w#1/w,(y+0.5)*h#1/h],size(P),0,2);
      X+=mul(P,rot(-ang),2);
      if ($3,
        v = min(1,max(0.5,3*len));
        if ($3==1,
          C = [ 255*v,255 ],
          C = [ hsv2rgb([ ang,1,v ]), 255 ];
        );
      );
      for (k = 0, k<3, ++k,
        i0 = arg(k + 1,0,2,4);
        i1 = arg(k + 1,2,10,6);
        i2 = arg(k + 1,12,12,8);
        polygon(#1,3,X[i0,2],X[i1,2],X[i2,2],1,C);
      ); I"
    rm..
  endl done v +

#@cli drgba : eq. to 'display_rgba'.
drgba : skip "${1=none},${2=$1},${3=$1}"
  v - _gmic_s="$?" v +
  _display_rgba ${^0}
  v - if {!${}} noarg fi v +

#@cli display_rgba : _background_RGB_color
#@cli : Render selected RGBA images over a checkerboard or colored background.
#@cli : (eq. to 'drgba').
#@cli : Default values: 'background_RGB_color=undefined' (checkerboard).
#@cli : $ image.jpg +norm threshold[-1] 40% blur[-1] 3 normalize[-1] 0,255 append c display_rgba
display_rgba : skip "${1=none},${2=$1},${3=$1}"
  v - _gmic_s="$?" v +
  _$0 ${^0}
  v - if {!${}} noarg fi v +

_display_rgba : skip "${1=},${2=$1},${3=$1}"
  v - l[] is_rgb={"isval($1)"} onfail is_rgb=0 endl v +
  if $is_rgb e[0--4] "Render RGBA image"$_gmic_s" over RGB background ($*)."
  else e[0--4] "Render RGBA image"$_gmic_s" over a checkerboard background."
  fi
  v - repeat $! l[$>] if {s==2" || "s==4}
    if $is_rgb i[0] 100%,100%,1,3 fc[0] {[$*]}
    else i[0] (160,128;128,160) r[0] 16,16 r[0] [1],[1],1,{s-1},0,2
    fi
    nm[0] {1,n}
    sh. {s-1} j[0] [1],0,0,0,0,1,[2],255 k[0]
  fi endl done to_rgb u $is_rgb v +

#@cli dt : eq. to 'display_tensors'.
dt :
  v - _gmic_s="$?" v +
  _display_tensors $*

#@cli display_tensors : _size_factor>0,_ellipse_size>=0,_color_mode={ 0=monochrome | 1=grayscale | 2=color },_outline>=0
#@cli : Render selected images of tensors as a field of 2D ellipses.
#@cli : (eq. to 'dt').
#@cli : Default values: 'size_factor=16', 'ellipse_size=1.5', 'color_mode=2' and 'outline=2'.
#@cli : $ image.jpg diffusiontensors 0.1,0.9 resize2dx 32 +display_tensors 64,2
#@cli : $$
display_tensors :
  v - _gmic_s="$?" v +
  _$0 $*

_display_tensors : check "${1=16}>0 && ${2=1.5}>=0 && isint(${3=2}) && $3>=0 && $3<=2 && ${4=2}>=0"
  e[0--3] "Render field of 2x2 tensors from image"$_gmic_s", with size factor $1, ellipse size $2 in "${arg\ 1+$3,monochrome,grayscale,color}" mode and outline $4."
  v - repeat $! l[$>]
    * {($2*$1/2)/max(abs(im),abs(iM))} # Normalize tensor values.
    {$1*w},{$1*h},1,{"1<<cut($3,0,2)"}
    f.. "
      begin(C = resize([255],s#1,1); Co = resize([0],s#1,1); Co[s#1 - 1] = $3?255:0);
      "${-math_lib}"
      X = ([ x,y ]+=0.5)*$1;
      T = [ R, G, G, B ];
      E = eig(T);
      r1 = E[0];
      r2 = E[1];
      ang = atan2(E[3],E[2])*180/pi;
      if ($3,
        v = min(1,max(0.5,3*r1/($1*$2)));
        if ($3==1,
          C = [ 255*v,255 ],
          C = [ hsv2rgb([ 2*ang,1-r2/r1,v ]), 255 ];
        );
      );
      for (k = 1, k>=0, --k, ellipse(#1,X,r1 + k*$4,r2 + k*$4,ang,1,arg(k + 1,C,Co)));
      I"
    rm..
  endl done v +

#@cli dw : eq. to 'display_warp'.
dw :
  v - _gmic_s="$?" v +
  _display_warp $*

#@cli display_warp : _cell_size>0
#@cli : Render selected 2D warping fields.
#@cli : (eq. to 'dw').
#@cli : Default value: 'cell_size=15'.
#@cli : $ 400,400,1,2,'x=x-w/2;y=y-h/2;r=sqrt(x*x+y*y);a=atan2(y,x);5*sin(r/10)*[cos(a),sin(a)]' +display_warp 10
display_warp :
  v - _gmic_s="$?" v +
  _$0 $*

_display_warp : check "${1=15}>0"
  e[0--3] "Render 2D warping field"$_gmic_s", with cell size $1."
  v - repeat $! l[$>]
    if {d!=1||s!=2}
      v + error[0--3] "Command 'display_warp': Invalid image ["{$!-$>-1}"]: Dimensions "{w}","{h}","{d}","{s}" does not represent a 2D field of 2D vectors."
    fi
    i[0] 100%,100%,1,1,1 grid[0] $1,$1 nm[0] {1,n}
    warp[0] [1],1,1,0 rm[1]
  endl done * 255 v +

#@cli document_gmic : _format={ ascii | bash | html | images | latex },_image_path,_write_wrapper={ 0 | 1 }
#@cli : Create documentation of .gmic command files (loaded as raw 'uchar' images), in specified format.
#@cli : Default values: 'format=ascii', 'image_path=""' and 'write_wrapper=1'.\n
#@cli : Example(s) : raw:filename.gmic,char document_gmic html,img
document_gmic : skip ${1="ascii"},${2=""},${3=1}
  if {!$!} return fi
  v -1

  # Concatenate command data and split them into lines.
  _name={0,b} # Basename for the commands definition file.
  if {$!>1} i[1--2] (10) fi a y m {t} s -,10

  # Output header.
  _document_gmic_header_$1[] $3

  # Define parsing variables.
  _subsection=0                              # Index of current subsection.
  _example=0                                 # Index of current example.
  _command=0                                 # Index of current command.
  _is_example=0                              # Boolean telling if current line is an example.
  _path="$2"                                 # Path of example images.
  ks0="0" ks1="k[0]"
  go_on=1

  # Parse lines of the commands file.
  repeat $! l[$>] if {$go_on" && "h>7" && "same([{^}],'#@cli',5)" && (i[5]==_' ' || i[5]==_':')"} # Process only lines starting with '#@cli'.
    rows 6,100% autocrop {'" "'}  # Discard '#@cli'.
    _is_example=0
    if {i!=_':'}

      # Reached line as '#@cli Command : Arguments_line1 : Arguments_line2 : (qualifier)'.
      _command+=1
      s -,{'": "'} autocrop {'" "'}
      _document_gmic_declaration_$1

    else
      rows 1,100% # Discard ':' char.
      if {i==_':'}

        # Reached line as '#@cli :: Subsection name'.
        _subsection+=1
        rows 1,100% autocrop {'" "'} # Discard ':' character.
        if {"['"{t}"']=='Additional Gallery Images'"} go_on=0
        else _document_gmic_subsection_$1
        fi

      else
        autocrop {'" "'}
        if {i==_'$'}

          # Reached line as '#@cli : $ Example of use'.
          rows 1,100% autocrop {'" "'} # Discard '$' character.
          _is_example=1
          if {i!=_'$'} _example+=1 fi # Reached '#@cli : $$' for announcing available tutorial page.
          _filename=$_path$_name$_example.jpg
          _document_gmic_example_$1

        else

          # Reached line as '#@cli : description.'
          _document_gmic_description_$1
        fi
      fi
    fi
  fi ${ks{$!!=0}} endl done
  rm
  _document_gmic_footer_$1[] $3

# Define document_gmic commands for ascii output.
_document_gmic_header_ascii : skip $1
  use_vt100 _shortcut=0

_document_gmic_subsection_ascii :
  v +
  e[] "\n\n "$_gmic_r$_gmic_b"**** "{0,t}":"$_gmic_n"\n"
  v -

_document_gmic_declaration_ascii :
  if {[{^}]=='(+)'} qualifier=" "{t} rm. else qualifier="" fi
  if {$!>1" && "same([{^}],'"eq. to "',7)} # Declaration of a shortcut command.
    rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
    _shortcut$_shortcut={0,t}
    _shortcutlink$_shortcut={t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut+=1
  else                                     # Declaration of a regular command.
    v + e[] "\n    "$_gmic_m${_gmic_b}{0,t}${qualifier}":"$_gmic_n v - rm[0]
    if $!
      s="        "
      y x
      repeat {$!-1} ({'" |"'}) a[$>,-1] x done  # Insert ' |'.
      repeat $! l[$>] _document_gmic_split_ascii 80
        repeat {$!-1} ({'\\\\\n$s" "'}) a[$>,-1] x done
        a x v + e[] $_gmic_c$s{0,t}$_gmic_n v -
      endl done
    fi
    v + e[] "" v -
  fi

_document_gmic_description_ascii :
  s="      " bs0="\n" bs1="\\\\\n         "
  is_equivalent={same([{^}],"'(eq. to '",8)}
  is_default={same([{^}],"'Default value'",13)}
  y x if {!narg($_is_tutorial)} _document_gmic_split_ascii 96 fi
  if {$!==1" && "0$_vt100>0" && "$is_equivalent}
    replace_str "eq. to","equivalent to shortcut command"
    s +,39 if {$!==5} i[2] ({'$_gmic_m$_gmic_b'}) i[4] ({'$_gmic_n'}) y fi a y
  fi
  repeat {$!-1} ({'${bs$_is_example}$s"  "'}) a[$>,-1] x done a x
  if {0$_vt100>0}
    replace_str "Default values:","\n"$s$_gmic_n${_gmic_b}"Default values:"$_gmic_n
    replace_str "Default value:","\n"$s$_gmic_n${_gmic_b}"Default value:"$_gmic_n
    replace_str "G'MIC",${_gmic_g}"G'MIC"$_gmic_n
    replace_str "(no arg)",${_gmic_g}"(no arg)"$_gmic_n

    if {!$_is_example" && "!$is_equivalent}
      # Colorize parameters between single quotes.
      s +,39 if {$!>=3}
        ind=0 closing=0
        do
          if {"const ind = "$ind"; h#ind==1 && i#ind==39 && h#(ind+2)==1 && i#(ind+2)==39 && h#(ind+1)<48 && (im#(ind+1)>32 || "$is_default")"}
            l[$ind,{$ind+2}] rm (39,{'$_gmic_c'}) ({'$_gmic_n'},39) y endl
            ind+=2
          fi
          ind+=1
        while {$ind<$!-3}
        a y
      fi

      # Colorize parameters between braces '{}'.
      s +,{'\{'} s +,{'\}'} if {$!>=3}
        ind=0 closing=0
        do
          if {"const ind = "$ind"; h#ind==1 && i#ind==123 && h#(ind+2)==1 && i#(ind+2)==125"}
            l[$ind,{$ind+2}] rm ({'$_gmic_g'},123) (125,{'$_gmic_n'}) y endl
            ind+=2
          fi
          ind+=1
        while {$ind<$!-3}
        a y
      fi

      # Colorize parameters between brackets '[]'.
      s +,{'['} s +,{']'} if {$!>=3}
        ind=0 closing=0
        do
          if {"const ind = "$ind"; h#ind==1 && i#ind==91 && h#(ind+2)==1 && i#(ind+2)==93"}
            l[$ind,{$ind+2}] rm ({'$_gmic_c'},91) (93,{'$_gmic_n'}) y endl
            ind+=2
          fi
          ind+=1
        while {$ind<$!-3}
        a y
      fi

    fi
  fi
  v + repeat $! e[] $s{$>,t} v - done

_document_gmic_example_ascii :

_document_gmic_footer_ascii : skip $1
  if $_shortcut # Document shortcuts.
    ({'"Command shortcuts"'}) _document_gmic_subsection_ascii. v + e[] "" v - rm.
    _document_gmic_sort_shortcuts[]
    v + repeat $_shortcut
      e[] "    "$_gmic_m${_gmic_b}${_sshortcut$>}" "${_sshortcutqualifier$>}":"$_gmic_n" eq. to '"$_gmic_g${_sshortcutlink$>}$_gmic_n"'."
    done v -
  fi
  v + e[] "\n   "$_gmic_c"[ Total number of commands: "$_command" ]"$_gmic_n v -

_document_gmic_split_ascii :
  do if {w>$1}
    i={$1-1}
    repeat {$1/2} if {C=i($1-1-$>);C==32||C==38||C==42||C==43||C==44||C==46||C==47||C==58||C==59||C==63||C==92||C==124} i={$1-1-$>} break
    fi done
    +z. {$i+1},100% z.. 0,$i
  fi while {w>$1}
  if {$!>1" && "w<10} a[-2,-1] x fi

# Define document_gmic commands for bash auto-completion script output.
_document_gmic_header_bash : skip $1
  v +
  e[] "#
\n#  Bash completion rules for 'gmic'.
\n#
\n# This file has been generated automatically.
\n# Do not edit!
\n#
\n# This file should be copied/renamed in '/usr/share/bash-completion/completions/gmic'.
\n#
\n
\n_"$_name"()
\n{
\n\tlocal cur prev opts coms
\n\t_init_completion || return
\n\tCOMPREPLY=()
\n\tcur=\"${COMP_WORDS[COMP_CWORD]}\"
\n\tprev=\"${COMP_WORDS[COMP_CWORD-1]}\"
"
  v -
  _opts=
  _coms=
  _argcommand=0
  _shortcut=0
  _nbopts=0
  _nbcoms=0

_document_gmic_subsection_bash :
_document_gmic_description_bash :
_document_gmic_example_bash :

_document_gmic_declaration_bash :
  _opts$_nbopts={0,t}" "-{0,t}" "--{0,t}" "+{0,t}
  _nbopts+=1

  _coms$_nbcoms={0,t}
  _nbcoms+=1

  if {"s = ["{^}"]; s=='input' || s=='i' || s=='output' || s=='o' || s=='command' || s=='m'"} return fi # Manage special commands (remove arguments).

  repeat $! if {[{^}]=='(+)'} rm[$<] fi done # Discard '(+)' qualifier.
  if {$!==2" && "same([{^}],'"eq. to "',7)} # Command is a shortcut.
    rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39 autocrop. {'-'}
    _shortcut$_shortcut={0,t}
    _shortcutlink$_shortcut=${str2hex\ {1,t}}
    rm.
    _shortcut+=1
  elif {$!>1} # Command is regular and has arguments.
    _command$_argcommand={0,t}
    if {[{0,^}]=='help'}
      _argument$_argcommand="$coms\" -- \"$cur"  # Manage help command.
    else
      if {$!==2} ({'>'}) fi # Add shadow parameter when single argument.
      replace_str[^0] " ","_"
      replace_str[^0] "'","\\\\'"
      i[2--2] ({'" "'}) a[^0] y
      _argument$_argcommand={1,t}
    fi
    _argumentlink${str2hex\ {0,t}}=${_argument$_argcommand}
    _argcommand+=1
  fi

_document_gmic_footer_bash : skip $1

  str_coms= repeat $_nbcoms str_coms=${str_coms}" "${_coms$>} done
  v +
  e[] "\tcoms=\""${str_coms}" \""
  e[] "\topts=$(echo \"\$coms\" | sed \"s: \\([^ ]\\+\\): \\1 -\\1 \\+\\1 --\\1:g\")"
  e[] "\n\tcase \"${prev}\" in"
  repeat $_argcommand  # Regular commands with arguments.
    if {'${_command$>}'!='i'" && "'${_command$>}'!='o'" && "!same('${_command$>}','input',5)" && "!same('${_command$>}','output',6)}
      e[] "\t\t\""${_command$>}"\" | \"-"${_command$>}"\" | \"--"${_command$>}"\" | \"+"${_command$>}"\")\n\t\t    "\
          "COMPREPLY=( $(compgen -W \""${_argument$>}"\") ); return 0;;"
    fi
  done
  repeat $_shortcut # Shortcut commands (with arguments).
    if {['${_shortcut$>}']!='i'" && "['${_shortcut$>}']!='o'" && "narg(${_argumentlink${_shortcutlink$>}})}
      e[] "\t\t\""${_shortcut$>}"\" | \"-"${_shortcut$>}"\" | \"--"${_shortcut$>}"\" | \"+"${_shortcut$>}"\") "\
          "COMPREPLY=( $(compgen -W \""${_argumentlink${_shortcutlink$>}}"\") ); return 0;;"
    fi
  done
  e[] "\tesac\n
\n\tCOMPREPLY=( $(compgen -W \"$opts\" -- \"$cur\") )
\n\t_filedir
\n}
\ncomplete -F _"$_name" -o filenames gmic"
  v -

# Define document_gmic commands for html output.
_document_gmic_header_html :
  if $1 v + e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<head>
\n<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>
\n<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />
\n<script type=\"text/javascript\">
\nhs.graphicsDir = 'highslide/graphics/';
\nhs.wrapperClassName = 'wide-border';
\n</script>
\n</head>
\n<body>
\n"
  v - fi
  m "don : _document_gmic_desc_on_html"
  m "doff : _document_gmic_desc_off_html"
  m "eon : _document_gmic_ex_on_html"
  m "eoff : _document_gmic_ex_off_html"
  _is_desc=0
  _is_ex=0
  _shortcut=0

_document_gmic_desc_on_html :
  v -
  if $_is_desc
    u "<br/>"
  else
    u "<p style=\"margin-left:50px; text-align:left\"><tt>"
    _is_desc=1
  fi
  v +

_document_gmic_desc_off_html :
  v -
  if $_is_desc
    u "</tt></p>"
    _is_desc=0
  else u ""
  fi
  v +

_document_gmic_ex_on_html :
  v -
  if $_is_ex
    u ""
  else
    u "<br/><table style=\"margin-left:50px\" width=\"95%\" bgcolor=\"#FFFFFF\" bordercolor=\"black\" border=\"1\" cellpadding=\"4\" cellspacing=\"0\">"\
      "<tr><td colspan=\"2\" bgcolor=\"#000000\"><font color=\"white\"><b>Example of use:</b></font></td></tr>"
    _is_ex=1
  fi
  v +

_document_gmic_ex_off_html :
  v -
  if $_is_ex
    u "</table>"
    _is_ex=0
  else
    u ""
  fi
  v +

_document_gmic_subsection_html :
  v +
  e[] ${-eoff}${-doff}"<hr style=\"border-top: 1px solid \#ccc;\"/>\n<br/><h2><a href=\"#toc\"><img alt=\"\" border=\"0\" src=\"img/back_top.png\" /></a>&nbsp;&nbsp;"\
      "<a id=\"subsection"$_subsection"\"><font color=\"#B00000\">"{0,t}"</font></a></h2>"
  v -

_document_gmic_declaration_html :
  if {[{^}]=='(+)'} qualifier=" (+)" rm. else qualifier="" fi
  s1="\n" s0=" |<br/>"
  if {$!>1" && "same([{^}],'"eq. to "',7)} # Declaration of a shortcut command.
    rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
    _shortcut$_shortcut={0,t}
    _shortcutlink$_shortcut={t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut+=1
  else                                     # Declaration of a regular command.
    _command_name={0,t}
    v +
    e[] ${-eoff}${-doff}"<br/><hr style=\"border-top: 1px solid \#ccc;\"/><p><a id=\""{0,t}"\">"\
     "<span class=\"ref_decl\"><b>"{0,t}"</b></span></a>"$qualifier"&nbsp;&nbsp;&nbsp;<a style=\"font-weight: normal\" href=\"#"$_command_name"\"><img src=\"img/icon_link.png\" /></a>"
    if {$!>1}
      e[] "<p style=\"margin-left:50px; font-family: monospace; color: \#900090; text-align: left\">"
      repeat {$!-1} l[{1+$>}]
        if {h>48} v - replace_str ",",", " v + fi
        e[] "<span style=\"margin-left:-1.5em\">"{0,t}"</span>"${s{$<==0}}
      endl done
      e[] "</p>"
    else e[] ""
    fi
    v -
  fi

_document_gmic_description_html :
  is_equivalent={same([{^}],"'(eq. to '",8)}
  is_default={same([{^}],"'Default value'",13)}

  replace_str "\\n","<br/>"
  replace_str "G'MIC","<b><font color=\"#900090\">G\47MIC</font></b>"
  replace_str "(no arg)","<font color=\"#900090\">(no arg)</font>"
  add_link_html. 1

  if {!$_is_example" && "!$is_equivalent}
    # Colorize parameters between single quotes.
    s +,39 if {$!>=3}
      ind=0 closing=0
      do
        if {"const ind = "$ind"; h#ind==1 && i#ind==39 && h#(ind+2)==1 && i#(ind+2)==39 && h#(ind+1)<48 && (im#(ind+1)>32 || "$is_default")"}
          l[$ind,{$ind+2}] rm
          ({'"<span class=\"ref_code\">"'})
          ({'"</span>"'})
          y endl
          ind+=2
        fi
        ind+=1
      while {$ind<$!-3}
      a y
    fi

    # Colorize parameters between braces '{}'.
    s +,{'\{'} s +,{'\}'} if {$!>=3}
      ind=0 closing=0
      do
        if {"const ind = "$ind"; h#ind==1 && i#ind==123 && h#(ind+2)==1 && i#(ind+2)==125"}
          l[$ind,{$ind+2}] rm ({'"<span style=\"color: \#900090; font-family: monospace\">"'},123) (125,{'"</span>"'}) y endl
          ind+=2
        fi
        ind+=1
      while {$ind<$!-3}
      a y
    fi

    # Colorize parameters between brackets '[]'.
    s +,{'['} s +,{']'} if {$!>=3}
      ind=0 closing=0
      do
        if {"const ind = "$ind"; h#ind==1 && i#ind==91 && h#(ind+2)==1 && i#(ind+2)==93"}
          l[$ind,{$ind+2}] rm ({'"<font color=\"#005090\">"'},91) (93,{'"</font>"'}) y endl
          ind+=2
        fi
        ind+=1
      while {$ind<$!-3}
      a y
    fi

  fi

  if $is_default # Reached line as '#@cli : Default value(s) : ... '.
    s +,{':'} l[^0] a y endl autocrop {':'} autocrop {'" "'}
    if {$!>1}
      replace_str "ref_code","ref_defvals"
      v + e[] ${-don}"<br/><b>"{0,t}"</b>: "{t}
    else
      v + e[] ${-don}"<br/>"{0,t}
    fi
    v -

  elif $is_equivalent # Reached line as '#@cli : (eq. to shortcut)'.
    replace_str "eq. to","equivalent to shortcut command"
    s +,39 if {$!==5} rm[1,3] i[1]
    ({'"<span class=\"ref_code\">"'})
    i[3] ({'"</span>"'})
    y fi a y
    v + e[] ${-don}"<i>"{t}"</i>" v -

  else                                    # Reached line as '#@cli : description'.
    if {(i<_'A'" || "i>_'Z')" && "i!=40" && "i!=39} v + e[] ${-don}"&nbsp;"{t} v -
    else v + e[] ${-don}{t} v -
    fi

  fi

_document_gmic_example_html :
  if {i==_'$'} # Link to a tutorial page.
    if {h==1" && "i==_'$'} tuturl=https://gmic.eu/tutorial/_$_command_name.shtml
    else autocrop {'$'} autocrop {'" "'} tuturl=https://gmic.eu/tutorial/{0,t}.shtml
    fi
    v +
    e[] ${-eon}"<tr><td width=\"24\" align=\"center\"><a target=\"_blank\" href=\""$tuturl"\"><img src=\"img/icon_info.png\" /></td>"\
                "<td><a target=\"_blank\" href=\""$tuturl"\">A tutorial page exists for this command.</a></td></tr>"
    v -
  else # Regular example.
    if $_filename else # Generate picture only if the file doesn't yet exist.
       m "foo : "{t}
       l[] v -99 reset foo v -1 _document_gmic o $_filename,85 rm endl
       uncommand foo
    fi
    ({'${-eon}"<tr><td width=\"24\" align=\"center\"><div><a href=\""$_filename"\" class=\"highslide\" onclick=\"return hs.expand(this)\">"\
         "<img src=\"img/icon_magnifier.png\" /></a><div class=\"highslide-caption\"><b>"{t}"</b></div></div></td><td><span style=\"font-family: monospace; text-align: left\"><b>"{t}"</b></span></td></tr>"'})
    replace_str. " "$_command_name" "," <span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span> "
    replace_str. " "$_command_name"."," <span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>."
    replace_str. " "$_command_name"["," <span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>["
    replace_str. "+"$_command_name" ","+<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span> "
    replace_str. "+"$_command_name".","+<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>."
    replace_str. "+"$_command_name"[","+<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>["
    replace_str. $_command_name"<","<span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span><"
    replace_str. ">"$_command_name,"><span style=\"font-weight: bold; color: \#900090\">"$_command_name"</span>"
    v +
    e[] {t}
    v - rm.
  fi

_document_gmic_footer_html : skip $1
  if $_shortcut # Document shortcuts.
    _subsection+=1
    ({'"Command shortcuts"'}) _document_gmic_subsection_html. rm.
    _document_gmic_sort_shortcuts[]
    v + e[] "<p style=\"margin-left:20px\">"
    repeat $_shortcut
      e[] "<font color=\"green\"><b>&nbsp;&nbsp;"${_sshortcut$>}" "${_sshortcutqualifier$>}"</b>:</font>"
      v - ({'${_sshortcutlink$>}'}) scl={t} rm. v +
      e[] "<font color=\"blue\"><i>Shortcut for command '<a href=\"#"$scl"\">"${_sshortcutlink$>}"</a>'</i></font><br/>"
    done
    e[] "</p>" v -
  fi
  v +
  e[] ${-eoff}${-doff}"<p style=\"margin-left:50px\"><font color=\"blue\"><b>[ Total number of commands: "$_command" ]</b></font>"
  v -
  uncommand don,doff,eon,eoff

# Replace URL with HTML link in selected images of string.
# $1 can be { 0=open in same window (default) | 1=open in new window }
add_link_html : check "isbool(${1=0})"
  repeat $!
    _add_link_html[$>] $1,http://
    _add_link_html[$>] $1,https://
  done

_add_link_html :
  if $1 target=" target=\"_blank\"" fi
  s +,{'"$2"'}
  repeat {$!-1} if {$>,crop()==['"$2"']}
    l[{$>+1}]
      s +,{'" "'} s[0] +,{')'} s[0] +,{']'} s[0] +,39 s[0] +,{'\"'} s[0] +,{'<'}
      url="$2"{0,t} i[1] ({'</a>'}) y[1]
    a y endl
    rm[$>] i[$>] ({'"<a href=\""$url"\""$target">$2"'}) y[$>]
  fi done a y

# Define document_gmic commands for images-only output.
_document_gmic_header_images : skip $1
  use_vt100
  v +
  e[] "\n - Generate example images from set of commands '"${_gmic_c}$_name${gmic_n}"'.\n"
  if image.jpg else l[] sp pencils onfail testimage2d 400 endl o. image.jpg rm. fi
  v -

_document_gmic_subsection_images :
  v +
  e[] "\n "${_gmic_r}"** Section ""#"$_subsection": "{0,t}"."${_gmic_n}"\n"
  v -
_document_gmic_declaration_images : _command_name={0,t}
_document_gmic_description_images :

_document_gmic_example_images :
  if {i==_'$'} return fi
  v +
  e[] "    "${_gmic_c}"["$_example"]"${_gmic_n}" Command '"${_gmic_g}$_command_name${_gmic_n}"': $ "{t}
  v -
  if $_filename else # Generate picture only if the file doesn't yet exist.
    m "foo"$_example" : "{t}
    l[] v -1 reset v -99 etime=$| foo$_example etime={_round($|-$etime,0.01)} v -1 _document_gmic o $_filename,85 rm endl
    uncommand foo$_example
    v +
    e[] "\r    "${_gmic_c}"["$_example"]"${_gmic_n}" Command '"${_gmic_g}$_command_name${_gmic_n}"': $ "{t}\
     ${_gmic_m}" (done in "$_gmic_n${etime}"s"$_gmic_m")."$_gmic_n
    v -
  fi

_document_gmic_footer_images : skip $1
  v +
  e[] " - [ All done! ]\n\n"
  v -

# Define document_gmic commands for LateX output.
_document_gmic_header_latex :
  if $1 v +
    e[] "\\documentclass[a4paper,10.5pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,color}
\n\\graphicspath{{"$_path"}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{5.875in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\oddsidemargin}{15.5pt}
\n\\setlength{\\evensidemargin}{15.5pt}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\def\\Ccr{\\color{ca}}
\n\\def\\Ccb{\\color{cb}}
\n\\def\\Ccg{\\color{cc}}
\n\\def\\Ccc{\\color{cd}}
\n\\def\\Ccn{\\color{black}}
\n\\def\\comma{\\discretionary{,}{}{,}}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\begin{document}
\n\\tableofcontents"
  v - fi
  v + e[] "\n\\chapter{List of commands}" v -
  m "eon : _document_gmic_ex_on_latex"
  m "eoff : _document_gmic_ex_off_latex"
  _is_desc=0
  _is_ex=0
  _shortcut=0

_document_gmic_ex_on_latex :
  v -
  if $_is_ex
    u "\\\\"
  else
    u "\\begin{center}"
    _is_ex=1
  fi
  v +

_document_gmic_ex_off_latex :
  v -
  if $_is_ex
    u "\\end{center}"
    _is_ex=0
  else
    u ""
  fi
  v +

_document_gmic_subsection_latex :
  _is_desc=0
  _document_gmic_replace_latex
  v + e[] ${-eoff}"\n\\section{"{0,t}"}" v -

_document_gmic_declaration_latex :
  _is_desc=0
  if {[{^}]=='(+)'} qualifier={t} rm. else qualifier="" fi
  e1="\\end{flushleft}" e0="~~~\\\\"
  if {$!>1" && "same([{^}],'"eq. to "',7)}  # Declaration of a shortcut command.
    _document_gmic_replace_latex
    rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
    _shortcut$_shortcut={0,t}
    _shortcutlink$_shortcut={t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut+=1
  else                                         # Declaration of a regular command.
    _document_gmic_replace_latex[0]
    _command_name={0,t}
    v + e[] ${-eoff}"\n\n\\subsection{\\emph{"{0,t}"\\index{"{0,t}"}} "$qualifier"}\\vspace*{-0.7em}"
    if {$!>1}
      e[] "~\\\\\\textbf{\\Cb{Arguments: }}\\begin{flushleft}"
      repeat {$!-1} l[{1+$>}]
        v - s y,-60 if {$!>1} i[1--2] ({'\\-'}) fi y a y
        _document_gmic_replace_latex v +
        e[] "{\\small \\Cb{\\hspace*{0.5cm}$\\bullet$~~\\texttt{"{0,t}"}}}"${e{$<==0}}
      endl done
    fi
    v -
  fi

_document_gmic_description_latex :
  is_equivalent={same([{^}],"'(eq. to '",8)}
  is_default={same([{^}],"'Default value'",13)}
  s0="" s1="~\\\\" s=${s$_is_desc}
  _document_gmic_replace_latex
  if $is_default # Reached line as '#@cli : Default value(s) : ... '.
    s +,{':'} l[^0] a y endl autocrop {':'} autocrop {'" "'}
    if {$!>1}
      replace_str[1] " and ","} and \\\\texttt{"
      v + e[] ${-eoff}"\\begin{flushleft}\\Cc{\\textbf{"{0,t}"}:\\\\~\\\\\\hspace*{0.5cm}{\\small $\\bullet$~~\\texttt{"{t}"}}}\\end{flushleft}" v -
    else v + e[] ${-eoff}$s"~\\\\"{0,t} v -
    fi
  elif $is_equivalent # Reached line as '#@cli : (eq. to 'shortcut').'.
    rows. 8,100% autocrop. {'.'} autocrop. {')'} autocrop. {'" "'}
    v + e[] ${-eoff}$s"(\\emph{eq. to} {\\small \\texttt{"{t}"}})." v -
  else                                    # Reached line as '#@cli : description'.
    if {(i<_'A'" || "i>_'Z')" && "i!=40" && "i!=39} v + e[] ${-eoff}{t} v -
    else v + e[] ${-eoff}$s{t} v -
    fi
  fi
  _is_desc=1

_document_gmic_example_latex :
  if {i==_'$'} # Link to a tutorial page.
    if {h==1" && "i==_'$'} tuturl=https://gmic.eu/tutorial/\\_$_command_name.shtml
    else autocrop {'$'} autocrop {'" "'} tuturl=https://gmic.eu/tutorial/{0,t}.shtml
    fi
    l[] ({'$tuturl'}) replace_str "_","\\_"
    s x,-60 if {$!>1} i[1--2] ({'\\\\-'}) fi a x
    replace_str. "_","\\_" tuturl={t} rm endl
    v +
    e[] ${-eoff}
    if {!$_is_ex} e[] "~\\\\" fi
    e[] "~\\textbf{Tutorial page: }\\\\\\url{"$tuturl"}"
    v -
  else # Regular example.
    _is_desc=0
    if $_filename else # Generate picture only if the file doesn't yet exist.
       m "foo : "{t}
       l[] v -99 reset foo v -1 _document_gmic o $_filename,85 rm endl
       uncommand foo
    fi
    _document_gmic_replace_latex
    v +
    e[] ${-eon}"\\includegraphics[keepaspectratio=true,height=6cm,width=\\textwidth]{"$_filename"}\\\\"
    e[] "{\\footnotesize \\textbf{Example "$_example"~:} \\texttt{"{t}"}}"
    v -
  fi

_document_gmic_footer_latex :
  if $_shortcut # Document shortcuts.
    ({'"Command shortcuts"'}) _document_gmic_subsection_latex. rm.
    _document_gmic_sort_shortcuts[]
    v + repeat $_shortcut
      e[] "$\\bullet$~'\\texttt{\\Ca{"${_sshortcut$>}"}}' "${_sshortcutqualifier$>}"~is equivalent to~~'\\texttt{\\Ca{"${_sshortcutlink$>}"}}'.\\\\"
    done v -
  fi
  if $1
    v +
    e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
    v -
  fi
  uncommand eon,eoff

_document_gmic_replace_latex :
  replace_str "\\","\\\\textbackslash "  # Replace '\'
  replace_str "_","\\\\_"                # Replace '_'
  replace_str "%","\\\\%"                # Replace '%'
  replace_str "#","\\\\%"                # Replace '#'
  replace_str "^","\\\\textasciicircum " # Replace '^'
  replace_str "$","\\\\$"                # Replace '$'
  replace_str "\{","\\\\\{"              # Replace '{'
  replace_str "\}","\\\\\}"              # Replace '}'
  replace_str "&","\\\\&"                # Replace '&'
  replace_str "|","~$|$~"                # Replace '|'
  replace_str "<","$\<$"                 # Replace '<'
  replace_str ">","$\>$"                 # Replace '>'
  replace_str "\\\\textbackslash -","\\\\-"  # Keep word cut.
  replace_str ",","{\\\\\\comma}"        # Replace ','

# Define document_gmic commands for man page output.
_document_gmic_header_man : skip $1
  _gmic_n="\\fR"
  _gmic_b="\\fB"
  _gmic_r=""
  _gmic_g=""
  _gmic_c="\\fB"
  _gmic_m=""
  _document_gmic_header_ascii $"*"

_document_gmic_subsection_man :
  v +
  e[] "\n "$_gmic_b"** "{0,t}":"$_gmic_n
  v -

_document_gmic_declaration_man :
  if {[{^}]=='(+)'} qualifier=" "{t} rm. else qualifier="" fi
  if {$!>1" && "same([{^}],'"eq. to "',7)}  # Declaration of a shortcut command.
    rows. 7,100% autocrop. {'.'} autocrop. {'" "'} autocrop. 39
    _shortcut$_shortcut={0,t}
    _shortcutlink$_shortcut={t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut+=1
  else                                         # Declaration of a regular command.
    v + e[] "\n    "${_gmic_b}{0,t}${qualifier}":"$_gmic_n v - rm[0]
    if $!
      s="        "
      y x
      repeat {$!-1} ({'" |"'}) a[$>,-1] x done  # Insert ' |'.
      repeat $! l[$>] _document_gmic_split_ascii 80
        repeat {$!-1} ({'\n$s"  "'}) a[$>,-1] x done
        a x v + e[] $s{0,t} v -
      endl done
    fi
    v + e[] "" v -
  fi

_document_gmic_description_man :
  s="        " bs0="\n" bs1="\\\\\n         "
  y x if {!narg($_is_tutorial)} _document_gmic_split_ascii 96 fi
  repeat {$!-1} ({'${bs_is_example}$s"  "'}) a[$>,-1] x done a x
  replace_str "Default values:","Default values:"
  replace_str "Default value:","Default value:"
  replace_str "\\","\\\\"
  v + repeat $! e[] $s{$>,t} v - done

_document_gmic_example_man :

_document_gmic_footer_man : skip $1
  _document_gmic_footer_ascii $"*"

# Generate a single image from a list of images, for the reference documentation.
_document_gmic :
  repeat $! l[$>] W$>={w} H$>={h} D$>={d} S$>={s} IS_3D$>=${-_is_3d} endl done
  repeat $! l[$>]
    if ${IS_3D$>} r3d 1,1,0,-80 r3d 0,1,0,80 snapshot3d 400
    else if {w>8192} z 0,8191 elif {h>8192} rows 0,8191 fi n 0,255
    fi
  endl done
  +append_tiles 2 if {w>1024} r={round(1024*100/w,0.1)} r[^-1] $r%,$r%,1,100%,2 fi rm.
  repeat $! l[$>]
    if {s==1} r {w},{h},1,3 else r {w},{h},1,3,0 fi
    if {w<=h&&h<256} r2dy 256,2 elif {h<=w&&w<256} r2dx 256,2 fi
    if {w<=h&&h>512} r2dy 512,2 elif {h<=w&&w>512} r2dx 512,2 fi
    if {h<48} r 100%,48 fi
    if {w<48} r 48,100% fi
    frame 1,1,0 frame 4,4,255
  endl done
  N=$! repeat $N l[$>]
    {w},16,1,3,255
    if {w>75}
      if {$N>1} if {w>110} t. Image\ [$>]:,3,3,15 else t. [$>]:,3,3,15 fi fi
      if ${IS_3D$>} 0 t. (3d\ object),0,0,13,1,255
      else 0 t. (${W$>}x${H$>}x${D$>}x${S$>}),0,0,13,1,255
      fi
      negate. n. 0,255 +. 164 c. 0,255 to_rgb.
      j.. .,{{-2,w}-w-5},{{-2,h}-h-1} rm.
    else t. [$>]:,3,3,15 fi
    rv[-2,-1] a[-2,-1] y
  endl done
  - 255 append_tiles 2 + 255
  if {w<256} - 255 r 256,100%,1,3,0,0,0.5,0.5 + 255 fi
  if {h<256} - 255 r 100%,256,1,3,0,0,0.5,0.5 + 255 fi

# Sort shortcut by lexicographic order and generate new sorted variables 'sshortcut_?'.
_document_gmic_sort_shortcuts :
  $_shortcut,1,1,1,x s x repeat $! nm[$>] ${_shortcut$>} done sort_list +,n a x
  repeat {w} i={i[$>]}
    _sshortcut$>,_sshortcutqualifier$>,_sshortcutlink$>=${_shortcut$i},${_shortcutqualifier$i},${_shortcutlink$i}
  done
  rm

#@cli e : eq. to 'echo'. : (+)

#@cli echo : message : (+)
#@cli : Output specified message on the error output.
#@cli : (eq. to 'e').\n
#@cli : Command selection (if any) stands for displayed call stack subset instead of image indices.

#@cli echo_file : filename,message
#@cli : Output specified message, appending it to specified output file.
#@cli : (similar to 'echo' for specified output file stream).
echo_file : skip "${2='\n'}"
  v - ({"'${2--1}\n'"}) o. raw:$1,char rm. v +

#@cli echo_stdout : message
#@cli : Output specified message, on the standard output (stdout).
#@cli : (similar to 'echo' for output on standard output instead of standard error).
echo_stdout :
  v -  ({'"$*"\n'}) o. -.raw,char rm. v +

#@cli function1d : 0<=smoothness<=1,x0>=0,y0,x1>=0,y1,...,xn>=0,yn
#@cli : Insert continuous 1D function from specified list of keypoints (xk,yk)
#@cli : in range [0,max(xk)] (xk are positive integers).
#@cli : Default values: 'smoothness=1' and 'x0=y0=0'.
#@cli : $ function1d 1,0,0,10,30,40,20,70,30,80,0 +display_graph 400,300
function1d : check "${1=1}>=0 && $1<=1" skip ${2=0},${3=0}
  e[^-1] "Input continuous 1D function, with smoothness $1 and keypoints (${2--1})."
  v - l[]

  # Sort and normalize input keypoints.
  smoothness={max(0,min(1,$1))}
  (${2--1}) r 2,{int(w/2)},1,1,-1
  sort +,y s x size={0,if(iM>=0,1+int(iM),0)}
  if {!$size} rm 0 break fi
  a x

  # Compute slopes for splines.
  +f '0.5*(j(0,1,0,0,0,1)-j(0,-1,0,0,0,1))' s. x max.. 0.01 /. .. rm.. a x

  # Determine spline coefficients for each part of the curve.
  $size,1,1,1,-1
  repeat {0,h-1}
    x0={0,i(0,$>)} y0={0,i(1,$>)} x1={0,i(0,$>+1)} y1={0,i(1,$>+1)}
    slope={($y1-$y0)/max(0.01,$x1-$x0)}
    yp0={0,i(2,$>)*$smoothness+(1-$smoothness)*$slope}
    yp1={0,i(2,$>+1)*$smoothness+(1-$smoothness)*$slope}
    i={round($x0,1,1)} j={round($x1,1,0)}
    line[1] $i,0,$j,0,1,$>
    if {$j-$i<=1} # Linear interpolation for very close points.
      ({$y0-$x0*$slope}^{$slope}^0^0)
    else # Cubic interpolation otherwise.
      (1,$x0,{($x0)^2},{($x0)^3};\
       1,$x1,{($x1)^2},{($x1)^3};\
       0,1,{2*$x0},{3*($x0)^2};\
       0,1,{2*$x1},{3*($x1)^2})
      ($y0;$y1;$yp0;$yp1)
      solve. .. rm.. y. c
    fi
  done
  a[2--1] x map.. . rm.

  # Render final curve.
  100%,1,1,1,1
  (0,{w-1}) r. {-2,w},1,1,1,3 round.
  +sqr. +*[-2,-1] a[-4--1] c *[-2,-1] s. c +[-4--1] rm..
  endl v +

#@cli i : eq. to 'input'. : (+)

#@cli input : [type:]filename : [type:]http://URL : [selection]x_nb_copies>0 : { width>0[%] | [image_w] },{ _height>0[%] | [image_h] },{ _depth>0[%] | [image_d] },{ _spectrum>0[%] | [image_s] },_{ value1,_value2,... | 'formula' } : (value1{,|;|/|^}value2{,|;|/|^}...) : 0 : (+)
#@cli : Insert a new image taken from a filename or from a copy of an existing image [index],
#@cli : or insert new image with specified dimensions and values. Single quotes may be omitted in
#@cli : 'formula'. Specifying argument '0' inserts an 'empty' image.
#@cli : (eq. to 'i' | (no arg)).
#@cli : Default values: 'nb_copies=1', 'height=depth=spectrum=1' and 'value1=0'.
#@cli : $ input image.jpg
#@cli : $ input (1,2,3;4,5,6;7,8,9^9,8,7;6,5,4;3,2,1)
#@cli : $ image.jpg (1,2,3;4,5,6;7,8,9) (255^128^64) 400,400,1,3,'if(x>w/2,x,y)*c'
#@cli : $$

#@cli input_cube : "filename",_convert_1d_cluts_to_3d={ 0 | 1 }.
#@cli : Insert CLUT data from a .cube filename (Adobe CLUT file format).
#@cli : Default value: 'convert_1d_cluts_to_3d=1'.
input_cube : skip ${2=1}
  e[^-1] "Input CLUT from file '$1'."
  v - l[]
    i raw:"$1",uchar
    f "i<_' ' && i!=10?_' ':i"
    i[0] 0
    range={"
      line = vector512();
      dmin = [ 0,0,0 ];
      dmax = [ 1,1,1 ];
      dim = size = 0;
      target = 0;
      pos = 0;
      while (pos<h,
        while (i[#-1,pos]<_' ', ++pos);
        npos = find(#-1,'\n',1,pos);
        if (npos<0, npos = h);
        l = npos - pos;
        copy(line[0],i[pos],l);
        line[l] = 0;
        if (same(line,'LUT_1D_SIZE ',12),
          copy(line[0],line[12],size(line) - 12);
          size = stov(line);
          dim = 1;
          resize(#0,3,size,1,1,0);
        ,_(else); if (same(line,'LUT_3D_SIZE ',12),
          copy(line[0],line[12],size(line) - 12);
          size = stov(line);
          dim = 3;
          resize(#0,3,size,size,size,0);
        ,_(else); if (same(line,'DOMAIN_MIN ',11),
          copy(line[0],line[11],size(line) - 11);
          dmin[0] = stov(line);
          ind = find(line,_' ');
          copy(line[0],line[ind + 1],size(line) - ind);
          dmin[1] = stov(line);
          ind = find(line,_' ');
          copy(line[0],line[ind + 1],size(line) - ind);
          dmin[2] = stov(line);
        ,_(else); if (same(line,'DOMAIN_MAX ',11),
          copy(line[0],line[11],size(line) - 11);
          dmax[0] = stov(line);
          ind = find(line,_' ');
          copy(line[0],line[ind + 1],size(line) - ind);
          dmax[1] = stov(line);
          ind = find(line,_' ');
          copy(line[0],line[ind + 1],size(line) - ind);
          dmax[2] = stov(line);
        ,_(else); val = stov(line); if (val>=0,
          do (
            i[#0,target++] = val;
            ind = find(line,_' ');
            if (ind<0, break());
            copy(line[0],line[ind + 1],size(line) - ind);
            val = stov(line);
          ,_(while); val>=0);
        )))));
        pos = ++npos;
      );
      [dmin,dmax];"}

    rm.
    permute yzcx
    if {[$range]!=[0,0,0,1,1,1]}
      f "begin(
           range = ["$range"];
           dmin = range[0,3];
           dmax = range[3,3];
           delta = dmax - dmin;
         );
         (I - dmin)*255/delta"
    else * 255
    fi
    if {"w>1 && h==1 && d==1 && $2"} size={w} s c y.. y y. z r $size,$size,$size a c fi
    nm "$1"
  endl v +

#@cli ig : eq. to 'input_glob'.
ig :
  _input_glob "$*"

#@cli input_glob : pattern
#@cli : Insert new images from several filenames that match the specified glob pattern.
input_glob :
  _input_glob "$*"

_input_glob :
  e[0--3] "Input all files that match glob pattern '$*'."
  v -
  files 3,"$*"
  N=$!
  m "_ig : $""=arg repeat $""# i ${arg{1+$>}} done"
  _ig ${} uncommand _ig
  if {$N==$!} v + error[0--3] "Command 'input_glob': No matching filenames for pattern '$*'." fi
  v +

#@cli input_gpl : filename
#@cli : Input specified filename as a .gpl palette data file.
input_gpl :
  e[^-1] "Input .gpl palette file '$*'."
  v - l[]
    i raw:"$*",char replace 9,32 s -,10
    colors=0
    repeat $! l[$>]
      s -,32
      if {$!>=3" && "isint({0,t})" && "isint({1,t})" && "isint({2,t})} colors=$colors;{0,t},{1,t},{2,t} fi
      rm 0
    onfail rm 0 endl done
    rm ($colors) rows 1,100% nm "$1" permute yzcx
  endl v +

#@cli o : eq. to 'output'. : (+)

#@cli output : [type:]filename,_format_options : (+)
#@cli : Output selected images as one or several numbered file(s).
#@cli : (eq. to 'o').
#@cli : Default value: 'format_options'=(undefined).

#@cli output_cube : filename
#@cli : Output selected CLUTs as a .cube file (Adobe CLUT format).
output_cube :
 e[^-1] "Output CLUT$? as file '$1'."
 v - N=$! repeat $N +l[$>] to_rgb
   l={round((w*h*d)^(1/3))}
   if {w*h*d!=$l^3} v + error "Command '$0': CLUT '"{n}"' has invalid dimensions "({w},{h},{d},{s}). fi
   r $l,$l,$l,3,-1 permute cxyz / 255
   if {$N>1} fn=${"filename \"$1\",$>"} else fn="$1" fi
   o dlm:$fn rm i raw:$fn,uchar replace {','},32
   0 nm. $fn basename={b} rm.
   header="\# Created by: G'MIC (https://gmic.eu)\n"\
          "TITLE \""$basename"\"\n\n"\
          "# LUT size\n"\
          "LUT_3D_SIZE "$l"\n\n"\
          "# Data domain\n"\
          "DOMAIN_MIN 0.0 0.0 0.0\n"\
          "DOMAIN_MAX 1.0 1.0 1.0\n\n"\
          "# LUT data points\n"
   i[0] ({'$header'})
   y a y o raw:$fn,uchar rm
 endl done v +

#@cli output_ggr : filename,_gradient_name
#@cli : Output selected images as .ggr gradient files (GIMP).
#@cli : If no gradient name is specified, it is deduced from the filename.
output_ggr : skip "${2=}"
 e[^-1] "Output image$? as .ggr gradient file '$1'."
 v - N=$!
  repeat $N +l[$>] r 1,{w*h*d},1,100%,-1 to_rgba / 255
    if {narg("$2")} name="$2"
    else l[] 1 nm. "$1" ({'{b}'}) f "if(x==0 && i>=_'a' && i<=_'z',i-_'a'+_'A',i)" name={t} rm endl
    fi
    ({'"GIMP Gradient\nName: "$name\n{0,h}\n'})
    repeat {0,h}
      start={_$>/{0,h}}
      end={_($>+1)/{0,h}}
      mid={_0.5*($start+$end)}
      rgba={0,I(0,$>)}
      r={arg(1,$rgba)} g={arg(2,$rgba)} b={arg(3,$rgba)} a={arg(4,$rgba)}
      ({'$start" "$mid" "$end" "$r" "$g" "$b" "$a" "$r" "$g" "$b" "$a" 0 0\n"'})
    done
    rm[0] a x
    if {$N>1} o raw:${"filename \"$1\",$>"},char else o raw:"$1",char fi
    rm
  endl done v +

#@cli on : eq. to 'outputn'.
on :
  v - _gmic_s="$?" v +
  _outputn $*

#@cli outputn : filename,_index
#@cli : Output selected images as automatically numbered filenames in repeat...done loops.
#@cli : (eq. to 'on').
outputn :
  v - _gmic_s="$?" v +
  _$0 $*

_outputn :
  v -
  if {$#==1} filename=${filename\ "$1",$>}
  else filename=${filename\ "$1",$2}
  fi
  v +
  e[0--3] "Output image"$_gmic_s" as file '"$filename"'."
  v - o $filename v +

#@cli op : eq. to 'outputp'.
op :
  v - _gmic_s="$?" v +
  _outputp $*

#@cli outputp : prefix
#@cli : Output selected images as prefixed versions of their original filenames.
#@cli : (eq. to 'op').
#@cli : Default value: 'prefix=_'.
outputp :
  v - _gmic_s="$?" v +
  _$0 $*

_outputp : skip ${1="_"}
  if {$!>1} e[0--4] "Output image"$_gmic_s" as their initial locations, prefixed by '$1'."
  else e[0--4] "Output image"$_gmic_s" as its initial location, prefixed by '$1'."
  fi
  v - repeat $! o[$>] {$>,f}$1{$>,b}.{$>,x} done v +

#@cli ow : eq. to 'outputw'.
ow :
  v - _gmic_s="$?" v +
  _outputw

#@cli outputw
#@cli : Output selected images by overwriting their original location.
#@cli : (eq. to 'ow').
outputw :
  v - _gmic_s="$?" v +
  _$0 $*

_outputw :
  if {$!>1} e[0--4] "Output image"$_gmic_s" as their initial location."
  else e[0--4] "Output image"$_gmic_s" as its initial location."
  fi
  v - repeat $! o[$>] {$>,n} done v +

#@cli ox : eq. to 'outputx'.
ox :
  v - _gmic_s="$?" v +
  _outputx $*

#@cli outputx : extension1,_extension2,_...,_extensionN,_output_at_same_location={ 0 | 1 }
#@cli : Output selected images with same base filenames but for N different extensions.
#@cli : (eq. to 'ox').
#@cli : Default value: 'output_at_same_location=0'.
outputx :
  v - _gmic_s="$?" v +
  _$0 $*

_outputx :
  v -
  $=arg
  is_last_arg=0 is_same_location=0
  if {isval($-1)} is_last_arg={isint($-1)&&$-1>=0&&$-1<=1} is_same_location=$-1 fi
  N={$#-$is_last_arg} s0= s1=s
  if {!$N} v + e[0--3] "Output image"$_gmic_s" at same location, with same base filename but extension '' (skipped, no extension provided)." return
  fi
  if $is_same_location
    v +
    if $is_last_arg e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}"' ${^-1}'."
    else e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}" '$*'."
    fi
    v -  repeat $! l[$>]
      repeat $N o {0,f}{0,b}.${arg{1+$>}} done
    endl done
  else
    v +
    if $is_last_arg e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}"' ${^-1}'."
    else e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}" '$*'."
    fi
    v -  repeat $! l[$>]
      repeat $N o {0,b}.${arg{1+$>}} done
    endl done
  fi
  v +

#@cli pass : _shared_state={ 0=non-shared (copy) | 1=shared | 2=adaptive } : (+)
#@cli : Insert images from parent context of a custom command or a local environment.
#@cli : Command selection (if any) stands for a selection of images in the parent context.
#@cli : By default (adaptive shared state), selected images are inserted in a shared state if they do not belong to the context (selection) of the current custom command or local environment as well.
#@cli : Typical use of command 'pass' concerns the design of custom commands that take images as arguments.
#@cli : Default value: 'shared_state=2'.
#@cli : $ command "average : pass$""1 add[^-1] [-1] remove[-1] div 2" sample ? +mirror y +average[0] [1]

#@cli plot : _plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_exit_on_anykey={ 0 | 1 } : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_exit_on_anykey={ 0 | 1 } : (+)
#@cli : Display selected images or formula in an interactive viewer (use the instant display window [0] if opened).
#@cli : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@cli : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@cli : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@cli : Default values: 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0 (auto)' and 'exit_on_anykey=0'.

#@cli p : eq. to 'print'. : (+)

#@cli print : (+)
#@cli : Output information on selected images, on the standard error (stderr).
#@cli : (eq. to 'p').

#@cli rainbow_lut
#@cli : Input a 256-entries RGB colormap of rainbow colors.
#@cli : $ image.jpg rainbow_lut +luminance[-2] map[-1] [-2]
rainbow_lut :
  e[^-1] "Input RGB colormap of 256 rainbow colors."
  v -
  base642img "MiB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KMjU2IDEgMSAzICM2MjgKeJxj4uLl5Rfg5xcSl5JXVFVT19LS0dXR0dXVAdK6hkYmZuYWlhYWlpZWllZW1lY21lbWIGBjAyatIcDKysrCwszYQEddUYSVgYERjKAEHKDycABWSSOnwKi03LLGzgkz5q3YtH3f8fNX7zx+9ubTt1/////9+/fP71+/fv748f3Ht2/fvn77+vXrNyj4CgJfgBAGvgCZn9+/fvbozo3LZ04e2rdjw+olC2ZM6GqqKspOCPdztTTSU5MXZmXm4uMXFBIWEhaXlJNXVlUHetvA0MjYxNTC2t7JycXV3dPL28fH18/fPyAwMCgoOAQEQkPDgCA8IhxERURGRsXExCUkp2Vk55dW1DV19E2dvXD5mg2bNm/eBAQbN27cAATr165dt3bNaqxg7dq16zcAlW7dtmPXrn0HDh4+duLkmXMXL184d+rooX07t21as3zR3BkTulvqK4tz0pJiwv29XR3srMxNjAz1oUAPCIARp6WlqamhrqaqoiQvJysnJ6+goKCoqKSkqKSoIA8UkZIUFxXm5+UVEBISEuTn5eFkYhOWVNA0NHd09w+JSkjLyi+tbGhp6+6fNHXG7Dlz589fsHDR4iVLli5bvmzpsmXLl69YsWIlEKyCgNUQcvUakPs3bt6yfefufQePnTx39fbDx4/v37p25viBHZvXrFg0Z/rE7ta6isKspKjQIDQQEgKmgoMDAwMDAvz8/Hy8PD3dPVxdnB3trK0sjI0MdbU11FSVFeQhPlFWUQGlUh1dPT19A0MDOACHga6utrYW2P9qaqpArKamrgGCGurqQAFlJQU5GSlxEQE+HgFgAAgK8PFyMgEAsxoliDEgMTggMSAxICMyNgp4nHP3jWKILkrMzEvKL1fIKS2JZQAAON0GDg=="
  nm. [rainbow\ lut]
  v +

#@cli screen : _x0[%],_y0[%],_x1[%],_y1[%] : (+)
#@cli : Take screenshot, optionally grabbed with specified coordinates, and insert it
#@cli : at the end of the image list.

#@cli select : feature_type,_X[%]>=0,_Y[%]>=0,_Z[%]>=0,_exit_on_anykey={ 0 | 1 },_is_deep_selection={ 0 | 1 } : (+)
#@cli : Interactively select a feature from selected images (use the instant display window [0] if opened).
#@cli : 'feature_type' can be { 0=point | 1=segment | 2=rectangle | 3=ellipse }.
#@cli : Arguments 'X','Y','Z' determine the initial selection view, for 3D volumetric images.
#@cli : The retrieved feature is returned as a 3D vector (if 'feature_type==0') or as a 6d vector
#@cli : (if 'feature_type!=0') containing the feature coordinates.
#@cli : Default values: 'X=Y=Z=(undefined)', 'exit_on_anykey=0' and 'is_deep_selection=0'.

#@cli serialize : _datatype,_is_compressed={ 0 | 1 },_store_names={ 0 | 1 } : (+)
#@cli : Serialize selected list of images into a single image, optionnally in a compressed form.
#@cli : 'datatype' can be { auto | uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.
#@cli : Specify 'datatype' if all selected images have a range of values constrained to a particular datatype, in order to minimize the memory footprint.
#@cli : The resulting image has only integers values in [0,255] and can then be saved as a raw image of
#@cli : unsigned chars (doing so will output a valid .cimg[z] or .gmz file).
#@cli : If 'store_names' is set to '1', serialization uses the .gmz format to store data in memory (otherwise the .cimg[z] format).
#@cli : Default values: 'datatype=auto', 'is_compressed=1' and 'store_names=1'.
#@cli : $ image.jpg +serialize uchar +unserialize[-1]

#@cli shape_circle : _size>=0
#@cli : Input a 2D circle binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_circle ,
shape_circle : check "${1=512}>=0"
  e[^-1] "Input a $1x$1 circle binary shape."
  v -
  ir={round($1)}
  if {!$ir} 0
  elif {$ir<2} $ir,$ir,1,1,1
  else
    {int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} =. 1,100%,100%
    distance. 1 <=. {(i+0.4)/sqrt(2)}
    +mirror. x
    if {$ir>1&&($ir%2)} r. {w-1},100%,1,1,0,0,1 fi
    a[-2,-1] x +mirror. y
    if {$ir>1&&($ir%2)} r. 100%,{h-1},1,1,0,0,0,1 fi
    a[-2,-1] y
  fi
  nm. "[2D circle shape]"
  v +

#@cli shape_cupid : _size>=0
#@cli : Input a 2D cupid binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_cupid ,
shape_cupid : check "${1=512}>=0"
  e[^-1] "Input a $1x$1 cupid binary shape." v -
  ir={round($1)}
  if {!$ir} 0
  else
    base642img "MiBzaG9ydCBsaXR0bGVfZW5kaWFuCjEgMjMwMSAxIDEgIzI2NDQKeJx1mOl3lEUWxm+n6aS7IUSQRQQEFA37FtkFVFAEBxHZEoKACwRQEUHU0fGM58yZxa9z5i9AFBAhAZKwg8qACMM6CDgZIIQ9Kx0CmAHqzq/u2yR80A91nue5daveWm5tb2moNBSSkAiptCoq9RqToa6p3NVmMtyli2pzecp1IHWUke6R30wjyB9hfh0o97AMIw11D8kQ0mDXRga6VpLlWsoA10L6uQzpQ909XVy6u6hkulTp6lJkyamw1GhTGc33b2iGHHYR+RT8RVvIUReThKbI3+H/0wflGD512kT+oa3EaRt0M7mlEanFZ4X2QqdTLiLX8flK+5i+rWn36eb0MYqOyErT7eBp8rX2gz8Ej9H3iGww3Y5vZRg/QztvaqMuox13tAvpAdMX3JO0J+CX3AuGl904wytuvOFV9yLYF5wgG8Fy9xK6j1S4iWBvcBL23lLpXkH3kio3Bd1Tqt10sIdcczOkULtLws0Eu4GzwEypdbPJfxx8S3aC190i2aWPge+iu0idW4ruJDfcMvARuek+Ajsa7tT24O9lB33zuE3b4rdY1mtrw3zGPFtTZbm+K9/Qv+mM1Re6iPFKl2mM1Qp9R1Yxd1NJX8FXYptCDK2Ef0m5yfitgtcy7qsNMyi7iLY9IGsMW1Cvx5aylm94XGfYSgp0seF6w9aMyWLKt6HP76HbShFYCxaDCXCTYTvZqksYq4fp01KwA31dKjXE6ff6PthZ9uoyxrSL7AOr3KNyQD9gzB+Tg2CFe1yOGHaTf4Plrrv8BNYRq7eZi1OUqSN+7zJPJfCDGpJu6tdNXzmDPqRh6aHPShn8MDHXQ5+Ti8bD0l3HyiXa4u3ddZxcpT2ed9PxUtHAX5RKfA4Z/51UJXkmvJp+HYQ/Aa+BH2J8M3WCXKPfB+GPUzbgacYTxmNWNsGYHqSdmWb3vBn1jIcvop4IcZzKfKbKSdp1Td+2b9ajsyl/ClsC22H8/NrKoewp+pLQt8x2kzSDeT6lz1N2ofWjDlsue8hJ+p/QBeZXR30ziaEy2ndXx7BmA3st9le1JWPzstmOoBPYX2WNXzHbfPOrwT6LuKzQSazT+dbGauqaTcxW6SvUH/hVYZtDPNckbUewVZjtYeoNbEepqxzba8R/gvoCW4Q5iWLrQP3etoAYiMhlK8v60Yn2XW+7ZGUfZe+ZSPvyiJGIXKDOOdqVcXuJdr0hJ7CVYZvNGr3DHFToa4xRRErN70O+P0d+hp81/QHfno2OEEdpDboE/V+rY5lpz0tMv8/YzEJHrIzXl3Wm6VM2TkvJD/RJ00tMn0afsDFbgn8uuokct/F/j/wZfDsVnYZenNQROYYtlzi5ojmWf9Ri4B3ak2Nt9/P1BvFdT4xc1Wwr42NzHrFzhxgpT/p5W55+zDjk2Bj8i7RAPyHefX6EdRjoqqT/ftJC/QPzOMP8f2zQgf8+2vkW+lpS7yXf60SyfKA/RU+3Nv2zIT+Vto4z2+5knSU60vq2O9mGEh1h+rsGPczG8lvrwyeM21Cbi2+tn38iHoaY3kWb5uqf6fNg0ztIb+pf6GOjfl3/RhsCvd3m/nNibbDVv83m5nPiKsj3eib+9ejT6C2kHP0r6yf4ntfT9VvL22zzcMD4JvvuAfPZRB3zdCfnZ5rpYjAPfRheZHyH7QGFxrfbPN3j3mej8W3GN1hdW22drbe+brH59/xN3ZTkUfpY1GCfpRtsvRVYXwosnvLh2bqWtRTwV3QVa8jzKGdJAeOdZvbp1FkKrjP/rbae1uGTQ9sumD3K3rPL1uhaUo5+RwymwqP4f0+sRThfPP/B5t3bp+t+1nLApzJGt5I+U+D1ST4Jfsd4TCbC1fxj8rz+aPgcuA4co/usnjGmozIazDfcT39jhuvBZ8ENGpdnwI3oUfgVgk9RvhgcqLuZv7hk0eYt6CzdQ2x4/IEz2tv3c341Bc/JfwyvyDn24QFazvmSDlYRcxnST6tZHy05XyroV2swHuqhTUMlrPOpmh46Q53Z2jp0mTpytHPoOnt0rj4Rus39aoYOD03WJqGb+gTndkqoWjszJimh89QzWUOhMvZjj+eo/2VV5iVDxuovrLV0xuMW6yVOf2/anvU02IbUWuukhV6TGO2N6iVJ1YvSRM9LmBTSUql3P8stt4+7Uzr3j48Z8xhzlsk5wz3PfWjzcZF23EDXOn9OtSD2s8kPs889wNqPc89qTmxPw5ZCrMe5fzWFT6P/IcY2Lhe5a966Tx/nPnXP99e4n4+fXHbSPyYnuHcFPjE56XIb/Eu4f93zP+3mWJu8zxn3GmUD/7PudePe55x7Ax74lLk3OTe9PSrn3dwkj9HWeQ38ksuDh83H8xtJ+xU3v4FfdQuMF+FT7hbCw2avuI9Xci+sS/r/Fq9yb8ODtnl+Pdn+Knxqf4VX41OL/+Yk93f0+/kWxqcGfs14jLhPI969DnM/8+unOfW8TaymmB5LTG1J6m2UHUfMbeXsqMbfr4Px+hD2Rj2BM3o7ugr/Hfjncj9u1DH2md7gQvbdMOsnxnnWp0Hvwn8W97VGHUP3x28BayiFPT3OHjwgqcOcAT7f6/nsLWHWoc/PQuex76SgfX6j3m35T1JvHudCmHPH5z9JvXnEclj2WHsGYl8g5/G/p/fR/zL0Xmv/IM7DRaZ/QOey3x/izC2l/I/W3zGss0Wm96NzuHuVcmafxX+/rfEXqHsxazKFemKs/Qj311Gc4Uuwhbn/xeUFzrxK7g1eH0I/j67mnnGaMofRY/BPcE/xdRxBP82ZeF0/Mv9j6BE6nJj5mG+G2cfjMpgz6iZno/c/jh5An3/hbPX+J9D90PWcx2dt7TaVPujb+kfrw8/oXui7+pn1we9xPbTYfE+zz3WDe78zdm8tMn4Wn65w7+/3wke10Ph59pLOcO9zEXtH3Wj8Mrw93Ptcxacd55Ln5fC2ut54JbwV3PvXEKMtOYu8PQHP0Hzj19n30nWd8Trs8SS/RdlUzjTP6+Fh/cbafwcuugb+oDj3NdhCbrvVYHP2vlVgnHfLV2CU9fOl3V0qDbmPui/AJuxxcxmrIcYv2v4yyOo+z9vvBrHj+Tn2plp4Kd8/w15Ww3hudZPpU5Zs5s15mRgu5k16gVjf4J6hTD/Jd8MY676y1vVlzvvIN64r8dhb1vCe2swbdDXvsULePavYYwvAlbx91rLWVrgmvON6yATXm/MsLMvdAOI5zf4jrOQtvIc+3WF+VruBxHMz+5+wxg0iljvyrcGG+W4IeR2lwA1Fd6JNw5I4FHsnKXTDkziM+h4x3I1/Efj9fVgMfsd+UES5Xdzni8Gd3PWLqH8774BivreV/aOI72/WNobFnGVFtG0j+04h7d0AFoEFnCke19HeIpfFG7UZ5bN4z0bx6897N9X0cuZhEzgN36mkALNkiqX+Msn1I/WViYzPBNdTXuQdOc5lyljel8/x1hzN+/MZ0tOuk4wijWzA4J9K8D+lvf1PCf6ltLU0iPdvkO7Xngf/XIbw/r2H98r4fzD9eWf3Zu5GVv4foPOEnDEgMjAgMSAxICMzOQp4nHNn8GWIYmBgSGfIZchkSGaIZzCAQj0gLxMoms5QBZQHAHyqBfY="
    decompress_rle. r. $ir,$ir,1,1,5 if {$ir>480} b. 0.2% fi >=. 40%
  fi
  nm "[2D cupid shape]" v +

#@cli shape_diamond : _size>=0
#@cli : Input a 2D diamond binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_diamond ,
shape_diamond : check "${1=512}>=0"
  e[^-1] "Input a $1x$1 diamond binary shape."
  v -
  ir={round($1)}
  if {!$ir} 0
  elif {$ir<2} $ir,$ir,1,1,1
  else
    {int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} =. 1,100%,100%
    distance. 1,1 <=. {i/2}
    +mirror. x
    if {$ir>1&&($ir%2)} r. {w-1},100%,1,1,0,0,1 fi
    a[-2,-1] x +mirror. y
    if {$ir>1&&($ir%2)} r. 100%,{h-1},1,1,0,0,0,1 fi
    a[-2,-1] y
  fi
  nm. "[2D diamond shape]"
  v +

#@cli shape_fern : _size>=0,_density[%]>=0,_angle,0<=_opacity<=1,_type={ 0=Asplenium adiantum-nigrum | 1=Thelypteridaceae }
#@cli : Input a 2D Barnsley fern with specified size.
#@cli : Default value: 'size=512', 'density=50%', 'angle=30', 'opacity=0.3' and 'type=0'.
#@cli : $ shape_fern ,
shape_fern : check "${1=512}>=0 && ${2=50%}>=0 && isval(${3=30}) && ${4=0.3}>=0 && $4<=1 && isval(${5=0})"
  e[^-1] "Input a $1x$1 Barnsley fern, with density $2, angle $3 and opacity $4."
  v -
  ir={round($1)}
  if {!$ir} 0
  else l[]
    N={${"is_percent $2"}?$ir^2*$2:$2}
    $N,1,1,2
    eval "
     if ($5==0,
       # Type 0: Asplenium adiantum-nigrum.
       f1 = [ 0,0,0,0.16 ];           g1 = [ 0,0 ];
       f2 = [ 0.2,-0.26,0.23,0.22 ];  g2 = [ 0,1.6 ];
       f3 = [ -0.15,0.28,0.26,0.24 ]; g3 = [ 0,0.44 ];
       f4 = [ 0.85,0.04,-0.04,0.85 ]; g4 = [ 0,1.6 ],

       # Type 1: Thelypteridaceae.
       f1 = [ 0,0,0,0.25 ];             g1 = [ 0,-0.4 ];
       f2 = [ 0.035,-0.2,0.16,0.04 ];   g2 = [ -0.09,0.02 ];
       f3 = [ -0.04,0.2,0.16,0.04 ];    g3 = [ 0.12,0.07 ];
       f4 = [ 0.95,0.005,-0.005,0.93 ]; g4 = [ -0.002,0.5 ];
     );
     xy = [ 0,0 ];
     for (n = 0, n<"$N", ++n,
       r = u(100);
       xy = r<=1?((f1*xy)+=g1):
            r<=8?((f2*xy)+=g2):
            r<=15?((f3*xy)+=g3):((f4*xy)+=g4);
       I[n] = xy
    )"
    permute xczy
    i.. 2,2,1,1,{"R=rot(-$3); R[2] = -R[2]; R[3] = -R[3]; R"} m*
    repeat 2 sh. $>,$>,0,0 -. {im} rm. done n 0,{$ir-1}
    pointcloud -$4 r $ir,$ir,1,1,0,0,0.5,0.5
  endl fi
  nm "[2D Barnsley fern]"
  v +

#@cli shape_gear : _size>=0,_nb_teeth>0,0<=_height_teeth<=100,0<=_offset_teeth<=100,0<=_inner_radius<=100
#@cli : Input a 2D gear binary shape with specified size.
#@cli : Default value: 'size=512', 'nb_teeth=12', 'height_teeth=20', 'offset_teeth=0' and 'inner_radius=40'.
#@cli : $ shape_gear ,
shape_gear : check "${1=512}>=0 && isint(${2=12}) && $2>0 && ${3=20}>=0 && $3<=100 && ${4=0}>=0 && $4<=100 && ${5=40}>=0 && $5<=100"
  e[^-1] "Input a $1x$1 gear binary shape with $2 teeth, teeth height $3, teeth offset $4 and inner radius $5."
  v -
  ir={round($1)}
  if {!$ir} 0
  else l[]
    $ir,$ir
    polygon {"
      const nb_teeth = $2;
      const height_teeth = $3%;
      const offset_teeth = 2*$4%;
      pts = vector2048();
      for (i = 0, i<size(pts),
        a = i*2*pi/size(pts);
        r =  1 - height_teeth + height_teeth*(int(a*nb_teeth/pi + 2*nb_teeth - offset_teeth)%2);
        pts[i++] = round(w/2*(1 + r*cos(a)));
        pts[i++] = round(h/2*(1 + r*sin(a)));
      );
      [size(pts)/2,pts];
    "},1,1
    if $5 circle. 50%,50%,{0.5*w*$5%},1,0 fi
  endl fi
  nm "[2D gear shape]"
  v +

#@cli shape_heart : _size>=0
#@cli : Input a 2D heart binary shape with specified size.
#@cli : Default value: 'size=512'.
#@cli : $ shape_heart ,
shape_heart : check "${1=512}>=0"
  e[^-1] "Input a $1x$1 heart binary shape."
  v -
  ir={round($1)}
  if {!$ir} 0
  else l[]
      2048,1,1,1,"t = x*2*pi/w; 16*sin(t)^3"
      2048,1,1,1,"t = x*2*pi/w; 13*cos(t) - 5*cos(2*t) - 2*cos(3*t) - cos(4*t)"
      a c display_parametric $ir,$ir,1,0,0,0
      flood 50%,50%,0,0,0,1,0 ==. 0
    endl
  fi
  nm "[2D heart shape]"
  v +

#@cli shape_polygon : _size>=0,_nb_vertices>=3,_angle
#@cli : Input a 2D polygonal binary shape with specified geometry.
#@cli : Default value: 'size=512', 'nb_vertices=5' and 'angle=0'.
#@cli : $ repeat 6 shape_polygon 256,{3+$>} done
shape_polygon : check "${1=512}>=0 && isint(${2=5}) && $2>=3" skip ${3=0}
  e[^-1] "Input a $1x$1 polygon binary shape, with $2 vertices and angle $3 deg."
  v -
  ir={round($1)}
  if {!$ir} 0
  else l[]
      (0;{2*pi}) + {($3-90)*pi/180} r. 1,{$2+1},1,1,3 rows. 0,{h-2}
      ir2={round($ir/2)}
      +sin. cos..
      a x n 0,{$ir-1} s x +.. {-2,0.5*($ir-im-iM)} +. {-1,0.5*($ir-im-iM)} a x
      $ir,$ir polygon. $2,{-2,^},1,1 rm..
    endl
  fi
  nm "[2D $2-polygon shape]"
  v +

#@cli shape_snowflake : size>=0,0<=_nb_recursions<=6
#@cli : Input a 2D snowflake binary shape with specified size.
#@cli : Default values: 'size=512' and 'nb_recursions=5'.
#@cli : $ repeat 6 shape_snowflake 256,$> done
shape_snowflake : check "${1=512}>=0 && isint(${2=5}) && $2>=0 && $2<=6"
  e[^-1] "Input a $1x$1 snowflake binary shape, with $2 recursions."
  v -
  ir={round($1)}
  if {!$ir} 0
  else l[]
    $ir,$ir (0;120;240) *. {pi/180} +sin. cos.. a[-2,-1] c
    repeat $2
      1,{4*h},1,2
      f.. "
        p0 = I;
        p1 = I[(y+1)%h];
        t = (p1 - p0)/3;
        pm = (p0 + p1)/2 - 0.866*[ -t[1], t[0] ];
        k = 4*y;
        I[#-1,k++] = p0;
        I[#-1,k++] = p0 + t;
        I[#-1,k++] = pm;
        I[#-1,k] = p1 - t;
      "
      rm..
    done
    *. {0.5*$1} +. {$1/2} permute. cyzx polygon.. {h},{^},1,1 rm.
  endl fi
  nm "[2D snowflake shape]"
  v +

#@cli shape_star : _size>=0,_nb_branches>0,0<=_thickness<=1
#@cli : Input a 2D star binary shape with specified size.
#@cli : Default values: 'size=512', 'nb_branches=5' and 'thickness=0.38'.
#@cli : $ repeat 9 shape_star 256,{$>+2} done
shape_star : check "${1=512}>=0 && ${2=5}>0 && ${3=0.5}>=0 && $3<=1"
  e[^-1] "Input a $1x$1 star binary shape, with $2 branches and thickness $3."
  v -
  ir={round($1)}
  if {!$ir} 0
  else l[]
      star3d $2,$3 col3d 1 c3d n3d *3d $1,$1
      $1,$1 j3d. ..,50%,50%,0,1,2 rm..
    endl
  fi
  nm "[2D star shape]"
  v +

#@cli sh : eq. to 'shared'. : (+)

#@cli shared : x0[%],x1[%],y[%],z[%],v[%] : y0[%],y1[%],z[%],v[%] : z0[%],z1[%],v[%] : v0[%],v1[%] : v0[%] : (no arg) : (+)
#@cli : Insert shared buffers from (opt. points/rows/planes/channels of) selected images.
#@cli : Shared buffers cannot be returned by a command, nor a local environment.
#@cli : (eq. to 'sh').
#@cli : $ image.jpg shared 1 blur[-1] 3 remove[-1]
#@cli : $ image.jpg repeat {s} shared 25%,75%,0,$> mirror[-1] x remove[-1] done
#@cli : $$

#@cli sp : eq. to 'sample'.
sp : skip "${1=?}",${2=0}
  v - _sample[] "$1",${2--1}
  if {!${}} noarg fi v +

#@cli sample : _name1={ ? | apples | barbara | boats | bottles | butterfly | cameraman | car | cat | cliff | colorful | david | dog | duck | eagle | elephant | earth | flower | fruits | gmicky | gmicky_mahvin | gmicky_wilber | greece | gummy | house | inside | landscape | leaf | lena | leno | lion | mandrill | monalisa | monkey | parrots | pencils | peppers | roddy | rooster | rose | square | teddy | tiger | tulips | wall | waterfall | zelda },_name2,...,_nameN,_width={ >=0 | 0 (auto) },_height = { >=0 | 0 (auto) } : (no arg)
#@cli : Input a new sample RGB image (opt. with specified size).
#@cli : (eq. to 'sp').\n
#@cli : Argument 'name' can be replaced by an integer which serves as a sample index.
#@cli : $ repeat 6 sample done
sample : skip "${1=?}",${2=0}
  v - _sample[] "$1",${2--1}
  if {!${}} noarg fi v +

__sample :
  u apples,barbara,boats,bottles,butterfly,cameraman,car,cat,cliff,colorful,\
    david,dog,duck,eagle,elephant,earth,flower,fruits,gmicky,gmicky_mahvin,gmicky_wilber,greece,gummy,house,\
    inside,landscape,leaf,lena,leno,lion,mandrill,monalisa,monkey,parrots,\
    pencils,peppers,roddy,rooster,rose,square,teddy,tiger,tulips,wall,waterfall,zelda

_sample :
  if {"$#>=3 && isval($-2) && isint($-2) && $-2>=0 && isval($-1) && isint($-1) && $-1>=0"} # W and H specified.
    N={$#-2} W=$-2 H=$-1
  elif {"$#>=2 && isval($-1) && isint($-1) && $-1>=0"} # Only W specified.
    N={$#-1} W=$-1 H=0
  else # No dimensions specified
    N={$#} W=0 H=0
  fi

  # Check validity of given arguments.
  $=arg
  samples=${-__sample}
  M=${"arg2var _sp_name",$samples}
  is_arg=1
  repeat $N
    arg=${arg{1+$>}} is_rand{1+$>}=0
    if {['$arg']=='?'} arg={round(u(1,$M))} is_rand{1+$>}=1
    elif {!isval($arg)" || "!isint($arg)} repeat $M name=${_sp_name{1+$>}} if {'$name'!=0" && "'$name'==['$arg']} arg={1+$>} break fi done
    else arg={($arg%$M)+1} fi
    if {!isval($arg)" || "!isint($arg)} is_arg=0 break fi
    arg{1+$>}=$arg
  done
  if {!$is_arg} N=1 W=0 H=0 arg1={round(u(1,$M))} fi

  # Input sample images.
  repeat $N
    name=${_sp_name${arg{1+$>}}}

    # Retrieve image data.
    filename=${_path_rc}sample_$name.png
    url=https://gmic.eu/img/sample_$name.png
    if $filename $filename
    else
      if ${is_rand{1+$>}} l[] $url o. $filename onfail testimage2d {m=max($W,$H);m>0?m:400} endl
      else $url o. $filename
      fi
    fi

    # Resize to desired dimensions.
    if {$W>0" && "$H==0} r2dx. $W round.
    elif {$W==0" && "$H>0} r2dy. $H round.
    elif {$W>0" && "$H>0}
      if {w/$W>h/$H} r2dy. $H else r2dx. $W fi
      r. $W,$H,1,100%,0,0,0.5,0.5 round.
    fi
    nm. $name
    v + e[0--4] "Input sample image '"{n}"' (1 image "{w}x{h}x{d}x{s}")." v -
  done
  +. 0 u $is_arg

#@cli srand : value : (no arg) : (+)
#@cli : Set random generator seed.
#@cli : If no argument is specified, a random value is used as the random generator seed.

#@cli string : "string"
#@cli : Insert new image containing the ascii codes of specified string.
#@cli : $ string "foo bar"
string :
  e[^-1] "Input new image from string '$1'."
  v - ({'"$1"'}) nm. "$1" v +

#@cli testimage2d : _width>0,_height>0,_spectrum>0
#@cli : Input a 2D synthetic image.
#@cli : Default values: 'width=512', 'height=width' and 'spectrum=3'.
#@cli : $ testimage2d 512
testimage2d : check "${1=512}>0 && ${2=$1}>0 && ${3=3}>0"
  e[^-1] "Input 2D synthetic image of size $1x$2x$3."
  v -
  Dmax2={0.15*min($1,$2)^2}
  $1,$2,1,$3,'X=x-w/2;Y=y-h/2;a=atan2(Y,X);if(X^2+Y^2<=$Dmax2,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))'
  polygon. 4,20%,20%,60%,20%,70%,70%,35%,45%,0.9,0,255,0
  torus3d {$1/7},{$1/20} r3d. 0,1,1,-80 col3d. 128,200,255
  j3d.. .,30%,70%,0,1,5,0,0 rm. round. 1
  nm. "[2D test image]"
  v +

#@cli uncommand : command_name[,_command_name2,...] : * : (+)
#@cli : Discard definition of specified custom commands.
#@cli : Set argument to '*' for discarding all existing custom commands.

#@cli uniform_distribution : nb_levels>=1,spectrum>=1
#@cli : Input set of uniformly distributed spectrum-d points in [0,1]^spectrum.
#@cli : $ uniform_distribution 64,3 * 255 +distribution3d circles3d[-1] 10
uniform_distribution : check "isint($1) && $1>0 && isint($2) && $2>0"
  e[^1] "Input set of $1 uniformly distributed $2-d points in [0,1]^$2."
  v - n={round($1^(1/$2),1,1)}
  (0,1) r. $n,1,1,1,3
  repeat {$2-1} +channels. 100% r. {$n*w},1,1,1,1 r.. .,1,1,100%,0,2 a[-2,-1] c done
  r. $1,1,1,$2,1 nm. "[uniform $2D distribution]" v +

#@cli unserialize : : (+)
#@cli : Recreate lists of images from serialized image buffers, obtained with command 'serialize'.

#@cli up : eq. to 'update'.
up :
  _update

#@cli update
#@cli : Update commands from the latest definition file on the G'MIC server.
#@cli : (eq. to 'up').
update :
  _$0

_update :
  e[0--3] "Update commands from the latest definition file on the G\47MIC server."
  v -
  out=${_path_rc}update$_version.gmic
  l[] cimgz:https://gmic.eu/update$_version.gmic
    if {h>7" && "same([{^}],'#@gmic',6)} o raw:$out,char fi
    rm
  onfail v + error[0--3] "Command 'update' : Unreachable update file."
  endl
  m $out
  v +

# Generate images used in the G'MIC installer for Windows (InnoSetup).
update_instimg :
  sp gmicky,600

  # Large image.
  +l
    r2dx 164
    0 t. "G'MIC-Qt for GIMP",0,0,96,1,1
    0 t. "(version "${-strver}")",0,0,64,1,1
    a[-2,-1] y,0.5 rows. -5,100%
    *. -1 n. 0,255 to_rgb. r2dx. {0,0.95*w}
    - 255 a y,0.5 + 255
    - 255 r 164,314,1,3,0,0,0.5,0.25 + 255
    o $HOME/work/src/gmic/resources/gmic_instimg.bmp
    rm
  endl

  # Small image.
  r2dx 55 - 255 r 55,55,1,3,0,0,0.5,0.5 + 255
  o $HOME/work/src/gmic/resources/gmic_instimg_small.bmp
  rm

# Generate Color Presets page for the G'MIC website.
# Input images : samples you want to generate
# $1 = upload to G'MIC server, can be { 0 | 1 }.
update_color_presets_html : check "isbool(${1=0})"
  if {!$!} error[^-1] "Command '$0': Missing input images !" fi
  v -

  # Init variables.
  jpeg_quality=70   # Set JPEG quality of output images.
  thumb_width=180   # Set thumbnail width.
  thumb_height=90   # Set mini thumbnail height.
  categories=creative,lutifyme,picturefx,others,\
             bw,instant_consumer,instant_pro,fujixtransiii,negative_color,negative_new,negative_old,print,colorslide
  category_names="Creative: Creative Pack",\
                 "Creative: Lutify.Me",\
                 "Creative: PictureFX",\
                 "Creative: Others",\
                 "Films: Black and White",\
                 "Films: Instant [Consumer]",\
                 "Films: Instant [Pro]",\
                 "Films: Fuji XTrans III",\
                 "Films: Negative [Color]",\
                 "Films: Negative [New]",\
                 "Films: Negative [Old]",\
                 "Films: Print Films",\
                 "Films: Slide [Color]"
  category_authors="RawTherapee",\
                   "Lutify.Me",\
                   "Marc Roovers",\
                   0,\
                   "Pat David",\
                   "Pat David",\
                   "Pat David",\
                   "Stuart Sowerby",\
                   "Pat David",\
                   "Pat David",\
                   "Pat David",\
                   "Juan Melara",\
                   "Pat David"
  category_authors_url="https://rawpedia.rawtherapee.com/Film_Simulation",\
                       "https://lutify.me/free-luts/",\
                       "http://www.digicrea.be/haldclut-set-style-a-la-nik-software",\
                       0,\
                       "http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
                       "http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
                       "http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
                       "http://blog.sowerby.me/fuji-film-simulation-profiles",\
                       "http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
                       "http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
                       "http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html",\
                       "http://juanmelara.com.au/print-film-emulation-luts-for-download",\
                       "http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html"

  m "_thumb : frame 3%,3%,255 to_rgba drop_shadow 2,2,3 repeat $! l[$>] i[0] 100%,100%,1,3,245 blend alpha endl done"
  m "_title : ({'\"$""*\"'}) replace_str. \"_\",\" \" replace_str. \"iii\",\"III\" f. \"(!y || j(0,-1)==32) && i>=_'a' && i<=_'z'?uppercase(i):i\" u {t} rm."

  nb_presets=0
  repeat {narg($categories)}
    category=${arg\ {1+$>},$categories}
    presets=${-_fx_cluts_$category}
    nb_presets+={narg({/$presets})}
  done

  v + e[] "\n > Update 'Color Presets' pages, for "$!" image samples and "$nb_presets" presets." v -

  # Prepare folder structure.
  v + e[] "\n  * Prepare folder structure." v -
  x "ln -fs ../copyright.html ."
  x "ln -fs ../favicon.ico ."
  x "ln -fs ../favicon.png ."
  x "ln -fs ../footer.html ."
  x "ln -fs ../header.html ."
  x "ln -fs ../gmicmenu ."
  x "ln -fs ../jquery-1.11.0.min.js ."
  x "ln -fs ../style.css ."
  x "ln -fs ../images ."
  x "mkdir -p img"
  x "cd img && ln -fs ../../img/logo4.jpg ."
  x "cd img && ln -fs ../../img/logos.jpg ."
  x "cd img && ln -fs ../../img/rss.png ."
  x "ln -fs ../highslide ."

  # Generate thumbnails.
  v + e[] "\n  * Generate thumbnails from samples." v -
  if original else x "mkdir original" fi
  nb_samples=$!
  to_rgb repeat $nb_samples l[$<]
    nm[0] sample_{1+$<}
    basename={0,b} basename$<=$basename
    v + e[] "    - "$basename v -
    +r2dx $thumb_width
    +to[0] "Reference",4,{0,h-28},20,2 frame. 1,1,0
    o. original/$basename.jpg,$jpeg_quality rm.
    +_thumb[1] o. original/thumb_$basename.jpg,$jpeg_quality rm.
    +r2dy[0] $thumb_height r. {h},{h},1,100%,0,0,0.5,0.5 _thumb.
    o. original/minithumb_$basename.jpg,$jpeg_quality rm.
  endl done

  # Generate color grading data and rendering on each input sample.
  ind_preset=0
  repeat {narg($categories)}
    category=${arg\ {1+$>},$categories}
    presets=${-_fx_cluts_$category}

    v + e[] "\n  * Category ""#"{1+$>}": "$category"\n" v -
    if $category else x "mkdir "$category fi
    if $category/clut else x "mkdir "$category/clut fi

    repeat {narg({/$presets})}
      preset=${arg\ {1+$>},$presets}
      v + e[] "    - "$preset v -
      clut $preset,64 to_rgb.
      s={sqrt(w*h*d)} +r. $s,$s,1,3,-1
      if {iM<=255} *. 257 fi  # Force PNG to be saved in 16bits.
      o. $category/clut/$preset.png
      rm.

      repeat $nb_samples l[{2*$>},{2*$>+1},-1]
        basename={0,b}
        if $category/$basename/$preset.jpg else
          if $category/$basename else x "mkdir \""$category/$basename"\"" fi
          +map_clut[^-1] .
          _title $preset
          to.. ${},4,{-2,h-28},20,2 frame.. 1,1,0
          o.. $category/$basename/$preset.jpg,$jpeg_quality
          _thumb. o. $category/$basename/thumb_$preset.jpg,$jpeg_quality
          rm[-2,-1]
        fi
      endl done

      rm.

      ind_preset+=1
    done

  done

  rm[1--1:2]  # Remove thumbnails.

  # Generate HTML gallery code.
  v + e[] "\n  * Generate html code.\n" v -

  repeat {narg($categories)}
    category=${arg\ {1+$>},$categories}
    arg {1+$>},$category_names
    category_name=${}
    presets=${-_fx_cluts_$category}

    repeat $nb_samples
      width={$>,64+w} height={$>,64+h}
      basename={$>,b}
      v + e[] "    - "$category_name" / "$basename v -

      string "
<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n
                      \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n
<!--#include file=\"header.html\" -->\n
<script type=\"text/javascript\">\n
  hs.align = 'center';\n
</script>\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Color Presets</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<p>Among all features available in <b><font color=\"#000066\">G\47MIC</font></b>, our <b>Color Presets</b> and <b>Simulate Film</b> filters are able to apply
various pre-defined <b>color CLUTs</b> on your images
(<b>550+</b> color CLUTs available).</p>\n\n
<p>Below, you can navigate through the different proposed presets and see how they modify the colors of some sample images.\n
You can also download each color preset separately as its corresponding <a href=\"http://www.quelsolaar.com/technology/clut.html\">HaldCLUT</a> file (in <b>.png</b> format), to use it in\n
other software that support this feature.</p>\n\n
<p><b>Image credits:</b> Sample images below have been borrowed from <a href=\"https://www.flickr.com/photos/patdavid/\">Patrick David</a>,\n
<a href=\"https://www.flickr.com/photos/davelau/\">Chi King</a>,
<a href=\"https://pixabay.com/en/tulips-tulip-field-tulpenbluete-3359902/\">Capri23auto</a>
and
<a href=\"https://pixabay.com/en/girl-face-colorful-colors-artistic-2696947/\">ivanovgood</a>,
distributed a minima under\n
<a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-by-SA 2.0</a>.</p>\n\n
<p><font size=\"-1\"><b>Disclaimer:</b><br/>\n
<i>The trademarked names which may appear in the filenames of the HaldCLUT images are there for informational purposes only. They serve only to inform the user which film stock the given HaldCLUT image\n
is designed to approximate. As there is no way to convey this information other than by using the trademarked name, we believe this constitutes fair use. Neither the publisher nor the authors are affiliated\n
with or endorsed by the companies that own the trademarks.</i></font></p>\n\n
</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\"><a id=\"browse\">Browse</a></div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<table><tr>\n
<td valign=\"top\" width=\"400\">Select category:\n
<ul>\n"
      repeat {narg($categories)}
        _category=${arg\ {1+$>},$categories}
        arg {1+$>},$category_names
        _category_name=${}

        arg {1+$>},$category_authors_url
        if {isval(${})} _category_author_url_start= _category_author_url_end=
        else _category_author_url_start="<a href=\""${}"\">" _category_author_url_end="</a>"
        fi

        arg {1+$>},$category_authors
        if {isval(${})} _category_author=""
        else _category_author=$_category_author_url_start${}$_category_author_url_end
        fi

        if {narg($_category_author)}
          _category_author="<font size=\"1\">(by "$_category_author")</font>"
        fi

        if {['$_category']==['$category']}
          string "<li><font color=\"#CC7700\"><b>"$_category_name"</b> "$_category_author"</font></li>\n"
        else
          string "<li><a href=\""${_category}_$basename.shtml"#browse\">"$_category_name"</a> "$_category_author"</li>\n"
        fi
      done

      string "</ul>\n</td>\n<td align=\"left\" valign=\"top\">Select sample image:<br/><br/>\n"
      repeat {$nb_samples}
        _basename=${basename$>}
        if {['$_basename']==['$basename']}
          string "<a href=\""${category}_$_basename.shtml"#browse\"><img alt=\"\" style=\"border-color:#CC7700;\" border=\"3\" src=\""original/minithumb_$_basename.jpg"\"/></a>\n"
        else
          string "<a href=\""${category}_$_basename.shtml"#browse\"><img alt=\"\" border=\"0\" src=\""original/minithumb_$_basename.jpg"\"/></a>\n"
        fi
      done
      string "</td>\n</tr></table>\n</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n"
      string "\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Presets ("{narg({/$presets})}")</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<center><table>\n
<tr><td>\n
<div><a href=\"original/"$basename".jpg\" class=\"highslide\" onclick=\"return hs.expand(this)\"><img alt=\"\" border=\"0\" src=\"original/thumb_"$basename".jpg\" /></a>\n
<div class=\"highslide-caption\"><b>Reference Image</b></div></div>\n
</td></tr>\n
<tr><td align=\"center\"><b>Reference Image</b></td></tr>\n\n"
      repeat {narg({/$presets})}
        preset=${arg\ {1+$>},$presets}

        ({'$preset'}) replace_seq. 39,"92,92,39" preset_esc={t} rm.
        _title $preset title=${}
        if {$>%4==0} if $> string "</tr>\n" fi string "<tr>" fi

        string "
<td><table>\n
<tr><td>\n
<div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "$width", height: "$height" })\">\n
<img alt=\"\" border=\"0\" src=\""$category/$basename/thumb_$preset".jpg\" />\n
</a>\n
<div class=\"highslide-maincontent\"><center>\n
<img alt=\"\" border=\"0\" src=\""$category/$basename/$preset.jpg"\" onclick=\"hs.close()\" onmouseover=\"javascript:this.src='"$category/$basename/$preset_esc.jpg"';\" onmouseout=\"javascript:this.src='original/"$basename".jpg';\" />\n
</center></div>\n
<div class=\"highslide-caption\"><b>Preset:</b> <i>"$title"</i> [<a href=\""$category/clut/$preset.png"\">Download HaldCLUT</a>]</div></div>\n
</td></tr>\n
<tr><td align=\"center\"><font size=\"-1\">"$title"</font></td></tr>\n
</table></td>\n\n"
      done
      string "
</tr></table></center>\n
</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n"
      string "<!--#include file=\"copyright.html\" -->\n
<!--#include file=\"footer.html\" -->\n"
      a[$nb_samples--1] x o. raw:${category}_$basename.shtml,char rm.
    done
  done

  # All done, exiting.
  rm
  category=${arg\ 1,$categories}
  x "ln -fs "${category}_$basename0.shtml" index.shtml"
  if $1
    v + e[] "\n  * Transfer color presets on G'MIC server.\n" v -
    x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"mirror -eRL . /www/gmic/color_presets ; quit\""
  fi
  v + e[] "\n > All done, for "$nb_presets" presets.\n"

# Generate gallery page for the G'MIC website.
# $1 = upload to G'MIC server, can be { 0 | 1 }.
update_gallery_html : check "isbool(${1=0})"
  e[^-1] "Generate gallery pages for the G'MIC website."
  v -
  use_vt100

  # Check directory and clean in case of upload.
  if {narg(${"files *"})}
    if {narg(${"files *_full_*.jpg"})" && "\
        narg(${"files *_thumb_*.jpg"})" && "\
        narg(${"files *_original_*.jpg"})}
       if $1 x 0,"rm -f *" fi
    else v + error[0--4] "Current folder should be empty!"
    fi
  fi

  # Prepare folder structure.
  v + e[] "  * Prepare folder structure." v -
  x "ln -fs ../copyright.html ."
  x "ln -fs ../favicon.ico ."
  x "ln -fs ../favicon.png ."
  x "ln -fs ../footer.html ."
  x "ln -fs ../header.html ."
  x "ln -fs ../gmicmenu ."
  x "ln -fs ../jquery-1.11.0.min.js ."
  x "ln -fs ../style.css ."
  x "ln -fs ../images ."
  x "ln -fs ../highslide ."

  # Define categories and sample pictures.
  categories=arrays,artistic,blackandwhite,colors,deformations,filtering,patterns,3drendering,stylization,codesamples
  nb_categories={narg($categories)}
  commands_arrays=gallery_arrays,array,array_fade,array_mirror,frame_blur,frame_cube,frame_painting,img2ascii,imagegrid,rotate_tiles,vignette,tunnel
  commands_artistic=gallery_artistic,boxfitting,cartoon,cubism,draw_whirl,fractalize,halftone,sketchbw,light_relief,mosaic,linify,polaroid,polygonize,poster_hope,rodilius,stencil,stained_glass
  commands_blackandwhite=gallery_blackandwhite,pencilbw,old_photo,sepia
  commands_colors=gallery_colors,solarize,hsv2rgb,transfer_rgb
  commands_deformations=gallery_deformations,deform,map_sphere,seamcarve,spherize,twirl,warp_perspective,water,wave
  commands_filtering=gallery_filtering,blur_angular,blur_linear,blur_radial,glow,smooth,bilateral,dog,deriche,distance,gradient_norm,normalize_local,sharpen,solidify
  commands_patterns=gallery_patterns,tsp,chessboard,mandelbrot,maze_mask,plasma,shape_fern,shape_snowflake,sierpinski,syntexturize_matchpatch,truchet,turbulence,watermark_visible,weave
  commands_3drendering=gallery_3drendering,add3d,distribution3d,elevation3d,gmic3d,imageblocks3d,imagerubik3d,skeleton3d,spherical3d,tensors3d,text3d,torus3d,weird3d
  commands_stylization=gallery_stylization
  commands_codesamples=gallery_codesamples

  pics=apples,bottles,butterfly,car,cat,cliff,david,dog,duck,eagle,elephant,earth,flower,fruits,greece,gummy,inside,landscape,leaf,leno,lion,mandrill,monalisa,parrots,pencils,rooster,rose,square,teddy,tiger,wall,waterfall,zelda

  # Generate HTML pages.
  i raw:$HOME/work/src/gmic/src/gmic_stdlib.gmic,uchar
  nb_cols=3

  repeat $nb_categories,ncat
    category=${arg\ 1+$>,$categories}
    if {isfile('$category.shtml')} continue fi
    v + e[] "\n  * Process category '"$_gmic_b$category$_gmic_n"'." v -

    commands=${commands_$category}
    nb_commands={narg($commands)}
    col,nex=0

    repeat $nb_categories
      cat=${arg\ 1+$>,$categories}
      if {;'$cat'=='$category'} td_$cat="<td bgcolor=\"#DDDDDD\">"
      else td_$cat="<td>"
      fi
    done

    html="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"\
         "  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n"\
         "<!--#include file=\"header.html\" -->\n\n"\
         "<link rel=\"stylesheet\" href=\"//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css\">\n"\
         "<script src=\"https://code.jquery.com/jquery-1.12.4.js\"></script>\n"\
         "<script src=\"https://code.jquery.com/ui/1.12.1/jquery-ui.js\"></script>\n\n"\
         "<div id=\"bloc_option\"><div id=\"top_vert\"><div id=\"text_top\">Image gallery</div></div>\n"\
         "<div id=\"center\"><div id=\"text_centre_intro\">\n"\
         "This gallery gives a quick overview of the kind of features and generic filters available in the "\
         "<b><font color=\"#000066\">G\47MIC</font></b> open-source image processing framework.<br/>\n"\
         "All the images below have been processed by the CLI interface <tt><a href=\"documentation.shtml\">gmic</a></tt>\n"\
         "  of <b><font color=\"#000066\">G\47MIC</font></b>, from a set of initial 2D color images.\n"\
         "Click on an image to enlarge it and display the <b><font color=\"#000066\">G\47MIC</font></b> command-line "\
         "used for the processing (<i>note: to reproduce this, you may have to escape some characters, according to type of shell you use!</i>).<br/>\n"\
         "Remember, <b><font color=\"#000066\">G\47MIC</font></b> lets you define your own image pipelines through\n"\
         "custom <a href=\"https://gmic.eu/gmic_stdlib.gmic\">command files</a>.\n"\
         "Your custom filters can be easily added afterwards in the plug-in for <a href=\"http://www.gimp.org\">GIMP</a> or "\
         "<a href=\"http://www.krita.org\">Krita</a>.</br>\n\n"\
         "For more details, visit the <a href=\"https://gmic.eu/tutorial\">tutorial pages</a> as well as the "\
         "<a href=\"https://gmic.eu/reference.shtml\">technical reference</a> to get a full documentation on this software.\n"\
         "<br/><br/>\n<div id=\"menu\">\n"

    html_menu="<font size=\"-1\"><table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" align=\"center\"><tr>\n"\
         $td_arrays"<a href=\"arrays.shtml#menu\">Arrays &amp; Frames</a></td>"\
         $td_artistic"<a href=\"artistic.shtml#menu\">Artistic</a></td>"\
         $td_blackandwhite"<a href=\"blackandwhite.shtml#menu\">B&amp;W</a></td>"\
         $td_colors"<a href=\"colors.shtml#menu\">Colors</a></td>"\
         $td_deformations"<a href=\"deformations.shtml#menu\">Deformations</a></td>"\
         $td_filtering"<a href=\"filtering.shtml#menu\">Filtering</a></td>"\
         $td_patterns"<a href=\"patterns.shtml#menu\">Patterns</a></td>"\
         $td_3drendering"<a href=\"3drendering.shtml#menu\">3D Rendering</a></td>"\
         $td_stylization"<a href=\"stylization.shtml#menu\">Stylization</a></td>"\
         $td_codesamples"<a href=\"codesamples.shtml#menu\">Code samples</a></td>"\
         "</tr></table></font>\n"

    html=${html}${html_menu}\
         "</div><br/>\n"\
         "<table align=\"center\">\n"

    repeat $nb_commands
      command=${"arg "1+$>,$commands}
      is_stylization={;'$command'=='gallery_stylization'}

      v + e[] $_gmic_m"    - Command '"$_gmic_b$command$_gmic_n"' ["{1+$>}/$nb_commands"]."$_gmic_n v -
      +l # Parse command definition and examples
        s -,{'"#@cli "$command" :"'}
        if {$!<2} s -,{'"#@cli "$command"\n"'} i[1] ({'\n'}) a[-2,-1] y fi
        if {$!<2} v + warn[] "    ** Command '"$command"' not found! **" v -
        else
          k.
          eval "
            str = crop(#-1);
            ind = 0;
            while ((ind = find(str,'\n#@cli ',1,ind))>=0,
              ++ind;
              str[ind+6]!=_':' ? break() :
              str[ind+7]==_' ' && str[ind+8]==_'$' && str[ind+9]==_' '?(
                beg = ind + 10;
                end = find(str,_'\n',1,beg) - 1;
                com = vector1024(0);
                ext('+rows[0] ',beg,',',end);
              );
            );
          ";
          rm[0]

          nb_examples=$!
          repeat $nb_examples # For each example found
            example$nex={$>,t}

            v + e[] $_gmic_g"        $ "${example$nex}$_gmic_n v -
            sample=${"arg 1+"{($nex+8*$ncat)%narg($pics)},$pics}
            is_codesample=0

            l[] # Create a HTML representation of the command
              ({'${example$nex}'}) y
              is_input={find(#-1,'image.jpg')>=0}

              if {!$is_input" && "find(#-1,'"sample "')>=0}
                 s +,{'"sample "'}
                 if {0,crop()=='"sample "'" && "$!>1} l[1]
                   s +,{'" "'}
                   if {find(#0,_',')==-1} sample={0,t} is_input=1 fi
                   a y
                 endl fi
                 a y
              fi
              replace_str. "image.jpg","<a href=\"https://gmic.eu/img/sample_"$sample".png\" target=\"_blank\">"$sample".png</a>"
              replace_str. "_output_mode=1",""
              l. s +,{'" "'} repeat $! if {$<,crop(0,0,1,5)=='_fps='||crop(0,0,1,7)=='_label='} # Discard '_fps=?' and '_label=?'
                rm[$<]
              fi done a y endl
              l. s +,{'" "'} repeat $! if {$<,crop(0,0,1,8)=='https://'} l[$<] # Add hyperlink
                if {crop(0,0,1,24)=='https://gmic.eu/samples/'}
                  is_codesample=1
                  basename_codesample={`crop(0,24,1,h-24)`}
                  filename_codesample="../../resources/samples"/$basename_codesample
                  url_codesample="https://gmic.eu/samples/"$basename_codesample
                  if $1 x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"put -O /www/gmic/samples \\\""$filename_codesample"\\\"; quit\" >/dev/null" fi
                  i[0] ({'"<a onclick=\"javascript:$( '\#dialog"$nex"' ).dialog( 'open' );\" style=\"cursor: pointer;\">"'})
                else i[0] ({'"<a href=\""{$<,t}"\" target=\"_blank\">"'})
                fi
                ({'</a>'}) y a y
              endl fi done a y endl
              replaced_example$nex={t} rm
            endl
            ({'${example$nex}'}) replace_str. "https://gmic.eu/samples/","../../resources/samples/" example$nex={t} rm.
            m "_run : _preview_width,_preview_height=450,300 "${example$nex}

            if $is_input sample_=${sample}_ else sample_= fi
            filename_original=${category}_${sample_}original_$nex.jpg
            filename_thumb_original=${category}_${sample_}thumb_original_$nex.jpg
            if {"find(['"${example$nex}"'],' _fps=')>=0"}
              filename_full=${category}_${sample_}full_$nex.gif
              filename_thumb=${category}_${sample_}thumb_$nex.gif
              _is_animated=1
            else
              filename_full=${category}_${sample_}full_$nex.jpg
              filename_thumb=${category}_${sample_}thumb_$nex.jpg
              _is_animated=0
            fi

            etime=
            _label=
            if {!isfile('$filename_thumb')} l[]
              if $is_input sp $sample,600 o image.jpg rm fi

              db3d m3d md3d f3d l3d sl3d ss3d 0.8 srand 512
              etime=$| _run etime={_round($|-$etime,0.01)}

              if $is_stylization
                +l _gallery o $filename_full,70 rm endl k.
                _gallery
                width,height={[w,h]}
              else
                _gallery
                width,height={[w,h]}
                if $_is_animated o $filename_full,$_fps else o $filename_full,70 fi
              fi
              v + e[] "\r"$_gmic_g"        $ "${example$nex}" (done in "$_gmic_n${etime}"s"$_gmic_g")."$_gmic_n v -

              crop 5,5,{w-6},{h-6} # Remove frame added by '_gallery'
              frame 3%,3%,255 rr2d 440,440,0,3 drop_shadow 2,2,2
              if $_is_animated rr2d 230,230,0,3 else rr2d 300,300,0,3 fi
              100%,100%,1,3,245 blend[^-1] .,alpha,1,1 rm.
              if $_is_animated o $filename_thumb,$_fps else o $filename_thumb,60 fi
              rm

              if $is_input
                image.jpg _gallery
                rr2d $width,$height,0,5 c 0,255
                to "Input",2%,2%,6%
                - 255 r $width,$height,1,3,0,0,0.5,0.5 + 255
                o $filename_original,60

                crop 5,5,{w-6},{h-6} # Remove frame added by '_gallery'
                frame 3%,3%,255 rr2d 440,440,0,3 drop_shadow 2,2,2
                if $_is_animated rr2d 230,230,0,3 else rr2d 300,300,0,3 fi
                100%,100%,1,3,245 blend[^-1] .,alpha,1,1 rm.
                o $filename_thumb_original,60
                rm
              fi
            endl fi

            is_samesize=0
            l[]
              $filename_full
              width,height={round([w,h]*(max(w,h)<300?1.75:1))}
              if $filename_original $filename_original is_samesize={w==w#0" && "h==h#0} fi
              rm
            endl
            if {!$is_samesize} filename_original=$filename_full fi

            if {!($col%$nb_cols)} html=${html}"<tr>\n" fi
            if {$nb_examples==1} counter= else counter=" <font size=\"-2\"><i>"[{$>+1}/$nb_examples]"</i></font>" fi

            html_etime=
            if {narg($etime)} html_etime="<br/><font size=\"-2\"><i>(generated in "${etime}"s)</i></font>" fi

            html_codesample=
            if $is_codesample
               html_codesample="\n<div id=\"dialog"$nex"\" title=\""samples/$basename_codesample"\">\n<font size=\"-1\"><pre>\n"
               i raw:$url_codesample,uchar html_codesample=${html_codesample}{t} rm.
               html_codesample=${html_codesample}"\n</pre></font></div>\n"\
                              "<br/><script>$( function() { $( \"#dialog"$nex"\" ).dialog({ autoOpen: false, width:600 }); } );</script>\n"\
                              "<a onclick=\"javascript:$( '#dialog"$nex"' ).dialog( 'open' );\" style=\"cursor: pointer;\"><i><font size=\"-1\">[ Source code ]</font></i></a>\n"
            fi

            if {['$_label']==0} _label=$command$counter else ({'$_label'}) replace_str. "~"," " _label={t} rm. fi
            if $is_input
              html=${html}\
                  "  <td><center><div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "{$width+64}", height: "{$height+64}" })\">\n"\
                  "  <img alt=\""gallery_$command$nex"\" border=\"0\" src=\""$filename_thumb"\" "\
                  "onmouseover=\"javascript:this.src='"$filename_thumb_original"';\" onmouseout=\"javascript:this.src='"$filename_thumb"';\"/><br/><b>"${_label}${html_codesample}"</b></a>\n"\
                  "  <div class=\"highslide-maincontent\"><center>\n"\
                  "  <img alt=\""gallery_$command$nex"\" border=\"0\" width=\""$width"\" src=\""$filename_full"\" onclick=\"hs.close()\" onmouseover=\"javascript:this.src='"$filename_full"';\" onmouseout=\"javascript:this.src='"$filename_original"';\"/>\n"\
                  "</center></div>\n"\
                  "<div class=\"highslide-caption\">Command: <tt>$ gmic "${replaced_example$nex}"</tt>"${html_etime}"</div></div></center></td>\n"
            else
              html=${html}\
                  "  <td><center><div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "{$width+64}", height: "{$height+64}" })\">\n"\
                  "  <img alt=\""gallery_$command$nex"\" border=\"0\" src=\""$filename_thumb"\" /><br/><b>"${_label}${html_codesample}"</b></a>\n"\
                  "  <div class=\"highslide-maincontent\"><center>\n"\
                  "  <img alt=\""gallery_$command$nex"\" border=\"0\" width=\""$width"\" src=\""$filename_full"\" onclick=\"hs.close()\" />\n"\
                  "</center></div>\n"\
                  "<div class=\"highslide-caption\">Command: <tt>$ gmic "${replaced_example$nex}"</tt>"${html_etime}"</div></div></center></td>\n"
            fi
            nex+=1
            col={($col+1)%$nb_cols}
            if {!$col} html=${html}"</tr>\n" fi
          done
        fi
        rm
      endl
    done
    if $col html=${html}"</tr>\n" fi
    html=${html}"</table><br/>\n"\
         ${html_menu}\
         "</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n\n"\
         "<!--#include file=\"copyright.html\" -->\n"\
         "<!--#include file=\"footer.html\" -->\n"
    ({'$html'}) o. raw:$category.shtml,uchar rm.
  done
  rm

  # Transfer on G'MIC server
  x "ln -fs artistic.shtml index.shtml"
  if $1
    v + e[] "\n  * Transfer gallery on G'MIC server.\n" v -
    x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"mirror -eRL . /www/gmic/gallery ; quit\""
  fi
  v + e[] "  * All done!.\n"

# Generate a single image from a list of images, for the gallery.
_gallery :
  repeat $! l[$>] W$>={w} H$>={h} D$>={d} S$>={s} IS_3D$>=${-_is_3d} endl done
  repeat $! l[$>]
    if ${IS_3D$>} r3d 1,1,0,-80 r3d 0,1,0,80 snapshot3d 400
    else if {w>8192} z 0,8191 elif {h>8192} rows 0,8191 fi n 0,255
    fi
  endl done

  if {!$_is_animated}
    +__gallery
    if {w>1024} r={round(1024*100/w,0.1)} r[^-1] $r%,$r%,1,100%,2 fi rm.
  fi

  repeat $! l[$>]
    if {s==1} r {w},{h},1,3
    elif {s==4} drgba
    else r {w},{h},1,3,0 fi
    if {w<=h&&h<256} r2dy 256,2 elif {h<=w&&w<256} r2dx 256,2 fi
    if {w<=h&&h>620} r2dy 620,2 elif {h<=w&&w>620} r2dx 620,2 fi
    if {h<48} r 100%,48 fi
    if {w<48} r 48,100% fi
    if {$_is_animated" && "(w>480" || "h>480)} rr2d 480,480,0,2 fi
    frame 1,1,0 frame 4,4,255
  endl done

  if {$_is_animated}
    - 255 r ${-max_wh},1,3,0,0,0.5,0.5 + 255
  else
    - 255 __gallery + 255
    if {w<256} - 255 r 256,100%,1,100%,0,0,0.5,0.5 + 255 fi
    if {h<256} - 255 r 100%,256,1,100%,0,0,0.5,0.5 + 255 fi
  fi


__gallery :
  if {$!==2} if {w>h} a y else a x fi
  else montage A # append_tiles 2
  fi

# Function that inserts a new 'Update information' filter for a previous version number,
# passed as an argument.
update_deprecate : check "isint($1) && $1>0 && $1<999"
  e[^-1] "Deprecate filter updates for G'MIC version $1."
  v - l[]
  file=${_path_rc}update$1.gmic
  i cimgz:"https://gmic.eu/update$1.gmic",uchar
  +l. s +,{'"UPDATE"" INFORMATION"'} is_deprecated={$!>1} rm endl # Check if deprecation has not been already done.
  if $is_deprecated
    v + e[0--4] "  > Version $1 already deprecated -> Removing deprecation." v -
    off1={"data = crop(); find(data,'\n#@gui !<b><i>&gt;&gt; UPDATE"" INFORMATION</i></b>')"}
    if {$off1>0}
      +rows $off1,100% rows[0] 0,{$off1-1}
      off2={"data = crop(); find(data,'\n\n')"}
      if {$off2>0}
        rows. {$off2+2},100% a y
        o cimgz:$file,uchar
        _update_server_upload $file
        v + e[0--6] "  > Done! Version $1 is not deprecated anymore." v -
      fi
    fi
  else
    s +,{'"#@cli :: "'}
    i[1] ({'"\n\
            \#@gui !<b><i>&gt;&gt; UPDATE"" INFORMATION</i></b> : _none_, _none_\n\
            \#@gui : note = note{\"A <b>new version</b> of the <i>G\47MIC</i> plug-in is available!\\n\\n\n\
            \#@gui : You are strongly encouraged to upgrade your version, by visiting our <i>Download page</i> :\\n\\n\"}\n\
            \#@gui : url = link{\"Visit G\47MIC Download Page\",\"https://gmic.eu/download.shtml\"}\n\
            \#@gui : note = note{\"\\nOf course, your plug-in will continue to work, but please note that we won\47t be able\n\
            \#@gui : to provide filter updates anymore for your current plug-in version.\\n\\n\n\
            \#@gui : Best regards,\\n\\n <i>The G\47MIC team.</i>\"}\n\n"'})
    y[1] a y
    o cimgz:$file,uchar
    _update_server_upload $file
    v + e[0--4] "  > Done! Version $1 is now deprecated." v -
  fi
  rm endl v +

# Function that updates filters definitions on the G'MIC web server.
# It sorts and merges filters from all available sources, and save
# a single update file on the G'MIC server. It also print on the standard
# output (stdout), the list of available filters.
update_server :
  v -
  use_vt100

  # Promote cool testing filters to main filter tree.
  _update_server_move[] "/Testing/Garagecoder/Anti~Alias","/Repair"
  _update_server_move[] "/Testing/Garagecoder/Aurora","/Artistic"
  _update_server_move[] "/Testing/Garagecoder/Auto~Balance","/Colors"
  _update_server_move[] "/Testing/Garagecoder/Compression~Blur","/Repair"
  _update_server_move[] "/Testing/Garagecoder/Despeckle","/Repair"
  _update_server_move[] "/Testing/Garagecoder/Emboss","/Black~&amp;~White"
  _update_server_move[] "/Testing/Garagecoder/HSL~Adjustment","/Colors"
  _update_server_move[] "/Testing/Garagecoder/HSV~Select","/Colors"
  _update_server_move[] "/Testing/Garagecoder/JPEG~Smooth","/Repair"
  _update_server_move[] "/Testing/Garagecoder/Normalize~Brightness","/Colors"
  _update_server_move[] "/Testing/Garagecoder/Stereo~Image","/Stereoscopic~3D"
  _update_server_move[] "/Testing/Garagecoder/Undo~Anaglyph","/Stereoscopic~3D"
  _update_server_move[] "/Testing/Garagecoder/Sharpen~[Gradient]","/Details"
  _update_server_move[] "/Testing/Garagecoder/Sharpen~[Tones]","/Details"
  _update_server_move[] "/Testing/Garagecoder/Temperature~Balance","/Colors"
  _update_server_move[] "/Testing/Garagecoder/Unquantize~[JPEG~Smooth]","/Repair"
  _update_server_move[] "/Testing/Garagecoder/Wiremap","/Rendering"
  _update_server_move[] "/Testing/Garagecoder/Smooth~[Geometric-Median]","/Repair"
  _update_server_move[] "/Testing/Gmic~Tutorials/Hedcut~(Experimental)","/Patterns"
  _update_server_move[] "/Testing/Iain~Fergusson/Constrained~Sharpen","/Details"
  _update_server_move[] "/Testing/Iain~Fergusson/Easy~Skin~Retouch","/Details"
  _update_server_move[] "/Testing/Iain~Fergusson/Moire~Removal","/Repair"
  _update_server_move[] "/Testing/Iain~Fergusson/Halftone~Shapes","/Patterns"
  _update_server_move[] "/Testing/Iain~Fergusson/Simple~Local~Contrast","/Details"
  _update_server_move[] "/Testing/Iain~Fergusson/Turbulent~Halftone","/Patterns"
  _update_server_move[] "/Testing/Joan~Rake/Artistic/Ultrawarp++++","/Degradations"
  _update_server_move[] "/Testing/J&#233;J&#233;/Rays","/Patterns"
  _update_server_move[] "/Testing/Naggobot/Blockism","/Artistic"
  _update_server_move[] "/Testing/Samj/Arrays~&amp;~Tiles/Annular~Steiner~Chain~Round~Tile","/Arrays~&amp;~Tiles"
  _update_server_move[] "/Testing/Samj/Arrays~&amp;~Tiles/Reptile","/Patterns"
  _update_server_move[] "/Testing/Samj/Artistic/Anguish","/Artistic"
  _update_server_move[] "/Testing/Samj/Artistic/Chalk~It~Up","/Artistic"
  _update_server_move[] "/Testing/Samj/Artistic/Paint~Daub","/Artistic"
#  _update_server_move[] "/Testing/Samj/Artistic/Skeletik","/Artistic"
  _update_server_move[] "/Testing/Samj/Patterns/Denim","/Patterns"
  _update_server_move[] "/Testing/Samj/Patterns/Soft~Random~Shades","/Patterns"
  _update_server_move[] "/Testing/Samj/Rendering/Pythagoras~Tree","/Rendering"
  _update_server_move[] "/Testing/Samj/Rendering/Snowflake~2","/Rendering"
  _update_server_move[] "/Testing/Samj/Rendering/Twisted~Rays","/Rendering"
  _update_server_move[] "/Testing/Souphead/Disco","/Rendering"
  _update_server_move[] "/Testing/Souphead/Moon2panorama","/Deformations"
  _update_server_move[] "/Testing/Souphead/Spiral~RGB","/Rendering"
  _update_server_move[] "/Testing/Souphead/Kitaoka~Spin~Illusion","/Rendering"
  _update_server_move[] "/Testing/Zonderr/Spiral","/Rendering"

  # Define useful sub-commands.
  m "parent : l[] ({'$""1'}) s -,{'/'} if $! rm. fi i[0--1] (47) a y u {0,t} rm endl" # Command to return parent of a path
  m "varname : ({'\"$""1\"'}) f. if((i>=48&&i<=57)||(i>=65&&i<=90)||(i>=97&&i<=122),i,95) u {t} rm." # Convert string to a valid variable name
  m "load_gmic : "\
    "_nb_sources+=1 filename=${\"basename $""1\"} "\
    "v + e[] $_gmic_c\"  \"$_nb_sources\". \"$_gmic_n$filename\"  \" v - "\
    "l[] "\
    "  i raw:$""1,char nm {0,b} v + e[] $_gmic_g\"      [retrieved from source '$""1']\"$_gmic_n v - "\
    # "  l "\
    # "    o raw:/tmp/$filename,char "\
    # "    _update_server_upload /tmp/$filename,include/$filename "\
    # "    v + e[] $_gmic_g\"      [archived]\n\"$_gmic_n v - "\
    # "  onfail v + e[] $_gmic_r\"      [could not be archived!]\n\"$_gmic_n v - endl "\
    "onfail l[] "\
    "  source=https://gmic.eu/include/$filename "\
    "  i raw:$source,char v + e[] $_gmic_c\"      [retrieved from archive '\"$source\"']\n\"$_gmic_n v - "\
    "  onfail v + e[] $_gmic_r\"      [error, not reachable!]\n\"$_gmic_n v -"\
    "  endl endl"

  # Copy latest command definitions on G'MIC server if necessary.
  v + e[] "> Upload latest version ("${-strver}") of commands on G'MIC server.\n" v -
  _update_server_upload $HOME/work/src/gmic/src/gmic_stdlib.gmic,gmic_stdlib.$_version
  _update_server_upload $HOME/work/src/gmic/src/gmic_stdlib.gmic

  # Get command source files and archive them.
  v + e[] "> Load and archive .gmic source files.\n" v -
  _nb_sources=0
  load_gmic ${HOME}/work/src/gmic/src/gmic_stdlib.gmic
  x "cd $HOME/work/src/gmic-community && git pull 2>&1 >/dev/null"

  load_gmic ${HOME}/work/src/gmic-community/include/afre.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/andreas_pahlsson.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/andy_kelday.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/arto_huotari.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/david_tschumperle.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/garry_osgood.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/gentlemanbeggar.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/iain_fergusson.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/james_prichard.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/jerome_boulanger.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/jerome_ferrari.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/joan_rake.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/karsten_rodenacker.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/mccap.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/martin_souphead.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/mathew_callaghan.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/photocomix.gmic
  l[]
    load_gmic ${HOME}/work/src/gmic-community/include/sylvie_alexandre.gmic
    s +,{'"#@gui <b>"'} i[1--2:2] ({'"#@gui ________<b>Testing<b>\n#@gui <i>Samj</i>\n"'}) y a y
  endl
  load_gmic ${HOME}/work/src/gmic-community/include/tom_keil.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/reptorian.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/translation_ca.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/translation_fr.gmic
  load_gmic ${HOME}/work/src/gmic-community/include/translation_ja.gmic

  # Merge them together.
  i[0] (10) i[2--1] ({"'\n#@gui ________________\n'"}) y a y discard 13 replace 9,32
  s +,{'"#@gui"'}
  repeat {int(($!-1)/2)} a[{$>+1},{$>+2}] y done
  nm[0] !header

  # Parse filter tree.
  v + e[] "> Start filter parsing.\n" v -
  progress_factor={100/($!-1)}
  merge_request=0
  merge_start=0
  nb_filters=0
  offset=0
  path=/

  repeat $!
    ind={$>-$offset}
    if {{{$ind-1},@-1}==10" && "same([{^}],'#@gui',5)" && "({$ind,@5}==32" || "{$ind,@5}==_'_')} l[$ind] # Line starts by '#@gui[_] '

      if {i[5]==_'_'} locale=_{`[i[6],i[7]]`}  # Retrieve locale if any specified
      else locale=
      fi

      is_folder=0
      s +,10
      if {{0,@5}==_'_'} +rows[0] 8,100% rows[0] 0,7 # Treat a localized filter as a regular filter.
      else +rows[0] 5,100% rows[0] 0,4
      fi
      autocrop. 32 mv. 1

      if {narg($locale)" && "find(#1,'hide(')>=0} # Found a hide() pragma.
        i[1] ({'" "'})

      elif {{1,@0}!=_':'} # Found a new filter or folder definition.
        l[1]

          # Format string by removing special character sequences.
          s +,{':'}
          replace_str[0] "<b>"
          replace_str[0] "</b>"
          replace_str[0] "<i>"
          replace_str[0] "</i>"
          replace[0] {'/'},{'-'}
          replace[0] {','},{';'}
          autocrop[0] 32

          if {$!>1} # Found new filter.
            _update_server_calibrate_name[0] +replace[0] 32,{'~'}
            name=$path{t} rm.
            merge_request=1
            nb_filters+=1
            i[0,1] (32) a y
            v + e[] $_gmic_c"  "$nb_filters". "$_gmic_n$name" ("{round($>*$progress_factor)}"%)." v -

          else # Found new folder (opt. parent(s)).

            if {i==_'_'} # Folder has parents before creating it.
              do path=${"parent[] "$path} shift 0,-1,0,0 while {i==_'_'}
              autocrop 0
            fi
            autocrop 32
            if {w} # Folder name specified after the underscore(s).
              varname {0,t} locale_${}=$locale # Keep locale of each folder
              _update_server_calibrate_name[0]
              replace 32,{'~'}
              path=$path{0,t}/
            fi
            is_folder=1

          fi # if {$!>1}
        endl # l[1]

        if $is_folder rm[0,1] i[0] (10) # Discard folder definition (will be recreated afterwards).
        else nm[0] $name fi

      else # Found possibly a filter argument.

        if {$!>=3} l[1]
          s +,{'='}
          if {$!>=3} if {{1,@0}==_'='}
            if {find(#0,'"<span "')<0}
              rows[0] 1,100%
              _update_server_calibrate_name[0]
              i[0] ({':'};32) i[2] (32)
            fi
          fi fi
        endl fi
        i[1] (32)

      fi # if {i!=_':'}
      a y

    endl fi

    if {$merge_request" && "$ind>0} # Merge previous lines.
      a[$merge_start-{$ind-1}] y
      offset+={$ind-$merge_start-1}
      merge_start+=1
      merge_request=0
    fi

  done

  a[$merge_start--1] y # Final merge.

  # Force filters to move if necessary.
  v + e[] "\n> Force filters to move, if necessary." v -
  repeat $!,ind repeat $_nbm if {['{$ind,n}']==['${_to_move$>}']}
    v + e[] $_gmic_c"  "$ind$_gmic_n". Move '"${_gmic_g}{$ind,n}$_gmic_n"' to '"$_gmic_g${_move_to$>}$_gmic_n"'." v -
    nm[$ind] ${_move_to$>}/{$ind,b}
  fi done done

  # Sort filter code by lexicographical order.
  v + e[] "\n> Sort filters by lexicographic order." v -
  sort_list +,n

  # Rebuild folder structure.
  v + e[] "\n> Rebuild folder structure." v -
  m "nb_levels : l[] ({'$""1'}) s -,{'/'} u $! rm endl"  # Command to count number of folders in a given path.

  path=/

  repeat $! l[$>]
    npath=${"parent "{0,n}}
    if {['$path']!=['$npath']} # Need to change the path.
      nc=${"nb_levels[] "$path}
      nn=${"nb_levels[] "$npath}

      # Get the minimal basis path in common and the number of up/down operations.
      nb_up=0
      nb_down=0
      basis=$path nbasis=$npath
      do
        nc=${"nb_levels[] "$basis}
        nn=${"nb_levels[] "$nbasis}
        if {$nc>$nn} basis=${"parent[] "$basis} nb_up+=1
        elif {$nn>$nc} nbasis=${"parent[] "$nbasis} nb_down+=1
        elif {['$nbasis']!=['$basis']} basis=${"parent[] "$basis} nb_up+=1 nbasis=${"parent[] "$nbasis} nb_down+=1
        fi
      while {['$nbasis']!=['$basis']}

      # Deduce the G'MIC command to apply.
      command=
      if $nb_up 1,$nb_up,1,1,{'_'} command="#@gui "{t}"\n" rm. fi
      if $nb_down l[]
        ({'$npath'}) s -,{'/'} k[-$nb_down--1] replace {'~'},32
        level={${"nb_levels "$path}-$nb_up}
        balise=${"if "{$level<=0" && "['$npath']!='/About/'}" u b else u i fi"}
        repeat $!
          varname {$>,t} locale=${locale_${}} # Retrieve locale of folder name
          command=$command"#@gui"$locale" <"$balise">"{$>,t}"</"$balise">\n"
          balise="i"
        done rm
      endl fi
      if {narg(['$command'])} nm={0,n} i[0] ({'$command'}) y[0] a y nm $nm
      fi

      path=$npath
    fi
  endl done

  # Search / replace strings.
  v + e[] "> Search and replace strings." v -
  replace_str "#@gmic\n",""
  replace_str "<small>samj","<small>Author: <i>Samj</i>."
  replace_str " Update : <i>20","   Latest Update: <i>20"

  # Remove useless comments and line breaks.
  repeat $! l[$>] s -,10 repeat $! l[$<]
    if {i[0]==_'#'" && "i[1]!=_'@'} rm fi
  endl done i[^0] ({'\n'}) a y endl done

  # Retrieve G'MIC command name for each filter.
  repeat $! +l[$>] command_name$>=""
    +rows 0,5 head={t} rm.
    if {['$head']=='"#@gui "'} s -,{':'}
      if {$!>=1} l[1] s -,{','}
        if $! autocrop[0] 32 command_name$>={0,t} fi
      endl fi
    fi
  rm endl done

  # Save reordered .gmic file.
  if {$nb_filters>400}
    v + e[] "> Compress and save output .gmic files." v -
    +a y l.
    compress_gmic[0]

    # Add footer and header.
    i[0] ({'"#@gmic"\n\
            "#"\n\
            "#  File        : update"$_version".gmic"\n\
            "#                ( G\47MIC command file )"\n\
            "#"\n\
            "#  Description : Update file for G\47MIC commands and filters (for version "${-strver}")."\n\
            "#                ( https://gmic.eu )"\n\
            "#"\n\
            "#  License     : CeCILL v2.1 or CeCILL-C v1.0"\n\
            "#                ( http://www.cecill.info/index.en.html )"\n\
            "#"\n\n'})
    ({'"\n\n# Local Variables:"\n\
       "# mode: sh"\n\
       "# End:"\n\
       "#"\n\
       "# (End of G\47MIC update file)"'})
    y a y

    # Upload filter files on G'MIC server.
    o raw:${_path_rc}update$_version.gmic,uchar
    if {"d = date(3); h = date(4); h>=7 && d>=1 && d<=5"} url=https://goo.gl/Ryf7Cv
    else url=http://ow.ly/wpsV30fzhdI # url=https://goo.gl/Ryf7Cv
    fi
    replace_str "<i>David Tschumperl&#233;</i>","<i><a href=\""$url"\">David Tschumperl&#233;</a></i>"
    o cimgz:/tmp/update$_version.gmic,uchar

    (250)
    repeat {w}
      v={i[$>]}
      _update_server_upload[] ${_path_rc}update$_version.gmic,plain_update$v.gmic
      _update_server_upload[] /tmp/update$_version.gmic,update$v.gmic
    done rm.

    rm endl
  fi

  # Display list of filters (sorted alphabetically) on stdout.
  v + e[] "> Output list of filters in stdout.\n" v -
  echo_stdout "*** List of filters in the G\47MIC plug-in ("$nb_filters" filters, on "{date(0)}/{date(1)}/{date(2)}" "{date(4)}:{date(5)}") ***\n"
  echo_stdout "* List of filters, sorted by path:\n"
  repeat $! l[$>]
    ({'{0,n}'}) if {i!=_'!'}
      r. {w-1},1,1,1,0,0,1
      replace_str. "&amp;","&"
      replace_str. "&#233;","e"
      replace_str. "/","~/~"
      replace. {'~'},32
      if {narg(${command_name$>})} echo_stdout[] "  "{t}" (command '"${command_name$>}"')"
      else echo_stdout[] "  "{t}
      fi
    fi rm.
  endl done

  echo_stdout "\n* List of filters, sorted alphabetically:\n"

  repeat $!
    name={$>,b}
    path={$>,f}
    nm[$>] $name"~(in~'"$path"')"
  done

  sort_list +,n
  repeat $! l[$>]
    ({'{0,n}'}) if {i!=_'!'}
      replace_str. "&amp;","&"
      replace_str. "&#233;","e"
      replace. {'~'},32
      echo_stdout[] "  "{t}
    fi rm.
  endl done
  echo_stdout "\n*** End of list ***\n"

  # All done, exiting.
  rm v + e[] $_gmic_g"> All done !\n"$_gmic_n

_update_server_calibrate_name :
  replace {'_'},{'" "'} autocrop {'" "'}
  in={t}

  s +,{'.'} s +,{':'} s +,{';'}

  repeat $! l[$>]
    s +,{'" "'} s +,{'"/"'} s +,{'"["'} s +,{'"<"'} s +,{'"("'} s +,{'">"'} s +,{'"-"'}
    first={"ind = 0; while (ind<l && (c = lowercase(i[#ind,0]); !((c>=_'a' && c<=_'z') || (c>=_'0' && c<=_'9'))), ++ind); ind<l?ind:0"}
    f "x+y?i:( # Capitalize all words except a few ones
       s = crop();
       s=='a' || s=='an' || s=='and' ||
       s=='as' || s=='at' || s=='but' || s=='by' ||
       s=='for' || s=='from' || s=='in' || s=='into' ||
       s=='like' || s=='near' || s=='nor' || s=='of' || s=='off' ||
       s=='on' || s=='onto' || s=='or' || s=='over' || s=='past' ||
       s=='per' || s=='than' || s=='the' || s=='to' || s=='up' ||
       s=='upon' || s=='via' || s=='with'?i:uppercase(i)
       )"
    f[$first,-1] "x+y?i:uppercase(i)" # Always capitalize the first and last words.
    a y
  endl done
  a y
  replace_str "<B>","<b>"
  replace_str "</B>","</b>"
  replace_str "<I>","<i>"
  replace_str "</I>","</i>"
  replace_str "<Img Src","<img src"
  replace_str "<A Href","<a href"
  replace_str "<a Href","<a href"
  replace_str ".Gpl",".gpl"
  replace_str ".Png",".png"
  replace_str "(Deg)","(deg)"
  replace_str "(Px)","(px)"
  replace_str "(S)","(s)"
  replace_str "(T)","(t)"
  replace_str "Re-","re-"
  replace_str "Min-T","Min-t"
  replace_str "Max-T","Max-t"
  replace_str "SRGB","sRGB"
  if {['{t}']=='Sep'} replace_str "Sep","sep" fi
  if {['{t}']=='Note'} replace_str "Note","note" fi
  if {['{t}']=='Url'} replace_str "Url","url" fi
  out={t}
  if {['$in']!=['$out']} v + e[] $_gmic_m"       Warning: String '"$in"' substituted by '"$out"'"$_gmic_n v - fi

_update_server_move :
  if {!narg($_nbm)} _nbm=0 fi
  _to_move${_nbm}="$1" _move_to${_nbm}="$2" _nbm+=1

_update_server_upload : skip "${2=""}"
  if {narg("$2")} out="$2" else basename "$1" out=${} fi
  l[] GMIC_LOGIN=${gmic_ftp\ 0} onfail GMIC_LOGIN="" endl
  l[] GMIC_PASSWD=${gmic_ftp\ 1} onfail GMIC_PASSWD="" endl
  if {narg($GMIC_LOGIN)}
    x 0,"lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"put -O /www/gmic/ \\\"$1\\\" -o \\\""$out"\\\"; quit\" >/dev/null"
  fi

# Upload released binaries on the G'MIC web server.
# $1=version number (e.g "1.6.7_pre")
_update_server_binaries :
  e[^-1] "Upload released binaries ($1) on the G'MIC web server."
  v -
  is_pre=${"strcontains $1,_pre"}
  N=0
  file$N=gmic_$1_debian_wheezy_amd64.deb               N+=1
  file$N=gmic_$1_debian_jessie_amd64.deb               N+=1
  file$N=gmic_$1_debian_stretch_amd64.deb              N+=1
  file$N=gmic_$1_debian_sid_amd64.deb                  N+=1
  file$N=gmic_$1_ubuntu_xenial_amd64.deb               N+=1
  file$N=gmic_$1_ubuntu_artful_amd64.deb               N+=1
  file$N=gmic_$1_ubuntu_bionic_amd64.deb               N+=1
  file$N=gmic_$1_ubuntu_cosmic_amd64.deb               N+=1

  file$N=gmic_gimp2.8_qt_$1_linux64.zip                N+=1
  file$N=gmic_gimp2.8_qt_$1_debian_jessie_amd64.zip    N+=1
  file$N=gmic_gimp2.8_qt_$1_debian_stretch_amd64.zip   N+=1
  file$N=gmic_gimp2.10_qt_$1_debian_sid_amd64.zip      N+=1
  file$N=gmic_gimp2.8_qt_$1_ubuntu_xenial_amd64.zip    N+=1
  file$N=gmic_gimp2.8_qt_$1_ubuntu_artful_amd64.zip    N+=1
  file$N=gmic_gimp2.8_qt_$1_ubuntu_bionic_amd64.zip    N+=1
  file$N=gmic_gimp2.10_qt_$1_ubuntu_cosmic_amd64.zip   N+=1

  file$N=gmic_krita_qt_$1_debian_jessie_amd64.zip      N+=1
  file$N=gmic_krita_qt_$1_debian_stretch_amd64.zip     N+=1
  file$N=gmic_krita_qt_$1_debian_sid_amd64.zip         N+=1
  file$N=gmic_krita_qt_$1_ubuntu_xenial_amd64.zip      N+=1
  file$N=gmic_krita_qt_$1_ubuntu_artful_amd64.zip      N+=1
  file$N=gmic_krita_qt_$1_ubuntu_bionic_amd64.zip      N+=1
  file$N=gmic_krita_qt_$1_ubuntu_cosmic_amd64.zip      N+=1

  file$N=gmic_cli_$1_win64.zip                         N+=1
  file$N=gmic_lib_$1_win64.zip                         N+=1
  file$N=gmic_gimp2.10_qt_$1_win64.zip                 N+=1
  file$N=gmic_gimp2.10_qt_$1_win64.exe                 N+=1
  file$N=gmic_gimp2.8_qt_$1_win64.zip                  N+=1
  file$N=gmic_gimp2.8_qt_$1_win64.exe                  N+=1
  file$N=gmic_krita_qt_$1_win64.zip                    N+=1

  t0=$| n=0 t=0
  v + e[] "- Waiting for binary files to be build." v -
  do
    repeat $N
      file=${file$>}
      if $file
        strreplace $file,_$1_,_
        file_short=${}
        is_win=${strcontains[]" "$file,win}
        if $is_win folder="windows" else folder="linux" fi

        v + e[] "- Upload file '"$file"' to 'https://gmic.eu/files/prerelease/"$file_short"'." v -
        _update_server_upload $file,"files/prerelease/"$file_short
        v + e[] "- Upload file '"$file"' to 'https://gmic.eu/files/prerelease_"$folder/$file_short"'." v -
        _update_server_upload $file,"files/prerelease_"$folder/$file_short

        if {!$is_pre}
#          v + e[] "- Upload file '"$file"' to 'https://gmic.eu/files/"$folder/$file"'." v -
#          _update_server_upload $file,"files/"$folder/$file
          v + e[] "- Upload file '"$file"' to 'https://gmic.eu/files/"$folder/$file_short"'." v -
          _update_server_upload $file,"files/"$folder/$file_short
        fi

        file$>= n+=1
      fi
    done
    if {$n<$N}
      if {!($t%4)}
        remaining= sep=
        repeat $N if {narg(${file$>})} remaining.=${sep}${file$>} sep=", " fi done
        v + e[] "- Waiting for files: "$remaining"." v -
      fi
      wait 5000 t+=1
    fi
  while {$n<$N" && "$|<$t0+60*60*4}
  v +
  if {$n<$N} e[] "- Partial uploads done (timeout reached)."
  else e[] "- All uploads done !"
  fi

# Convert G'MIC tutorial from Garry Osgood's blog (http://www.particularart.com), into the G'MIC web look.
update_tutorial_html :
  e[^-1] "Convert G\47MIC tutorial from Garry Osgood\47s blog (http://www.particularart.com), for the G\47MIC web page."
  v - rm m "add_page : __update_tutorial_html $""*"
  use_vt100

  # Init list of pages to retrieve.
  # add_page /,1700,index,__index
  # add_page basics,4000

  # add_page beginners-cookbook,1000
  # add_page beginners-cookbook/cauldron,3500
  # add_page beginners-cookbook/dyidiffusion,1000
  # add_page beginners-cookbook/dyidiffusion/graduated-blurs,3800
  # add_page beginners-cookbook/dyidiffusion/variations-on-a-theme,3800
  # add_page beginners-cookbook/dyidiffusion/eigenvalues-and-eigenvectors,2300
  # add_page beginners-cookbook/dyidiffusion/directional-blurring,3500
  # add_page beginners-cookbook/dyidiffusion/tensors-for-the-tonsorially-challenged,8500
  # add_page beginners-cookbook/dyidiffusion/eigen-thingys,4800
  # add_page beginners-cookbook/dyidiffusion/fake-depth-of-field,7600
  # add_page beginners-cookbook/fingerpainting,12000
  # add_page beginners-cookbook/ramps,1200
  # add_page beginners-cookbook/ramps/applying-a-curve,600
  # add_page beginners-cookbook/ramps/blurring,600
  # add_page beginners-cookbook/ramps/general-ramps,2500
  # add_page beginners-cookbook/ramps/input-and-fill,1200
  # add_page beginners-cookbook/ramps/one-dimensional-functions,800
  # add_page beginners-cookbook/ramps/remapping-space,2200
  # add_page beginners-cookbook/ramps/resizing,600
  # add_page beginners-cookbook/ramps/warp,800
  # add_page beginners-cookbook/road-systems,2500
  # add_page beginners-cookbook/stained-glass,4000
  # add_page beginners-cookbook/spectral-art,1500
  # add_page beginners-cookbook/spectral-art/the-spatial-and-the-spectral,2000
  # add_page beginners-cookbook/spectral-art/the-spectral-course,2000
  # add_page beginners-cookbook/spectral-art/the-spectral-domain,2000
  # add_page beginners-cookbook/spectral-art/the-complex-number-field,3300
  # add_page beginners-cookbook/spectral-art/painting-with-waves-part-one,2200
  # add_page beginners-cookbook/spectral-art/painting-with-waves-part-two,2200
  # add_page beginners-cookbook/spectral-art/a-revised-map,1500
  # add_page beginners-cookbook/spectral-art/intermezzo-spectral-editing,1500
  # add_page beginners-cookbook/spectral-art/a-wave-painting-workflow,2000
  # add_page beginners-cookbook/spectral-art/tiletex,5000
  # add_page beginners-cookbook/spectral-art/coefficient-values,3000
  # add_page beginners-cookbook/spectral-art/coefficient-values-part-two,4500
  # add_page beginners-cookbook/spectral-art/coefficient-values-part-three,2500
  # add_page beginners-cookbook/spectral-art/cheat-sheet,9000
  # add_page beginners-cookbook/spectral-art/appendix,2500

  # add_page command-decorations,3500
  # add_page images,2000
  # add_page images/conjuring-images,1000
  # add_page images/images-as-datasets,3500
  # add_page images/images-have-edges,1200
  # add_page command-guide,5500

  # add_page command-guide/color-manipulation/-autoindex,1000,,,commands-colors-manipulation
  # add_page command-guide/color-manipulation/-compose_channels,1000,,,commands-colors-manipulation
  # add_page command-guide/color-manipulation/-colormap,1000,,,commands-colors-manipulation
  # add_page command-guide/color-manipulation/-direction2rgb,1000,,,commands-colors-manipulation
  # add_page command-guide/color-manipulation/-fill_color,1000,,,commands-colors-manipulation
  # add_page command-guide/color-manipulation/-gradient2rgb,1000,,,commands-colors-manipulation
  # add_page command-guide/color-manipulation/-mix_rgb,4000,,,commands-colors-manipulation
  # add_page command-guide/color-manipulation/-select_color,3000,,,commands-colors-manipulation

  # add_page command-guide/feature-extraction/-distance,9500,,,commands-features-extraction
  # add_page command-guide/feature-extraction/-area,2000,,,commands-features-extraction
  # add_page command-guide/feature-extraction/-label,1300,,,commands-features-extraction

  # add_page command-guide/filtering/-bandpass,5000,,,commands-filtering
  # add_page command-guide/filtering/-blur,2000,,,commands-filtering
  # add_page command-guide/filtering/-blur_angular,700,,,commands-filtering
  # add_page command-guide/filtering/-blur_linear,700,,,commands-filtering
  # add_page command-guide/filtering/-blur_radial,700,,,commands-filtering
  # add_page command-guide/filtering/-blur_selective,3500,,,commands-filtering
  # add_page command-guide/filtering/-blur_x,700,,,commands-filtering
  # add_page command-guide/filtering/-blur_xy,700,,,commands-filtering
  # add_page command-guide/filtering/-blur_xyz,700,,,commands-filtering
  # add_page command-guide/filtering/-blur_y,700,,,commands-filtering
  # add_page command-guide/filtering/-blur_z,2500,,,commands-filtering
  # add_page command-guide/filtering/-convolve,3500,,,commands-filtering
  # add_page command-guide/filtering/-dct-and-idct,1500,,,commands-filtering
  # add_page command-guide/filtering/-deriche,1500,,,commands-filtering
  # add_page command-guide/filtering/-diffusiontensors,7200,,,commands-filtering
  # add_page command-guide/filtering/-fft,6300,,,commands-filtering
  # add_page command-guide/filtering/-gradient,3000,,,commands-filtering
  # add_page command-guide/filtering/-gradient_norm,1300,,,commands-filtering
  # add_page command-guide/filtering/-gradient_orientation,3300,,,commands-filtering
  # add_page command-guide/filtering/-haar,2000,,,commands-filtering
  # add_page command-guide/filtering/-smooth,4300,,,commands-filtering
  # add_page command-guide/filtering/-structuretensors,3300,,,commands-filtering

  # add_page command-guide/geometry-manipulation/-warp,5000,,,commands-geometry-manipulation

  # add_page command-guide/image-drawing/-gaussian,2000,,,commands-image-drawing
  # add_page command-guide/image-drawing/-plasma,4500,,,commands-image-drawing
  # add_page command-guide/image-drawing/-turbulence,5500,,,commands-image-drawing

  # add_page command-guide/inputs-outputs/-display,2000,,,commands-inputs-outputs
  # add_page command-guide/inputs-outputs/-display_tensors,1500,,,commands-inputs-outputs
  # add_page command-guide/inputs-outputs/-input,7500,,,commands-inputs-outputs
  # add_page command-guide/inputs-outputs/-shared,2000,,,commands-inputs-outputs

  add_page command-guide/list-manipulation/-name,8000,,,commands-list-manipulation

  # add_page command-guide/matrix-computation/-eigen,2000,,,commands-matrix-computation

  # add_page command-guide/program-control/-local,3500,,,commands-program-control
  # add_page command-guide/program-control/-do,6500,,,commands-program-control
  # add_page command-guide/program-control/-if,3500,,,commands-program-control
  # add_page command-guide/program-control/-repeat,2000,,,commands-program-control

  # add_page command-guide/values-manipulation/-eigen2tensor,5500,,,commands-values-manipulation
  # add_page command-guide/values-manipulation/-fill,20000,,,commands-values-manipulation
  # add_page command-guide/values-manipulation/-index,3500,,,commands-values-manipulation
  # add_page command-guide/values-manipulation/-map,3500,,,commands-values-manipulation
  # add_page command-guide/values-manipulation/-norm,700,,,commands-values-manipulation
  # add_page command-guide/values-manipulation/-normalize,1700,,,commands-values-manipulation
  # add_page command-guide/values-manipulation/-orientation,5000,,,commands-values-manipulation
  # add_page command-guide/values-manipulation/-threshold,1500,,,commands-values-manipulation

  # add_page technical-notes/trigometric-and-inverse-trigometric-commands,2500
  # add_page technical-notes/wavelet-analysis-and-synthesis-in-gmic,5000
  # add_page technical-notes/gmic-color-mapping,1000
  # add_page technical-notes/gmic-color-mapping/median-cut-algorithm,5500
  # add_page technical-notes/gmic-color-mapping/k-means-algorithm,10000

  # add_page gimp-filters,1500
  # add_page gimp-filters/blur-by-color-filter,23500
  # add_page gimp-filters/hedcut-filter,2000
  # add_page gimp-filters/the-fingerpainting-filter,2200
  # add_page gimp-filters/the-hairlock-filter,8500

  # Prepare folder structure.
  v + e[] "\n  * Prepare folder structure." v -
  x "ln -fs ../../gmic/html/tutorial.css ."
  x "ln -fs ../../gmic/html/copyright.html ."
  x "ln -fs ../../gmic/html/favicon.ico ."
  x "ln -fs ../../gmic/html/favicon.png ."
  x "ln -fs ../../gmic/html/footer.html ."
  x "ln -fs ../../gmic/html/header.html ."
  x "ln -fs ../../gmic/html/gmicmenu ."
  x "ln -fs ../../gmic/html/jquery-1.11.0.min.js ."
  x "ln -fs ../../gmic/html/style.css ."
  x "ln -fs ../../gmic/html/images ."
  x "mkdir -p img"
  x "cd img && ln -fs ../../../gmic/html/img/logo4.jpg ."
  x "cd img && ln -fs ../../../gmic/html/img/logos.jpg ."
  x "cd img && ln -fs ../../../gmic/html/img/rss.png ."
  x "cd img && ln -fs ../../../gmic/html/convert_raw_img/* ."
  x "ln -fs ../../gmic/html/convert_raw.html ../../gmic/html/convert_raw.shtml ."
  x "ln -fs ../../gmic/html/tutorial_toc.html ."
  x "ln -fs ../../gmic/html/highslide ."

  # Create images for toc tree.
  11,11,1,3,255 frame 1,1,0 line 3,50%,{w-4},50%,1,0 +line 50%,3,50%,{h-4},1,0
  a x o img/toc_buttons.png
  100%,100%,1,4 fc. 245,245,245,0 o. img/toc_void.png
  rm

  # Start page conversion.
  if {!narg($_N)} _N=0 fi
  0 repeat $_N
    o. ${_output_html$>} o. ${_output_shtml$>}
  done rm.
  repeat $_N
    v + _update_tutorial_html[] ${_input$>},${_height$>},${_output_shtml$>},${_output_html$>},${_img_prefix$>},${_tocid$>} v -
  done

  # Clean temp files.
  x "rm -f __tmp.html"
  v + e[] "\n  * All done !.\n\n"

# Add page to the list of pages to explore.
__update_tutorial_html : skip ${3=""},${4=""},${5=""}
  if {!narg($_N)} _N=0 fi
  _input$_N=$1 _height$_N=$2

  # Determine parent id for toc.
  if {narg("$5")} _tocid$_N="$5"
  else
    ({'"$1"'}) s -,{'/'} if $! _tocid$_N={0,t} rm else _tocid$_N=index fi
  fi

  # Determine output filenames.
  ({'"$1"'}) s -,{'/'}
  output_base=""
  if $! output_base={t} fi
  if {$!>2" && "i[0]!=_'-'} output_base={-2,t}_{t} fi
  rm
  if {narg($output_base)}
    ({'$output_base'}) if {i==_'-'} =. {'_'} output_base={t} fi rm. # Replace first '-' by underscore if necessary.
  fi
  if {narg("$3")} _output_shtml$_N="$3".shtml _output_html$_N="$3".html _img_prefix$_N="$3"
  else _output_shtml$_N=$output_base.shtml _output_html$_N=$output_base.html _img_prefix$_N=$output_base
  fi
  if {narg("$4")} _output_html$_N="$4".html fi
  _N+=1

# Retrieve one html page and convert it.
_update_tutorial_html :
  v -
  url="http://particularart.com/tools-and-toys/gmic/$1"
  v + e[] "\n  * Convert tutorial page '"$url"'." v -

  # Get web page.
  v + e[] "    > Retrieve page '"$url"'." v -
  x "wget -q "$url" -O __tmp.html"
  i raw:__tmp.html,char

  # Discard or replace undesired text.
  discard 13
  replace_str "class=\"internal\" "
  replace_str "class=\"external\" "
  replace_str "dir=\"ltr\" "
  replace_str "border: 1px","border: 0px"
  replace_str "G\140MIC","G\47MIC"
  replace_str "CNTL","CTRL"
  replace_str "Rashid","Rachid"
  replace_str "gmic.sourceforge.net","gmic.eu"
  replace_str "gmic_def","gmic_stdlib"
  replace_str "@#","$!"
  replace_str "@{-1,","{"
  replace_str "@{","{"
  replace_str "gmic-minimal","gmic"

  # Discard original header.
  s -,{'"<!-- GIMMICKRY! -->"'} k[1]
  s -,{'"<!-- GIMMICKRY! End -->"'} k[0]

  # Discard original footer.
  s +,{'"   </div>\n</div>\n<footer>"'} k[0]

  # Add header and footer.
  i[0] ({'"<!DOCTYPE html>"\n\
         "<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
         "<link rel=\"stylesheet\" href=\"tutorial.css\">"\n\
         "<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>"\n\
         "<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />"\n\
         "<script type=\"text/javascript\">"\n\
         "hs.graphicsDir = 'highslide/graphics/';"\n\
         "hs.wrapperClassName = 'wide-border';"\n\
         "</script>"\n\
         "<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>"\n\
         "<body>"\n\n'})
  ({'\n</body></html>'})
  y a y

  # Replace image links.
  replace_str "\"/static/media/uploads/","\"http://particularart.com/static/media/uploads/"
  replace_str "\"/tools-and-toys/gmic/","\"http://particularart.com/tools-and-toys/gmic/"
  replace_str "\"http://particularart.com/","\"http://www.particularart.com/"

  # Search and replace links to 'internal' pages.
  s +,{'"<a "'}
  repeat $! if {$>>0" && "[{{$>-1},^}]=='"<a "'} l[$>] s +,{'href=\"'} l.
    s +,{'\"'}
    if {$!>0}
      link={0,t}
      ({'$link'}) z. 0,48 baselink={t} rm.

      if {['$baselink']=='http://www.particularart.com/tools-and-toys/gmic/'}  # Check for a 'local' link.

        # Retrieve anchor if any.
        l[] anchor="" ({'$link'}) s +,{"'#'"} if {$!>1} anchor=#{t} link={0,t} fi rm endl
        ({'$link'}) autocrop. {'/'}
        l. s -,{'/'} if {com='command-guide';$!>6" && "[{-2,^}]!=com" && "[{-3,^}]!=com} relink={-2,t}_{t}.shtml else relink={t}.shtml fi rm endl
        ({'$relink'}) if {i==_'-'} =. {'_'} relink={t} fi rm. # Replace first '-' by underscore if necessary.

        if $relink # If the relinked page exists.
          relink=$relink$anchor
          v + e[] "    > Local link '"$link$anchor"' relinked to '"$relink"'." v -
          rm[0] i[0] ({'$relink'}) y[0]
        else # Else try to relink to reference page if link to a command.
          ({'$relink'}) if {i==_'_'}
            l. z 1,100% s -,{'.'} command=${basename\ {0,t}} k[0] endl
            relink="https://gmic.eu/reference.shtml#"$command
            v + e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_g}"(reference command)."${_gmic_n} v -
            rm[0] i[0] ({'$relink'}) y[0]
          else # If fail, link to original page with a hard link.
            relink=$link$anchor
            v + e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_r}"(no corresponding local page)."${_gmic_n} v -
            rm[0] i[0] ({'$relink'}) y[0]
          fi
          rm.
        fi
       else l # External link.
         0 nm. $link ext={x} rm.
         if {narg($ext)} ext=${strlowercase\ $ext} fi
         if {s=['$ext'];s=='png'||s=='jpg'||s=='jpeg'}  # Check for an image link.
           basename $link relink=img/$5_${} 0 nm. $relink relink={f}{b}.jpg rm.
           if $relink v + e[] "    > External image link '"$link"' relinked to '"$relink"'." v -
           else
             l[] i $link k[0] is_opaque=0
             split_opacity if {$!==1" || "ia>250} is_opaque=1 fi a c
             if {$is_opaque} to_rgb else to_rgba i[0] 100%,100%,1,3 fc[0] 245,245,245 blend alpha fi
             o $relink,60 rm
             # x "git add "$relink
             v + e[] "    > Image link '"$link"' converted and relinked to '"$relink"'." v -
             onfail relink=$link v + e[] "    > Failed to retrieve image link '"$link"'." v - rm
             endl
           fi
           rm[0] i[0] ({'$relink'})
           i[2] ({'" class=\"highslide\" onclick=\"return hs.expand(this)\""'})
           y[0,2]
         else
           v + e[] "    > External link '"$link"' found." v -
         fi
       onfail endl fi
       a y
    fi
  endl a y endl fi done
  a y

  # Manage embedded images.
  s +,{'"<img"'}
  repeat $! if {$>>0" && "[{{$>-1},^}]=='"<img "'}
    l[$>]
      s +,{'"src=\""'}
      l[2]
        s +,{'\"'} link={0,t}
        relink=img/$5_${basename\ $link} 0 nm. $relink relink={f}{b}.jpg rm.
        if $relink v + e[] "    > Image '"$link"' relinked to '"$relink"'." v -
        else
          l[] i $link k[0] is_opaque=0
          split_opacity if {$!==1" || "ia>250} is_opaque=1 fi a c
          if $is_opaque to_rgb frame 1,1,0 frame 10,10,245
          else to_rgba i[0] 100%,100%,1,3 fc[0] 245,245,245 blend alpha
          fi
          o $relink,60 rm
          # x "git add "$relink
          v + e[] "    > Image '"$link"' converted and relinked to '"$relink"'." v -
          onfail relink=$link v + e[] "      > Failed to retrieve image '"$link"'." v - rm
          endl
        fi
        rm[0] i[0] ({'$relink'}) y[0]
      endl
      a y
    endl
  fi done
  a y

  # Force images in tables to have a minimal width (fix for Chrome).
  replace_str "<td><img","<td width=\"256\"><img"
  replace_str "<td>\n<p><img","<td width=\"256\"><p><img"
  replace_str "<td>&nbsp;<img","<td width=\"256\"><img"

  # Set all links targets to "_parent"
  replace_str "<a ","<a target=\"_parent\" "

  # Save .html page.
  o raw:$4,char
  # x "git add $4"
  rm

  # Generate parent .shtml page.
  ({'"<!DOCTYPE html>"\n\
     "<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
     "<!--#include file=\"header.html\" -->"\n\
     "<div id=\"bloc_option\"><div id=\"top_vert\"><div id=\"text_top\">Tutorial</div></div>"\n\
     "<div id=\"center\"><div id=\"text_centre_intro\">"\n\
     "<script language=\"javascript\">var gFilename = '$6';</script>"\n\
     "<!--#include file=\"tutorial_toc.html\" -->"\n\
     "<iframe width=\"100%\" height=\"$2\" frameborder=\"0\" src=\""$4"\" seamless></iframe>"\n\
     "</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>"\n\
     "<!--#include file=\"copyright.html\" -->"\n\
     "<!--#include file=\"footer.html\" -->"\n'})
  o raw:$3,char
  # x "git add $3"
  rm
  wait {5000+u(2000)}
  v +

# Update version number in HTML header file.
# (works both for CImg and G'MIC !)
# $1 = filename
# $2 = version number
# $3 = is_prerelease = { 0 | 1 }
_update_header_html : check "${2=0}>=0 && isbool(${3=0})"
  if {!$2} return fi
  v -
  filename=$1
  l[]
    i raw:$filename,uchar
    s +,{'\n'}
    repeat $! if {$>,h>=64} l[$>]
      +autocrop {'" "'} autocrop. {'\t'}
      if {"s = ['Latest stable version: ']; crop(0,0,1,size(s))==s"}

        is_gmic={find(#-1,'gmic.eu')>=0}
        is_cimg={find(#-1,'cimg.eu')>=0}
        if (!$is_gmic" && "!$is_cimg} v + return fi

        # Retrieve latest stable version specified in the header file.
        +l. s -,{'>'}
          if {2,"i[0]>=_'0' && i[0]<=_'9' && i[1]==_'.' && i[2]>=_'0' && i[2]<=_'9' && i[3]==_'.' && i[4]>=_'0' && i[4]<=_'9'"}
            sta={2,`crop(0,0,1,5)`}
          fi
          if $3 pre=${strver\ $2} else sta=${strver\ $2} fi
        rm endl

        rm[0]
        if $is_gmic
          i[0] ({'"                Latest stable version: <b><a href=\"https://gmic.eu/download.shtml\">"$sta"</a></b>"'})
          if $3 i[1] ({'" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Current pre-release: <b><a href=\"https://gmic.eu/files/prerelease\">"$pre"</a></b>"'}) fi
        else
          i[0] ({'"                Latest stable version: <b><a href=\"http://cimg.eu/files/CImg_"$sta".zip\">"$sta"</a></b>"'})
          if $3 i[1] ({'" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Current pre-release: <b><a href=\"http://cimg.eu/files/CImg_latest.zip\">"$pre"</a></b>"'}) fi
        fi
        y
      fi
      rm.
    endl fi done
    a y
    o raw:$filename,uchar
  endl v +

#@cli v : eq. to 'verbose'. : (+)

#@cli verbose : level : { + | - } : (+)
#@cli : Set or increment/decrement the verbosity level. Default level is 0.
#@cli : (eq. to 'v').\n
#@cli : When 'level'>=0, G'MIC log messages are displayed on the standard error (stderr).
#@cli : Default value: 'level=0'.

#@cli wait : delay : (no arg) : (+)
#@cli : Wait for a given delay (in ms), optionally since the last call to 'wait'.
#@cli : or wait for a user event occurring on the selected instant display windows.
#@cli : 'delay' can be { <0=delay+flush events | 0=event | >0=delay }.
#@cli : Command selection (if any) stands for instant display window indices instead of image indices.
#@cli : If no window indices are specified and if 'delay' is positive, the command results
#@cli : in a 'hard' sleep during specified delay.
#@cli : Default value: 'delay=0'.

#@cli warn : _force_visible={ 0 | 1 },_message : (+)
#@cli : Print specified warning message, on the standard error (stderr).
#@cli : Command selection (if any) stands for displayed call stack subset instead of image indices.

#@cli w : eq. to 'window'. : (+)

#@cli window : _width[%]>=-1,_height[%]>=-1,_normalization,_fullscreen,_pos_x[%],_pos_y[%],_title : (+)
#@cli : Display selected images into an instant display window with specified size, normalization type,
#@cli : fullscreen mode and title.
#@cli : (eq. to 'w').\n
#@cli : If 'width' or 'height' is set to -1, the corresponding dimension is adjusted to the window
#@cli : or image size.
#@cli : When arguments 'pos_x' and 'pos_y' are both different than -1, the window is moved to
#@cli : the specified coordinates.
#@cli : 'width'=0 or 'height'=0 closes the instant display window.
#@cli : 'normalization' can be { -1=keep same | 0=none | 1=always | 2=1st-time | 3=auto }.
#@cli : 'fullscreen' can be { -1=keep same | 0=no | 1=yes }.
#@cli : You can manage up to 10 different instant display windows by using the numbered variants
#@cli : 'w0' (default, eq. to 'w'),'w1',...,'w9' of the command 'w'.
#@cli : Invoke 'window' with no selection to make the window visible, if is has been closed by the user.
#@cli : Default values: 'width=height=normalization=fullscreen=-1' and 'title=(undefined)'.

#---------------------------------
#
#@cli :: List Manipulation
#
#---------------------------------

#@cli k : eq. to 'keep'. : (+)

#@cli keep : (+)
#@cli : Keep only selected images.
#@cli : (eq. to 'k').
#@cli : $ image.jpg split x keep[0-50%:2] append x
#@cli : $ image.jpg split x keep[^30%-70%] append x

#@cli mv : eq. to 'move'. : (+)

#@cli move : position[%] : (+)
#@cli : Move selected images at specified position.
#@cli : (eq. to 'mv').
#@cli : $ image.jpg split x,3 move[1] 0
#@cli : $ image.jpg split x move[50%--1:2] 0 append x

#@cli nm : eq. to 'name'. : (+)

#@cli name : "name1","name2",... : (+)
#@cli : Set names of selected images.
#@cli : - If the selection contains a single image, then it is assumed the command has a single name argument (possibly containing multiple comas).
#@cli : - If the selection contains more than one image, each command argument defines a single image name for each image of the selection.
#@cli : (eq. to 'nm').
#@cli : $ image.jpg name image blur[image] 2
#@cli : $$

#@cli rm : eq. to 'remove'. : (+)

#@cli remove : (+)
#@cli : Remove selected images.
#@cli : (eq. to 'rm').
#@cli : $ image.jpg split x remove[30%-70%] append x
#@cli : $ image.jpg split x remove[0-50%:2] append x

#@cli remove_duplicates
#@cli : Remove duplicates images in the selected images list.
#@cli : $ (1,2,3,4,2,4,3,1,3,4,2,1) split x remove_duplicates append x
remove_duplicates :
  e[^-1] "Remove duplicates images in selected list of image$?."
  v - repeat $!,base
    off=0
    repeat {$!-$>-1}
      comp={$base+1+$>-$off}
      if {$comp>=$!} break fi
      +-[$base,$comp] abs. is_duplicate={!is} rm.
      if $is_duplicate rm[$comp] off+=1 fi
    done
  done v +

#@cli remove_empty
#@cli : Remove empty images in the selected image list.
remove_empty :
  e[^-1] "Remove empty images in selected list of image$?."
  v - repeat $! if {$<,!whds} rm[$<] fi done v +

#@cli rv : eq. to 'reverse'. : (+)

#@cli reverse : (+)
#@cli : Reverse positions of selected images.
#@cli : (eq. to 'rv').
#@cli : $ image.jpg split x,3 reverse[-2,-1]
#@cli : $ image.jpg split x,-16 reverse[50%-100%] append x

#@cli sort_list : _ordering={ + | - },_criterion
#@cli : Sort list of selected images according to the specified image criterion.
#@cli : Default values: 'ordering=+', 'criterion=i'.
#@cli : $ (1;4;7;3;9;2;4;7;6;3;9;1;0;3;3;2) split y sort_list +,i append y
sort_list : skip ${1=+},${2=i}
  v - s0="descending" s1="ascending" v +
  e[^-1] "Sort list of image$? in "${s{_'+'=='$1'}" order, according to the image criterion '$2'."
  v - if $!
    if {;'$2'=='n'} # Special case : lexicographic order from image names
      op={`;'$1'=='-'?_'>':_'<'`}
      (0,{$!-1})
      do
        lo0={i(0,h-1)} hi0={i(1,h-1)}
        lo=$lo0 hi=$hi0
        if {h>1} r. 2,{h-1},1,1,0 else rm. 0 fi
        pivot={{int(($lo+$hi)/2)},n}
        do if {$lo<=$hi}
          do if ${_sort_list_lexi\ \"{$lo,n}\",\"$pivot\",$op} lo+=1 else break fi while 1
          do if ${_sort_list_lexi\ \"$pivot\",\"{$hi,n}\",$op} hi-=1 else break fi while 1
          if {$lo<=$hi} rv[$lo,$hi] lo+=1 hi-=1 fi
        else break fi while 1
        if {$lo0<$hi} ($lo0,$hi) a[-2,-1] y fi
        if {$lo<$hi0} ($lo,$hi0) a[-2,-1] y fi
      while {h}
      rm.
    else # Generic case
      i=$! repeat $! ({$>,$2}) done a[$i--1] y +f. 'y' a[-2,-1] x sort. $1,y z. 1,1
      repeat {h} nm$>={$>,n} nm[$>] sortlist$> done
      repeat {h} mv[sortlist{i(0,$>)}] -1 done
      repeat {h} nm[$>] ${nm{i(0,$>)}} done
      rm.
    fi
  fi v +

_sort_list_lexi :
  u {"
       str1 = ['$1'];
       str2 = ['$2'];
       siz = min(size(str1),size(str2));
       lex = -1;
       for (i = 0, i<siz && lex<0, ++i,
         s1 = lowercase(str1[i]);
         s2 = lowercase(str2[i]);
         lex = s1"$3"s2?1:s2"$3"s1?0:-1;
       );
       lex<0?size(str1)"$3"size(str2):lex;
     "}

#@cli sort_str
#@cli : Sort selected images (viewed as a list of strings) in lexicographic order.
sort_str :
  e[^-1] "Sort image$? in lexicographic order."
  v - y a x
  repeat {round(h/4,1,1)} y={4*$>}
    repeat $! l[$<]
      +rows $y,{$y+3} f[1] 'if(i>=97&&i<=122,i-32,i)' -. 32 c. 0,63 s. y *.. 64 *... 4096 *[-4] 262144 +[-4--1]
      rv a y sort +,x +rows 0 rows[0] 1,100% label[1] %[1] 2
      s[1] +,0 N={$!-1}
      x0=0 repeat {$!-1} x1={$x0+{{1+$>},h}} +z[0] $x0,{$x1-1} x0=$x1 done
      rm[0-$N]
    endl done
  done s x v +

#---------------------------------
#
#@cli :: Mathematical Operators
#
#---------------------------------

#@cli abs : (+)
#@cli : Compute the pointwise absolute values of selected images.
#@cli : $ image.jpg +sub {ia} abs[-1]
#@cli : $ 300,1,1,1,'cos(20*x/w)' +abs display_graph 400,300

#@cli acos : (+)
#@cli : Compute the pointwise arccosine of selected images.
#@cli : $ image.jpg +normalize -1,1 acos[-1]
#@cli : $ 300,1,1,1,'cut(x/w+0.1*u,0,1)' +acos display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands

#@cli acosh : (+)
#@cli : Compute the pointwise hyperbolic arccosine of selected images.

#@cli + : eq. to 'add'. : (+)

#@cli add : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Add specified value, image or mathematical expression to selected images,
#@cli : or compute the pointwise sum of selected images.
#@cli : (eq. to '+').
#@cli : $ image.jpg +add 30% cut 0,255
#@cli : $ image.jpg +blur 5 normalize 0,255 add[1] [0]
#@cli : $ image.jpg add '80*cos(80*(x/w-0.5)*(y/w-0.5)+c)' cut 0,255
#@cli : $ image.jpg repeat 9 +rotate[0] {$>*36},1,0,50%,50% done add div 10

#@cli & : eq. to 'and'. : (+)

#@cli and : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise AND of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential bitwise AND of selected images.
#@cli : (eq. to '&').
#@cli : $ image.jpg and {128+64}
#@cli : $ image.jpg +mirror x and

#@cli argmax
#@cli : Compute the argmax of selected images. Returns a single image
#@cli : with each pixel value being the index of the input image with maximal value.
#@cli : $ image.jpg sample lena,lion,square +argmax
argmax :
  e[^-1] "Compute argmax of image$?."
  v - $!,1,1,1,x ({'{^}'}) l. s +,{','} i[0--1:2] ({'i#'}) y a y str={t} endl rm[-2,-1]
  ${-max_whds},"argmax("$str")" k. nm [argmax] v +

#@cli argmin
#@cli : Compute the argmin of selected images. Returns a single image
#@cli : with each pixel value being the index of the input image with minimal value.
#@cli : $ image.jpg sample lena,lion,square +argmin
argmin :
  e[^-1] "Compute argmin of image$?."
  if {!$!} return fi
  v - $!,1,1,1,x ({'{^}'}) l. s +,{','} i[0--1:2] ({'i#'}) y a y str={t} endl rm[-2,-1]
  ${-max_whds},"argmin("$str")" k. nm [argmin] v +

#@cli asin : (+)
#@cli : Compute the pointwise arcsine of selected images.
#@cli : $ image.jpg +normalize -1,1 asin[-1]
#@cli : $ 300,1,1,1,'cut(x/w+0.1*u,0,1)' +asin display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands

#@cli asinh : (+)
#@cli : Compute the pointwise hyperbolic arcsine of selected images.

#@cli atan : (+)
#@cli : Compute the pointwise arctangent of selected images.
#@cli : $ image.jpg +normalize 0,8 atan[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +atan display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands

#@cli atan2 : [x_argument] : (+)
#@cli : Compute the pointwise oriented arctangent of selected images.
#@cli : Each selected image is regarded as the y-argument of the arctangent function, while the
#@cli : specified image gives the corresponding x-argument.
#@cli : $ (-1,1) (-1;1) resize 400,400,1,1,3 atan2[1] [0] keep[1] mod {pi/8}
#@cli : $$ trigometric-and-inverse-trigometric-commands

#@cli atanh : (+)
#@cli : Compute the pointwise hyperbolic arctangent of selected images.

#@cli << : eq. to 'bsl'. : (+)

#@cli bsl : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise left shift of selected images with specified value, image or
#@cli : mathematical expression, or compute the pointwise sequential bitwise left shift of
#@cli : selected images.
#@cli : (eq. to '<<').
#@cli : $ image.jpg bsl 'round(3*x/w,0)' cut 0,255

#@cli >> : eq. to 'bsr'. : (+)

#@cli bsr : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise right shift of selected images with specified value, image or"
#@cli : mathematical expression, or compute the pointwise sequential bitwise right shift of
#@cli : selected images.
#@cli : (eq. to '>>').
#@cli : $ image.jpg bsr 'round(3*x/w,0)' cut 0,255

#@cli cos : (+)
#@cli : Compute the pointwise cosine of selected images.
#@cli : $ image.jpg +normalize 0,{2*pi} cos[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +cos display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands

#@cli cosh : (+)
#@cli : Compute the pointwise hyperbolic cosine of selected images.
#@cli : $ image.jpg +normalize -3,3 cosh[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +cosh display_graph 400,300

#@cli / : eq. to 'div'. : (+)

#@cli div : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Divide selected images by specified value, image or mathematical expression,
#@cli : or compute the pointwise quotient of selected images.
#@cli : (eq. to '/').
#@cli : $ image.jpg div '1+abs(cos(x/10)*sin(y/10))'
#@cli : $ image.jpg +norm add[-1] 1 +div

#@cli div_complex : [divider_real,divider_imag],_epsilon>=0
#@cli : Perform division of the selected complex pairs (real1,imag1,...,realN,imagN) of images by specified complex pair of images (divider_real,divider_imag).
#@cli : In complex pairs, the real image must be always located before the imaginary image in the image list.
#@cli : Default value: 'epsilon=1e-8'.
div_complex : check ${3=1e-8}>=0
  e[^-1] "Divide complex pair$? by complex pair $1,$2 (with epsilon $3)."
  v - repeat {int($!/2)} pass${1,2} 0 l[$>,{$>+1},-2,-1]
    +*[1,2] +*[0,3] -[-2,-1] # bc-ad
    *[0] [2] *[1] [3] +[0,1] # ac+bd
    sqr[1,2] +[1,2] +[1] $3  # c^2+d^2
    /[2] [1] /[0,1]
  endl done v +

#@cli == : eq. to 'eq'. : (+)

#@cli eq : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean equality of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean equality of selected images.
#@cli : (eq. to '==').
#@cli : $ image.jpg round 40 eq {round(ia,40)}
#@cli : $ image.jpg +mirror x eq

#@cli exp : (+)
#@cli : Compute the pointwise exponential of selected images.
#@cli : $ image.jpg +normalize 0,2 exp[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +exp display_graph 400,300

#@cli >= : eq. to 'ge'. : (+)

#@cli ge : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'greater or equal than' of selected images with specified value, image
#@cli : or mathematical expression, or compute the boolean 'greater or equal than' of selected images.
#@cli : (eq. to '>=').
#@cli : $ image.jpg ge {ia}
#@cli : $ image.jpg +mirror x ge

#@cli > : eq. to 'gt'. : (+)

#@cli gt : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'greater than' of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean 'greater than' of selected images.
#@cli : (eq. to '>').
#@cli : $ image.jpg gt {ia}
#@cli : $ image.jpg +mirror x gt

#@cli <= : eq. to 'le'. : (+)

#@cli le : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'less or equal than' of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean 'less or equal than' of selected images.
#@cli : (eq. to '<=').
#@cli : $ image.jpg le {ia}
#@cli : $ image.jpg +mirror x le

#@cli < : eq. to 'lt'. : (+)

#@cli lt : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean 'less than' of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean 'less than' of selected images.
#@cli : (eq. to '<').
#@cli : $ image.jpg lt {ia}
#@cli : $ image.jpg +mirror x lt

#@cli log : (+)
#@cli : Compute the pointwise base-e logarithm of selected images.
#@cli : $ image.jpg +add 1 log[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +log display_graph 400,300

#@cli log10 : (+)
#@cli : Compute the pointwise base-10 logarithm of selected images.
#@cli : $ image.jpg +add 1 log10[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +log10 display_graph 400,300

#@cli log2 : (+)
#@cli : Compute the pointwise base-2 logarithm of selected images
#@cli : $ image.jpg +add 1 log2[-1]
#@cli : $ 300,1,1,1,'7*x/w+u' +log2 display_graph 400,300

#@cli max : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the maximum between selected images and specified value, image or
#@cli : mathematical expression, or compute the pointwise maxima between selected images.
#@cli : $ image.jpg +mirror x max
#@cli : $ image.jpg max 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@cli m/ : eq. to 'mdiv'. : (+)

#@cli mdiv : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the matrix division of selected matrices/vectors by specified value, image or
#@cli : mathematical expression, or compute the matrix division of selected images.
#@cli : (eq. to 'm/').

#@cli min : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the minimum between selected images and specified value, image or
#@cli : mathematical expression, or compute the pointwise minima between selected images.
#@cli : $ image.jpg +mirror x min
#@cli : $ image.jpg min 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@cli % : eq. to 'mod'. : (+)

#@cli mod : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the modulo of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential modulo of selected images.
#@cli : (eq. to '%').
#@cli : $ image.jpg +mirror x mod
#@cli : $ image.jpg mod 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@cli m* : eq. to 'mmul'. : (+)

#@cli mmul : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the matrix right multiplication of selected matrices/vectors by specified value, image or
#@cli : mathematical expression, or compute the matrix right multiplication of selected images.
#@cli : (eq. to 'm*').
#@cli : $ (0,1,0;0,0,1;1,0,0) (1;2;3) +mmul

#@cli * : eq. to 'mul'. : (+)

#@cli mul : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Multiply selected images by specified value, image or mathematical expression,
#@cli : or compute the pointwise product of selected images.
#@cli : (eq. to '*').
#@cli : $ image.jpg +mul 2 cut 0,255
#@cli : $ image.jpg (1,2,3,4,5,6,7,8) resize[-1] [0] mul[0] [-1]
#@cli : $ image.jpg mul '1-3*abs(x/w-0.5)' cut 0,255
#@cli : $ image.jpg +luminance negate[-1] +mul

#@cli mul_channels : value1,_value2,...,_valueN
#@cli : Multiply channels of selected images by specified sequence of values.
#@cli : $ image.jpg +mul_channels 1,0.5,0.8
mul_channels :
  e[^-1] "Multiply channels of image$? by value sequence ($*)."
  v - $=arg repeat $#,i
    fact=${arg{1+($>%$#)}}
    repeat $! if {$>,$i<s} sh[$>] $i *. $fact rm. fi done
  done v +

#@cli mul_complex : [multiplier_real,multiplier_imag]
#@cli : Perform multiplication of the selected complex pairs (real1,imag1,...,realN,imagN) of images by specified complex pair of images (multiplier_real,multiplier_imag).
#@cli : In complex pairs, the real image must be always located before the imaginary image in the image list.
mul_complex :
  e[^-1] "Multiply complex pair$? by complex pair $1,$2."
  v - repeat {int($!/2)} pass${1,2} 0 l[$>,{$>+1},-2,-1]
    +*[0,3] +*[1,2] +[-2,-1] # ad+bc
    *[0,2] *[1,2] -[0,1] # ac-bd
  endl done v +

#@cli != : eq. to 'neq'. : (+)

#@cli neq : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the boolean inequality of selected images with specified value, image or
#@cli : mathematical expression, or compute the boolean inequality of selected images.
#@cli : (eq. to '!=').
#@cli : $ image.jpg round 40 neq {round(ia,40)}

#@cli | : eq. to 'or'. : (+)

#@cli or : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise OR of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential bitwise OR of selected images.
#@cli : (eq. to '|').
#@cli : $ image.jpg or 128
#@cli : $ image.jpg +mirror x or

#@cli ^ : eq. to 'pow'. : (+)

#@cli pow : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Raise selected images to the power of specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential powers of selected images.
#@cli : (eq. to '^').
#@cli : $ image.jpg div 255 +pow 0.5 mul 255
#@cli : $ image.jpg gradient pow 2 add pow 0.2

#@cli rol : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise left rotation of selected images with specified value, image or
#@cli : mathematical expression, or compute the pointwise sequential bitwise left rotation of
#@cli : selected images.
#@cli : $ image.jpg rol 'round(3*x/w,0)' cut 0,255

#@cli ror : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise right rotation of selected images with specified value, image or
#@cli : mathematical expression, or compute the pointwise sequential bitwise right rotation of
#@cli : selected images.
#@cli : $ image.jpg ror 'round(3*x/w,0)' cut 0,255

#@cli sign : (+)
#@cli : Compute the pointwise sign of selected images.
#@cli : $ image.jpg +sub {ia} sign[-1]
#@cli : $ 300,1,1,1,'cos(20*x/w+u)' +sign display_graph 400,300

#@cli sin : (+)
#@cli : Compute the pointwise sine of selected images.
#@cli : $ image.jpg +normalize 0,{2*pi} sin[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +sin display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands

#@cli sinc : (+)
#@cli : Compute the pointwise sinc function of selected images.
#@cli : $ image.jpg +normalize {-2*pi},{2*pi} sinc[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +sinc display_graph 400,300

#@cli sinh : (+)
#@cli : Compute the pointwise hyperbolic sine of selected images.
#@cli : $ image.jpg +normalize -3,3 sinh[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +sinh display_graph 400,300

#@cli sqr : (+)
#@cli : Compute the pointwise square function of selected images.
#@cli : $ image.jpg +sqr
#@cli : $ 300,1,1,1,'40*x/w+u' +sqr display_graph 400,300

#@cli sqrt : (+)
#@cli : Compute the pointwise square root of selected images.
#@cli : $ image.jpg +sqrt
#@cli : $ 300,1,1,1,'40*x/w+u' +sqrt display_graph 400,300

#@cli - : eq. to 'sub'. : (+)

#@cli sub : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Subtract specified value, image or mathematical expression to selected images,
#@cli : or compute the pointwise difference of selected images.
#@cli : (eq. to '-').
#@cli : $ image.jpg +sub 30% cut 0,255
#@cli : $ image.jpg +mirror x sub[-1] [0]
#@cli : $ image.jpg sub 'i(w/2+0.9*(x-w/2),y)'
#@cli : $ image.jpg +mirror x sub

#@cli tan : (+)
#@cli : Compute the pointwise tangent of selected images.
#@cli : $ image.jpg +normalize {-0.47*pi},{0.47*pi} tan[-1]
#@cli : $ 300,1,1,1,'20*x/w+u' +tan display_graph 400,300
#@cli : $$ trigometric-and-inverse-trigometric-commands

#@cli tanh : (+)
#@cli : Compute the pointwise hyperbolic tangent of selected images.
#@cli : $ image.jpg +normalize -3,3 tanh[-1]
#@cli : $ 300,1,1,1,'4*x/w+u' +tanh display_graph 400,300

#@cli xor : value[%] : [image] : 'formula' : (no arg) : (+)
#@cli : Compute the bitwise XOR of selected images with specified value, image or mathematical
#@cli : expression, or compute the pointwise sequential bitwise XOR of selected images.
#@cli : $ image.jpg xor 128
#@cli : $ image.jpg +mirror x xor

#---------------------------------
#
#@cli :: Values Manipulation
#
#---------------------------------

#@cli apply_curve : 0<=smoothness<=1,x0,y0,x1,y1,x2,y2,...,xN,yN
#@cli : Apply curve transformation to image values.
#@cli : Default values: 'smoothness=1', 'x0=0', 'y0=100'.
#@cli : $ image.jpg +apply_curve 1,0,0,128,255,255,0
apply_curve : check "${1=1}>=0 && $1<=1" skip ${2=0},${3=100}
  e[^-1] "Apply intensity curve with smoothness $1 and keypoints (${2--1}) on image$?."
  v - function1d ${^0} map[^-1] .,1 rm.
  v +

#@cli apply_gamma : gamma>=0
#@cli : Apply gamma correction to selected images.
#@cli : $ image.jpg +apply_gamma 2
apply_gamma : check $1>=0
  e[^-1] "Apply Gamma-correction to image$?, with gamma $1."
  if {$1==1} return fi
  v - repeat $! l[$>] mM={[im,iM]} n 0,1 ^ {1/$1} n $mM endl done v +

#@cli balance_gamma : _ref_color1,...
#@cli : Compute gamma-corrected color balance of selected image, with respect to specified reference color.
#@cli : Default value: 'ref_color1=128'.
#@cli : $ image.jpg +balance_gamma 128,64,64
balance_gamma : skip ${1=128}
  e[^-1] "Apply gamma-corrected color balance of image$?, with reference color ("${^0}")."
  v - repeat $! l[$>]
    (${^0}) r. {-2,s},1,1,1,0,1 s.. c /. 255
    repeat {$!-1} /[$>] 255 ^[$>] {log({@$>})/log({$>,ia})} *[$>] 255 done
    rm. a c c 0,255
  endl done v +

#@cli cast : datatype_source,datatype_target
#@cli : Cast datatype of image buffer from specified source type to specified target type.
#@cli : 'datatype_source' and 'datatype_target' can be { uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.
cast :
  e[^-1] "Cast datatype of image buffer$? from '$1' to '$2'."
  v -
  stype="$1"
  if {s='$stype';s[0]==_'u'&&s[1]!=_'n'} stype="unsigned_"{`s='$stype';s[1,size(s)-1]`}
  elif {s='$stype';s[0]==_'u'&&s[0,9]=='"unsigned "'} stype="unsigned_"{`s='$stype';s[9,size(s)-9]`}
  fi
  dtype="$2"
  if {s='$dtype';s[0]==_'u'&&s[1]!=_'n'} dtype="unsigned_"{`s='$dtype';s[1,size(s)-1]`}
  elif {s='$dtype';s[0]==_'u'&&s[0,9]=='"unsigned "'} dtype="unsigned_"{`s='$dtype';s[9,size(s)-9]`}
  fi
  ssize={s='$stype';s=='"unsigned_char"'||s=='char'?1:s=='"unsigned_short"'||s=='short'?2:s=='"unsigned_int"'||s=='int'||s=='float'?4:8}
  dsize={s='$dtype';s=='"unsigned_char"'||s=='char'?1:s=='"unsigned_short"'||s=='short'?2:s=='"unsigned_int"'||s=='int'||s=='float'?4:8}
  repeat $! l[$>]
    w,h,d,s={[w,h,d,s]}
    serialize $1,0,0
    s -,{'\n$w\ $h\ $d\ $s\n'}
    i[1] ({'\n1\ {int($w*$h*$d*$s*$ssize/$dsize)}\ 1\ 1\n'}) y[1]
    replace_str[0] $stype,$dtype
    a y unserialize
  endl done v +

#@cli complex2polar
#@cli : Compute complex to polar transforms of selected images.
#@cli : $ image.jpg +fft complex2polar[-2,-1] log[-2] shift[-2] 50%,50%,0,0,2 remove[-1]
complex2polar :
  e[^-1] "Compute complex to polar transforms of image$?."
  v - repeat {int($!/2)} l[{2*$>},{2*$>+1}]
    r[1] [0],3 +atan2[1] [0] nm. {1,n} sqr[-3,-2] +[-3,-2] sqrt..
  endl done v +

#@cli compress_clut : _max_error>0,_avg_error>0,_max_nbpoints>=8
#@cli : Compress selected color LUTs as sequences of colored keypoints.
#@cli : Default values: 'max_error=8', 'avg_error=2' and 'max_nb_points=2048'.
compress_clut : check "isint(${1=8}) && $1>0 && ${2=2}>0 && isint(${3=2048}) && $3>8"
  e[^-1] "Compress color LUT$? as a set of colored keypoints, with maximum error $1, average error $2 and $3 maximum keypoints."
  v - max_error,avg_error,max_keypoints=${1--1}
  repeat $! l[$>] nm={b}
    if {iM>255} / 257 fi # When input is 16bits
    if {d==1} S={round(cbrt(wh))} r $S,$S,$S,100%,-1 fi # When input is a 2D haldclut image
    v + e[] "\n* Process CLUT '"$nm"' ("{w}"x"{h}"x"{d}")." v -

    # Initialize keypoints (corners of the RGB cube).
    1,8,1,{s+3}
    eval "
      coords = [ 0,0,0, 255,0,0, 255,255,0, 0,255,0, 0,0,255, 255,0,255, 255,255,255, 0,255,255 ];
      for (k = 0, k<size(coords)/3, ++k,
        P = coords[3*k,3];
        I[k] = [ P, I(#0,round(P*([w#0,h#0,d#0]-1)/255)) ]
      )"

    # Iteratively add keypoints.
    sep="\n"
    do
      +decompress_clut. {0,[w,h,d]} -. [0] norm. emax,eavg={[iM,ia]}
      v + e[] "\r"$sep"  > Add [#"{1,h}"] Max_Err = "{_$emax}", Avg_Err = "{_$eavg}"         " v - sep=""
      if {$emax<=$max_error" && "$eavg<=$avg_error} rm. break fi
      1,1,1,{0,s+3},{"P = [ xM,yM,zM ]; [ round(P*255/[max(1,w#0-1),max(1,h#0-1),max(1,d#0-1)]), I(#0,P) ]"} rm..
      a[-2,-1] y
    while {1,h<$max_keypoints}

    # Iteratively remove keypoints.
    max_error,avg_error={[max($max_error,round($emax,1,1)),max($avg_error,round($eavg,0.25,1))]}
    index=0 sep="\n"
    do
      +l. s y rm[$index] a y endl # Remove random keypoint
      +decompress_clut. {0,[w,h,d]} -. [0] norm. emax,eavg={[iM,ia]} rm.
      if {$emax<=$max_error" && "$eavg<=$avg_error} rv[-2,-1] else index+=1 fi
      v + e[] "\r"$sep"  > Rem [#"{1,min($index,h-1)}"/"{1,h}"] Max_Err = "{_$emax}", Avg_Err = "{_$eavg}"       " v - sep=""
      rm.
    while {$index<h}
    k.

    # Sort keypoints by lexicographic order.
    1,100%,1,1,"P = I(#0); P[0]*65536 + P[1]*256 + P[2]" rv a x sort +,y z. 1,100%
    to_clutname $nm nm ${}

  endl done v +

# compress_cluts : "file_pattern" : "file_list.txt"
# Batch compress CLUT files.
compress_cluts :
  v - rm
  if "$1" i raw:"$1",uchar s -,{'\n'}
  else files "$1" ({'${}'}) s -,{','}
  fi
  rv
  repeat $! l[$<]
    filename={t} 0 nm. $filename ext={x} rm
    basename $filename
    l[] ({'${}'}) replace_str .$ext,"" basename={t} rm endl
    need_compression=1
    cclut=cclut_rbf_$basename.gmz

    if $cclut
      i $cclut
      if {"dat = (date(5) + 60*(date(4) + date(2)*24));
           fdat = (date(5,'"$cclut"') + 60*(date(4,'"$cclut"') + date(2,'"$cclut"')*24));
           !h && dat-fdat<30"}
        v + e[] "* Skip file '"$filename"' (CLUT already being compressed)." v -
        need_compression=0
      elif {h>0" && "h!=2048}
        v + e[] "* Skip file '"$filename"' (CLUT already compressed)." v -
        need_compression=0
      fi
      rm.
    fi

    if $need_compression
      0 o. $cclut rm. # Lock current file
      if {lowercase(['$ext'])=='cube'} input_cube $filename
      elif {lowercase(['$ext'])=='png'} i $filename S={round(cbrt(wh))} r $S,$S,$S,100%,-1
      else v + e[] "* Skip file '"$filename"' (unknown CLUT format)." v - continue
      fi

      v + e[] "* Compress file '"$filename"'." v -
      if {w>64} r3dx 64 fi
      to_rgb
      v + tic compress_clut ,,2047 toc v -
      o $cclut
    fi
  endl done v +

#@cli compress_rle : _is_binary_data={ 0 | 1 },_maximum_sequence_length>=0
#@cli : Compress selected images as 2xN data matrices, using RLE algorithm.
#@cli : Set 'maximum_sequence_length=0' to disable maximum length constraint.
#@cli : Default values: 'is_binary_data=0' and 'maximum_sequence_length=0'.
#@cli : $ image.jpg resize2dy 100 quantize 4 round +compress_rle , +decompress_rle[-1]
compress_rle : skip ${1=0} check "isint(${2=0}) && $2>=0"
  v - s0=" for binary data" s1=""
  if $2 s=", with maximal sequence length "$2 else s="" fi
  v + e[^-1] "Compress image$? using RLE algorithm"${s{!$1}}$s"." v -
  repeat $! l[$>] nm={0,n} im={im} header={w};{h};{d};{s};$im;{$1!=0}
    - $im y x ({{0,@-1}+1}) a x r 100%,3
    f '>if(y==0,i,if(y==1,if(i(x,0)==i(x+1,0),-1,x),if(i(x-1,1)==-1,i(x-1,2)+1,1)))'
    if $2 # Constrain maximum sequence length.
      transpose mirror x
      f. '>if(x==2,i,if(x==0,if(j(0,-1)==$2,1,if(i!=1,j(0,-1)+1,1)),if(i==-1&&j(-1)==$2,y,i)))'
      mirror x transpose
    fi
    z 0,{w-2} s y,3 discard[1] -1 warp[0,2] [1],0,0 rm[1]
    if $1 # Encode for binary data.
      !=[0] 0 *[0] 2 -[0] 1 *
    else # Encode for arbitrary data.
      *. -1 rv a x y discard -1 f '>if(i(0,y-1)<0&&i==0&&i(0,y+1)<0,-1,i)' discard -1
    fi
    i[0] ($header) a y nm $nm
  endl done v +

#@cli cumulate : { x | y | z | c }...{ x | y | z | c } : (no arg) : (+)
#@cli : Compute the cumulative function of specified image data, optionally along the specified axes.
#@cli : $ image.jpg +histogram +cumulate[-1] display_graph[-2,-1] 400,300,3

#@cli c : eq. to 'cut'. : (+)

#@cli cut : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (no arg) : (+)
#@cli : Cut values of selected images in specified range.
#@cli : (eq. to 'c').\n
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : In interactive mode, the chosen cut values are returned in the status.
#@cli : $ image.jpg +add 30% cut[-1] 0,255
#@cli : $ image.jpg +cut 25%,75%

#@cli decompress_clut : _width>0,_height>0,_depth>0
#@cli : Decompress selected colored keypoints into 3D CLUTs.
#@cli : Default value: 'width=height=depth=64'.
decompress_clut : check "isint(${1=64}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=$1}) && $3>0"
  e[^-1] "Decompress colored keypoint$? into $1x$2x$3 CLUTs."
  v - repeat $! l[$>]
    if {w==6" && "s==1} permute cyzx fi # Manage old way of storing keypoints
    1,1,1,{s-3}
    do
      +f. 0 .,.,.,1
      eval[0] "PC = I; X = round(PC[0,3]*([w#1,h#1,d#1] - 1)/255); I(#2,X)+=PC[3,s-3]; ++i(#3,X); I"
      f. "*i?(I(#2)/=i;1):0"
      if {im} rm[-3,-1] # No missing data so far
      else # Reconstruct missing data by anisotropic diffusion scheme
        +distance. 1 .,.,.,3
        eval.. "* # Specific gradient discretization for distance function
          const boundary = 1;
          maxabs(a,b) = (abs(a)>abs(b)?a:b);
          I(#-1) = [ maxabs(j(1) - i,i - j(-1)),
                     maxabs(j(0,1) - i,i - j(0,-1)),
                     maxabs(j(0,0,1) - i,i - j(0,0,-1)) ]"
        orientation. rm..
        repeat 20
          j[-4] ...,0,0,0,0,1,..
          +warp[-4] .,1,2,1 *.. -1 warp[-5] ..,1,2,1 +[-5,-1] /[-4] 2
        done
        j[-4] ...,0,0,0,0,1,.. k[0,1]
      fi
      if {"w<$1 || h<$2 || d<$3"} r. {[min($1,2*w),min($2,2*h),min($3,2*d)]},100%,3 else break fi
    while 1 k.
  endl done v +

#@cli decompress_rle
#@cli : Decompress selected data vectors, using RLE algorithm.
decompress_rle :
  e[^-1] "Decompress data vector$?, using RLE algorithm."
  v - repeat $! l[$>]

    # Retrieve original data dimension and min value.
    y whds={0,@0-3} im={0,@4} is_binary_data={0,@5} rows 6,100%

    # Transform RLE data to list of pairs {nb_occurrences,value}.
    if $is_binary_data  # Decode for binary data.
      +>= 0 abs[0] a x
    else # Decode for arbitrary data
      +<. 0
      (0;1;1)
      erode.. .,0 rm. -. 1 a x discard -1 # Get back compressed '0' (minimum) values.
      +< 0 (0;1;1) dilate.. . rm. *. -2 +. 1 # Get back singletons.
      rv abs. a x discard -1
      r 2,{h/2},1,1,-1
    fi

    # Decompress, using 3D objects.
    s y,-256
    repeat $! l[$>]
      i[0] ({'CImg3d'}) +[0] 0.5
      i[1] ({2*h};{h})
      s. x,2 cumulate.. siz={-2,@-1}
      +shift.. 0,1 -... 1 rv[-3,-1] z[-3,-1] 0,2 a[-3,-1] x
      i[3] (2,0,1;2,{2*h-2},{2*h-1}) r[3] 3,{h},1,1,3 round[3]
      r[4] 3 1,100%,1,1,1 y a y
      $siz j3d. ..,0,0,0,1,2,0,0 rm..
    endl done
    a x r $whds,-1 + $im
  endl done v +

#@cli discard : _value1,_value2,... : { x | y | z | c}...{ x | y | z | c},_value1,_value2,... : (no arg) : (+)
#@cli : Discard specified values in selected images or discard neighboring duplicate values,
#@cli : optionally only for the values along the first of a specified axis.
#@cli : If no values are specified, neighboring duplicate values are discarded.
#@cli : If all pixels of a selected image are discarded, an empty image is returned.
#@cli : $ (1;2;3;4;3;2;1) +discard 2
#@cli : $ (1,2,2,3,3,3,4,4,4,4) +discard x

#@cli eigen2tensor
#@cli : Recompose selected pairs of eigenvalues/eigenvectors as 2x2 or 3x3 tensor fields.
#@cli : $$
eigen2tensor :
  e[^-1] "Recompose pairs in eigen field$? as 2x2 or 3x3 tensor fields."
  v - repeat {$!/2} l[$>,{$>+1}] nm={0,n}
    if {s==2} # 2D tensors.
      s. c
      +sqr. *.. ... sqr... # u^2 uv v^2
      sh. +*... -1
      sh[-5]     # v^2 -uv u^2
      a[-3--1] c a[-4--2] c
      sh... 0 *[-3,-1]          # l1*(u^2;uv;v^2)
      sh... 1 *[-2,-1]          # l2*(v^2;-uv;u^2)
      rm... +[-2,-1]
    elif {s==6} # 3D tensors.
      s. c
      l[-6--4] +sqr.. +*[-2,-3] +sqr... *[-5] [-6] *[-4] [-6] sqr[-6] a c endl
      l[-3--1] +sqr.. +*[-2,-3] +sqr... *[-5] [-6] *[-4] [-6] sqr[-6] a c endl
      s... c
      -[-5] ... -[-4] ... *.. [-5] *. [-4]
      (1^0^0^1^0^1) r. ... *. [-4] rm[-6--4] +[-3--1]
    else v + error[0--3] "Command '$0': Invalid image ["{$!-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2D or 3D eigenvectors."
    fi
  nm $nm endl done v +

#@cli endian : _datatype : (+)
#@cli : Reverse data endianness of selected images, eventually considering the pixel being of the specified datatype.
#@cli : 'datatype' can be { uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.

#@cli equalize : _nb_levels>0[%],_value_min[%],_value_max[%] : (+)
#@cli : Equalize histograms of selected images.
#@cli : If value range is specified, the equalization is done only for pixels in the specified
#@cli : value range.
#@cli : Default values: 'nb_levels=256', 'value_min=0%' and 'value_max=100%'.
#@cli : $ image.jpg +equalize
#@cli : $ image.jpg +equalize 4,0,128

#@cli f : eq. to 'fill'. : (+)

#@cli fill : value1,_value2,... : [image] : 'formula' : (+)
#@cli : Fill selected images with values read from the specified value list, existing image
#@cli : or mathematical expression. Single quotes may be omitted in 'formula'.
#@cli : (eq. to 'f').
#@cli : $ 4,4 fill 1,2,3,4,5,6,7
#@cli : $ 4,4 (1,2,3,4,5,6,7) fill[-2] [-1]
#@cli : $ 400,400,1,3 fill "X=x-w/2; Y=y-h/2; R=sqrt(X^2+Y^2); a=atan2(Y,X); if(R<=180,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))"
#@cli : $$

#@cli index : { [palette] | predefined_palette },0<=_dithering<=1,_map_palette={ 0 | 1 } : (+)
#@cli : Index selected vector-valued images by specified vector-valued palette.
#@cli : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@cli : Default values: 'dithering=0' and 'map_palette=0'.
#@cli : $ image.jpg +index 1,1,1
#@cli : $ image.jpg (0;255;255^0;128;255^0;0;255) +index[-2] [-1],1,1
#@cli : $$

#@cli ir : eq. to 'inrange'.
ir :
  v - _gmic_s="$?" v +
  _inrange $*

#@cli inrange : min[%],max[%]
#@cli : Detect pixels whose values are in specified range [min,max], in selected images.
#@cli : (eq. to 'ir').
#@cli : $ image.jpg +inrange 25%,75%
inrange :
  v - _gmic_s="$?" v +
  _$0 $*

_inrange :
  e[0--3] "Detect pixel values in range [$1,$2] in image"$_gmic_s"."
  v - repeat $! l[$>]
    m=$1 M=$2
    if ${is_percent\ $1} m={im+(iM-im)*$1} fi
    if ${is_percent\ $2} M={im+(iM-im)*$2} fi
    - {0.5*($m+$M)} abs <= {0.5*abs($M-$m)}
  endl done v +

#@cli map : [palette],_boundary_conditions : predefined_palette,_boundary_conditions : (+)
#@cli : Map specified vector-valued palette to selected indexed scalar images.
#@cli : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'boundary_conditions=0'.
#@cli : $ image.jpg +luminance map[-1] 3
#@cli : $ image.jpg +rgb2ycbcr split[-1] c (0,255,0) resize[-1] 256,1,1,1,3 map[-4] [-1] remove[-1] append[-3--1] c ycbcr2rgb[-1]
#@cli : $$

#@cli map_clut : [clut] | "clut_name"
#@cli : Map specified RGB color LUT to selected images.
#@cli : $ image.jpg uniform_distribution {2^6},3 mirror[-1] x +map_clut[0] [1]
map_clut :
  e[^-1] "Map color LUT $1 on image$?."
  if {!$!} return fi
  v - to_color
  if ${"is_image_arg $1"} pass$1 0 to_rgb. else clut "$1" fi
  l={round((w*h*d)^(1/3))}
  if {w*h*d!=$l^3} v + error "Command '$0': Specified CLUT $1 has invalid dimensions "({w},{h},{d},{s}). fi
  r. $l,$l,$l,3,-1
  repeat {$!-1} l[$>,-1] nm={0,n} split_opacity[0] /[0] {256/$l}
    +warp. [0],0,1,1
    rm[0] mv. 0 a[^-1] c nm[0] $nm
  endl done rm. v +

#@cli mix_channels : (a00,...,aMN) : [matrix]
#@cli : Apply specified matrix to channels of selected images.
#@cli : $ image.jpg +mix_channels (0,1,0;1,0,0;0,0,1)
mix_channels :
  e[^-1] "Apply matrix $1 to channels of image$?."
  v -
  if ${"is_image_arg $1"} pass$1 1 else i ${^0} fi
  repeat {$!-1} l[$>] nm={n}
    whd={[w,h,d]} r. {[whd,s]},1,1,-1
    pass. 0 mv. 0 m* r $whd,{h},-1
  nm $nm endl done rm. v +

#@cli negate : base_value : (no arg)
#@cli : Negate image values.
#@cli : Default value: 'base_value=(undefined)'.
#@cli : $ image.jpg +negate
negate : skip "${1=,}"
  if {isval("$*")}
    e[0--3] "Negate values of image$?, according to base value $*."
    v - - {"$*"} * -1 v +
  else
    e[0--3] "Negate values of image$?."
    v - repeat $! -[$>] {$>,iM} done * -1
    if {;['"$1"']!=','} noarg fi
    v +
  fi

#@cli noise : std_deviation>=0[%],_noise_type : (+)
#@cli : Add random noise to selected images.
#@cli : 'noise_type' can be { 0=gaussian | 1=uniform | 2=salt&pepper | 3=poisson | 4=rice }.
#@cli : Default value: 'noise_type=0'.
#@cli : $ image.jpg +noise[0] 50,0 +noise[0] 50,1 +noise[0] 10,2 cut 0,255
#@cli : $ 300,300,1,3 [0] noise[0] 20,0 noise[1] 20,1 +histogram 100 display_graph[-2,-1] 400,300,3

#@cli noise_perlin : _scale_x[%]>0,_scale_y[%]>0,_scale_z[%]>0,_seed_x,_seed_y,_seed_z
#@cli : Render 2D or 3D Perlin noise on selected images, from specified coordinates.
#@cli : The Perlin noise is a specific type of smooth noise, described here : 'https://en.wikipedia.org/wiki/Perlin_noise'.
#@cli : Default values: 'scale_x=scale_y=scale_z=16' and 'seed_x=seed_y=seed_z=0'.
#@cli : $$ 500,500,1,3 noise_perlin ,
noise_perlin : check "${1=16}>0 && ${2=$1}>0 && ${3=$1}>0 && isval(${4=0}) && isval(${5=0}) && isval(${6=0})"
  e[^-1] "Render Perlin noise on image$?, with scales (${1-3}) and seeds (${4-6})."
  v -
  init="permutation = [ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
          190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,
          168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,
          244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,
          198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,
          28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,
          113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,
          239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,
          24,72,243,141,128,195,78,66,215,61,156,180 ];
        p = [ permutation,permutation ];
        fade(t) = (t*t*t*(t*(t*6 - 15) + 10));
        lerp(t,a,b) = (a + t*(b - a));
        pcmod255 = vectors(); for (k = 0, k<s, ++k, pcmod255[k] = p[k%255]);
        sx = ['$1']; is_px = sx[size(sx) - 1]==_'%';
        sy = ['$2']; is_py = sy[size(sy) - 1]==_'%';
        sz = ['$3']; is_pz = sz[size(sz) - 1]==_'%';
        x0 = $4;
        y0 = $5;
        z0 = $6;
        x1 = x0 + (is_px?1/$1:w/$1);
        y1 = y0 + (is_py?1/$2:h/$2);
        z1 = z0 + (is_pz?1/$3:d/$3);
        fw = (x1 - x0)/max(w - 1,1);
        fh = (y1 - y0)/max(h - 1,1);
        fd = (z1 - z0)/max(d - 1,1);"

  repeat $! if {$>,d>1} # 3D version
    f[$>] "*begin("$init" grad(hash,x,y,z) = ( gh = hash&15; gu = gh<8?x:y; gv = gh<4?y:gh==12 || gh==14?x:z; (!(gh&1)?gu:-gu) + (!(gh&2)?gv:-gv)));
       x = x0 + x*fw + pcmod255[c]; y = y0 + y*fh + pcmod255[c]; z = z0 + z*fd + pcmod255[c];
       ix = floor(x); iy = floor(y); iz = floor(z);
       X = ix&255; Y = iy&255; Z = iz&255;
       fx = x - ix; fy = y - iy; fz = z - iz;
       u = fade(fx); v = fade(fy); w = fade(fz);
       A = p[X] + Y; AA = p[A] + Z; AB = p[A + 1] + Z;
       B = p[X + 1] + Y; BA = p[B] + Z; BB = p[B + 1] + Z;
       fx1 = fx - 1; fy1 = fy - 1; fz1 = fz - 1;
       lerp(w,lerp(v,lerp(u,grad(p[AA],fx,fy,fz),
                            grad(p[BA],fx1,fy,fz)),
                      lerp(u,grad(p[AB],fx,fy1,fz),
                             grad(p[BB],fx1,fy1,fz))),
               lerp(v,lerp(u,grad(p[AA + 1],fx,fy,fz1),
                             grad(p[BA + 1],fx1,fy,fz1)),
                      lerp(u,grad(p[AB + 1],fx,fy1,fz1),
                             grad(p[BB+1],fx1,fy1,fz1))))"
  else # 2D version
    f[$>] "*begin("$init" grad(hash,x,y) = ( gh = hash&15; gu = gh<8?x:y; gv = gh<4?y:gh==12 || gh==14?x:0; (!(gh&1)?gu:-gu) + (!(gh&2)?gv:-gv)));
       x = x0 + x*fw + pcmod255[c]; y = y0 + y*fh + pcmod255[c];
       ix = floor(x); iy = floor(y);
       X = ix&255; Y = iy&255;
       fx = x - ix; fy = y - iy;
       u = fade(fx); v = fade(fy);
       A = p[X] + Y; B = p[X + 1] + Y;
       fx1 = fx - 1; fy1 = fy - 1;
       lerp(v,lerp(u,grad(p[A],fx,fy),
                     grad(p[B],fx1,fy)),
              lerp(u,grad(p[A + 1],fx,fy1),
                     grad(p[B + 1],fx1,fy1)))"
  fi done v +

#@cli noise_poissondisk : _radius[%]>0,_max_sample_attempts>0
#@cli : Add poisson disk sampling noise to selected images.
#@cli : Implements the algorithm from the article "Fast Poisson Disk Sampling in Arbitrary Dimensions", by Robert Bridson (SIGGRAPH'2007).
#@cli : Default values: 'radius=8' and 'max_sample_attempts=30'.
#@cli : $ 300,300 noise_poissondisk 8
##### : Original G'MIC code by Garagecoder (Andy Kelday)
noise_poissondisk : check "${1=8}>0 && ${2=30}>0"
  e[^-1] "Add poisson disk sampling points to image$?, with radius $1 and max sample attempts $2."
  v - repeat $! l[$>]
    R={${"is_percent $1"}?max(w,h,d)*$1:$1} # [0] input image to draw samples on
    dim={d>1?3:h>1?2:1} cw={0.999*$R/sqrt($dim)} # dimensions, grid cell width
    ({[w,h,d,1]}) y. c  # [1] image dimensions vector
    {[ceil(I/$cw)]}     # [2] "accelerator" grid/cells
    r[1] 1,1,1,$dim,-1  # keep only used dimensions in [1]
    1,1,1,$dim 1,1,1,1  # [3] samples list, [4] active list
    {vector$dim(2*ceil(sqrt($dim))+1)} r. 100%,100%,100%,2 # [5] cell proximity kernel
    f. "P=[x,y,z]-int([w/2,h/2,d/2]);[sum(sqr(P)),dot(P,[1,w#2,w#2*h#2])]"
    r. {[whd,s,1,1,-1]} sort. +,x z. 0,1,100%,100% y. c # sort kernel by distance
    nm[1] dims nm[2] grid nm[3] samples nm[4] active nm[5] prox
    eval ${-math_lib}"
      begin(
        dotoff = resize([ 1,w#2,w#2*h#2 ],d#2>1?3:h#2>1?2:1,0);
      );
      const N = "$dim";
      const radius = "$R";
      const grid_cw = "$cw";
      const max_sample_attempts = $2;
      const value = iM#0 + (im#0==iM#0);
      mag2(vec) = sum(sqr(vec));
      prox = I#5;
      lim = I#1;

      dar_insert(#3,I#1,0);               # dummy sample to simplify bounds checks
      dar_insert(#3,u(I#1),1);            # add initial sample to list
      dar_insert(#4,1,0);                 # add its index to active list
      I(#2,int(I[#3,1]/grid_cw)) = 1;     # add its index to grid cell
      I(#0,I[#3,1]) = value;              # draw the point

      while (dar_size(#4)>0,
        R = int(u(dar_size(#4)-1e-4));    # choose a random active list index
        P = i[#4,R];                      # get the index of that sample
        T = I[#3,P];                      # position vector of that sample

        for (attempts=0, attempts < max_sample_attempts, ++attempts,

          do (S = 4*(u(vectorN(1)) - 0.5); M = mag2(S), M <= 1 || M > 4);

          X = T + radius * S;             # potential sample from annulus around T
          if (min(X)<0 || min(lim-X)<0, continue()); # check within bounds

          # check proximity of surrounding points
          G = int(X/grid_cw);             # grid cell position vector
          GI = dot(G,dotoff);    # grid cell direct buffer index

          for (K = 0; rejected = 0, K<size(prox), ++K,
            V = i[#2,GI+prox[K]];         # sample index from grid to check
            if (V>0 && mag2(I[#3,V]-X)<sqr(radius), rejected = 1;break())
          );

          if (!rejected,
            Q = dar_size(#3);               # sample found, get new index
            dar_insert(#3,X);               # insert into samples list
            dar_insert(#4,Q);               # insert its index into active
            I(#2,G) = Q;                    # insert its index into grid
            I(#0,X) = value;                # draw the point
            break();
          );
        );
        if (attempts == max_sample_attempts, dar_remove(#4,R));
      );
    " k[0]
  endl done v +

#@cli normp : p>=0
#@cli : Compute the pointwise Lp-norm norm of vector-valued pixels in selected images.
#@cli : Default value: 'p=2'.
#@cli : $ image.jpg +normp[0] 0 +normp[0] 1 +normp[0] 2 +normp[0] inf
normp : check "isval(${1==2}) && $1>=0"
  e[^-1] "Compute pointwise L"$1"-norm of vectors, in image$?."
  v -
  if {$1==0} != 0 compose_channels +
  elif {$1==1} abs compose_channels +
  elif {$1==2} norm
  elif {$1==inf} abs compose_channels max
  else ^ $1 compose_channels + ^ {1/$1}
  fi
  v +

#@cli norm
#@cli : Compute the pointwise euclidean norm of vector-valued pixels in selected images.
#@cli : $ image.jpg +norm
#@cli : $$
norm :
  e[^-1] "Compute pointwise euclidean norm of vectors, in image$?."
  v - sqr compose_channels + sqrt v +

#@cli n : eq. to 'normalize'. : (+)

#@cli normalize : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (+)
#@cli : Linearly normalize values of selected images in specified range.
#@cli : (eq. to 'n').
#@cli : $ image.jpg split x,2 normalize[-1] 64,196 append x
#@cli : $$

#@cli normalize_sum
#@cli : Normalize selected images with a unitary sum.
#@cli : $ image.jpg +histogram normalize_sum[-1] display_graph[-1] 400,300
normalize_sum :
  e[^-1] "Normalize image$? with a unitary sum."
  v - repeat $! /[$>] {sum={$>,is};if(sum!=0,sum,1)} done v +

#@cli not
#@cli : Apply boolean not operation on selected images.
#@cli : $ image.jpg +ge 50% +not[-1]
not :
  e[^-1] "Apply boolean not operation on image$?."
  v - == 0 v +

#@cli orientation
#@cli : Compute the pointwise orientation of vector-valued pixels in selected images.
#@cli : $ image.jpg +orientation +norm[-2] negate[-1] mul[-2] [-1] reverse[-2,-1]
#@cli : $$
orientation :
  e[^-1] "Compute pointwise orientation vectors, in image$?."
  v - repeat $! +norm[$>] replace. 0,1 /[$>,-1] done v +

#@cli oneminus
#@cli : For each selected image, compute one minus image.
#@cli : $ image.jpg normalize 0,1 +oneminus
oneminus :
  e[^-1] "Compute one minus selected images$?."
  v + * -1 + 1 v -

#@cli otsu : _nb_levels>0
#@cli : Hard-threshold selected images using Otsu's method.
#@cli : The computed thresholds are returned as a list of values in the status.
#@cli : Default value: 'nb_levels=256'.
#@cli : $ image.jpg luminance +otsu ,
otsu : check "isint(${1=256}) && $1>0"
  e[^-1] "Hard-threshold image$? using Otsu\47s method, with $1 histogram levels."
  v - repeat $! l[$>]
    imM={[im,iM]} +histogram $1,$imM
    otsu={"
      sum = sumB = wB = best_variance = best_t = 0;
      for (t = 0, t<w, ++t, sum+=t*i[t]);
      for (t = 0, t<w, ++t,
        wB+=i[t];
        if (!wB, continue());
        wF = whds#-2 - wB;
        if (!wF, break());
        sumB+=t*i[t];
        mB = sumB/wB;
        mF = (sum - sumB)/wF;
        variance = wB*wF*(mB - mF)^2;
        if (variance>best_variance, best_variance = variance; best_t = t);
      );
      imM = ["$imM"];
      imM[0] + best_t*(imM[1] - imM[0])/(w - 1)"}
    rm. >=. $otsu
    if $> u ${},$otsu else u $otsu fi
  endl done v +

#@cli polar2complex
#@cli : Compute polar to complex transforms of selected images.
polar2complex :
  e[^-1] "Compute polar to complex transforms of image$?."
  v - repeat {int($!/2)} l[{2*$>},{2*$>+1}]
    r[1] [0],3 +sin. cos.. *. ... *[-3,-2]
  endl done v +

#@cli quantize : nb_levels>=1,_keep_values={ 0 | 1 },_is_uniform={ 0 | 1 }
#@cli : Quantize selected images.
#@cli : Default value: 'keep_values=1' and 'is_uniform=0'.
#@cli : $ image.jpg luminance +quantize 3
#@cli : $ 200,200,1,1,'cos(x/10)*sin(y/10)' +quantize[0] 6 +quantize[0] 4 +quantize[0] 3 +quantize[0] 2
quantize : check "isint($1) && $1>=1" skip ${2=1},${3=0}
  e[^-1] "Quantize image$? using $1 levels, "${arg\ 1+!$2,with,without}" keeping value range."
  v - repeat $! l[$>]
    if $3 # Uniform quantization.
      if {s==1} # Greyscale image.
        if $2 mM={[im,iM]} n 0,$1 round 1,-1 min {$1-1} n $mM
        else n 0,$1 round 1,-1 min {$1-1} fi
      else mM={[im,iM]} uniform_distribution $1,{s} n. $mM index.. .,0,$2 rm.
      fi
    else +colormap $1,1,1 index.. .,0,$2 rm. # Non-uniform quantization.
    fi
  endl done v +

#@cli quantize_area : _min_area>0
#@cli : Quantize selected images such that each flat region has an area greater or equal to 'min_area'.
#@cli : Default value: 'min_area=10'.
#@cli : $ image.jpg quantize 3 +blur 1 round[-1] +quantize_area[-1] 2
quantize_area : check "${1=10}>0"
  e[^-1] "Quantize image$? by regions of areas greater than $1."
  v -
  if {$1==1} v + return fi
  repeat $! l[$>]
    if {s>1} +f. "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm. round. 0.01 else [0] fi
    area. 0,0 <. $1
    do
      [0]
      f.. "*
        begin(
          const boundary = 1;
          offx = [ -1,1,0,0,0,0 ];
          offy = [ 0,0,-1,1,0,0 ];
          offz = [ 0,0,0,0,-1,1 ];
          nb_offs = d>1?6:h>1?4:2;
        );
        is_neighbor = j(-1) && j(-1);
        if (h>1, is_neighbor&=j(1,0) && j(0,1));
        if (d>1, is_neighbor&=j(0,0,-1) && j(0,0,1));
        is_neighbor = !is_neighbor;
        i && is_neighbor?(
          col0 = I(#0);
          kmin = -1;
          distmin = inf;
          for (k = 0, k<nb_offs, ++k,
            p = offx[k];
            q = offy[k];
            r = offz[k];
            if (!j(p,q,r),
              col = J(#0,p,q,r);
              dist = norm(col-=col0);
              if (dist<distmin, distmin = dist; kmin = k);
            );
          );
          if (kmin>=0,
            I(#-1) = J(#0,offx[kmin],offy[kmin],offz[kmin]);
            0,
            1
          );
        ):i"
      rv[0,-1] rm.
    while {iM}
    rm.
  endl done v +

#@cli rand : { value0[%] | [image0] },_{ value1[%] | [image1] } : [image] : (+)
#@cli : Fill selected images with random values uniformly distributed in the specified range.
#@cli : $ 400,400,1,3 rand -10,10 +blur 10 sign[-1]

#@cli replace : source,target
#@cli : Replace pixel values in selected images.
#@cli : $ (1;2;3;4) +replace 2,3
replace :
  e[^-1] "Replace pixel values $1 with $2 in image$?."
  v - f "i==$1?$2:i" v +

#@cli replace_inf : _expression
#@cli : Replace all infinite values in selected images by specified expression.
#@cli : $ (0;1;2) log +replace_inf 2
replace_inf :
  e[^-1] "Replace all infinite values in image$? by expression '$1'."
  v - f "isinf(i)?$1:i" v +

#@cli replace_nan : _expression
#@cli : Replace all NaN values in selected images by specified expression.
#@cli : $ (-1;0;2) sqrt +replace_nan 2
replace_nan :
  e[^-1] "Replace all NaN values in images$? by expression '$1'."
  v - f "isnan(i)?$1:i" v +

#@cli replace_seq : "search_seq","replace_seq"
#@cli : Search and replace a sequence of values in selected images.
#@cli : $ (1;2;3;4;5) +replace_seq "2,3,4","7,8"
replace_seq : skip "${2=}"
  e[^-1] "Replace value sequence '$1' by value sequence '${2--1}' in image$?."
  v - ns,nd={[narg($1),narg(${2--1})]}
  repeat $! l[$>]
    s +,$1 ind={"w#0 && crop(#0,0,0,0,0,1,min("$ns",h#0),1,1)!=[$1]"}
    if {$ind<$!}
      if $nd
        eval "for (t = "$ind", t<l, t+=2, resize(#t,1,round(h#t*"$nd/$ns"),1,1,0))"
        f[$ind--1:2] ${2--1}
      else
        rm[$ind--1:2]
      fi
      a y
    fi
  endl done v +

#@cli replace_str : "search_str","replace_str"
#@cli : Search and replace a string in selected images (viewed as strings, i.e. sequences of ascii codes).
#@cli : $ ({'"Hello there, how are you ?"'}) +replace_str "Hello there","Hi David"
replace_str : skip "${2=}"
  e[^-1] "Replace string '$1' by string '${2--1}' in image$? (viewed as string$?)."
  v -
  replace_seq {``{'"$1"'}},{'"${2--1}"'}
  v +

#@cli round : rounding_value>=0,_rounding_type : (no arg) : (+)
#@cli : Round values of selected images.
#@cli : 'rounding_type' can be { -1=backward | 0=nearest | 1=forward }.
#@cli : Default value: 'rounding_type=0'.
#@cli : $ image.jpg +round 100
#@cli : $ image.jpg mul {pi/180} sin +round

#@cli roundify : gamma>=0
#@cli : Apply roundify transformation on float-valued data, with specified gamma.
#@cli : Default value: 'gamma=0'.
#@cli : $ 1000 fill '4*x/w' repeat 5 +roundify[0] {$>*0.2} done append c display_graph 400,300
roundify : check $1>=0
  e[^-1] "Roundify image$?, with gamma $1."
  if {$1==1} return fi
  v - repeat $! l[$>]
    +round 1 -.. . +*.. 2 abs. ^. $1 sign... *[-3,-1] *.. 0.5 +
  endl done v +

#@cli = : eq. to 'set'. : (+)

#@cli set : value,_x[%],_y[%],_z[%],_c[%] : (+)
#@cli : Set pixel value in selected images, at specified coordinates.
#@cli : (eq. to '=').\n
#@cli : If specified coordinates are outside the image bounds, no action is performed.
#@cli : Default values: 'x=y=z=c=0'.
#@cli : $ 2,2 set 1,0,0 set 2,1,0 set 3,0,1 set 4,1,1
#@cli : $ image.jpg repeat 10000 set 255,{u(100)}%,{u(100)}%,0,{u(100)}% done

#@cli set_vector_covariance : coef1,coef2,...,coefN
#@cli : Apply linear transformation on selected images so that the covariance matrix of their vector-valued pixels
#@cli : is prescribed to given matrix. Matrix size 'N' must be equal to 'spectrum^2'.
set_vector_covariance :
  e[^-1] "Set covariance matrix of image$? to [ $* ]."
  v - repeat $! l[$>]
    if {narg($*)!=s^2} error[0--4] "Command '$0': Invalid arguments '$*' for image '"{n}"' with size ("{[w,h,d,s]}") ("{s^2}" argument"${"if {s==1} u \"\" else u s fi"}" expected)." fi

    # Compute current covariance matrix.
    C=${"vector_covariance _avg"}

    # Transform data to fit new covariance matrix.
    f "begin(
         avg = [ "$_avg" ];
         C1 = [ "$C" ];
         C2 = [ $* ];
         eig1 = eig(C1);
         eig2 = eig(C2);
         for (k = 0, k<s, ++k, # Align eigenvector orientations.
           k1s = (k + 1)*s;
           if (dot(eig2[k1s,s],eig1[k1s,s])<0, copy(eig2[k1s],eig2[k1s,s]*=-1,s));
         );
         invD1 = diag(eig1[0,s]^-0.5);
         invR1 = eig1[s,size(eig1)-s];
         D2 = diag(eig2[0,s]^0.5);
         R2 = transp(eig2[s,size(eig2)-s],s);
         T = mul(R2,mul(D2,mul(invD1,invR1,s),s),s);
       );
       avg + T*(I - avg)"
  endl done v +

#@cli threshold : value[%],_is_soft={ 0 | 1 } : (no arg) : (+)
#@cli : Threshold values of selected images.
#@cli : 'soft' can be { 0=hard-thresholding | 1=soft-thresholding }.
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : In interactive mode, the chosen threshold value is returned in the status.
#@cli : Default value: 'is_soft=0'.
#@cli : $ image.jpg +threshold[0] 50% +threshold[0] 50%,1
#@cli : $$

#@cli unrepeat
#@cli : Remove repetition of adjacent values in selected images.
#@cli : $ (1;1;1;1;1;2;2;2;3;4;4;4;5;5;5) +unrepeat
unrepeat :
  e[^-1] "Remove repetition of adjacent values in image$?."
  v - repeat $! l[$>] nm={0,n}
    y x ({{0,@-1}+1}) a x r 100%,2
    f. '>if(y==0,i,if(i(x,0)==i(x+1,0),-1,x))'
    z 0,{w-2} s y,2 discard[1] -1 map[1] [0]
    rm[0] nm $nm
  endl done v +

#@cli vector2tensor
#@cli : Convert selected vector fields to corresponding tensor fields.
vector2tensor :
  e[^-1] "Convert vector field$? to tensor field$?."
  v - repeat $! l[$>]
    s c
    if {$!==2} +sqr. *.. ... sqr...
    elif {$!==3} +sqr.. +*... .. +sqr... *[-5,-4] [-6] sqr[-6]
    else v + error[0--4] "Command '$0': Invalid image ["{$!-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2D or 3D vectors."
    fi
    a c
  endl done v +

#---------------------------------
#
#@cli :: Colors Manipulation
#
#---------------------------------

#@cli adjust_colors : -100<=_brightness<=100,-100<=_contrast<=100,-100<=_gamma<=100,-100<=_hue_shift<=100,-100<=_saturation<=100,_value_min,_value_max
#@cli : Perform a global adjustment of colors on selected images.
#@cli : Range of correct image values are considered to be in [value_min,value_max] (e.g. [0,255]).
#@cli : If 'value_min==value_max==0', value range is estimated from min/max values of selected images.
#@cli : Processed images have pixel values constrained in [value_min,value_max].
#@cli : Default values: 'brightness=0', 'contrast=0', 'gamma=0', 'hue_shift=0', 'saturation=0', 'value_min=value_max=0'.
#@cli : $ image.jpg +adjust_colors 0,30,0,0,30
adjust_colors : check "${1=0}>=-100 && $1<=100 && ${2=0}>=-100 && $2<=100 && ${3=0}>=-100 && $3<=100 && ${4=0}>=-100 && $4<=100 && ${5=0}>=-100 && $5<=100" skip ${6=0},${7=0}
  e[^-1] "Adjust colors of image$?, with brightness $1, contrast $2, gamma $3, hue shift $4, saturation $5 and value range [$6,$7]."
  v - repeat $! l[$>] split_opacity
    range={"$6==$7 && $6==0?[im,iM]:[min($6,$7),max($6,$7)]"}
    m={arg(1,$range)} M={arg(2,$range)} fact={255/max(1e-5,$M-$m)}
    - $m * $fact
    if {$4" || "$5} # Adjust Hue/Saturation
      to_rgb[0] rgb2hsv[0]
      sh[0] 0 +. {$4*1.8} rm.
      sh[0] 1 +. {($5%)^(1+($5>0))} c. 0,1 rm.
      hsv2rgb[0]
    fi
    if $3 # Adjust Gamma
      /[0] 255 ^[0] {10^-($3%)} *[0] 255
    fi
    if $2 # Adjust Contrast
      -[0] 128 *[0] {exp($2/64)} +[0] 128
    fi
    +[0] {$1*2} # Adjust Brightness
    /[0] $fact +[0] $m c[0] $range # Renormalize values.
    a c
  endl done v +

#@cli ac : eq. to 'apply_channels'.
ac :
  v - _gmic_s="$?" v +
  _apply_channels $"*"

#@cli apply_channels : "command",color_channels,_value_action={ 0=none | 1=cut | 2=normalize }
#@cli : Apply specified command on the chosen color channel(s) of each selected images.
#@cli : (eq. to 'ac').\n
#@cli : Argument 'color_channels' refers to a colorspace, and can be basically one of { all | rgba | rgb | lrgb | ycbcr | lab | lch | hsv | hsi | hsl | cmy | cmyk | yiq }.
#@cli : You can also make the processing focus on a few particular channels of this colorspace, by setting 'color_channels' as 'colorspace_channel' (e.g. 'hsv_h' for the hue).
#@cli : All channel values are considered to be provided in the [0,255] range.
#@cli : Default value: 'value_action=0'.
#@cli : $ image.jpg +apply_channels "equalize blur 2",ycbcr_cbcr
apply_channels :
  v - _gmic_s="$?" v +
  _$0 $"*"

_apply_channels : check "isint(${3=0}) && $3>=0 && $3<=2"
  v - mode="$2"
  if {isval("$2")} if {isint("$2")}
    mode=${arg\ 1+$2,all,rgba,rgb,rgb_r,rgb_g,rgb_b,rgba_a,\
                     lrgb,lrgb_r,lrgb_g,lrgb_b,\
                     ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
                     lab_l,lab_ab,lab_a,lab_b,\
                     lch_ch,lch_c,lch_h,\
                     hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
                     cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
                     yiq_y,yiq_iq}
  fi fi
  v + e[^-1] "Apply command '$1' on channels '"$mode"' of image"$_gmic_s"." v -
  ({'$/'}) id={h=0;for(k=0,k<w,((h*=31)+=i[k++])%=1048576)} rm.
  _ac_$mode m _ac_precond$id:$_p m _ac_forward$id:$_f m _ac_backward$id:$_b
  repeat $! l[$>]
    _ac_precond$id is_alpha={s==2" || "s==4}
    if $is_alpha s c,{1-s} fi
    _ac_forward$id[0] a c
    sh $_s _ac. "$1"
    if {$3==1} c. 0,255 elif {$3==2} n. 0,255 fi
    rm.
    if $is_alpha s c,{1-s} fi
    _ac_backward$id[0] a c
  endl done
  uncommand _ac_precond$id,_ac_forward$id,_ac_backward$id
  v +

_ac :
  whds={w},{h},{d},{s} ${1--1} k[0] r $whds,0

_ac_all : _p="" _f="" _b="" _s=0,100%

_ac_rgba : _p="to_rgba" _f="" _b="" _s=0,3
_ac_rgba_r : _p="to_color" _f="" _b="" _s=0
_ac_rgba_g : _p="to_color" _f="" _b="" _s=1
_ac_rgba_b : _p="to_color" _f="" _b="" _s=2
_ac_rgba_a : _p="to_rgba" _f="" _b="" _s=3

_ac_rgb : _p="to_color" _f="" _b="" _s=0,2
_ac_rgb_r : _ac_rgba_r
_ac_rgb_g : _ac_rgba_g
_ac_rgb_b : _ac_rgba_b

_ac_lrgb : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=0,2
_ac_lrgb_r : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=0
_ac_lrgb_g : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=1
_ac_lrgb_b : _p="to_color" _f="srgb2rgb" _b="rgb2srgb" _s=2

_ac_ycbcr : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=0,2
_ac_ycbcr_y : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=0
_ac_ycbcr_cbcr : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=1,2
_ac_ycbcr_cb : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=1
_ac_ycbcr_cr : _p="to_color" _f="rgb2ycbcr" _b="ycbcr2rgb" _s=2
_ac_ycbcr_cg : _p="to_color" _f="sh 0,1 mirror. c rm. rgb2ycbcr" _b="ycbcr2rgb sh 0,1 mirror. c rm." _s=2

_ac_lab : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=0,2
_ac_lab_l : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=0
_ac_lab_ab : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=1,2
_ac_lab_a : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=1
_ac_lab_b : _p="to_color" _f="srgb2lab8" _b="lab82srgb" _s=2

_ac_lch : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=0,2
_ac_lch_l : _ac_lab_l
_ac_lch_ch : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=1,2
_ac_lch_c : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=1
_ac_lch_h : _p="to_color" _f="srgb2rgb rgb2lch8" _b="lch82rgb rgb2srgb" _s=2

_ac_hsv : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=0,2
_ac_hsv_h : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=0
_ac_hsv_s : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=1
_ac_hsv_v : _p="to_color" _f="rgb2hsv8" _b="hsv82rgb" _s=2

_ac_hsi : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=0,2
_ac_hsi_h : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=0
_ac_hsi_s : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=1
_ac_hsi_i : _p="to_color" _f="rgb2hsi8" _b="hsi82rgb" _s=2

_ac_hsl : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=0,2
_ac_hsl_h : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=0
_ac_hsl_s : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=1
_ac_hsl_l : _p="to_color" _f="rgb2hsl8" _b="hsl82rgb" _s=2

_ac_cmy : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=0,2
_ac_cmy_c : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=0
_ac_cmy_m : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=1
_ac_cmy_y : _p="to_color" _f="rgb2cmy" _b="cmy2rgb" _s=2

_ac_cmyk : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=0,3
_ac_cmyk_c : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=0
_ac_cmyk_m : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=1
_ac_cmyk_y : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=2
_ac_cmyk_k : _p="to_color" _f="rgb2cmyk" _b="cmyk2rgb" _s=3

_ac_yiq : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=0,2
_ac_yiq_y : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=0
_ac_yiq_iq : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=1,2
_ac_yiq_i : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=1
_ac_yiq_q : _p="to_color" _f="rgb2yiq8" _b="yiq82rgb" _s=2

#@cli autoindex : nb_colors>0,0<=_dithering<=1,_method={ 0=median-cut | 1=k-means }
#@cli : Index selected vector-valued images by adapted colormaps.
#@cli : Default values: 'dithering=0' and 'method=1'.
#@cli : $ image.jpg +autoindex[0] 4 +autoindex[0] 8 +autoindex[0] 16
autoindex : check "isint($1) && $1>0 && ${2=0}>=0" skip ${3=1}
  e[^-1] "Index colors in images$? by adapted colormap with $1 entries, dithering level $2 and "\
          ${arg\ 1+!$3,k-means,median-cut}" method."
  v - repeat $! l[$>]
    if {w>h} if {w>256} +r2dx 256 else [0] fi
    else if {h>256} +r2dy 256 else [0] fi
    fi
    colormap[1] $1,$3,0
    index[0] [1],$2,1 rm[1]
  endl done v +

#@cli bayer2rgb : _GM_smoothness,_RB_smoothness1,_RB_smoothness2
#@cli : Transform selected RGB-Bayer sampled images to color images.
#@cli : Default values: 'GM_smoothness=RB_smoothness=1' and 'RB_smoothness2=0.5'.
#@cli : $ image.jpg rgb2bayer 0 +bayer2rgb 1,1,0.5
bayer2rgb : skip ${1=1},${2=1},${3=0.5}
  e[^-1] "Transform RGB-Bayer image$? to color images, with smoothness ($1,$2,$3)."
  v - channels 0 repeat $! l[$>]

    # Expand image size to avoid problems with borders.
    expand_x {"2 + 4*$1"},0 expand_y {"2 + 4*$1"},0

    # Compute green-magenta chromaticity.
    (-1,1;1,-1) r. ..,..,1,1,0,2
    +*.. .

    (0.25,0.5,0.25) convolve.. . transpose. convolve.. . rm.
    b. $1

    *.. .
    -[-3,-2]

    # Compute red-blue chromaticity.
    (1,-1) r. ..,..,1,1,0,2  # Horizontal estimate
    *. ...
    (0.25,0.5,0.25) convolve.. . transpose. convolve.. . rm.
    blur_y. $2 blur_x. $3

    (1;-1) r. ..,..,1,1,0,2  # Vertical estimate
    *. [-4]
    (0.25,0.5,0.25) convolve.. . transpose. convolve.. . rm.
    blur_x. $2 blur_y. $3

    +[-2,-1] /. 2

    # Luminance reconstruction.
    (2,0;0,-2) r. ..,..,1,1,0,2
    *. ..
    -[-4,-1]

    # RGB reconstruction.
    a[-3--1] c
    mix_rgb. 1,-1,2,1,1,0,1,-1,-2

    # Shrink to original image size.
    shrink_x {"2 + 4*$1"},0 shrink_y {"2 + 4*$1"},0
    c 0,255

  endl done v +

#@cli cmy2rgb
#@cli : Convert color representation of selected images from CMY to RGB.
cmy2rgb :
  e[^-1] "Convert color representation of image$? from CMY to RGB."
  v - rgb2cmy v +

#@cli cmyk2rgb
#@cli : Convert color representation of selected images from CMYK to RGB.
cmyk2rgb :
  e[^-1] "Convert color representation of image$? from CMYK to RGB."
  v - repeat $! l[$>]
    s c +/. -255 +. 1 *[0-2] . rm. +[0-2] . rm.
    a c cmy2rgb
  endl done v +

#@cli colorblind : type={ 0=protanopia | 1=protanomaly | 2=deuteranopia | 3=deuteranomaly | 4=tritanopia | 5=tritanomaly | 6=achromatopsia | 7=achromatomaly }
#@cli : Simulate color blindness vision.
#@cli : $ image.jpg +colorblind 0
colorblind : check "isint($1) && $1>=0 && $1<=7"
  v - s0="protanopia" s1="protanomaly" s2="deuteranopia" s3="deuteranomaly" s4="tritanopia" s5="tritanomaly" s6="achromatopsia" s7="achromatomaly"
  v + e[^-1] "Simulate color blindness of type '"${s$1}"' on image$?." v -
  type0=(0.567,0.433,0;0.558,0.442,0;0,0.242,0.758)
  type1=(0.817,0.183,0;0.333,0.667,0;0,0.125,0.875)
  type2=(0.625,0.375,0;0.7,0.3,0;0,0.3,0.7)
  type3=(0.8,0.2,0;0.258,0.742,0;0,0.142,0.858)
  type4=(0.95,0.05,0;0,0.433,0.567;0,0.475,0.525)
  type5=(0.967,0.033,0;0,0.733,0.267;0,0.183,0.817)
  type6=(0.299,0.587,0.114;0.299,0.587,0.114;0.299,0.587,0.114)
  type7=(0.618,0.320,0.062;0.163,0.775,0.062;0.163,0.320,0.516)
  repeat $! l[$>] split_opacity l[0] to_rgb mix_channels ${type$1} endl a c endl done
  v +

#@cli colormap : nb_levels>=0,_method={ 0=median-cut | 1=k-means },_sort_vectors={ 0 | 1 }
#@cli : Estimate best-fitting colormap with 'nb_colors' entries, to index selected images.
#@cli : Set 'nb_levels==0' to extract all existing colors of an image.
#@cli : Default value: 'method=1' and 'sort_vectors=1'.
#@cli : $ image.jpg +colormap[0] 4 +colormap[0] 8 +colormap[0] 16
#@cli : $$
colormap : check "isint($1) && $1>=0" skip ${2=1},${3=1}
  if $1 e[0--3] "Estimate colormap with $1 entries for image$?, by "${arg\ 1+!$2,k-means,median-cut}" method."
  else e[0--3] "Estimate full colormap for image$?."
  fi
  v - repeat $! l[$>] nm={b}
    r {w*h*d},1,1,100%,-1

    if $1 # Estimate quantized colormap.
      if {!$2} _colormap $1 # Just run the median-cut algorithm
      else
        +_colormap $1
        max_diff={(iM-im+1)/8192}
        do
          +index.. . # Find nearest cluster for each color
          ..,1,1,{-2,s+1}
          f.. ">I[#3,i]+=[ I[#0,x],1 ]" rm..
          f. "s = i(x,0,0,s-1); s?I/s:[ I[#1,x], 0 ]"
          +-.. . abs. diff={iM/w} rm. # Compute colormap difference
          j.. . rm.
        while {$diff>$max_diff}
        rm..
      fi

    else # Extract full colormap.
      repeat {s} ap "sort +,x" s x,0 ap "shift 0,0,0,1,2" done
      ap "discard x" a x

    fi
    if $3 +norm rv a c sort +,x channels 1,100% fi # Sort colors by increasing norm.
    nm "[colormap of "$nm"]"
  endl done v +

_colormap : # Implementation of the median-cut algorithm.
  m "__colormap : repeat {s} sh[$""1] $> =.. {iv},$""1,0,0,$> rm. done"
  1,1,1,{s} __colormap 0 # Initialize image of box variances
  repeat {$1-1}
    b,a={[xM,cM]} # b = box with highest variance, a = axis with highest variance
    shift[$b] 0,0,0,{-$a},2 sort[$b] +,x shift[$b] 0,0,0,$a,2 s[$b] x,2 # Split selected box along its median axis
    mv[$b] -1 r. {w+1},1,1,100%,0
    __colormap $b __colormap {$!-2} # Update box variances
  done
  rm. r 1,1,1,100%,2 a x # Average value in each box and append as final colormap
  uncommand __colormap

#@cli compose_channels
#@cli : Compose all channels of each selected image, using specified arithmetic operator (+,-,or,min,...).
#@cli : Default value: '1=+'.
#@cli : $ image.jpg +compose_channels and
#@cli : $$
compose_channels : skip ${1="+"}
  e[^-1] "Compose all channels of image$?, with operator '$1'."
  v - repeat $! l[$>]
    sh 0
    repeat {-2,s-1} sh.. {$>+1} l[-2,-1] $1 endl done
    rm. r 100%,100%,100%,1,-1
  endl done v +

#@cli direction2rgb
#@cli : Compute RGB representation of selected 2D direction fields.
#@cli : $ image.jpg luminance gradient append c blur 2 orientation +direction2rgb
direction2rgb :
  e[^-1] "Compute RGB representation of 2D direction field$?."
  v - channels 0,1 repeat $! l[$>] nm={0,n}
    s c complex2polar round.. 0.001
    *. {180/pi} %. 360 100%,100%,1,1,1 mv... $!
    if {im!=iM} n. 0,1 else f. 1 fi
    a c hsv2rgb
  nm $nm endl done v +

#@cli ditheredbw
#@cli : Create dithered B&W version of selected images.
#@cli : $ image.jpg +equalize ditheredbw[-1]
ditheredbw :
  e[^-1] "Create dithered B&W version of image$?."
  v - repeat $! l[$>] split_opacity
    luminance[0] n[0] 0,255 (0,255) index[0] .,1,1 rm.
  a c endl done v +

#@cli fc : eq. to 'fill_color'.
fc :
  v - _gmic_s="$?" v +
  _fill_color $*

#@cli fill_color : col1,...,colN
#@cli : Fill selected images with specified color.
#@cli : (eq. to 'fc').
#@cli : $ image.jpg +fill_color 255,0,255
#@cli : $$
fill_color :
  v - _gmic_s="$?" v +
  _$0 $*

_fill_color :
  e[0--3] "Fill image"$_gmic_s" with color (${^0})."
  v - repeat $! l[$>]
    repeat {s} sh[0] $> f. {arg(1+$>,${^0})} done k[0]
  nm {n} endl done v +

#@cli gradient2rgb : _is_orientation={ 0 | 1 }
#@cli : Compute RGB representation of 2D gradient of selected images.
#@cli : Default value: 'is_orientation=0'.
#@cli : $ image.jpg +gradient2rgb 0 equalize[-1]
gradient2rgb : check "isbool(${1=0})"
  arg 1+!$1,"orientation ",""
  e[^-1] "Compute RGB representation of 2D gradient "${}"of image$?."
  v - norm repeat $! l[$>]
    if $1 gradient_orientation 2 else g xy fi
    a c direction2rgb
  endl done v +

#@cli hcy2rgb :
#@cli : Convert color representation of selected images from HCY to RGB.
hcy2rgb :
  e[^-1] "Convert color representation of image$? from HCY to RGB."
  v - to_color f "
    H = (R/60)%6;
    X = G*(1 - abs(H%2 - 1));
    RGB = arg(1 + int(H),[G,X,0],[X,G,0],[0,G,X],[0,X,G],[X,0,G],[G,0,X]);
    m = B - 0.3*RGB[0] - 0.59*RGB[1] - 0.11*RGB[2];
    cut((RGB+=m)*=255,0,255)"
  v +

#@cli hsi2rgb
#@cli : Convert color representation of selected images from HSI to RGB.
hsi2rgb :
  e[^-1] "Convert color representation of image$? from HSI to RGB."
  v - to_color
  f "
    H = (R/60)%6;
    S = cut(G,0,1);
    I = cut(B,0,1);
    Z = 1 - abs((H%2) - 1);
    C = I*S/(1 + Z);
    X = C*Z;
    m = I*(1 - S)/3;
    RGB = arg(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
    cut((RGB+=m)*=3*255,0,255);
  "
  v +

#@cli hsi82rgb
#@cli : Convert color representation of selected images from HSI8 to RGB.
hsi82rgb :
  e[^-1] "Convert color representation of image$? from HSI8 to RGB."
  v - _hsx82rgb hsi2rgb v +

#@cli hsl2rgb
#@cli : Convert color representation of selected images from HSL to RGB.
hsl2rgb :
  e[^-1] "Convert color representation of image$? from HSL to RGB."
  v - to_color
  f "
    H = (R/60)%6;
    S = cut(G,0,1);
    L = cut(B,0,1);
    C = (1 - abs(2*L - 1))*S;
    X = C*(1 - abs(H%2 - 1));
    m = L - C/2;
    RGB = arg(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
    cut((RGB+=m)*=255,0,255);
  "
  v +

#@cli hsl82rgb
#@cli : Convert color representation of selected images from HSL8 to RGB.
hsl82rgb :
  e[^-1] "Convert color representation of image$? from HSL8 to RGB."
  v - _hsx82rgb hsl2rgb v +

#@cli hsv2rgb
#@cli : Convert color representation of selected images from HSV to RGB.
#@cli : $ (0,360;0,360^0,0;1,1^1,1;1,1) resize 400,400,1,3,3 hsv2rgb
hsv2rgb :
  e[^-1] "Convert color representation of image$? from HSV to RGB."
  v - to_color
  f "
    H = (R/60)%6;
    S = cut(G,0,1);
    V = cut(B,0,1);
    C = V*S;
    X = C*(1 - abs(H%2 - 1));
    m = V - C;
    RGB = arg(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
    cut((RGB+=m)*=255,0,255);
  "
  v +

#@cli hsv82rgb
#@cli : Convert color representation of selected images from HSV8 to RGB.
hsv82rgb :
  e[^-1] "Convert color representation of image$? from HSV8 to RGB."
  v - _hsx82rgb hsv2rgb v +

_hsx82rgb :
 repeat $!
   sh[$>] 0 /. 0.708333 rm.
   sh[$>] 1,2 /. 255 rm.
 done

#@cli int2rgb
#@cli : Convert color representation of selected images from INT24 to RGB.
int2rgb :
  e[^-1] "Convert color representation of image$? from INT24 scalars to RGB."
  v - round repeat $! l[$>]
    +>> 8 &[1] 255 +&[0] 255 >>[0] 16 a c
  endl done v +

#@cli lab2lch
#@cli : Convert color representation of selected images from Lab to Lch.
lab2lch :
  e[^-1] "Convert color representation of image$? from Lab to Lch."
  v - r 100%,100%,100%,3 repeat $! l[$>]
    s c complex2polar[-2,-1] a c
  endl done v +

#@cli lab2rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab to RGB.
#@cli : Default value: 'illuminant=1'.
#@cli : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) resize 400,400,1,3,3 lab2rgb
lab2rgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from Lab to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - lab2xyz $illu xyz2rgb $illu v +

#@cli lab2srgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab to sRGB.
#@cli : Default value: 'illuminant=1'.
#@cli : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) resize 400,400,1,3,3 lab2rgb
lab2srgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from Lab to sRGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - lab2rgb $illu rgb2srgb v +

#@cli lab82srgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab8 to sRGB.
#@cli : Default value: 'illuminant=1'.
#@cli : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) resize 400,400,1,3,3 lab2rgb
lab82srgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from Lab8 to sRGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - lab82rgb $illu rgb2srgb v +

#@cli lab2xyz : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab to XYZ.
#@cli : Default value: 'illuminant=1'.
lab2xyz : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from Lab to XYZ, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - to_color
  f "
    begin(
      D65 = [ 0.4124564, 0.3575761, 0.1804375,
              0.2126729, 0.7151522, 0.0721750,
              0.0193339, 0.1191920, 0.9503041 ];
      D50 = [ 0.43603516, 0.38511658, 0.14305115,
              0.22248840, 0.71690369, 0.06060791,
              0.01391602, 0.09706116, 0.71392822 ];
      white = ("$illu"?D65:D50)*[ 1,1,1 ];
    );
    cY = (R + 16)/116;
    cZ = cY - B/200;
    cX = G/500 + cY;
    XYZ = [ 24389*cX>216?cX^3:(116*cX - 16)*27/24389,
            27*R>216?cY^3:27*R/24389,
            24389*cZ>216?cZ^3:(116*cZ - 16)*27/24389 ];
    XYZ*=white;
  "
  v +

#@cli lab82rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lab8 to RGB.
#@cli : Default value: 'illuminant=1'.
lab82rgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from Lab8 to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - repeat $!
    sh[$>] 0 /. 2.55 rm.
    sh[$>] 1 /. 1.275 -. 100 rm.
    sh[$>] 2 /. 1.15909 -. 110 rm.
  done lab2rgb $illu v +

#@cli lch2lab
#@cli : Convert color representation of selected images from Lch to Lab.
lch2lab :
  e[^-1] "Convert color representation of image$? from Lch to Lab."
  v - r 100%,100%,100%,3 repeat $! l[$>]
    s c polar2complex[-2,-1] a c
  endl done v +

#@cli lch2rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lch to RGB.
#@cli : Default value: 'illuminant=1'.
lch2rgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from Lch to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - lch2lab lab2rgb $illu v +

#@cli lch82rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from Lch8 to RGB.
#@cli : Default value: 'illuminant=1'.
lch82rgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from Lch8 to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - repeat $!
    sh[$>] 0 /. 2.55 rm.
    sh[$>] 1 /. 1.88889 rm.
    sh[$>] 2 /. 40.5845 -. 3.14159 rm.
  done lch2rgb $illu v +

#@cli luminance
#@cli : Compute luminance of selected sRGB images.
#@cli : $ image.jpg +luminance
luminance :
  e[^-1] "Compute luminance of image$?."
  v - remove_opacity srgb2rgb
  repeat $! l[$>]
  if {s==3} sh 0 sh[0] 1 sh[0] 2 *[1] 0.22248840 *[2] 0.71690369 *[3] 0.06060791 +[1-3] rm[1]
  elif {s!=1} norm n 0,255
  fi endl done
  channels 0 rgb2srgb v +

#@cli mix_rgb : a11,a12,a13,a21,a22,a23,a31,a32,a33
#@cli : Apply 3x3 specified matrix to RGB colors of selected images.
#@cli : Default values: 'a11=1', 'a12=a13=a21=0', 'a22=1', 'a23=a31=a32=0' and 'a33=1'.
#@cli : $ image.jpg +mix_rgb 0,1,0,1,0,0,0,0,1
#@cli : $$
mix_rgb : skip ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
  e[^-1] "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
  v - to_color repeat $! sh[$>] 0,2 mix_channels. (${1-3};${4-6};${7-9}) rm. done v +

#@cli pseudogray : _max_increment>=0,_JND_threshold>=0,_bits_depth>0
#@cli : Generate pseudogray colormap with specified increment and perceptual threshold.
#@cli : If 'JND_threshold' is 0, no perceptual constraints are applied.
#@cli : Default values: 'max_increment=5', 'JND_threshold=2.3' and 'bits_depth=8'.
#@cli : $ pseudogray 5
pseudogray : check "isint(${1=5}) && $1>=0 && ${2=2.3}>=0 && isint(${3=8}) && $3>0"
  e[^-1] "Generate pseudogray colormap with increment $1, JND threshold $2 and $3 bits depth."
  v -

  # Generate all possible sRGB colors with given increments.
  {round(2^$3)},1,1,3,'x'
  if {!$1} n. 0,255 v + return fi
  {$1+1},{$1+1},{$1+1},1,'x' +f. 'y' +f. 'z' a[-3--1] c r. {w*h*d},1,1,3,-1
  f. 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(min(R,G,B),-1,i)'
  permute. cxyz discard. -1 r. 3,{h/3},1,1,-1 permute. yzcx
  r.. {w*100}% r. ..,0,2 +[-2,-1]
  f. 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(max(R,G,B)>2^$3-1,-1,i)'
  permute. cxyz discard. -1 r. 3,{h/3},1,1,-1 permute. yzcx
  n. 0,255
  +srgb2lab. rv[-2,-1] a[-2,-1] y sort. +,x  # Sort by increasing lightness.
  if {!$2} rows. 1
  else # Add perceptual constraint if requested.

    # Constraint 1 : keep colors close enough to equivalent 'pure' grays.
    s. y rv[-2,-1] . sh. 1,2 f. 0 rm. -[-2,-1] norm.
    <=. $2 *. 'x+1' discard. 0 -. 1 map. .. rm..

    # Constraint 2 : remove neighboring colors that are above the JND.
    repeat 10000
      +srgb2lab. +shift. 0,{1-2*($>%2)},0,0,1 -[-2,-1] norm.
      <=. $2
      if {im} rm. break fi
      *. 'y+1' discard. 0 -. 1 map. .. rm..
    done
    transpose.

  fi
  v +

#@cli replace_color : tolerance[%]>=0,smoothness[%]>=0,src1,src2,...,dest1,dest2,...
#@cli : Replace pixels from/to specified colors in selected images.
#@cli : $ image.jpg +replace_color 40,3,204,153,110,255,0,0
replace_color : check "$1>=0 && $2>=0"
  v - l[] (${3--1}) y c s c,2 col1={0,^} col2={1,^} rm endl v +
  e[^-1] "Replace color ("$col1") by color ("$col2") in image$?, with tolerance $1 and smoothness $2."
  v - repeat $! l[$>]
    1,1,1,100%,$col1 r[1] [0]
    if $1 -[1] [0] norm[1] <=[1] $1 else ==[1] [0] l[1] s c & endl fi
    b[1] $2
    1,1,1,{0,s},$col2 r[2] [0] j[0] [2],0,0,0,0,1,[1] k[0]
  endl done v +

#@cli retinex : _value_offset>0,_colorspace={ hsi | hsv | lab | lrgb | rgb | ycbcr },0<=_min_cut<=100,0<=_max_cut<=100,_sigma_low>0,_sigma_mid>0,_sigma_high>0
#@cli : Apply multi-scale retinex algorithm on selected images to improve color consistency.
#@cli : (as described in the page http://www.ipol.im/pub/art/2014/107/).
#@cli : Default values: 'offset=1', 'colorspace=hsv', 'min_cut=1', 'max_cut=1', 'sigma_low=15','sigma_mid=80' and 'sigma_high=250'.
retinex : check "${1=5}>0 && ${3=1}>=0 && $3<=100 && ${4=1}>=0 && $4<=100 && ${5=15}>0 && ${6=80}>0 && ${7=250}>0" skip "${2=hsv}"
  e[^-1] "Apply Retinex color consistency algorithm on image$?, with value offset $1, colorspace '$2', cuts ($3,$4) and sigmas (${5-7})."
  v -
  if {;'$2'=='hsi'} mode=hsi_i
  elif {;'$2'=='hsv'} mode=hsv_v
  elif {;'$2'=='lab'} mode=lab_l
  elif {;'$2'=='rgb'} mode=rgb
  elif {;'$2'=='lrgb'} mode=lrgb
  elif {;'$2'=='ycbcr'} mode=ycbcr_y
  else v + error[0--2] "Command '$0': Invalid colorspace argument '$2'."
  fi
  ac "_retinex $1,${3--1}",$mode
  v +

_retinex :
  - {im-$1} {[w,h,d,s]},1
  repeat 3 +b[0] {arg(1+$>,${4-6})} +/[0,-1] rm.. *[1,-1] done
  rm[0] log c $2%,{100-$3}% n 0,255

#@cli rgb2bayer : _start_pattern=0,_color_grid=0
#@cli : Transform selected color images to RGB-Bayer sampled images.
#@cli : Default values: 'start_pattern=0' and 'color_grid=0'.
#@cli : $ image.jpg +rgb2bayer 0
rgb2bayer : skip ${1=0},${2=0}
  e[^-1] "Transform image$? to a RGB-Bayer "${arg\ 1+!$2,color,monochrome}" grid, starting from pattern '$1'."
  v - to_rgb repeat $! l[$>]
    _rgb2bayer$1 r[1] [0],0,2 * if {!$2} s c + fi
  endl done v +

_rgb2bayer0 : (1,0;0,0^0,1;1,0^0,0;0,1)
_rgb2bayer1 : (0,0;0,1^0,1;1,0^1,0;0,0)
_rgb2bayer2 : (0,1;0,0^1,0;0,1^0,0;1,0)
_rgb2bayer3 : (0,0;1,0^1,0;0,1^0,1;0,0)

#@cli rgb2cmy
#@cli : Convert color representation of selected images from RGB to CMY.
#@cli : $ image.jpg rgb2cmy split c
rgb2cmy :
  e[^-1] "Convert color representation of image$? from RGB to CMY."
  v - to_rgb * -1 + 255 c 0,255 v +

#@cli rgb2cmyk
#@cli : Convert color representation of selected images from RGB to CMYK.
#@cli : $ image.jpg rgb2cmyk split c
#@cli : $ image.jpg rgb2cmyk split c fill[3] 0 append c cmyk2rgb
rgb2cmyk :
  e[^-1] "Convert color representation of image$? from RGB to CMYK."
  v - rgb2cmy repeat $! l[$>]
    s c +min -[0-2] . +/. 255 -. 1 *. -1 +==. 0 +[-2,-1]
    /[0-2] . rm. a c
  endl done v +

#@cli rgb2hcy
#@cli : Convert color representation of selected images from RGB to HCY.
#@cli : $ image.jpg rgb2hcy split c
rgb2hcy :
  e[^-1] "Convert color representation of image$? from RGB to HCY."
  v - to_color f "
    M = max(R,G,B);
    C = M - min(R,G,B);
    H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
    Y = 0.299*R + 0.587*G + 0.114*B;
    [ H,C/255,Y/255 ]"
  v +

#@cli rgb2hsi
#@cli : Convert color representation of selected images from RGB to HSI.
#@cli : $ image.jpg rgb2hsi split c
rgb2hsi :
  e[^-1] "Convert color representation of image$? from RGB to HSI."
  v - to_color
  f "
    m = min(R,G,B);
    M = max(R,G,B);
    C = M - m;
    sum = R + G + B;
    H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
    S = sum<=0?0:1 - 3*m/sum;
    I = sum/(3*255);
    [ cut(H,0,360), cut(S,0,1), cut(I,0,1) ];
  "
  v +

#@cli rgb2hsi8
#@cli : Convert color representation of selected images from RGB to HSI8.
#@cli : $ image.jpg rgb2hsi8 split c
rgb2hsi8 :
  e[^-1] "Convert color representation of image$? from RGB to HSI8."
  v - rgb2hsi _rgb2hsx8 v +

#@cli rgb2hsl
#@cli : Convert color representation of selected images from RGB to HSL.
#@cli : $ image.jpg rgb2hsl split c
#@cli : $ image.jpg rgb2hsl +split c add[-3] 100 mod[-3] 360 append[-3--1] c hsl2rgb
rgb2hsl :
  e[^-1] "Convert color representation of image$? from RGB to HSL."
  v - to_color
  f "
    m = min(R,G,B);
    M = max(R,G,B);
    C = M - m;
    H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
    L = 0.5*(m + M)/255;
    S = L>=1 || L<=0?0:C/(1-abs(2*L-1))/255;
    [ cut(H,0,360), cut(S,0,1), cut(L,0,1) ];
  "
  v +

#@cli rgb2hsl8
#@cli : Convert color representation of selected images from RGB to HSL8.
#@cli : $ image.jpg rgb2hsl8 split c
rgb2hsl8 :
  e[^-1] "Convert color representation of image$? from RGB to HSL8."
  v - rgb2hsl _rgb2hsx8 v +

#@cli rgb2hsv
#@cli : Convert color representation of selected images from RGB to HSV.
#@cli : $ image.jpg rgb2hsv split c
#@cli : $ image.jpg rgb2hsv +split c add[-2] 0.3 cut[-2] 0,1 append[-3--1] c hsv2rgb
rgb2hsv :
  e[^-1] "Convert color representation of image$? from RGB to HSV."
  v - to_color
  f "
    M = max(R,G,B);
    C = M - min(R,G,B);
    H = 60*(C==0?0:M==R?((G-B)/C)%6:M==G?(B-R)/C+2:(R-G)/C+4);
    S = M<=0?0:C/M;
    [ cut(H,0,360), cut(S,0,1), cut(M/255,0,1) ];
  "
  v +

#@cli rgb2hsv8
#@cli : Convert color representation of selected images from RGB to HSV8.
#@cli : $ image.jpg rgb2hsv8 split c
rgb2hsv8 :
  e[^-1] "Convert color representation of image$? from RGB to HSV8."
  v - rgb2hsv _rgb2hsx8 v +

_rgb2hsx8 :
  repeat $!
    sh[$>] 0 *. 0.708333 rm.
    sh[$>] 1,2 *. 255 rm.
  done

#@cli rgb2lab : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lab.
#@cli : Default value: 'illuminant=1'.
rgb2lab : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from RGB to Lab, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - rgb2xyz $illu xyz2lab $illu v +

#@cli rgb2lab8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lab8.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2lab8 split c
rgb2lab8 : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from RGB to Lab8, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - rgb2lab $illu repeat $!
    sh[$>] 0 *. 2.55 rm.
    sh[$>] 1 +. 100 *. 1.275 rm.
    sh[$>] 2 +. 110 *. 1.15909 rm.
  done v +

#@cli rgb2lch : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lch.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2lch split c
rgb2lch : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from RGB to Lch, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - rgb2lab $illu lab2lch v +

#@cli rgb2lch8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to Lch8.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2lch8 split c
rgb2lch8 : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from RGB to Lch8, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - rgb2lch $illu repeat $!
    sh[$>] 0 *. 2.55 rm.
    sh[$>] 1 *. 1.88889 rm.
    sh[$>] 2 +. 3.14159 *. 40.5845 rm.
  done v +

#@cli rgb2luv
#@cli : Convert color representation of selected images from RGB to LUV.
#@cli : $ image.jpg rgb2luv split c
rgb2luv :
  e[^-1] "Convert color representation of image$? from RGB to LUV."
  v - repeat $! l[$>]
    +rgb2xyz rgb2lab.. channels.. 0 s. c
    *. 3 +*.. 15 +[-2,-1] +. ... +. 1e-8  # Z <- X+15Y+3Z
    *... 4 *.. 9 /[-3,-2] . rm.
    -.. 0.2009 -. 0.4610
    +*... 13 *... . *[-2,-1] a c
  endl done v +

#@cli rgb2int
#@cli : Convert color representation of selected images from RGB to INT24 scalars.
#@cli : $ image.jpg rgb2int
rgb2int :
  e[^-1] "Convert color representation of image$? from RGB to INT24 scalars."
  v - to_rgb round repeat $! l[$>]
    s c <<[0] 16 <<[1] 8 +
  endl done v +

#@cli rgb2srgb
#@cli : Convert color representation of selected images from linear RGB to sRGB.
rgb2srgb :
  e[^-1] "Convert color representation of image$? from linear RGB to sRGB."
  v - f "val = i/255; sval = val<=0.0031308?val*12.92:1.055*val^0.416667 - 0.055; cut(255*sval,0,255)" v +

#@cli rgb2xyz : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to XYZ.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2xyz split c
rgb2xyz : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from RGB to XYZ, using the D"{arg(1+$illu,50,65)}" illuminant."
  v -
  if $illu # D65
    mix_rgb {[0.4124564,0.3575761,0.1804375,\
              0.2126729,0.7151522,0.0721750,\
              0.0193339,0.1191920,0.9503041]/255}
  else # D50
    mix_rgb {[0.43603516,0.38511658,0.14305115,\
              0.22248840,0.71690369,0.06060791,\
              0.01391602,0.09706116,0.71392822]/255}
  fi
  v +

#@cli rgb2xyz8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from RGB to XYZ8.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg rgb2xyz8 split c
rgb2xyz8 : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from RGB to XYZ8, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - rgb2xyz $illu repeat $!
    sh[$>] 0 *. 255 rm.
    sh[$>] 1 *. 255 rm.
    sh[$>] 2 *. 231.8182 rm.
  done v +

#@cli rgb2yiq
#@cli : Convert color representation of selected images from RGB to YIQ.
#@cli : $ image.jpg rgb2yiq split c
rgb2yiq :
  e[^-1] "Convert color representation of image$? from RGB to YIQ."
  v -
  mix_rgb 0.299,0.587,0.114,\
          0.595716,-0.274453,-0.321263,\
          0.211456,-0.522591,0.311135
  v +

#@cli rgb2yiq8
#@cli : Convert color representation of selected images from RGB to YIQ8.
#@cli : $ image.jpg rgb2yiq8 split c
rgb2yiq8 :
  e[^-1] "Convert color representation of image$? from RGB to YIQ."
  v - rgb2yiq
  repeat $!
    sh[$>] 1 +. 151.908 *. 0.8393238012481239 rm.
    sh[$>] 2 +. 133.261 *. 0.9567690472081104 rm.
  done v +

#@cli rgb2ycbcr
#@cli : Convert color representation of selected images from RGB to YCbCr.
#@cli : $ image.jpg rgb2ycbcr split c
rgb2ycbcr :
  e[^-1] "Convert color representation of image$? from RGB to YCbCr."
  v - mix_rgb 66,129,25,-38,-74,112,112,-94,-18
  repeat $!
    sh[$>] 0,2 +. 128 /. 256 rm.
    sh[$>] 0 +. 16 rm.
    sh[$>] 1,2 +. 128 rm.
  done v +

#@cli rgb2yuv
#@cli : Convert color representation of selected images from RGB to YUV.
#@cli : $ image.jpg rgb2yuv split c
rgb2yuv :
  e[^-1] "Convert color representation of image$? from RGB to YUV."
  v -
  mix_rgb {[0.299,0.587,0.114,\
            -0.14713,-0.28886,0.436,\
            0.615,-0.51498,-0.10001]/255}
  v +

#@cli rgb2yuv8
#@cli : Convert color representation of selected images from RGB to YUV8.
#@cli : $ image.jpg rgb2yuv8 split c
rgb2yuv8 :
  e[^-1] "Convert color representation of image$? from RGB to YUV8."
  v - rgb2yuv repeat $!
    sh[$>] 0 *. 255 rm.
    sh[$>] 1 +. 0.44 *. 289.773 rm.
    sh[$>] 2 +. 0.62 *. 205.645 rm.
  done v +

#@cli remove_opacity
#@cli : Remove opacity channel of selected images.
remove_opacity :
  e[^-1] "Remove opacity channel of image$?."
  v - repeat $! l[$>]
    if {s==2} channels 0
    elif {s==4} channels 0,2
    fi
  nm {n} endl done v +

#@cli select_color : tolerance[%]>=0,col1,...,colN
#@cli : Select pixels with specified color in selected images.
#@cli : $ image.jpg +select_color 40,204,153,110
#@cli : $$
select_color : skip ${1=0}
  e[^-1] "Select color (${2--1}) in image$?, with tolerance $1."
  v - repeat $! l[$>]
    +fc ${2--1} - norm <= $1
  endl done v +

#@cli sepia
#@cli : Apply sepia tones effect on selected images.
#@cli : $ image.jpg sepia
sepia :
  e[^-1] "Apply sepia tones effect on image$?."
  v - (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200) r. 256,1,1,3,3
  repeat {$!-1} l[$>,-1] split_opacity luminance[0] map[0] . a[^-1] c endl done
  rm. v +

#@cli solarize
#@cli : Solarize selected images.
#@cli : $ image.jpg solarize
solarize :
  e[^-1] "Solarize image$?."
  v - luminance n 0,128 map 1 v +

#@cli split_colors : _tolerance>=0,_max_nb_outputs>0,_min_area>0
#@cli : Split selected images as several image containing a single color.
#@cli : One selected image can be split as at most 'max_nb_outputs' images.
#@cli : Output images are sorted by decreasing area of extracted color regions and have an additional alpha-channel.
#@cli : Default values: 'tolerance=0', 'max_nb_outputs=256' and 'min_area=8'.
#@cli : $ image.jpg quantize 5 +split_colors , display_rgba
split_colors : check "${1=0}>=0 && isint(${2=256}) && $2>0 && ${3=8}>=1"
  e[^-1] "Split image$? as single color outputs, with tolerance $1, $2 maximal outputs and minimal color area $3."
  v - repeat $! l[$>]
    +label 0,1 norm. area. 0,1

    # Loop over biggest color regions.
    repeat {$2-1}
      coordsM={1,[xM,yM,zM,cM]}
      if {1,i($coordsM)<$3} break fi
      color={0,I($coordsM)}
      +select_color[0] $1,$color
      ==. 0 *[1] . ==. 0
    done
    if {1,iM} !=[1] 0 mv[1] $! # Residual mask, if any.
    else rm[1] fi
    r[^0] [0],[0],[0],{0,s+1}
    N={$!-1}
    sh[^0] 0,{s-2} *[-$N--1] [0] rm[-$N--1]
    sh[^0] 100% *[-$N--1] 255 rm[0,-$N--1]

  endl done v +

#@cli split_opacity
#@cli : Split color and opacity parts of selected images.
split_opacity :
  e[^-1] "Split color and opacity parts of image$?."
  v - repeat $! l[$<] s c,{if(s==4,-3,if(s==2,-1,-s))} endl done v +

#@cli srgb2lab : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from sRGB to Lab.
#@cli : Default value: 'illuminant=1'.
#@cli : $ image.jpg srgb2lab split c
#@cli : $ image.jpg srgb2lab +split c mul[-2,-1] 2.5 append[-3--1] c lab2srgb
srgb2lab : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from sRGB to Lab, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - srgb2rgb rgb2lab $illu v +

#@cli srgb2lab8 : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from sRGB to Lab8.
#@cli : Default value: 'illuminant=1'.
srgb2lab8 : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from sRGB to Lab8, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - srgb2rgb rgb2lab8 $illu v +

#@cli srgb2rgb
#@cli : Convert color representation of selected images from sRGB to linear RGB.
srgb2rgb :
  e[^-1] "Convert color representation of image$? from sRGB to linear RGB."
  v - f "sval = i/255; val = sval<=0.04045?sval/12.92:((sval + 0.055)/(1.055))^2.4; cut(255*val,0,255)" v +

#@cli to_a
#@cli : Force selected images to have an alpha channel.
to_a :
  e[^-1] "Force image$? to have an alpha channel."
  v - repeat $! l[$>]
    if {s==1||s==3} channels 0,{s} sh. {s-1} f. 255 rm. fi
  endl done v +

#@cli to_color
#@cli : Force selected images to be in color mode (RGB or RGBA).
to_color :
  e[^-1] "Force image$? to be in color mode."
  v - repeat $! l[$>]
    if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
    elif {s==2} r 100%,100%,1,4,0,1,0,0,0,1
    elif {s==1} r 100%,100%,1,3,1
    fi
  endl done v +

#@cli to_colormode : mode={ 0=adaptive | 1=G | 2=GA | 3=RGB | 4=RGBA }
#@cli : Force selected images to be in a given color mode.
#@cli : Default value: 'mode=0'.
to_colormode : skip ${1=0}
  if {$1==1} to_gray
  elif {$1==2} to_graya
  elif {$1==3} to_rgb
  elif {$1==4} to_rgba
  else
    v - is_rgb=0 is_alpha=0
    repeat $!
      if {$>,!s||s>4} v + error "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
      elif {$>,s==2} is_alpha=1
      elif {$>,s==3} is_rgb=1
      elif {$>,s==4} is_rgb=1 is_alpha=1
      fi
    done
    to_colormode {if($is_rgb,3,1)+$is_alpha}
    v +
  fi

#@cli to_gray
#@cli : Force selected images to be in GRAY mode.
#@cli : $ image.jpg +to_gray
to_gray :
  e[^-1] "Force image$? to be in GRAY mode."
  v - repeat $! l[$>]
    if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
    elif {s>=3} channels 0,2 luminance
    elif {s==2} r 100%,100%,100%,1,0
    fi
  endl done v +

#@cli to_graya
#@cli : Force selected images to be in GRAYA mode.
to_graya :
  e[^-1] "Force image$? to be in GRAYA mode."
  v - repeat $! l[$>]
    if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
    elif {s==4} +channels 3 channels.. 0,2 luminance.. a c
    elif {s==3} luminance channels 0,1 sh. 1 f. 255 rm.
    elif {s==1} channels 0,1 sh. 1 f. 255 rm.
    fi
  endl done v +

#@cli to_pseudogray : _max_step>=0,_is_perceptual_constraint={ 0 | 1 },_bits_depth>0
#@cli : Convert selected scalar images ([0-255]-valued) to pseudo-gray color images.
#@cli : Default values: 'max_step=5', 'is_perceptual_constraint=1' and 'bits_depth=8'.
#@cli : The original pseudo-gray technique has been introduced by Rich Franzen [http://r0k.us/graphics/pseudoGrey.html].
#@cli : Extension of this technique to arbitrary increments for more tones, has been done by David Tschumperle.
to_pseudogray : check "isint(${1=5}) && $1>=0 && isint(${3=8}) && $3>0" skip ${2=1}
  e[^-1] "Convert scalar image$? to pseudo-gray color images, with steps $1."
  v - channels 0 srgb2rgb pseudogray $1,{2.3*$2},$3

  # Compute colormap with 65336 entries, to have match corresponding lightness.
  +srgb2lab. channels. 0 *. {65535/100} round. rows. 0,2
  rv[-2,-1] permute. xcyz +. 1 a[-2,-1] y pointcloud. 0
  +norm. !=. 0 distance. 1 *. -1 watershed.. . rm. -. 1

  # Map colormap to images, with lightness preservation.
  repeat {$!-1}
    to_rgb[$>] rgb2lab[$>] channels[$>] 0 *[$>] {65535/100} round[$>] c[$>] 0,65535
    map[$>] .
  done rm. v +

#@cli to_rgb
#@cli : Force selected images to be in RGB mode.
to_rgb :
   e[^-1] "Force image$? to be in RGB mode."
   v - repeat $! l[$>]
     if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
     elif {s==4} channels 0,2
     elif {s==2} channels 0,0 r 100%,100%,100%,3
     elif {s==1} r 100%,100%,100%,3
     fi
   endl done v +

#@cli to_rgba
#@cli : Force selected images to be in RGBA mode.
to_rgba :
   e[^-1] "Force image$? to be in RGBA mode."
   v - repeat $! l[$>]
     if {s>4} v + error[] "Command '$0': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
     elif {s==3} channels 0,3 sh. 3 f. 255 rm.
     elif {s==2} r 100%,100%,100%,4 sh. 2 f. .. rm.
     elif {s==1} r 100%,100%,100%,4 sh. 3 f. 255 rm.
     fi
   endl done v +

#@cli transfer_histogram : [reference_image],_nb_levels>0,_color_channels
#@cli : Transfer histogram of the specified reference image to selected images.
#@cli : Argument 'color channels' is the same as with command 'apply_channels'.
#@cli : Default value: 'nb_levels=256' and 'color_channels=all'.
#@cli : $ image.jpg 100,100,1,3,"u([256,200,100])" +transfer_histogram[0] [1]
transfer_histogram : check ${"is_image_arg $1"}" && ${2=256}>0" skip "${3=0}"
  v - mode="$3"
  if {isval("$3")} if {isint("$3")}
    mode=${arg\ 1+$3,all,rgba,rgb,rgb_r,rgb_g,rgb_b,rgba_a,\
                     lrgb,lrgb_r,lrgb_g,lrgb_b,\
                     ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
                     lab_l,lab_ab,lab_a,lab_b,\
                     lch_ch,lch_c,lch_h,\
                     hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
                     cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
                     yiq_y,yiq_iq}
  fi fi
  v + e[^-1] "Transfer histogram of image $1 to image$?, with $2 levels on channels '"$mode"'." v -
  if {['$mode']!='all'} repeat $! pass$1 # Small geometric hack to be able to use 'apply_channels'.
      w0,h0,d0,s0={$>,[w,h,d,s]}
      w1,h1,d1,s1={-1,[w,h,d,s]}
      to_colormode[$>] {s}
      a[$>,-1] x
      ac_arg="+z "$w0",0,0,100%,"{[$h1,$d1]-1}" r.. "$w0,$h0,$d0",100%,0,0 _transfer_histogram $2 rm."
      apply_channels[$>] {``$ac_arg},$mode,0
      r[$>] $w0,$h0,$d0,$s0,0
    done
  else repeat $! pass$1 _transfer_histogram[$>,-1] $2 done rm.
  fi v +

_transfer_histogram :
  repeat {min(s#0,s#1)}
    sh $> im,iM={[min(im#0,im#1),max(iM#0,iM#1)]}
    equalize.. $1
    +histogram_cumul. $1,1,$im,$iM *. {$iM-$im} +. $im rm..
    index.. .,0,0 *.. {($iM-$im)/$1} +.. $im
    rm[-2,-1]
  done

#@cli transfer_rgb : [target],_gamma>=0,_regularization>=0,_luminosity_constraints>=0,_rgb_resolution>=0,_is_constraints={ 0 | 1 }
#@cli : Transfer colors from selected source images to selected reference image (given as argument).
#@cli : 'gamma' determines the importance of color occurrences in the matching process (0=none to 1=huge).
#@cli : 'regularization' determines the number of guided filter iterations to remove quantization effects.
#@cli : 'luminosity_constraints' tells if luminosity constraints must be applied on non-confident matched colors.
#@cli : 'is_constraints' tells if additional hard color constraints must be set (opens an interactive window).
#@cli : Default values: 'gamma=0.3','regularization=8', 'luminosity_constraints=0.1', 'rgb_resolution=64' and 'is_constraints=0'.
#@cli : $ sample pencils,wall +transfer_rgb[0] [1],0,0.01
transfer_rgb : check "${2=0.3}>=0 && ${3=8}>=0 && ${4=0.15}>=0 && ${5=64}>=0 && isint(${6=0})"
  e[^-1] "Transfer colors of image $1 to image$?."
  v - sigma=1.5
  repeat $! pass$1 0 l[$>,-1]
    nm_source={0,b} nm_target={1,b}
    nm[0] source nm[1] target

    # Generate matching functions from 3D RGB features.
    +_transfer_rgb[source,target] $2,$sigma,$5
    nm.. fsource nm. ftarget
    n[fsource,ftarget] 0,255

    # Manage color constraints.
    if $6
      h0={2*{*,v}/3} ws0={source,max(1,w*$h0/h)} wt0={target,max(1,w*$h0/h)}
      w1={2*{*,u}/3} hs1={source,max(1,h*$w1/w)} ht1={target,max(1,h*$w1/w)}
      if {abs($ws0+$wt0-$w1)<abs($hs1+$ht1-$h0)} # Append along X.
        +r2dy[source,target] $h0 +b[-2,-1] 0.5% a[-4,-3] x a[-2,-1] x
      else # Append along Y.
        +r2dx[source,target] $w1 +b[-2,-1] 0.5% a[-4,-3] y a[-2,-1] y
      fi
      if {w>$w1} r2dx[-2,-1] $w1 fi
      if {h>$h0} r2dy[-2,-1] $h0 fi
      nm.. visu nm. both

      w[visu] -1,-1
      N=0 do
        w[] -1,-1,"[G'MIC] Add Color Guide (Constraint ""#"{1+$N}")"
        +select[$visu] 1 if {i==-1} rm. break fi
        line[$visu] {i[0]},{i[1]},{i[3]},{i[4]},1,0xF0F0F0F0,0
        line[$visu] {i[0]},{i[1]},{i[3]},{i[4]},1,0x0F0F0F0F,255
        circle[$visu] {i[0]},{i[1]},5,1,0,0,0 circle[$visu] {i[0]},{i[1]},3,1,255,0,0
        circle[$visu] {i[3]},{i[4]},5,1,0,0,0 circle[$visu] {i[3]},{i[4]},3,1,0,255,0
        s. y,2 rows[-2,-1] 0,1 a[-2,-1] x permute. xczy
        +warp[$both] .,0,0 rm..
        *. {($5-1)/255} s. x,2
        -. .. *. -1 a[-2,-1] c
        N+=1
      while {*}
      if $N a[-$N--1] x permute. xczy nm. constraints fi
      rm[$visu,$both] w 0
    fi

    # Estimate warping field.
    if $constraints
      +pointcloud. 0 r. ...,...,...,3,0 +compose_channels. + a[-2,-1] c
      displacement[fsource] [ftarget],0.001,5,0,10000,1,. rm[ftarget,constraints,-1]
    else
      displacement[fsource] [ftarget],0.005 rm[ftarget]
    fi
    nm[fsource] displacement

    # Generate video of matching.
    # if videos
    #   N=$!
    #   [displacement],[displacement],[displacement],1,x +f. y +f. z a[-3--1] c *. {255/(w-1)} +. 1
    #   +_transfer_rgb[source] 0,$sigma,{w} *.. . distance. 1 *. -1 watershed.. . rm.
    #   +_transfer_rgb[source] 0,$sigma,{w} a[-2,-1] c

    #   [displacement],[displacement],[displacement],1,x +f. y +f. z a[-3--1] c *. {255/(w-1)} +. 1
    #   +_transfer_rgb[target] 0,$sigma,{w} *.. . distance. 1 *. -1 watershed.. . rm.
    #   +_transfer_rgb[target] 0,$sigma,{w} a[-2,-1] c
    #   warp. [displacement],1,1,1,48

    #   l[$N--1]
    #     f3d 1200
    #     ap "s. c,-3 view_func. 6,.. rm.."
    #     ap "makefig"
    #     append[^0] [0],x rm[0]
    #     r2dx 1024
    #     [-1]x20
    #     o videos/video_${nm_source}_to_${nm_target}.avi,10
    #     rm
    #   endl
    # fi

    # Estimate confidence of the color mapping.
    +_transfer_rgb[target] 0,$sigma,{displacement,w}
    warp. [displacement],1,1,1 c. 0,100% nm. fconfidence
    +map_clut[source] . nm. confidence

    # Generate transfer CLUT.
    [displacement],[displacement],[displacement],1,x +f. y +f. z a[-3--1] c *. {255/(w-1)} +. 1
    +_transfer_rgb[target] 0,0,{w} *.. .
    warp[-2,-1] [displacement],1,0,1
    distance. 1 *. -1 watershed.. . rm. -. 1
    nm. clut
    b[clut] $sigma%

    # Enforce luminosity constraint for non-confident colors.
    if {$4>0}
      ^[fconfidence] {$4/10} *[fconfidence] -1 +[fconfidence] 1
      +f[fconfidence] x +f. y +f. z a[-3--1] c *. {255/(w-1)}
      rgb2hsv[clut,-1] channels. 100%
      j[clut] .,0,0,0,2,1,[fconfidence] rm.
      hsv2rgb[clut]
    fi

    # Map CLUT to get result.
    +map_clut[source] [clut] nm. res_noregul

    # Apply guided smoothing to remove quantization artifacts.
    if {!$3}
      nm[res_noregul] res
    else
      l[source,res_noregul]
        rgb2ycbcr  # Perform regularization in YCbCr to avoid creation of false colors.
        +-[1] [0] repeat $3 guided. [0],5,5 done +. [0] c. 0,255
        ycbcr2rgb
      endl
      nm. res
      j[res] [res_noregul],0,0,0,0,1,[confidence]
      rm[res_noregul]
    fi

    k[res]
  endl done v +

# _transfer_rgb : _gamma>=0,_smoothness>=0,_resolution>0
# Convert selected images into 3D volumetric scalar function for color matching.
_transfer_rgb : v - l[] check "${1=0}>=0 && ${2=1.5}>=0 && ${3=128}>0" gamma=$1 smoothness=$2 res=$3 onfail noarg gamma=0 smoothness=1.5 res=128 endl v +
  e[^-1] "Convert image$? as 3D volumetric scalar functions for color matching, with gamma "$gamma", smoothness "$smoothness" and resolution "$res"."
  v - to_rgb repeat $! l[$>]
    b 0.3%
    r {w*h},3,1,1,-1 * {($res-1)/255}
    pointcloud 1,$res,$res,$res f 'if(i,i^$gamma,0)' b $smoothness% n 0,1
  endl done v +

#@cli xyz2lab : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from XYZ to Lab.
#@cli : Default value: 'illuminant=1'.
xyz2lab : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from XYZ to Lab, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - to_color
  f "
    begin(
      lab(x) = (24389*x>216?cbrt(x):(24389*x/27 + 16)/116);
      D65 = [ 0.4124564, 0.3575761, 0.1804375,
              0.2126729, 0.7151522, 0.0721750,
              0.0193339, 0.1191920, 0.9503041 ];
      D50 = [ 0.43603516, 0.38511658, 0.14305115,
              0.22248840, 0.71690369, 0.06060791,
              0.01391602, 0.09706116, 0.71392822 ];
      white = ("$illu"?D65:D50)*[ 1,1,1 ];
    );
    fX = lab(R/white[0]);
    fY = lab(G/white[1]);
    fZ = lab(B/white[2]);
    [ cut(116*fY - 16,0,100), 500*(fX - fY), 200*(fY - fZ) ];
  "
  v +

#@cli xyz2rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from XYZ to RGB.
#@cli : Default value: 'illuminant=1'.
xyz2rgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from XYZ to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v -
  if $illu # D65
    mix_rgb {[3.2404542,-1.5371385,-0.4985314,\
              -0.9692660,1.8760108,0.0415560,\
              0.0556434,-0.2040259,1.0572252]*255}
  else # D50
    mix_rgb {[3.134274799724,-1.617275708956,-0.490724283042,\
              -0.978795575994,1.916161689117,0.033453331711,\
              0.071976988401,-0.228984974402,1.405718224383]*255}
  fi
  c 0,255 v +

#@cli xyz82rgb : illuminant={ 0=D50 | 1=D65 } : (no arg)
#@cli : Convert color representation of selected images from XYZ8 to RGB.
#@cli : Default value: 'illuminant=1'.
xyz82rgb : skip "${1=,}"
  v - l[] if {isval("$1")} illu={"$1?1:0"} else if {["'$1'"]!=','} noarg fi illu=1 fi onfail noarg illu=1 endl v +
  e[^-1] "Convert color representation of image$? from XYZ8 to RGB, using the D"{arg(1+$illu,50,65)}" illuminant."
  v - repeat $!
    sh[$>] 0 /. 255 rm.
    sh[$>] 1 /. 255 rm.
    sh[$>] 2 /. 231.8182 rm.
  done xyz2rgb $illu v +

#@cli ycbcr2rgb
#@cli : Convert color representation of selected images from YCbCr to RGB.
ycbcr2rgb :
  e[^-1] "Convert color representation of image$? from YCbCr to RGB."
  v - repeat $!
    sh[$>] 0 -. 16 rm.
    sh[$>] 1,2 -. 128 rm.
    sh[$>] 0,2 mix_rgb. 298,0,409,\
                        298,-100,-208,\
                        298,516,0
    +. 128 /. 256 c. 0,255 rm.
  done v +

#@cli yiq2rgb
#@cli : Convert color representation of selected images from YIQ to RGB.
yiq2rgb :
  e[^-1] "Convert color representation of image$? from YIQ to RGB."
  v -
  mix_rgb 1,0.9563,0.6210,\
          1,-0.2721,-0.6474,\
          1,-1.1070,1.7046
  c 0,255 v +

#@cli yiq82rgb
#@cli : Convert color representation of selected images from YIQ8 to RGB.
yiq82rgb :
  e[^-1] "Convert color representation of image$? from YIQ8 to RGB."
  v - repeat $!
    sh[$>] 1 /. 0.8393238012481239 -. 151.908 rm.
    sh[$>] 2 /. 0.9567690472081104 -. 133.261 rm.
  done
  mix_rgb 1,0.9563,0.6210,\
          1,-0.2721,-0.6474,\
          1,-1.1070,1.7046
  c 0,255 v +

#@cli yuv2rgb
#@cli : Convert color representation of selected images from YUV to RGB.
yuv2rgb :
  e[^-1] "Convert color representation of image$? from YUV to RGB."
  v -
  mix_rgb {[1,0,1.13983,\
            1,-0.39465,-0.5806,\
            1,2.03211,0]*255}
  c 0,255 v +

#@cli yuv82rgb
#@cli : Convert selected images from YUV8 to RGB color bases.
yuv82rgb :
  e[^-1] "Convert color representation of image$? from YUV8 to RGB."
  v - repeat $!
    sh[$>] 0 /. 255 rm.
    sh[$>] 1 /. 289.773 -. 0.44 rm.
    sh[$>] 2 /. 205.645 -. 0.62 rm.
  done yuv2rgb v +

#---------------------------------
#
#@cli :: Geometry Manipulation
#
#---------------------------------

#@cli a : eq. to 'append' : (+)

#@cli append : [image],axis,_centering : axis,_centering : (+)
#@cli : Append specified image to selected images, or all selected images together, along specified axis.
#@cli : (eq. to 'a').\n
#@cli : 'axis' can be { x | y | z | c }.
#@cli : Usual 'centering' values are { 0=left-justified | 0.5=centered | 1=right-justified }.
#@cli : Default value: 'centering=0'.
#@cli : $ image.jpg split y,10 reverse append y
#@cli : $ image.jpg repeat 5 +rows[0] 0,{10+18*$>}% done remove[0] append x,0.5
#@cli : $ image.jpg append[0] [0],y

#@cli append_tiles : _M>=0,_N>=0,0<=_centering_x<=1,0<=_centering_y<=1
#@cli : Append MxN selected tiles as new images.
#@cli : If 'N' is set to 0, number of rows is estimated automatically.
#@cli : If 'M' is set to 0, number of columns is estimated automatically.
#@cli : If 'M' and 'N' are both set to '0', auto-mode is used.
#@cli : If 'M' or 'N' is set to 0, only a single image is produced.
#@cli : 'centering_x' and 'centering_y' tells about the centering of tiles when they have different sizes.
#@cli : Default values: 'M=0', 'N=0', 'centering_x=centering_y=0.5'.
#@cli : $ image.jpg split xy,4 append_tiles ,
append_tiles : check "isint(${1=0}) && isint(${2=0}) && ${3=0.5}>=0 && $3<=1 && ${4=$3}>=0 && $4<=1"
  if {!$!} e[0--3] "Append image$? as a 0x0-tiled image." return fi
  if {!$1&&!$2} # auto-mode
    v - N={int(sqrt($!))} M={round($!/$N,1,1)}
    v + e[0--3] "Append image$? as a "${M}x${N}"-tiled image (auto-mode)." v -
    MN={$M*$N} if {$!%$MN} {$MN-($!%$MN)} s. x fi
  elif {!$2} # auto-rows
    v - M=$1 N={round($!/$1,1,1)}
    v + e[0--3] "Append image$? as a "${M}x${N}"-tiled image." v -
    if {$M>$!} v + warn[0--3] "Missing images for having one row in a "${M}x${N}"-tiled image." return fi
    if {$!%$M} {$M-($!%$M)} s. x fi
  elif {!$1} # auto-columns
    v - M={round($!/$2,1,1)} N=$2
    v + e[0--3] "Append image$? as a "${M}x${N}"-tiled image." v -
    if {$N>$!} v + warn[0--3] "Missing images for having one column in a "${M}x${N}"-tiled image." return fi
    if {$!%$M} {$M-($!%$M)} s. x fi
  else
    e[0--3] "Append image$?, as $1x$2-tiled images." v -
    M=$1 N=$2
  fi

  MN={$M*$N}
  repeat {int($!/$MN)} l[$>-{$>+$MN-1}]

    # Resize to best match for each column and row.
    $MN,1,1,2 repeat $MN point. $>,0,0,1,{$>,w},{$>,h} done r. $M,$N,1,2,-1
    s. c l.. s y max endl l. s x max endl
    i=0 repeat $N,y repeat $M r[$i] {-2,@$>},{@$y},100%,100%,0,0,$3,$4 i+=1 done done
    rm[-2,-1]

    # Append images together.
    repeat {int($!/$M)} a[$>-{$>+$M-1}] x done
    repeat {int($!/$N)} a[$>-{$>+$N-1}] y done
  endl done
  v +

#@cli apply_scales : "command",number_of_scales>0,_min_scale[%]>=0,_max_scale[%]>=0,_scale_gamma>0,_interpolation
#@cli : Apply specified command on different scales of selected images.
#@cli : 'interpolation' can be { 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : Default value: 'min_scale=25%', 'max_scale=100%' and 'interpolation=3'.
#@cli : $ image.jpg apply_scales "blur 5 sharpen 1000",4
apply_scales : skip "${1=}" check "isint($2) && $2>0 && ${3=25%}>=0 && ${4=100%}>=0 && ${5=1}>0 && isint(${6=3}) && $6>=0"
  v - s0="no" s1="nearest-neighbor" s2="average" s3="linear" s4="grid" s5="bicubic" s6="lanczos" v +
  e[^-1] "Apply command '$1' on image$? for $2 scales ($3 -> $4) and "${s{min(6,$6)}}" interpolation."
  v - repeat $! l[$<] nm={0,n}
    scale0={if(${"is_percent $3"},$3*max(w,h,d),$3)}
    scale1={if(${"is_percent $4"},$4*max(w,h,d),$4)}
    repeat $2
      scale={$scale0+($scale1-$scale0)*($>/max(1,$2-1))^$5}
      w={0,w==1?1:max(1,round($scale*w/max(w,h,d)))}
      h={0,h==1?1:max(1,round($scale*h/max(w,h,d)))}
      d={0,d==1?1:max(1,round($scale*d/max(w,h,d)))}
      +r[0] $w,$h,$d,100%,$6
      if {narg("$1")} l. $1 endl fi
    done
    rm[0] nm $nm
  endl done v +

#@cli autocrop : value1,value2,... : (no arg) : (+)
#@cli : Autocrop selected images by specified vector-valued intensity.
#@cli : If no arguments are provided, cropping value is guessed.
#@cli : $ 400,400,1,3 fill_color 64,128,255 ellipse 50%,50%,120,120,0,1,255 +autocrop

#@cli autocrop_components : _threshold[%],_min_area[%]>=0,_is_high_connectivity={ 0 | 1 },_output_type={ 0=crop | 1=segmentation | 2=coordinates }
#@cli : Autocrop and extract connected components in selected images, according to a mask given as the last channel of
#@cli : each of the selected image (e.g. alpha-channel).
#@cli : Default values: 'threshold=0%', 'min_area=0.1%', 'is_high_connectivity=0' and 'output_type=1'.
#@cli : $ 256,256 noise 0.1,2 eq 1 dilate_circ 20 label_fg 0,1 normalize 0,255 +neq 0 *[-1] 255 append c +autocrop_components ,
autocrop_components : skip ${1=0%} check "${2=0.1%}>=0 && isbool(${3=0}) && isint(${4=1}) && $4>=0 && $4<=2"
  e[^-1] "Autocrop connected components from image$?, with threshold $1, minimal area $2, "${arg\ 1+$3,low,high}" connectivity "\
          "and output type set to '"${arg\ 1+$4,crop,segmentation,coordinates}"'.\n"
  v - repeat $! l[$>]
    min_area={max(1,round(if(${is_percent\ $2},$2*w*h,$2)))}
    +channels 100% >. $1 area_fg. 0,$3 >=. $min_area  # Discard background and small objects.
    +area. 0,1 <. $min_area -|[-2,-1] label_fg. 0,1    # Fill small holes in objects.

    # Extract detected objects.
    N={iM} repeat {iM}
      n={1+$>}
      v + e[] "\r  > "$n/$N v -
      rprogress {100*$n/$N}
      +==[1] $n +*[0,-1] rm..
      if {$4==0} coords=${autocrop_coords.\ auto} rm. +z[0] $coords
      elif {$4==1} autocrop.
      else coords=${autocrop_coords.\ auto} rm. ($coords) y.
      fi
    done
    rm[0,1]
    if {!$!} 0 fi
    if {$4==2} a x fi
  endl done v +

#@cli autocrop_seq : value1,value2,... | auto
#@cli : Autocrop selected images using the crop geometry of the last one by specified vector-valued intensity,
#@cli : or by automatic guessing the cropping value.
#@cli : Default value: auto mode.
#@cli : $ image.jpg +fill[-1] 0 ellipse[-1] 50%,50%,30%,20%,0,1,1 autocrop_seq 0
autocrop_seq : skip ${1=auto}
  e[^-1] "Auto-crop image$? using crop geometry of last image by vector '$*'."
  if {!$!} return fi
  v -
  is_auto={['"$1"']=='auto'}
  if {$!==1} _autocrop$is_auto ${1--1} v + return fi
  coords=${autocrop_coords.\ ${1--1}}
  x0={arg(1,$coords)} y0={arg(2,$coords)} z0={arg(3,$coords)}
  x1={arg(4,$coords)} y1={arg(5,$coords)} z1={arg(6,$coords)}
  if {$x0>$x1" || "$y0>$y1" || "$z0>$z1} i[0--2] 0 rm[1--1:2]
  else z $x0,$y0,$z0,$x1,$y1,$z1
  fi
  v +

#@cli channels : { [image0] | c0[%] },_{ [image1] | c1[%] } : (+)
#@cli : Keep only specified channels of selected images.
#@cli : Dirichlet boundary is used when specified channels are out of range.
#@cli : $ image.jpg channels 0,1
#@cli : $ image.jpg luminance channels 0,2

#@cli columns : { [image0] | x0[%] },_{ [image1] | x1[%] } : (+)
#@cli : Keep only specified columns of selected images.
#@cli : Dirichlet boundary is used when specified columns are out of range.
#@cli : $ image.jpg columns -25%,50%

#@cli z : eq. to 'crop'. : (+)

#@cli crop : x0[%],x1[%],_boundary_conditions : x0[%],y0[%],x1[%],y1[%],_boundary_conditions : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%],_boundary_conditions : x0[%],y0[%],z0[%],c0[%],x1[%],y1[%],z1[%],c1[%],_boundary_conditions : (no arg) : (+)
#@cli : Crop selected images with specified region coordinates.
#@cli : (eq. to 'z').\n
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : In interactive mode, the chosen crop coordinates are returned in the status.
#@cli : Default value: 'boundary_conditions=0'.
#@cli : $ image.jpg +crop -230,-230,280,280,1 crop[0] -230,-230,280,280,0
#@cli : $ image.jpg crop 25%,25%,75%,75%

#@cli diagonal
#@cli : Transform selected vectors as diagonal matrices.
#@cli : $ 1,10,1,1,'y' +diagonal
diagonal :
  e[^-1] "Transform vector$? as diagonal matrix."
  v - y repeat $! r[$>] {$>,h+1},100%,1,1,0 r[$>] {$>,h},100%,1,1,-1 done v +

# downsize_aliased : 100<=factor<=0
# Downsize selected images with a specific algorithm to better render anti-aliased rendering
# over transparent background (from aliased transparent images, manage transparent border pixels with more care).
downsize_aliased : check "${1=50}>=0 && $1<=100"
  if {$1==100} return elif {!$1} r 1,1,1,100%,2 return fi
  N={ceil(1+100/$1)}
  repeat $! l[$>]
    split_opacity
    if {$!==1} continue fi
    +dilate.. $N +==.. 0
    j[0] ..,0,0,0,0,1,. rm[-2,-1]
    a c
    r $1%,$1%,$1%,100%,2
  endl done

#@cli elevate : _depth,_is_plain={ 0 | 1 },_is_colored={ 0 | 1 }
#@cli : Elevate selected 2D images into 3D volumes.
#@cli : Default values: 'depth=64', 'is_plain=1' and 'is_colored=1'.
elevate : check "${1=64}>0" skip ${2=1},${3=1}
  e[^-1] "Elevate 2D image$? into $1-slices volume(s)."
  v - r 100%,100%,1,100%
  repeat $! l[$>] nm={0,n}
    +norm 100%,100%,$1,{if($3,{0,s},1)}
    m={-2,im} d={-2,iM-$m}
    repeat $1
      if $2 +>=[1] {$m+$d*($>+1)/$1}
      else +ir[1] {$m+$d*$>/$1},{$m+$d*($>+1)/$1}
      fi
      r. 100%,100%,1,.. if $3 *. [0] fi
      j.. .,0,0,$> rm.
    done
  rm[0,1] nm $nm endl done v +

#@cli expand_x : size_x>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the x-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg expand_x 30,0
expand_x : check "$1>=0 && ${2=1}>=0 && $2<=3"
  e[^-1] "Expand image$? along the x-axis with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! r[$>] {$>,w+2*$1},100%,100%,100%,0,$2,0.5,0.5,0.5 done v +

#@cli expand_xy : size>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the xy-axes.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg expand_xy 30,0
expand_xy : check "$1>=0 && ${2=1}>=0 && $2<=3"
  e[^-1] "Expand image$? along the xy-axes with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! r[$>] {$>,w+2*$1},{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 done v +

#@cli expand_xyz : size>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the xyz-axes.
#@cli : Default value: 'boundary_conditions=1'.
expand_xyz : check "$1>=0 && ${2=1}>=0 && $2<=3"
  e[^-1] "Expand image$? along the xyz-axes with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! r[$>] {$>,w+2*$1},{$>,h+2*$1},{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 done v +

#@cli expand_y : size_y>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the y-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg expand_y 30,0
expand_y : check "$1>=0 && ${2=1}>=0 && $2<=3"
  e[^-1] "Expand image$? along the y-axis with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! r[$>] 100%,{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 done v +

#@cli expand_z : size_z>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Expand selected images along the z-axis.
#@cli : Default value: 'boundary_conditions=1'.
expand_z : check "$1>=0 && ${2=1}>=0 && $2<=3"
  e[^-1] "Expand image$? along the z-axis with size $1 and "${"arg 1+$2,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! r[$>] 100%,100%,{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 done v +

#@cli extract_region : [label_image],_extract_xyz_coordinates={ 0 | 1 },_label_1,...,_label_M
#@cli : Extract all pixels of selected images whose corresponding label in '[label_image]' is equal to 'label_m',
#@cli : and output them as M column images.
#@cli : Default value: 'extract_xyz_coordinates=0'.
#@cli : $ image.jpg +blur 3 quantize. 4,0 +extract_region[0] [1],0,1,3
extract_region : check ${"is_image_arg $1"}" && isval(${2=0})"
  if {$#<3} e[0--3] "Extract pixels of image$? for labels [] in image $1, with"${"arg 1+!!$2,out"}" coordinates -> no labels provided, ignoring." return fi
  e[^-1] "Extract pixels of image$? for labels {${3--1}} in image $1, with"${"arg 1+!!$2,out"}" coordinates."
  v - pass$1 mv. 0 repeat {$!-1} l[0,{1+$<}]
    1,16,1,{s+($2?3:0)} if {$#>3} .x{$#-3} fi
    f[0] ">"${-math_lib}"
      begin(
        const N = iM + 1;  # Number of labels
        R = [ ${3--1} ];   # Requested labels
        hash = vectorN(0); # Correspondence table
        for (k = 0, k<size(R), ++k, hash[R[k]] = k + 2);
      );
      (ind = hash[i])>0?(
        $2?dar_insert(#ind,[ I(#1),x,y,z ]):dar_insert(#ind,I(#1));
      ); i;
      end(for (k = 2, k<l, ++k, resize(#k,1,dar_size(#k),1,-100,0)))"
    rm[1]
  endl done rm[0] v +

#@cli montage : "_layout_code",_montage_mode={ 0<=centering<=1 | 2<=scale+2<=3 },_output_mode={ 0=single layer | 1=multiple layers },"_processing_command"
#@cli : Create a single image montage from selected images, according to specified layout code :
#@cli : - 'X' to assemble all images using an automatically estimated layout.
#@cli : - 'H' to assemble all images horizontally.
#@cli : - 'V' to assemble all images vertically.
#@cli : - 'A' to assemble all images as an horizontal array.
#@cli : - 'B' to assemble all images as a vertical array.
#@cli : - 'Ha:b' to assemble two blocks 'a' and 'b' horizontally.
#@cli : - 'Va:b' to assemble two blocks 'a' and 'b' vertically.
#@cli : - 'Ra' to rotate a block 'a' by 90 deg. ('RRa' for 180 deg. and 'RRRa' for 270 deg.).
#@cli : - 'Ma' to mirror a block 'a' along the X-axis ('MRRa' for the Y-axis).
#@cli : A block 'a' can be an image index (treated periodically) or a nested layout expression 'Hb:c','Vb:c','Rb' or 'Mb' itself.
#@cli : For example, layout code 'H0:V1:2' creates an image where image [0] is on the left, and images [1] and [2] vertically packed on the right.
#@cli : Default values: 'layout_code=X', 'montage_mode=2', output_mode='0' and 'processing_command=""'.
#@cli : $ image.jpg sample ? +plasma[0] shape_cupid 256 normalize 0,255 frame 3,3,0 frame 10,10,255 to_rgb +montage A +montage[^-1] H1:V0:VH2:1H0:3
montage : check "isval(${2=2}) && $2>=0 && $2<=3" skip "${1=X}",${3=0},"${4=}"
  if {$2<=1} e[0--3] "Create aligned montage from image$?, with layout code '$1' and centering $2."
  else e[0--3] "Create scaled montage from image$?, with layout code '$1' and scale "{$2-2}"."
  fi
  v - to_colormode 0

  # Manage automatic layout.
  if {lowercase('"$1"')=='x'} +l
    repeat $! nm[$>] $> done
    repeat {$!-1}
      if {{-2,w>h}" && "w>h} mode=V      # Both landscape.
      elif {{-2,h>w}" && "h>w} mode=H    # Both portrait.
      elif {{-2,w>h}" && "h>w} # Landscape - portrait.
        if {{-2,h/w}<(w/h)} mode=V else mode=H fi
      else # Portrait - landscape.
        if {{-2,w/h}<(h/w)} mode=H else mode=V fi
      fi
      name=$mode{-2,n}:{n}
      montage[-2,-1] $mode,$2
      mv. 0 nm[0] $name
    done
    layout={0,n}
    rm endl montage $layout,$2,$3,"$4"

  else # Non-automatic layout.

    # Format and check validity of layout code.
    N=$!
    l[] _scode="$1" _mode=$2
      if {lowercase('"$1"')=='h'} if {$N>1} {$N-1},1,1,1,-1 $N,1,1,1,x a x y else v + return fi # Simple horizontal montage.
      elif {lowercase('"$1"')=='v'} if {$N>1} {$N-1},1,1,1,-2 $N,1,1,1,x a x y else v + return fi # Simple vertical montage.
      elif {s=lowercase('"$1"');s=='a'||s=='b'} # Montage as an array.
        if {$N<2} v + return fi
        nr={round(sqrt($N))} nc={round($N/$nr,1,1)}              # Horizontal array.
        if {lowercase('"$1"')=='b'} n=$nr nr=$nc nc=$n fi # Vertical array.
        $N,1,1,1,x s x,-{round(w/$nr,1,1)} repeat $! l[$>] if {w>1} i[0] {w-1},1,1,1,-1 a x fi endl done a x
        if {$nr>1} i[0] {$nr-1},1,1,1,-2 a x fi y
      else # Other complex montage.
        ({'"$1"'}) f 'if(i==72||i==104,-1,if(i==86||i==118,-2,if(i==82||i==114,-3,if(i==77||i==109,-4,if(i>=48&&i<=57,i-48,-5)))))'
        s +,-1 s +,-2 s +,-3 s +,-4 s +,-5
        repeat $! l[$>] if {im>=0} ++. 48 =.. {t} rm. rows 0 fi endl done a y discard -5
      fi
      f 'if(i<0,i,i%$N)'
    endl
    if {$!==$N} rm v + return fi  # Empty layout code.
    nm[^-1] 0 repeat {h} c={i[$>]} if {$c>=0} if {$c,n} i.. [$c] i={$!-2} =. $i,0,$> ref$i=$c else nm[$c] 1 ref$c=$c fi fi done # Duplicate multiple references.
    _code={^} _lcode={narg($_code)} rm.

    # Determine image positions and sizes.
    N=$! repeat $N ($>,0,0,{$>,w},{$>,h},0,0,0) done
    l[$N--1] _p=1 k[${-_montage}] w={i[3]} h={i[4]} f 'if(i(0,y)<0,-1,i)' discard -1 r 8,{h/8},1,1,-1
    onfail error[0--3] "Too many input images."
    endl

    # Render montage.
    if {narg("$4")} m "__montage : $4 k[0]"
    else
    m "__montage : if {$""7%2} mirror x fi if {$""8%2} mirror y fi rotate {90*$""6} r {max(1,round($""4,1,1))},{max(1,round($""5,1,1))},1,100%,3"
    fi
    s=${max_s[^-1]}
    repeat {h}
      i={i(0,$>)} xi={i(1,$>)} yi={i(2,$>)} wi={i(3,$>)} hi={i(4,$>)} ai={i(5,$>)} mxi={i(6,$>)} myi={i(7,$>)}
      if {$3||!$>} i.. $w,$h,1,$s fi
      __montage[$i] ${ref$i},$xi,$yi,{max(1,$wi)},{max(1,$hi)},$ai,$mxi,$myi
      j.. [$i],$xi,$yi
    done
    uncommand __montage
    rm[0-{$N-1},-1]

  fi
  nm "[Montage '$1']"
  v +

_montage :
  if {$_p>$_lcode} v + error "Command 'montage': Incomplete layout code '"$_scode"'." fi
  c={arg($_p,$_code)}
  if {$c>=0} _p+=1 u $c # Single index.
  elif {$c==-4} # Mirror.
    _p+=1 l=${-_montage} f[$l] 'a=i(5,y)%2;if((x==7&&a)||(x==6&&!a),!i,if(x==1,i(3,0)-i(3,y)-i,i))' u $l
  elif {$c==-3} # Rotation.
    _p+=1 l=${-_montage} l[$l] s x +[2] [4] rv[1,2] *[1] -1 +[1] {4,@0} rv[3,4] +[5] 1 a x endl u $l
  else # Merge.
    _p+=1
    l=${-_montage} lw={$l,@3} lh={$l,@4}
    r=${-_montage} rw={$r,@3} rh={$r,@4}

    if {$c==-1} # Horizontal merge.
      if {$_mode<2}
        h={max($lh,$rh)} +[$l] '0,0,{($h-$lh)*min(1,$_mode)},0,0,0,0,0' +[$r] '0,$lw,{($h-$rh)*min(1,$_mode)},0,0,0,0,0'
      else
        h={($_mode-2)*max($lh,$rh)+(3-$_mode)*min($lh,$rh)}
        lf={$h/$lh} rf={$h/$rh} lw={$lw*$lf} rw={$rw*$rf}
        *[$l] '1,$lf,$lf,$lf,$lf,1,1,1' *[$r] '1,$rf,$rf,$rf,$rf,1,1,1' +[$r] '0,$lw,0,0,0,0,0,0'
      fi
      i[$l] (-1,0,0,{$lw+$rw},$h,0,0,0) a[$l,{$l+1}] y a[$l] [$r],y r[$r] 1,1,1,1,0

    else # Vertical merge.
      if {$_mode<2}
        w={max($lw,$rw)} +[$l] '0,{($w-$lw)*min(1,$_mode)},0,0,0,0,0,0' +[$r] '0,{($w-$rw)*min(1,$_mode)},$lh,0,0,0,0,0'
      else
        w={($_mode-2)*max($lw,$rw)+(3-$_mode)*min($lw,$rw)}
        lf={$w/$lw} rf={$w/$rw} lh={$lh*$lf} rh={$rh*$rf}
        *[$l] '1,$lf,$lf,$lf,$lf,1,1,1' *[$r] '1,$rf,$rf,$rf,$rf,1,1,1' +[$r] '0,0,$lh,0,0,0,0,0'
      fi
      i[$l] (-1,0,0,$w,{$lh+$rh},0,0,0) a[$l,{$l+1}] y a[$l] [$r],y r[$r] 1,1,1,1,0
    fi
    u $l
  fi

#@cli mirror : { x | y | z }...{ x | y | z } : (+)
#@cli : Mirror selected images along specified axes.
#@cli : $ image.jpg +mirror y +mirror[0] c
#@cli : $ image.jpg +mirror x +mirror y append_tiles 2,2

#@cli permute : permutation_string : (+)
#@cli : Permute selected image axes by specified permutation.
#@cli : 'permutation' is a combination of the character set {x|y|z|c},
#@cli : e.g. 'xycz', 'cxyz', ...
#@cli : $ image.jpg permute yxzc

#@cli r : eq. to 'resize'. : (+)

#@cli resize : [image],_interpolation,_boundary_conditions,_ax,_ay,_az,_ac : {[image_w] | width>0[%]},_{[image_h] | height>0[%]},_{[image_d] | depth>0[%]},_{[image_s] | spectrum>0[%]},_interpolation,_boundary_conditions,_ax,_ay,_az,_ac : (no arg) : (+)
#@cli : Resize selected images with specified geometry.
#@cli : (eq. to 'r').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0 or 4'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@cli : Default values: 'interpolation=1', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg (0,1;0,1^0,0;1,1^1,1;1,1) resize[-1] [-2],3 mul[-2] [-1]
#@cli : $ image.jpg +resize[-1] 256,128,1,3,2 +resize[-1] 120%,120%,1,3,0,1,0.5,0.5 +resize[-1] 120%,120%,1,3,0,0,0.2,0.2 +resize[-1] [0],[0],1,3,4

#@cli resize_mn : width[%]>=0,_height[%]>=0,_depth[%]>=0,_B_value,_C_value
#@cli : Resize selected images with Mitchell-Netravali filter (cubic).
#@cli : For details about the method, see: https://de.wikipedia.org/wiki/Mitchell-Netravali-Filter
#@cli : Default values: 'height=100%', 'depth=100%', 'B=0.3333' and 'C=0.3333'.
#@cli : $ image.jpg resize2dx 32 resize_mn 800%,800%
resize_mn : check "${2=100%}>=0 && ${3=100%}>=0" skip "${4=0.333},${5=0.333}"
  e[^-1] "Resize image$? to $1x$2x$3 using Mitchell-Netravali filter (B=$4, C=$5)."
  v -
  lib="const B = $4; const C = $5; const boundary = 1; const interp = 0;
       mn(P0,P1,P2,P3,d) = ( ( (-B/6-C)*P0 + (-3*B/2-C+2)*P1 + (3*B/2+C-2)*P2 + (B/6+C)*P3 )*d^3
                           + ( (B/2+2*C)*P0 + (2*B+C-3)*P1 + (-5*B/2-2*C+3)*P2 -C*P3)*d^2
                           + ( (-B/2-C)*P0 + (B/2+C)*P2)*d
                           + B/6*P0 + (-B/3+1)*P1 + B/6*P2);"
  repeat $! l[$>] nm={n}
    nw={${"is_percent $1"}?max(1,round($1*w)):round($1)}
    nh={${"is_percent $2"}?max(1,round($2*h)):round($2)}
    nd={${"is_percent $3"}?max(1,round($3*d)):round($3)}
    if {!$nw" || "!$nh" || "!$nd} rm 0
    elif {!w} rm $nw,$nh,$nd,1
    else
      if {w==1||$nw<w} r $nw,100%,100%,100%,{w==1?1:2}
      elif {$nw>w} $nw,100%,100%,100%,${lib}"X = x*(w#-1-1)/(w-1); d = X - int(X); P0 = I(#-1,X-1); P1 = I(#-1,X); P2 = I(#-1,X+1); P3 = I(#-1,X+2); mn(P0,P1,P2,P3,d);" k.
      fi
      if {h==1||$nh<h} r 100%,$nh,100%,100%,{h==1?1:2}
      elif {$nh!=h} 100%,$nh,100%,100%,${lib}"Y = y*(h#-1-1)/(h-1); d = Y - int(Y); P0 = I(#-1,x,Y-1); P1 = I(#-1,x,Y); P2 = I(#-1,x,Y+1); P3 = I(#-1,x,Y+2); mn(P0,P1,P2,P3,d);" k.
      fi
      if {d==1||$nd<d} r 100%,100%,$nd,100%,{d==1?1:2}
      elif {$nd!=d} 100%,100%,$nd,100%,${lib}"Z = z*(d#-1-1)/(d-1); d = Z - int(Z); P0 = I(#-1,x,y,Z-1); P1 = I(#-1,x,y,Z); P2 = I(#-1,x,y,Z+1); P3 = I(#-1,x,y,Z+2); mn(P0,P1,P2,P3,d);" k.
      fi
    fi
    nm $nm
  endl done v +

#@cli resize_pow2 : _interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images so that each dimension is a power of 2.
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=0', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg +resize_pow2[-1] 0
resize_pow2 : check "isint(${1=0}) && $1>=-1 && $1<=6" skip ${2=0},${3=0},${4=0},${5=0},${6=0}
  e[^-1] "Resize image$? so that each dimension is a power of 2."
  v - repeat $!
    r[$>] {$>,2^(round(log2(w),1,1))},{$>,2^(round(log2(h),1,1))},{$>,2^(round(log2(d),1,1))},100%,${1-6}
  done v +

#@cli rr2d : eq. to 'resize_ratio2d'.
rr2d :
  v - _gmic_s="$?" v +
  _resize_ratio2d $*

#@cli resize_ratio2d : width>0,height>0,_mode={ 0=inside | 1=outside | 2=padded },0=<_interpolation<=6
#@cli : Resize selected images while preserving their aspect ratio.
#@cli : (eq. to 'rr2d').
#@cli : Default values: 'mode=0' and 'interpolation=6'.
resize_ratio2d :
  v - _gmic_s="$?" v +
  _$0 $*

_resize_ratio2d : check "$1>0 && $2>0 && ${3=0}>=0 && $3<=2 && ${4=6}>=0 && $4<=6"
  e[0--3] "Resize 2D image"$_gmic_s" to $1x$2 with ratio-"${arg\ 1+$3,inside,outside,padded}\
           " mode and interpolation type $4."
  v - repeat $!
    ratio={$>,if($3==1,max($1/w,$2/h),min($1/w,$2/h))}
    r[$>] {$>,w*$ratio},{$>,h*$ratio},100%,100%,$4
  done
  if {$3==2} r $1,$2,100%,100%,0,0,0.5,0.5 fi
  v +

#@cli r2dx : eq. to 'resize2dx'.
r2dx :
  v - _gmic_s="$?" v +
  _resize2dx $*

#@cli resize2dx : width[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the x-axis, preserving 2D ratio.
#@cli : (eq. to 'r2dx').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg +resize2dx 100,2 append x
resize2dx :
  v - _gmic_s="$?" v +
  _$0 $*

_resize2dx : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 2D image"$_gmic_s" to $1 pixels along the x-axis, preserving 2D ratio."
  v - repeat $! l[$>]
    size={if(${is_percent\ $1},$1*w,$1)}
    r {max(1,$size)},{max(1,h*$size/w)},100%,100%,${2-7}
  endl done v +

#@cli r2dy : eq. to 'resize2dy'.
r2dy :
  v - _gmic_s="$?" v +
  _resize2dy $*

#@cli resize2dy : height[%]>=0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the y-axis, preserving 2D ratio.
#@cli : (eq. to 'r2dy').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
#@cli : $ image.jpg +resize2dy 100,2 append x
resize2dy :
  v - _gmic_s="$?" v +
  _$0 $*

_resize2dy : check "$1>=0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 2D image"$_gmic_s" to $1 pixels along the y-axis, preserving 2D ratio."
  v - repeat $! l[$>]
    size={if(${is_percent\ $1},$1*h,$1)}
    r {max(1,w*$size/h)},{max(1,$size)},100%,100%,${2-7}
  endl done v +

#@cli r3dx : eq. to 'resize3dx'.
r3dx :
  v - _gmic_s="$?" v +
  _resize3dx $*

#@cli resize3dx : width[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the x-axis, preserving 3D ratio.
#@cli : (eq. to 'r3dx').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dx :
  v - _gmic_s="$?" v +
  _$0 $*

_resize3dx : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the x-axis, preserving 3D ratio."
  v - repeat $! l[$>]
    size={if(${is_percent\ $1},$1*w,$1)}
    r {max(1,$size)},{max(1,h*$size/w)},{max(1,d*$size/w)},100%,${2-7}
  endl done v +

#@cli r3dy : eq. to 'resize3dy'.
r3dy :
  v - _gmic_s="$?" v +
  _resize3dy $*

#@cli resize3dy : height[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the y-axis, preserving 3D ratio.
#@cli : (eq. to 'r3dy').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dy :
  v - _gmic_s="$?" v +
  _$0 $*

_resize3dy : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the y-axis, preserving 3D ratio."
  v - repeat $! l[$>]
    size={if(${is_percent\ $1},$1*h,$1)}
    r {max(1,w*$size/h)},{max(1,$size)},{max(1,d*$size/h)},100%,${2-7}
  endl done v +

#@cli r3dz : eq. to 'resize3dz'.
r3dz :
  v - _gmic_s="$?" v +
  _resize3dz $*

#@cli resize3dz : depth[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
#@cli : Resize selected images along the z-axis, preserving 3D ratio.
#@cli : (eq. to 'r3dz').\n
#@cli : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@cli : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
#@cli : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
#@cli : . When 'interpolation==0', 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0=none | 1=neumann }.
#@cli : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@cli : (set to '0' by default, must be defined in range [0,1]).
#@cli : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dz :
  v - _gmic_s="$?" v +
  _$0 $*

_resize3dz : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the z-axis, preserving 3D ratio."
  v - repeat $! l[$>]
    size={if(${is_percent\ $1},$1*d,$1)}
    r[$>] {max(1,w*$size/d)},{max(1,h*$size/d)},{max(1,$size)},100%,${2-7}
  endl done v +

#@cli rotate : angle,_interpolation,_boundary_conditions,_center_x[%],_center_y[%] : u,v,w,angle,interpolation,boundary_conditions,_center_x[%],_center_y[%],_center_z[%] : (+)
#@cli : Rotate selected images with specified angle (in deg.), and optionally 3D axis (u,v,w).
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : When a rotation center (cx,cy,_cz) is specified, the size of the image is preserved.
#@cli : Default values: 'interpolation=1', 'boundary_conditions=0' and 'center_x=center_y=(undefined)'.
#@cli : $ image.jpg +rotate -25,1,2,50%,50% rotate[0] 25

#@cli rotate_tileable : angle,_max_size_factor>=0
#@cli : Rotate selected images by specified angle and make them tileable.
#@cli : If resulting size of an image is too big, the image is replaced by a 1x1 image.
#@cli : Default values: 'max_size_factor=8'.
rotate_tileable : check ${2=8}>=0
  e[^-1] "Rotate image$? with angle $1 deg. and make them tileable."
  v -

  # Reduce angle to known fraction.
  angle={$1%360}
  if {$angle>=270} rotate 270 angle-=270
  elif {$angle>=180} rotate 180 angle-=180
  elif {$angle>=90} rotate 90 angle-=90
  fi
  (0,1;1,8;1,7;1,6;1,5;1,4;1,5;1,3;2,5;1,2;2,5;3,5;2,3;3,4;4,5;1,1;5,4;7,5;3,2;8,5;9,5;2,1;3,1;4,1;5,1;6,1;7,1;8,1) # List of known fractions.
  s. x,2 +/[-2,-1] atan. *. {180/pi}   # Compute corresponding angles.
  ($angle) index. .. rm..
  p={-3,@{^}} q={-2,@{^}} rm[-3--1]       # Find nearest fraction p/q to atan(angle).
  if {!$p||!$q} v + return fi

  repeat $! l[$>]
    # Compute width and height of tile.
    theta={atan2($p,$q)}
    gcd=${gcd" "{h*$q},{w*$p}}
    pw={h*$q/$gcd}
    nw={round($pw*w/cos($theta))}
    gcd=${gcd" "{h*$p},{w*$q}}
    qh={w*$q/$gcd}
    nh={round($qh*h/cos($theta))}

    # Rotate and make tileable (may result in very large images!).
    if {!$2" || "($nw<$2*w" && "$nh<$2*h)}
      r {1.5*$nw},{1.5*$nh},1,100%,0,2
      rotate {$theta*180/pi},1,2,50%,50%
      r $nw,$nh,1,100%,0,2,0.5,0.5
    else v + error[0--4] "Command '$0': Invalid image dimension "({w},{h},{d},{s}).
    fi
  endl done v +

#@cli rows : { [image0] | y0[%] },_{ [image1] | y1[%] } : (+)
#@cli : Keep only specified rows of selected images.
#@cli : Dirichlet boundary conditions are used when specified rows are out of range.
#@cli : $ image.jpg rows -25%,50%

#@cli scale2x
#@cli : Resize selected images using the Scale2x algorithm.
#@cli : $ image.jpg threshold 50% resize 50%,50% +scale2x
scale2x :
  e[^-1] "Double xy-dimensions of image$?, using Scale2x algorithm."
  v - repeat $! l[$>]
    r 200%,200%
    f "dx=x&1;dy=y&1;A=j(0,-2,0,0,0,1);B=j(2,0,0,0,0,1);C=j(-2,0,0,0,0,1);D=j(0,2,0,0,0,1);"\
      "!dy*(!dx*if(C==A&&C!=D&&A!=B,A,i) + dx*if(A==B&&A!=C&&B!=D,B,i)) + dy*(dx*if(B==D&&B!=A&&D!=C,D,i) + !dx*if(D==C&&D!=B&&C!=A,C,i))"
  endl done v +

#@cli scale3x
#@cli : Resize selected images using the Scale3x algorithm.
#@cli : $ image.jpg threshold 50% resize 33%,33% +scale3x
scale3x :
  e[^-1] "Triple xy-dimensions of image$?, using Scale3x algorithm."
  v - repeat $! l[$>]
    r 300%,300%
    f "dx=x%3;dy=y%3;c0=!dx;c1=(dx==1);c2=(dx==2);"\
      "A=j(-3,-3,0,0,0,1);B=j(0,-3,0,0,0,1);C=j(3,-3,0,0,0,1);"\
      "D=j(-3,0,0,0,0,1);F=j(3,0,0,0,0,1);"\
      "G=j(-3,3,0,0,0,1);H=j(0,3,0,0,0,1);I=j(3,3,0,0,0,1);"\
      "!dy*(c0*if(D==B&&D!=H&&B!=F,D,i) + c1*if((D==B&&D!=H&&B!=F&&i!=C)||(B==F&&B!=D&&F!=H&&i!=A),B,i) + c2*if(B==F&&B!=D&&F!=H,F,i)) + "\
      "(dy==1)*(c0*if((H==D&&H!=F&&D!=B&&i!=A)||(D==B&&D!=H&&B!=F&&i!=G),D,i) + c1*i + c2*if((B==F&&B!=D&&F!=H&&i!=I)||(F==H&&F!=B&&H!=D&&i!=C),F,i)) + "\
      "(dy==2)*(c0*if(H==D&&H!=F&&D!=B,D,i) + c1*if((F==H&&F!=B&&H!=D&&i!=G)||(H==D&&H!=F&&D!=B&&i!=I),H,i) + c2*if(F==H&&F!=B&&H!=D,F,i))"
  endl done v +

#@cli scale_dcci2x : _edge_threshold>=0,_exponent>0,_extend_1px={ 0=false | 1=true }
#@cli : Double image size using directional cubic convolution interpolation,
#@cli : as described in https://en.wikipedia.org/wiki/Directional_Cubic_Convolution_Interpolation.
#@cli : Default values: 'edge_threshold=1.15', 'exponent=5' and 'extend_1px=0'.
#@cli : $ image.jpg +scale_dcci2x ,
scale_dcci2x : check "${1=1.15}>=0 && ${2=5}>=0" skip ${3=0}
  e[^-1] "Double xy-dimensions of image$?, using DCCI2x algorithm."
  v - repeat $! l[$>]
    r {2*w-(!$3)},{2*h-(!$3)},1,100%,4

    # Estimate diagonal values.
    f "begin(
         const threshold = $1;
         const exponent = $2;
         interpolation = 0;
         boundary = 1;
         j1(x,y) = P[7*y + x + 24]; # eq. to 'j(x,y)', but faster
         j2(x,y) = P[7*x - y + 24]; # eq. to 'j(-y,x)', but faster
         interp(k) = -k#(-3,-3) + 9*k#(-1,-1) + 9*k#(1,1) - k#(3,3);
         d(k) = sum(abs([
                    k#(-1,-3) - k#(-3,-1), k#(1,-3) - k#(-1,-1), k#(3,-3) - k#(1,-1),
                    k#(-1,-1) - k#(-3,1), k#(1,-1) - k#(-1,1), k#(3,-1) - k#(1,1),
                    k#(-1,1) - k#(-3,3), k#(1,1) - k#(-1,3), k#(3,1) - k#(1,3)
                ]));
       );
       if (!((x*y)%2),i,
       P = crop(x - 3,y - 3,0,c,7,7,1,1);
       d1 = d(j1);
       d2 = d(j2);
       ratio = (1 + d1)/(1 + d2);
       value = ratio>threshold ? interp(j1): # Up-right edge
               ratio<(1/threshold) ? interp(j2): # Down-right edge
               (w1 = 1/(1 + d1^exponent); w2 = 1/(1 + d2^exponent); (interp(j1)*w1 + interp(j2)*w2)/(w1 + w2)); # Smooth area
       value/=16)"

    # Estimate remaining values.
    f "begin(
         const threshold = $1;
         const exponent = $2;
         interpolation = 0;
         boundary = 1;
         j1(x,y) = P[7*y + x + 24]; # eq. to 'j(x,y)', but faster
         j2(x,y) = P[7*x - y + 24]; # eq. to 'j(-y,x)', but faster
         interp(k) = -k#(0,-3) + 9*k#(0,-1) + 9*k#(0,1) - k#(0,3);
         d(k) = sum(abs([
                    k#(-1,-2) - k#(1,-2),
                    k#(-2,-1) - k#(0,-1), k#(0,-1) - k#(2,-1),
                    k#(-3,0) - k#(-1,0), k#(-1,0) - k#(1,0), k#(1,0) - k#(3,0),
                    k#(-2,1) - k#(0,1), k#(0,1) - k#(2,1),
                    k#(-1,2) - k#(1,2)
                ]));
       );
       if ((x%2) + (y%2)!=1,i,
         P = crop(x - 3,y - 3,0,c,7,7,1,1);
         d1 = d(j1);
         d2 = d(j2);
         ratio = (1 + d1)/(1 + d2);
         value = ratio>threshold ? interp(j1) : # Horizontal edge
                 ratio<(1/threshold) ? interp(j2) : # Vertical edge
                 (w1 = 1/(1 + d1^exponent); w2 = 1/(1 + d2^exponent); (interp(j1)*w1 + interp(j2)*w2)/(w1 + w2)); # Smooth area
         value/=16)"
  endl done v +

###### Old version: Original code by Garagecoder (Andy Kelday)
scale_dcci2x_old : check "${1=1.15}>=0 && ${2=5}>=0" skip ${3=0}
  e[^-1] "Double xy-dimensions of image$?, using DCCI2x algorithm."
  v - repeat $! l[$>]
    a={-1/16} b={9/16} whd={w},{h},{d} s={s}
    # d1, d2 (sum of diagonal absolute gradients)
    (0,-1,0;1,0,0;0,0,0) +convolve[0] [1] mirror[1] x +convolve[0] [1] rm[1] abs[^0]
    3,3,1,1,1 convolve[-3,-2] . rm. r[-2,-1] $whd,1,2 r[-2,-1] $whd,$s

    # calc all possible interpolated output [diagonal]
    ($a,$b,$b,$a,0) diagonal. +convolve[0] . mirror.. x shift.. -1,0 +convolve[0] .. rm...
    ++[1,2] 1 /[-2,-1] # edge comparison mask (1 + d1) / (1 + d2)
    _scale_dcci2x_smooth[-5,-4] ...,..,$2 _scale_dcci2x_mask[-4--1] $1

    # d1, d2 (sum of h/v absolute gradients)
    +g[0] x,-1 +g[0] y,1 +g[1] xy,-1 abs[-4--1]
    (1,1,0;1,1,0;0,0,0) convolve[-5] . rm. (1,1,1) convolve[-4] . rm.
    (1;1;1) convolve... . rm. (0,1,1;0,1,1;0,0,0) convolve.. . rm.
    +[-3,-1] +[-3,-1] r[-2,-1] $whd,1,2 r[-2,-1] $whd,$s

    # calc all possible interpolated output [h/v]
    ($a;$b;$b;$a;0) +convolve[0] . rm.. (0,$a,$b,$b,$a) +convolve[1] . rm..
    ++[2,3] 1 /[-2,-1] # edge comparison mask (1 + d1) / (1 + d2)
    _scale_dcci2x_smooth[-5,-4] ...,..,$2 _scale_dcci2x_mask[-4--1] $1

    # d1, d2 (sum of h/v absolute gradients)
    +g[0] x,1 +g[0] y,-1 +g[1] xy,-1 abs[-4--1]
    (1;1;1) convolve[-5] . rm. (1,1,0;1,1,0;0,0,0) convolve[-4] . rm.
    (0,0,0;1,1,0;1,1,0) convolve... . rm. (1,1,1) convolve.. . rm.
    +[-3,-1] +[-3,-1] r[-2,-1] $whd,1,2 r[-2,-1] $whd,$s

    # calc all possible interpolated output [h/v]
    (0;$a;$b;$b;$a) +convolve[1] . rm.. ($a,$b,$b,$a,0) +convolve[0] . rm..
    ++[3,4] 1 /[-2,-1] # edge comparison mask (1 + d1) / (1 + d2)
    _scale_dcci2x_smooth[-5,-4] ...,..,$2 _scale_dcci2x_mask[-4--1] $1

    # resize and distribute pixels
    r2dx 200%,4 shift[1] 1,1 shift[2] 0,1 shift[3] 1 +
    if {!$3} r {w-1},{h-1},100%,100%,0 fi
  endl done v +

_scale_dcci2x_smooth : skip ${3=5}
  # calculate interpolated output for smooth areas
  ^[0,1] $3 +[0,1] 1 ++[0,1] /[0,1] . rm. # weights
  pass$1 pass$2 *[0,-2] *[1,-1] +[0,1] # smooth

_scale_dcci2x_mask : skip ${1=1.15}
  # combine edge mask with interp outputs
  +<. {1/$1} >.. $1 *[-4] .. *... .
  or[-2,-1] not. *[-4,-1] +[-3--1]

#@cli seamcarve : _width[%]>=0,_height[%]>=0,_is_priority_channel={ 0 | 1 },_is_antialiasing={ 0 | 1 },_maximum_seams[%]>=0
#@cli : Resize selected images with specified 2D geometry, using the seam-carving algorithm.
#@cli : Default values: 'height=100%', 'is_priority_channel=0', 'is_antialiasing=1' and 'maximum_seams=25%'.
#@cli : $ image.jpg seamcarve 60%
# The main code of this algorithm has been done by Andy (Garagecoder).
seamcarve : check "${2=100%}>=0 && ${5=25%}>=0" skip ${3=0},${4=1}
  e[^-1] "Resize image$? to $1x$2 using seam-carving algorithm, "${arg\ 1+!$3,with,without}" priority channel, "${arg\ 1+!$4,with,without}" anti-aliasing and maximum seams $5."
  v - repeat $! l[$>]
    nw={max(1,round(if(${is_percent\ $1},$1*w,$1)))}
    nh={max(1,round(if(${is_percent\ $2},$2*h,$2)))}
    if {$nw!=w} _seamcarve $nw,$3,$4,$5 fi
    if {$nh!=h} transpose _seamcarve $nh,$3,$4,$5 transpose fi
  endl done v +

# Subroutine to remove/add vertical seams/
# $1 = desired width.
# $2 = is_priority_channel={ 0 | 1 }
# $3 = is_antialiasing={ 0 | 1 }
# $4 = max number of seams added/removed at once.
_seamcarve :
  do
    max_seams={max(1,round(if(${is_percent\ $4},$4*w,$4)))}
    ssms={max(min(round($1-w),w),1-w)}
    sms={min($max_seams,abs($ssms))}

    # Compute potential map.
    if $2 s[0] c,{1-s} /. 256 fi
    +gradient[0] a[-2,-1] c abs. compose_channels. + n. 0,1
    if $2 +. .. a[0,1] c fi

    # Add x-coordinates channel for anti-aliasing.
    if $3 100%,1,1,1,x r. [0],[0] a[0,-1] c fi

    # Calculate low matrix (backwards propagation).
    .
    repeat {h}
      +rows. {$<+1} erode. 3
      j.. .,0,$<,0,0,-1 rm.
    done

    # Initialise seams, top matrix.
    100%,100% +rows[1] 0
    nm[1] grad nm[2] low nm[3] seam nm[4] top

    repeat {0,h-1} nr={$>+1}
      +rows[low] $nr

      # Find optimum matches between two 1D matrices.
      +*[4,5] +shift[4] 1 *. [5] +shift[5] 1 *. [4]
      +[-2,-1] j[5] [4] a[-3--1] c
      f. ">if(c,i,max(j(-1)+j(0,0,0,1),j(-2)+j(0,0,0,2)))"
      s. c shift... 1 +.. ... shift... 1 +[-3,-1]
      >[-2,-1] f. "<if(j(1)<0,1,-i)"

      # Add matched row to seams.
      j[seam] .,0,$>

      # Distribute matched pixels in top matrix.
      a[-2,-1] c f. "j(i,0,0,-1)" channels. 1

      # Add next energy row to top matrix.
      +rows[grad] $nr +[top,-1]
    done

    # Add / remove seams.
    max={iM*2} repeat $sms =. $max,{xm} done
    j[grad] .,0,100% rm[low,top] a[-2,-1] c
    f. "<if(c,i,j(j(0,0,0,1),1,0,0,0,1))" channels. 0
    +[0] 0.1 !=. $max
    w={w} h={h} s={0,s}
    if {$ssms<0} * discard 0 r {$w-$sms},$h,1,$s,-1  # Remove seams.
    elif {$ssms>0}              # Add seams.
      -. 2 s[0] c
      repeat $s if {$><($s-1)} . fi a[$>,-1] c done
      permute cxyz a c discard -1 f "if(i<0,j(0,-1),i)"
      r {$w+$sms},$h,1,$s,-1
    fi

    # Perform anti-aliasing step.
    if $3
      s c,{1-s} g. x,1 round !=. 1
      (0.5,0.5) +convolve[0] . rm..
      j[0] .,0,0,0,0,1,[1] rm[-2,-1]
    fi

    rprogress {a=w/$1;if(a<1,a*100,100/a)}
  while {w!=$1}

#@cli shift : vx[%],_vy[%],_vz[%],_vc[%],_boundary_conditions,_interpolation={ 0=nearest_neighbor | 1=linear } : (+)
#@cli : Shift selected images by specified displacement vector.
#@cli : Displacement vector can be non-integer in which case linear interpolation of the shift is computed.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'boundary_conditions=0' and 'interpolation=0'.
#@cli : $ image.jpg +shift[0] 50%,50%,0,0,0 +shift[0] 50%,50%,0,0,1 +shift[0] 50%,50%,0,0,2

#@cli shrink_x : size_x>=0
#@cli : Shrink selected images along the x-axis.
#@cli : $ image.jpg shrink_x 30
shrink_x : check "$1>=0"
  e[^-1] "Shrink image$? along the x-axis with size $1."
  v - repeat $! z[$>] $1,{$>,w-$1-1} done v +

#@cli shrink_xy : size>=0
#@cli : Shrink selected images along the xy-axes.
#@cli : $ image.jpg shrink_xy 30
shrink_xy : check "$1>=0"
  e[^-1] "Shrink image$? along the xy-axes with size $1."
  v - repeat $! z[$>] $1,$1,{$>,w-$1-1},{$>,h-$1-1} done v +

#@cli shrink_xyz : size>=0
#@cli : Shrink selected images along the xyz-axes.
shrink_xyz : check "$1>=0"
  e[^-1] "Shrink image$? along the xyz-axes with size $1."
  v - repeat $! z[$>] $1,$1,$1,{$>,w-$1-1},{$>,h-$1-1},{$>,d-$1-1} done v +

#@cli shrink_y : size_y>=0
#@cli : Shrink selected images along the y-axis.
#@cli : $ image.jpg shrink_y 30
shrink_y : check "$1>=0"
  e[^-1] "Shrink image$? along the y-axis with size $1."
  v - repeat $! z[$>] 0,$1,100%,{$>,h-$1-1} done v +

#@cli shrink_z : size_z>=0
#@cli : Shrink selected images along the z-axis.
shrink_z : check "$1>=0"
  e[^-1] "Shrink image$? along the z-axis with size $1."
  v - repeat $! z[$>] 0,0,$1,100%,100%,{$>,d-$1-1} done v +

#@cli slices : { [image0] | z0[%] },_{ [image1] | z1[%] } : (+)
#@cli : Keep only specified slices of selected images.
#@cli : Dirichlet boundary conditions are used when specified slices are out of range.

#@cli sort : _ordering={ + | - },_axis={ x | y | z | c } : (+)
#@cli : Sort pixel values of selected images.
#@cli : If 'axis' is specified, the sorting is done according to the data of the first column/row/slice/channel
#@cli : of selected images.
#@cli : Default values: 'ordering=+' and 'axis=(undefined)'.
#@cli : $ 64 rand 0,100 +sort display_graph 400,300,3

#@cli s : eq. to 'split'. : (+)

#@cli split : { x | y | z | c }...{ x | y | z | c },_split_mode : keep_splitting_values={ + | - },_{ x | y | z | c }...{ x | y | z | c },value1,_value2,... : (no arg) : (+)
#@cli : Split selected images along specified axes, or regarding to a sequence of scalar values (optionally along specified axes too).
#@cli : (eq. to 's').\n
#@cli : 'split_mode' can be { 0=split according to constant values | >0=split in N parts | <0=split in parts of size -N }.
#@cli : Default value: 'split_mode=-1'.
#@cli : $ image.jpg split c
#@cli : $ image.jpg split y,3
#@cli : $ image.jpg split x,-128
#@cli : $ 1,20,1,1,"1,2,3,4" +split -,2,3 append[1--1] y
#@cli : $ (1,2,2,3,3,3,4,4,4,4) +split x,0 append[1--1] y

#@cli split_tiles : M!=0,_N!=0,_is_homogeneous={ 0 | 1 }
#@cli : Split selected images as a MxN array of tiles.
#@cli : If M or N is negative, it stands for the tile size instead.
#@cli : Default values: 'N=M' and 'is_homogeneous=0'.
#@cli : $ image.jpg +local split_tiles 5,4 blur 3,0 sharpen 700 append_tiles 4,5 endlocal
split_tiles : skip ${2=$1},${3=0}
  if $3 e[^-1] "Split image$? as a $1x$2 array of homogeneous tiles."
  else e[^-1] "Split image$? as a $1x$2 array of tiles."
  fi
  v - repeat $! l[$<] s y,$2 s x,$1 if $3 r [0],[0],100%,100%,0 fi endl done v +

#@cli undistort : -1<=_amplitude<=1,_aspect_ratio,_zoom,_center_x[%],_center_y[%],_boundary_conditions
#@cli : Correct barrel/pincushion distortions occurring with wide-angle lens.
#@cli : References:
#@cli : [1] Zhang Z. (1999). Flexible camera calibration by viewing a plane from unknown orientation.
#@cli : [2] Andrew W. Fitzgibbon (2001). Simultaneous linear estimation of multiple view geometry and lens distortion.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default values: 'amplitude=0.25', 'aspect_ratio=0', 'zoom=0', 'center_x=center_y=50%'  and 'boundary_conditions=0'.
undistort : check "${1=0.1}>=-1 && $1<=1 && ${6=0}>=0 && $6<=3" skip ${2=0},${3=0},${4=50%},${5=50%}
  e[^-1] "Undistort barrel/pincushion effect in image$?, with amplitude $1, aspect ratio $2, zoom factor $3, center ($4,$5) and "${"arg 1+$6,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! l[$>]
    center_x={${"is_percent $4"}?w*$4:$4}
    center_y={${"is_percent $5"}?h*$5:$5}
    f "
      const interpolation = 1;
      const boundary = $6;
      const center_x = "$center_x";
      const center_y = "$center_y";
      const alpha = cut($1,-0.999,0.999);
      const ratio = $2>=0?1+$2:1/(1-$2);
      const zoom = $3>=0?1+$3:1/(1-$3);
      const M = max(w,h);
      x = 2*(x - center_x)/(zoom*ratio*M);
      y = 2*(y - center_y)/(zoom*M);
      r = norm(x,y);
      nr = r/(1 - alpha*r^2);
      if (r>0,
        nx = nr/r*x; ny = nr/r*y,
        nx = x; ny = y
      );
      x = 0.5*nx*ratio*M + center_x;
      y = 0.5*ny*M + center_y;
      I(x,y)"
  endl done v +

#@cli y : eq. to 'unroll'. : (+)

#@cli unroll : _axis={ x | y | z | c } : (+)
#@cli : Unroll selected images along specified axis.
#@cli : (eq. to 'y').
#@cli : Default value: 'axis=y'.
#@cli : $ (1,2,3;4,5,6;7,8,9) +unroll y

#@cli upscale_smart : width[%],_height[%],_depth,_smoothness>=0,_anisotropy=[0,1],sharpening>=0
#@cli : Upscale selected images with an edge-preserving algorithm.
#@cli : Default values: 'height=100%', 'depth=100%', 'smoothness=2', 'anisotropy=0.4' and 'sharpening=10'.
#@cli : $ image.jpg resize2dy 100 +upscale_smart 500%,500% append x
upscale_smart : skip ${2=100%},${3=100%} check "${4=2}>=0 && ${5=0.4}>=0 && $5<=1 && ${6=10}>=0"
  e[^-1] "Upscale image$? to $1x$2x$3, with smoothness $4, anisotropy $5 and sharpening $6."
  v - repeat $! l[$>]
    w={w} h={h}
    +r. $1,$2,$3,1,0 # Compute desired dimensions.
    if {w<$w" && "h<$h} # Test for downscaling
      rm. r. $1,$2,$3,100%,2
    else
      rm. +diffusiontensors 0,$5,1.2,1.2
      r[-2,-1] $1,$2,$3,100%,5
      smooth.. .,$4 rm.
      ac "sharpen. $6,10",ycbcr_y
    fi
  endl done v +

#@cli warp : [warping_field],_mode,_interpolation,_boundary_conditions,_nb_frames>0 : (+)
#@cli : Warp selected images with specified displacement field.
#@cli : 'mode' can be { 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=forward-relative }.
#@cli : 'interpolation' can be { 0=nearest-neighbor | 1=linear | 2=cubic }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default values: 'mode=0', 'interpolation=1', 'boundary_conditions=1' and 'nb_frames=1'.
#@cli : $ image.jpg 100%,100%,1,2,'X=x/w-0.5;Y=y/h-0.5;R=(X*X+Y*Y)^0.5;A=atan2(Y,X);130*R*if(c==0,cos(4*A),sin(8*A))' warp[-2] [-1],1,1,0 quiver[-1] [-1],10,1,1,1,100
#@cli : $$

#@cli warp_patch : [warping_field],patch_width>=1,_patch_height>=1,_patch_depth>=1,_std_factor>0,_boundary_conditions.
#@cli : Patch-warp selected images, with specified 2D or 3D displacement field (in backward-absolute mode).
#@cli : Argument 'std_factor' sets the std of the gaussian weights for the patch overlap, equal to 'std = std_factor*patch_size'.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default values: 'std_factor=0.3' and 'boundary_conditions=3'.
warp_patch : check ${is_image_arg\ $1}" && isint(${2=3}) && $2>=1 && isint(${3=$2}) && $3>=1 && isint(${4=1}) && $4>=1 && isval(${5=0.3}) && $5>0 && isint(${6=3}) && $6>=0 && $6<=3"
  e[^-1] "Patch-warp image$? with backward-absolute displacement field $1, using $2x$3x$4 patches, std factor $5 and "${"arg 1+$6,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - if {$2<=1} pass$1 warp[^-1] .,0 rm. v + return fi
  repeat $! pass$1 l[$>,-1]
    [0],[0],[0],1,1 a[0,-1] c # Add weighting channel
    100%,100%,100%,{0,s}

    if {1,s>=3} # 3D version
      eval[1] ">
        begin(
          const pw = $2;
          const ph = $3;
          const pd = $4;
          const stdf = $5;
          const boundary = $6;

          const pw1 = int(pw/2);
          const pw2 = pw - pw1 - 1;
          const ph1 = int(ph/2);
          const ph2 = ph - ph1 - 1;
          const pd1 = int(pd/2);
          const pd2 = pd - pd1 - 1;
          const pwhd = pw*ph*pd;

          # Pre-compute gaussian weights.
          if (stdf<5,
            weights = vectorpwhd();
            offw = 0;
            for (zw = -pd1, zw<=pd2, ++zw,
              for (yw = -ph1, yw<=ph2, ++yw,
                for (xw = -pw1, xw<=pw2, ++xw,
                  weights[offw++] = exp(-xw^2/(2*(stdf*pw)^2) - yw^2/(2*(stdf*ph)^2) - zw^2/(2*(stdf*pd)^2));
                );
              );
            );
          );
        );
        u = i(x,y,z,0);
        v = i(x,y,z,1);
        w = i(x,y,z,2);
        patch = crop(#0,u - pw1, v - ph1,w - pd1,pw,ph,pd,boundary);
        stdf<5?
          draw(#2,patch,x - pw1,y - ph1,z - pd1,0,pw,ph,pd,s#0,-1,weights):
          draw(#2,patch,x - pw1,y - ph1,z - pd1,0,pw,ph,pd,s#0,-1)"
    else # 2D version
      eval[1] ">
        begin(
          const pw = $2;
          const ph = $3;
          const stdf = $5;
          const boundary = $6;

          const pw1 = int(pw/2);
          const pw2 = pw - pw1 - 1;
          const ph1 = int(ph/2);
          const ph2 = ph - ph1 - 1;
          const pwh = pw*ph;

          # Pre-compute gaussian weights.
          if (stdf<5,
            weights = vectorpwh();
            offw = 0;
            for (yw = -ph1, yw<=ph2, ++yw,
              for (xw = -pw1, xw<=pw2, ++xw,
                weights[offw++] = exp(-xw^2/(2*(stdf*pw)^2) - yw^2/(2*(stdf*ph)^2));
              );
            );
          );
        );

        u = i(x,y,z,0);
        v = i(x,y,z,1);
        patch = crop(#0,u - pw1, v - ph1,pw,ph,boundary);
        stdf<5?
          draw(#2,patch,x - pw1,y - ph1,0,0,pw,ph,1,s#0,-1,weights):
          draw(#2,patch,x - pw1,y - ph1,0,0,pw,ph,1,s#0,-1)"
    fi
    s. c,-{0,s-1} /[-2,-1] k.
  endl done v +

#---------------------------------
#
#@cli :: Filtering
#
#---------------------------------

#@cli bandpass : _min_freq[%],_max_freq[%]
#@cli : Apply bandpass filter to selected images.
#@cli : Default values: 'min_freq=0' and 'max_freq=20%'.
#@cli : $ image.jpg bandpass 1%,3%
#@cli : $$
bandpass : skip ${1=0},${2=20%}
  e[^-1] "Apply bandpass filter [$1,$2] to image$?."
  v - repeat $! l[$>]
    100%,100%,100% f. "sqrt((x/w-0.5)^2 + (y/h-0.5)^2 + (z/d-0.5)^2)"
    n. 0,1 ir. $1,$2 shift. {int(w/2)},{int(h/2)},{int(d/2)},0,2
    fft.. *... . *[-2,-1] ifft rm.
  endl done v +

#@cli bilateral : [guide],std_deviation_s[%]>=0,std_deviation_r[%]>=0,_sampling_s>=0,_sampling_r>=0 : std_deviation_s[%]>=0,std_deviation_r[%]>=0,_sampling_s>=0,_sampling_r>=0 : (+)
#@cli : Blur selected images by anisotropic (eventually joint/cross) bilateral filtering.
#@cli : If a guide image is provided, it is used for drive the smoothing filter.
#@cli : A guide image must be of the same xyz-size as the selected images.
#@cli : Set 'sampling' arguments to '0' for automatic adjustment.
#@cli : $ image.jpg repeat 5 bilateral 10,10 done

#@cli b : eq. to 'blur'. : (+)

#@cli blur : std_deviation>=0[%],_boundary_conditions,_kernel : axes,std_deviation>=0[%],_boundary_conditions,_kernel : (+)
#@cli : Blur selected images by a quasi-gaussian or gaussian filter (recursive implementation).
#@cli : (eq. to 'b').\n
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann } and 'kernel' can be { 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@cli : Specifying one axis multiple times apply also the blur multiple times.
#@cli : Default values: 'boundary_conditions=1' and 'kernel=0'.
#@cli : $ image.jpg +blur 5,0 +blur[0] 5,1
#@cli : $ image.jpg +blur y,10%
#@cli : $$

#@cli blur_angular : amplitude[%],_center_x[%],_center_y[%]
#@cli : Apply angular blur on selected images.
#@cli : Default values: 'center_x=center_y=50%'.
#@cli : $ image.jpg blur_angular 2%
#@cli : $$
blur_angular : skip ${2=50%},${3=50%}
  e[^-1] "Apply angular blur on image$?, with amplitude $1 and center point ($2,$3)."
  v - euclidean2polar $2,$3,1.3,1
  repeat $! l[$>] 1,100% =. 1,50%,50% b. y,$1 convolve_fft.. . rm. endl done
  polar2euclidean $2,$3,1.3,1 v +

#@cli blur_bloom : _amplitude>=0,_ratio>=0,_nb_iter>=0,_blend_operator={ + | max | min },_kernel={ 0=quasi-gaussian (faster) | 1=gaussian | 2=box | 3=triangle | 4=quadratic },_normalize_scales={ 0 | 1 },_axes
#@cli : Apply a bloom filter that blend multiple blur filters of different radii,
#@cli : resulting in a larger but sharper glare than a simple blur.
#@cli : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@cli : Specifying one axis multiple times apply also the blur multiple times.
#@cli : Reference: Masaki Kawase, "Practical Implementation of High Dynamic Range Rendering", GDC 2004.
#@cli : Default values: 'amplitude=1', 'ratio=2', 'nb_iter=5', 'blend_operator=+', 'kernel=0','normalize_scales=0' and 'axes=(all)'
#@cli : $ image.jpg blur_bloom ,
blur_bloom : check "${1=1}>=0 && ${2=2}>=0 && isint(${3=5}) && $3>=0 && isint(${5=0}) && $5>=0 && $5<=4 && isval(${6=0})" skip ${4=+},${7=}
  e[^-1] "Apply bloom effect on image$?, with amplitude $1, ratio $2, $3 iterations, blend operator '$4' and "${"arg 1+!$6,\"\",\"no \""}"scale normalization."
  v -
  if {narg("$7")} axes=$7, fi
  m "_bloom0 : b "$axes"$""1"
  m "_bloom1 : b "$axes"$""1,1,1"
  m "_bloom2 : boxfilter "$axes"{1+2*$""1},0,1"
  m "_bloom3 : boxfilter "$axes"{1+2*$""1},0,1,2"
  m "_bloom4 : boxfilter "$axes"{1+2*$""1},0,1,3"
  repeat $! l[$>] nm={n} mM={[im,iM]}
    [0] repeat $3 sigma={$1*($2^$>)} +_bloom$5[0] $sigma
    if $6 n. $mM fi
    -$4[1,-1]
    done
    n. $mM k. nm $nm
  endl done
  uncommand _bloom0,_bloom1,_bloom2,_bloom3,_bloom4
  v +

#@cli blur_linear : amplitude1[%],_amplitude2[%],_angle,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Apply linear blur on selected images, with specified angle and amplitudes.
#@cli : Default values: 'amplitude2=0', 'angle=0' and 'boundary_conditions=1'.
#@cli : $ image.jpg blur_linear 10,0,45
#@cli : $$
blur_linear : skip ${2=0},${3=0},${4=1}
  e[^-1] "Apply linear blur on image$?, with angle $3 deg. and amplitudes ($1,$2)."
  v -
  std1={if(${is_percent\ $1},$1*max(w,h),$1)}
  std2={if(${is_percent\ $2},$2*max(w,h),$2)}
  stdM={round(1.25*max($std1,$std2))}
  if {$stdM<=0} v + return fi
  repeat $! l[$>]
    expand_xy $stdM,{$4!=0}
    {2*$stdM},{2*$stdM} gaussian. $1,$2,$3 normalize_sum.
    convolve_fft[0] [1] rm. shrink_xy $stdM
  endl done v +

#@cli blur_radial : amplitude[%],_center_x[%],_center_y[%]
#@cli : Apply radial blur on selected images.
#@cli : Default values: 'center_x=center_y=50%'.
#@cli : $ image.jpg blur_radial 2%
#@cli : $$
blur_radial : skip ${2=50%},${3=50%}
  e[^-1] "Apply radial blur on image$?, with amplitude $1 and center point ($2,$3)."
  v - euclidean2polar $2,$3,5,1 blur_x $1 polar2euclidean $2,$3,5,1 v +

#@cli blur_selective : sigma>=0,_edges>0,_nb_scales>0
#@cli : Blur selected images using selective gaussian scales.
#@cli : Default values: 'sigma=5', 'edges=0.5' and 'nb_scales=5'.
#@cli : $ image.jpg noise 20 cut 0,255 +local[-1] repeat 4 blur_selective , done endlocal
#@cli : $$
blur_selective : check "${1=5}>=0 && ${2=0.5}>=0 && isint(${3=5}) && $3>0"
  e[^-1] "Blur image$? using $3 selective gaussian scales, with sigma $1 and edges $2."
  v - repeat $! l[$>] nm={0,n}
    +gradient_norm +. 1 ^. {-max(0.01,$2)} quantize. {$3+1},0,1 min. {$3-1} r. ..
    repeat $3 +==. $> *. ... +[-2,-1] b.. {$1/($3+1)} done
  rm.. nm $nm endl done v +

#@cli blur_x : amplitude[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the x-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +blur_x 6
#@cli : $$
blur_x : skip ${2=1}
  e[^-1] "Blur image$? along the x-axis, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  v - deriche $1,0,x,$2 v +

#@cli blur_xy : amplitude_x[%],amplitude_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the X and Y axes.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +blur_xy 6
#@cli : $$
blur_xy : skip ${2=$1},${3=1}
  e[^-1] "Blur image$? along the xy-axes, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  v - deriche $1,0,x,$3 deriche $2,0,y,$3 v +

#@cli blur_xyz : amplitude_x[%],amplitude_y[%],amplitude_z,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the X, Y and Z axes.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $$
blur_xyz : skip ${4=1}
  e[^-1] "Blur image$? along the xyz-axes, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  v - deriche $1,0,x,$4 deriche $2,0,y,$4 deriche $3,0,z,$4 v +

#@cli blur_y : amplitude[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the y-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +blur_y 6
#@cli : $$
blur_y : skip ${2=1}
  e[^-1] "Blur image$? along the y-axis, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  v - deriche $1,0,y,$2 v +

#@cli blur_z : amplitude[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Blur selected images along the z-axis.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $$
blur_z : skip ${2=1}
  e[^-1] "Blur image$? along the z-axis, with sigma $1 and "${arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  v - deriche $1,0,z,$2 v +

#@cli boxfilter : size>=0[%],_order,_boundary_conditions,_nb_iter>=0 : axes,size>=0[%],_order,_boundary_conditions,_nb_iter>=0 : (+)
#@cli : Blur selected images by a box filter of specified size (fast recursive implementation).
#@cli : 'order' can be { 0=smooth | 1=1st-derivative | 2=2nd-derivative }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@cli : Specifying one axis multiple times apply also the blur multiple times.
#@cli : Default values: 'order=0', 'boundary_conditions=1' and 'nb_iter=1'.
#@cli : $ image.jpg +boxfilter 5%
#@cli : $ image.jpg +boxfilter y,3,1

#@cli bump2normal
#@cli : Convert selected bumpmaps to normalmaps.
#@cli : $ 300,300 circle 50%,50%,128,1,1 blur 5% bump2normal
bump2normal :
  e[^-1] "Convert bumpmap$? to normalmap."
  v - repeat $! l[$>]
    channels 0 g xy,1 +f. 1 a c orientation
    * 127 + 128 round c 0,255
  endl done v +

#@cli compose_freq
#@cli : Compose selected low and high frequency parts into new images.
#@cli : $ image.jpg split_freq 2% mirror[-1] x compose_freq
compose_freq :
  e[^-1] "Compose low and high frequency part$? into new images."
  v - repeat {int($!/2)} +[$>,{$>+1}] done v +

#@cli convolve : [mask],_boundary_conditions,_is_normalized={ 0 | 1 } : (+)
#@cli : Convolve selected images by specified mask.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg (0,1,0;1,-4,1;0,1,0) convolve[-2] [-1] keep[-2]
#@cli : $ image.jpg (0,1,0) resize[-1] 130,1,1,1,3 +convolve[0] [1]
#@cli : $$

#@cli convolve_fft : [mask]
#@cli : Convolve selected images with specified mask, in the fourier domain.
#@cli : $ image.jpg 100%,100% gaussian[-1] 20,1,45 +convolve_fft[0] [1]
convolve_fft : check ${is_image_arg\ $1}
  e[^-1] "Convolve image$? with mask $1, in the fourier domain."
  v - repeat $! pass$1 0 l[$>,-1]
    w2={0,int(w/2)} h2={0,int(h/2)} d2={0,int(d/2)}
    r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 shift[1] -$w2,-$h2,-$d2,0,2
    fft[0] fft[2]
    +*[-4] . +*[-4] ... +[-2,-1]
    *[-5,-3] *[-3,-2] -[-3,-2]
    ifft rm.
  endl done v +

#@cli correlate : [mask],_boundary_conditions,_is_normalized={ 0 | 1 } : (+)
#@cli : Correlate selected images by specified mask.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg (0,1,0;1,-4,1;0,1,0) correlate[-2] [-1] keep[-2]
#@cli : $ image.jpg +crop 40%,40%,60%,60% +correlate[0] [-1],0,1

#@cli cross_correlation : [mask]
#@cli : Compute cross-correlation of selected images with specified mask.
#@cli : $ image.jpg +shift -30,-20 +cross_correlation[0] [1]
cross_correlation : check ${is_image_arg\ $1}
  e[^-1] "Compute cross-correlation of image$? with mask $1."
  v - repeat $! pass$1 0 l[$>,-1]
    norm fft.. fft. [-2,-1] *.. [-5] *. [-6]
    -[-2,-1] *[-5,-3] *[-3,-2] +[-3,-2] ifft rm.
  endl done v +

#@cli curvature
#@cli : Compute isophote curvatures on selected images.
#@cli : $ image.jpg blur 10 curvature
curvature :
  e[^-1] "Compute isophote curvatures on image$?."
  v - repeat $! l[$>]
    if {d==1}
      +g xy,0 hessian... xxxyyy                          # ixx ixy iyy ix iy
      *... .. *[-4] . *[-4] -2                           # ixx -2iyixy ixiyy ix iy
      +[-4,-3] *... ..                                   # ixx -2ixiyixy+ix^2iyy ix iy
      sqr[-2,-1] *[-4] . +[-4,-3]                        # iy^2ixx-2ixiyixy+ix^2iyy ix^2 iy^2
      +[-2,-1] +. 0.1 ^. 1.5 /                           # (iy^2ixx+2ixiyixy+ix^2iyy)/(ix^2+iy^2)
    else
      +inn +gradient_norm.. laplacian...                 # inn+iee inn in
      -[-3,-2] +. 0.1 /[-2,-1]                           # iee in
      +inn. laplacian.. -                                # iee/in
    fi
  endl done v +

#@cli dct : _{ x | y | z }...{ x | y | z } : (no arg)
#@cli : Compute the discrete cosine transform of selected images,
#@cli : optionally along the specified axes only.
#@cli : Default values: (no arg)
#@cli : $ image.jpg +dct +idct[-1] abs[-2] +[-2] 1 log[-2]
#@cli : $$ _dct-and-idct
dct : skip ${1=0}
  v - ({'"$1"'})
  is_axes={im>=_'x'" && "iM<=_'z'}
  if $is_axes
    v + e[0--3] "Compute discrete cosine transform of image$? along axes '$1'." v -
    repeat {w}
      axis={i[$>]}
      if {$axis==_'x'} repeat {$!-1} l[$>] if {w>1} _dct fi endl done
      elif {$axis==_'y'} repeat {$!-1} l[$>] if {h>1} permute yxzc _dct permute yxzc fi endl done
      elif {$axis==_'z'} repeat {$!-1} l[$>] if {d>1} permute zxyc _dct permute yzxc fi endl done
      fi
    done
  else
    rm.
    v + e[0--3] "Compute discrete cosine transform of image$?." v -
    noarg
    repeat $! l[$>]
      if {w>1} _dct fi
      if {h>1} permute yxzc _dct permute yxzc fi
      if {d>1} permute zxyc _dct permute yzxc fi
    endl done
  fi
  v +

# 1D direct transform (DCT-II) for a single image.
_dct :
  is_odd={w%2}
  if $is_odd r {w+1},100%,100%,100%,0,1 fi
  s x l[1--1:2] a x mirror x endl mv[1] $! a x
  fft x
  100%,1,1,1,2*cos(-x*pi/(2*w)) *[0,2]
  100%,1,1,1,2*sin(-x*pi/(2*w)) *[1,2]
  -
  if $is_odd r {w-1},100%,100%,100%,0 fi
  +z[0] 0,0 /. {sqrt(2)} j.. .,0,0,0 rm. * {sqrt(2/w)}  # Make the transform orthogonal.

#@cli deblur : amplitude[%]>=0,_nb_iter>=0,_dt>=0,_regul>=0,_regul_type={ 0=Tikhonov | 1=meancurv. | 2=TV }
#@cli : Deblur image using a regularized Jansson-Van Cittert algorithm.
#@cli : Default values: 'nb_iter=10', 'dt=20', 'regul=0.7' and 'regul_type=1'.
#@cli : $ image.jpg blur 3 +deblur 3,40,20,0.01
deblur : check "${2=10}>=0 && ${3=20}>=0 && ${4=0.7}>=0" skip ${5=1}
  e[^-1] "Deblur image$? with a regularized Jansson-Van Cittert algorithm, with sigma $1, $2 iterations, time step $3 and regularization $4." v -
  repeat $! l[$>] nm={0,n}
    [0]
    repeat $2
      if {$5>=2} +curvature.                         # TV regularization.
      elif {$5>=1} +iee.                             # Meancurv. regularization.
      else +laplacian.                               # Tikhonov regularization.
      fi
      *. $4
      +b.. $1 -. [-4]                                # Data fidelity term.
      -[-2,-1]
      *. {$3/(0.0001+max(abs(im),abs(iM)))}          # Adaptive time step.
      +[-2,-1]                                       # Update image.
      done
    rm..
  nm $nm endl done v +

#@cli deblur_goldmeinel : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg +blur 1 +deblur_goldmeinel[-1] 1
###### : (contribution from Jérôme Boulanger).
deblur_goldmeinel : check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" skip ${4=1}
  e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${arg\ 1+!$4,"",quasi-}"gaussian kernel."
  v - repeat $! l[$>]
    [0] repeat $2
      +b. $1,1,$4 +/[0,-1] rm.. ^. $3 *[-1,-2] # u *= f / Hu
    done rm[0]
  endl done v +

#@cli deblur_richardsonlucy : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur selected images using Richardson-Lucy algorithm.
#@cli : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@cli : $ image.jpg +blur 1 +deblur_richardsonlucy[-1] 1
###### : (contribution from Jérôme Boulanger).
deblur_richardsonlucy : check "$1>=0 && ${2=50}>=0" skip ${3=1}
  e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${arg\ 1+!$3,"",quasi-}"gaussian kernel."
  v - repeat $! l[$>]
    [0] repeat $2
      +b. $1,1,{$3!=0} max. 1e-6 +/[0,-1] rm.. b. $1,1,{$3!=0} *[-1,-2] # u *= H ( f / Hu )
    done rm[0]
  endl done v +

#@cli deconvolve_fft :  [kernel],_regularization>=0
#@cli : Deconvolve selected images by specified mask in the fourier space.
#@cli : Default value: 'regularization>=0'.
#@cli : $ image.jpg +gaussian 5 +convolve_fft[0] [1] +deconvolve_fft[-1] [1]
deconvolve_fft : check ${is_image_arg\ $1}" && ${2=.001}>=0"
  e[^-1] "Deconvolve image$? with mask $1 and regularization $2, in the fourier domain."
  v - repeat $! pass$1 0 l[$>,-1]
    w2={0,int(w/2)} h2={0,int(h/2)} d2={0,int(d/2)}
    r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 shift[1] -$w2,-$h2,-$d2,0,2
    fft[0] fft[2]                 # a b a' b'
    +l[-1,-2] sqr + + $2 endl     # a b a' b' (a'^2+b'^2+eps)
    +*[-4] ...                    # a b a' b' (a'^2+b'^2) ba'
    +*[-6] ...                    # a b a' b' (a'^2+b'^2) ba' ab'
    -[-2,-1]                      # a b a' b' (a'^2+b'^2) ba'-ab'
    *[-6,-4]                      # aa' b b' (a'^2+b'^2) ba'-ab'
    *[-4,-3]                      # aa' bb' (a'^2+b'^2) ba'-ab'
    +[-4,-3]                      # aa'+bb' (a'^2+b'^2) ba'-ab'
    /. .. /[-3,-2]                # divide (aa'+bb') and (ba'-ab') by (a'^2+b'^2)
    ifft rm.
  endl done v +

#@cli deinterlace : _method={ 0 | 1 }
#@cli : Deinterlace selected images ('method' can be { 0=standard or 1=motion-compensated }).
#@cli : Default value: 'method=0'.
#@cli : $ image.jpg +rotate 3,1,1,50%,50% resize 100%,50% resize 100%,200%,1,3,4 shift[-1] 0,1 add +deinterlace 1
deinterlace : skip ${1=0}
  e[^-1] "Deinterlace image$? with "${arg\ 1+!$1,motion-compensated,standard}" method."
  v - repeat $! l[$>]
    wh={w},{h}
    s y a[0--1:2] y a[^0] y r.. .,0 r 100%,200%,1,100%,5
    if {$1!=0} +displacement. ..,0.05 warp... .,1,1,1 rm. fi
    + / 2 c 0,255 r $wh
  endl done v +

#@cli denoise : std_deviation_s>=0,_std_deviation_p>=0,_patch_size>0,_lookup_size>0,_smoothness,_fast_approx={ 0 | 1 } : (+)
#@cli : Denoise selected images by non-local patch averaging.
#@cli : Default values: 'std_deviation_p=10', 'patch_size=5', 'lookup_size=6' and 'smoothness=1'.
#@cli : $ image.jpg +denoise 5,5,8

#@cli denoise_haar : _threshold>=0,_nb_scales>=0,_cycle_spinning>0
#@cli : Denoise selected images using haar-wavelet thresholding with cycle spinning.
#@cli : Set 'nb_scales==0' to automatically determine the optimal number of scales.
#@cli : Default values: 'threshold=1.4', 'nb_scale=0' and 'cycle_spinning=10'.
#@cli : $ image.jpg noise 20 cut 0,255 +denoise_haar[-1] 0.8
denoise_haar : check "${1=1.4}>=0 && isint(${2=0}) && $2>=0 && isint(${3=10}) && $3>0"
  e[^-1] "Denoise image$? using haar-wavelet thresholding, with threshold $1, "\
          ${arg\ 1+($2>0),auto,$2}" scales and $3 spinning cycles."
  v - repeat $! l[$>] nm={0,n}
    nb_scales={min(if($2,$2,32),int(log2(min(w,h))-1))}
    w={w} h={h} d={d} sigma=${-std_noise}
    r {round(w,2^($nb_scales+1),1)},{round(h,2^($nb_scales+1),1)},{if(d==1,1,round(d,2^($nb_scales+1),1))},100%,0,0
    +f 0
    repeat $3
      dx={round(u(0,{4*$nb_scales}))}
      dy={round(u(0,{4*$nb_scales}))}
      dz={if($d==1,0,round(u(0,{4*$nb_scales})))}
      +shift[0] $dx,$dy,$dz,0,2
      haar. $nb_scales
      threshold. {$1*$sigma},1
      ihaar. $nb_scales
      shift. {-$dx},{-$dy},{-$dz},0,2
      +[-2,-1]
    done
    rm[0] / $3 r $w,$h,$d,100%,0
  nm $nm endl done v +

#@cli denoise_patchpca : _strength>=0,_patch_size>0,_lookup_size>0,_spatial_sampling>0
#@cli : Denoise selected images using the patch-pca algorithm.
#@cli : Default values: 'patch_size=7', 'lookup_size=11', 'details=1.8' and 'spatial_sampling=5'.
#@cli : $ image.jpg +noise 20 cut[-1] 0,255 +denoise_patchpca[-1] ,
denoise_patchpca : check "${1=1.8} && $1>=0 && isint(${2=7}) && $2>0 && isint(${3=11}) && $3>0 && isint(${4=5}) && $4>0"
  e[^-1] "Denoise image$? using patch-pca, with strength $1, patch size $2, lookup size $3 and spatial sampling $4."
  v - repeat $! l[$>] nm={n}
    N2={$2*$2} M2={$3*$3} stdnoise=${-std_noise}
    100%,100%,1,100% nm. aggreg
    100%,100% nm. weights
    f[0] "*
    begin(
      n1 = int($2/2); n2 = $2 - n1 - 1;
      m1 = int($3/2); m2 = $3 - m1 - 1;
      patch(x,y) = crop(x-n1,y-n1,0,c,$2,$2,1,1,1);
      ngauss(x) = exp(-x*x/(2*n1*n1));
      zero = vector"$N2"(0);
      mask = vector"$N2"(0);
      for (l = 0; q = -n1, q<=n2, ++q,
        for (p = -n1, p<=n2, ++p, mask[l++] = ngauss(p)*ngauss(q)
        )
      )
    );

    if (!(x%$4) && !(y%$4),  # Sub-sampling
      X = patch(x,y);

      # Build correlation matrix for PCA.
      M = vector"{$N2*$N2}"(0);
      for (q = -m1, q<=m2, ++q,
        for (p = -m1, p<=m2, ++p,
          Xk = patch(x + p,y + q) - X;
          M += mul(Xk,Xk,"$N2");
        )
      );
      M/="$M2";
      eig = eig(M);
      lambda = sqrt(abs(eig[0,"$N2"]));

      # Determine number of lambdas to keep and project neighboring patches.
      for (k = 0, k<size(lambda) && lambda[k]>=$1*"$stdnoise", ++k);
      Qt = eig["$N2","{$N2*$N2}"];
      Q = transp(Qt,"$N2");
      for (q = -m1, q<=m2, ++q,
        for (p = -m1, p<=m2, ++p,
          pY = Qt*(patch(x + p,y + q) - X);
          copy(pY[k],zero[0],size(pY) - k);
          (Y = Q*pY)+=X;
          draw(#"$aggreg",Y,x + p - n1,y + q - n1,0,c,$2,$2,1,1,-1,mask);
          draw(#"$weights",mask,x + p - n1,y + q - n1,0,c,$2,$2,1,1,-1);
        )
      );
    0);0"
    max[weights] 0.01 /[aggreg,weights] k[aggreg] nm $nm
  endl done v +

#@cli deriche : std_deviation>=0[%],order={ 0 | 1 | 2 },axis={ x | y | z | c },_boundary_conditions : (+)
#@cli : Apply Deriche recursive filter on selected images, along specified axis and with
#@cli : specified standard deviation, order and boundary conditions.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg deriche 3,1,x
#@cli : $ image.jpg +deriche 30,0,x deriche[-2] 30,0,y add
#@cli : $$

#@cli dilate : size>=0 : size_x>=0,size_y>=0,size_z>=0 : [kernel],_boundary_conditions,_is_real={ 0=binary-mode | 1=real-mode } : (+)
#@cli : Dilate selected images by a rectangular or the specified structuring element.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_z=1', 'boundary_conditions=1' and 'is_real=0'.
#@cli : $ image.jpg +dilate 10

#@cli dilate_circ : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply circular dilation of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +dilate_circ 7
dilate_circ : check $1>=0 skip ${2=1},${3=0}
  e[^-1] "Apply circular dilation of image$? by size $1, boundary conditions $2 and is_normalized $3."
  if {$1<2} return fi
  v - shape_circle $1 dilate[^-1] .,$2,$3 rm. v +

#@cli dilate_oct : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply octagonal dilation of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +dilate_oct 7
dilate_oct : check $1>=0 skip ${2=1},${3=0}
  e[^-1] "Apply octagonal dilation of image$? by size $1, boundary conditions $2 and is_normalized $3."
  if {$1<2} return fi
  v -
  if {$1&1} ss={$1} else ss={$1+1} fi
  i[0] (0,1,0;1,1,1;0,1,0) i[1] (1,1,1;1,1,1;1,1,1)
  repeat {$!-2}
    r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
    q={round(($ss-1)/(1+sqrt(2))/2)}
    if {$r>0} repeat $r dilate. [0],$2,$3 done fi
    if {$q>0} repeat $q dilate. [1],$2,$3 done fi
  mv. 2 done rm[0,1] v +

_kr_circle :
  if {$1%2==0} 2,2,1,1,1 else 1,1,1,1,1 fi r. $1,$1,1,1,0,0,0.5,0.5
  distance. 1 round. 0.5 ir. 0,{$1/2}

_jf_circle :
  {round($1)},{round($1)}
  center={0.5*(w-1)}
  f. 'sqrt((x-$center)^2+(y-$center)^2)'
  if {!(w%2)}
    round. 0.0001,-1
    t1={sqrt(((round($1)-1)/2)^2+0.25)}
    t2={sqrt(((round($1)+1)/2)^2+0.25)}
    k={$1-round($1)+0.5}
    t={$t1+($t2-$t1)*$k}
    ir. 0,$t
  else ir. 0,{$1/2-0.25}
  fi

#@cli dilate_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary_conditions
#@cli : Dilate selected images in the (X,Y,Z,I) space.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary_conditions=1'.
dilate_threshold : check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
  e[^-1] "Dilate image$? with mask $1x$2x$3, threshold $4 and "${arg\ $5,dirichlet,neumann}" boundary conditions."
  v - l[]
    dx1={int($1/2)} dx2={$1-$dx1-1}
    dy1={int($2/2)} dy2={$2-$dy1-1}
    dz1={int($3/2)} dz2={$3-$dz1-1}
    (-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) r $1,$2,$3,1,3 a c round r {w*h*d},3,1,1,-1 transpose.
    i.. 1,100%,1,1,254 1,100%,1,1,255 a x
    ({'{^}'}) rm.. replace_str "254,","(v=j(" replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,-1e20))" list={t}
    rm
  endl
  f 'max($list)'
  v +

#@cli divergence
#@cli : Compute divergence of selected vector fields.
#@cli : $ image.jpg luminance +gradient append[-2,-1] c divergence[-1]
divergence :
  e[^-1] "Compute divergence of vector field$?."
  v - repeat $! l[$>]
    if {s==1} g x,0
    elif {s==2} s c g.. x,0 g. y,0 +
    elif {s==3} s c g... x,0 g.. y,0 g. z,0 +
    else v + error[] "Command '$0': Cannot compute divergence of image ["$>"] (has "{s}">3 channels)."
    fi
  endl done v +

#@cli dog : _sigma1>=0[%],_sigma2>=0[%]
#@cli : Compute difference of gaussian on selected images.
#@cli : Default values: 'sigma1=2%' and 'sigma2=3%'.
#@cli : $ image.jpg dog 2,3
dog : check "${1=2%}>=0 && ${2=3%}>=0"
  e[^-1] "Compute difference of gaussian on image$?, with standard deviations $1 and $2."
  v - repeat $! l[$>]
    [0] parallel "b[0] $1","b[1] $2" - abs
  endl done v +

#@cli diffusiontensors : _sharpness>=0,0<=_anisotropy<=1,_alpha[%],_sigma[%],is_sqrt={ 0 | 1 }
#@cli : Compute the diffusion tensors of selected images for edge-preserving smoothing algorithms.
#@cli : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1' and 'is_sqrt=0'.
#@cli : $ image.jpg diffusiontensors 0.8 abs pow 0.2
#@cli : $$
diffusiontensors : check "${1=0.7}>=0 && ${2=0.3}>=0 && $2<=1" skip ${3=0.6},${4=1.1},${5=0}
  e[^-1] "Compute diffusion tensors for image$?, with sharpness $1, anisotropy $2, alpha $3 and sigma $4."
  v -
  p1={if($5,0.5,1)*max($1,1e-2)}
  p2={$p1/(1e-7+1-$2)}
  b $3 n 0,255 structuretensors 0 b $4
  repeat $! l[$>]
    eigen max.. 0
    if {s==2} s.. c +[-3,-2] +.. 1 +^.. -$p1 ^... -$p2 a[-3,-1] c                 # 2D
    else s.. c +[-4--2] +.. 1 +^.. -$p1 r. 100%,100%,100%,2 ^... -$p2 a[-3,-1] c  # 3D
    fi
    eigen2tensor
  endl done v +

#@cli edges : _threshold[%]>=0
#@cli : Estimate contours of selected images.
#@cli : Default value: 'edges=15%'
#@cli : $ image.jpg +edges 15%
edges : skip ${1=15%}
  e[^-1] "Estimate image contours of image$?, with threshold $1."
  v - gradient_norm b 0.5 >= $1 distance 0 equalize negate c 30%,70% n 0,1 v +

#@cli erode : size>=0 : size_x>=0,size_y>=0,_size_z>=0 : [kernel],_boundary_conditions,_is_real={ 0=binary-mode | 1=real-mode } : (+)
#@cli : Erode selected images by a rectangular or the specified structuring element.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_z=1', 'boundary_conditions=1' and 'is_real=0'.
#@cli : $ image.jpg +erode 10

#@cli erode_circ : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply circular erosion of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +erode_circ 7
erode_circ : check $1>=0 skip ${2=1},${3=0}
  e[^-1] "Apply circular erosion of image$? by size $1, boundary conditions $2 and is_normalized $3."
  if {$1<2} return fi
  v - shape_circle $1 erode[^-1] .,$2,$3 rm. v +

#@cli erode_oct : _size>=0,_boundary_conditions,_is_normalized={ 0 | 1 }
#@cli : Apply octagonal erosion of selected images by specified size.
#@cli : Default values: 'boundary_conditions=1' and 'is_normalized=0'.
#@cli : $ image.jpg +erode_oct 7
erode_oct : check $1>=0 skip ${2=1},${3=0}
  e[^-1] "Apply octagonal erosion of image$? by size $1, boundary conditions $2 and is_normalized $3."
  if {$1<2} return fi
  v -
  if {$1&1} ss={$1} else ss={$1+1} fi
  i[0] (0,1,0;1,1,1;0,1,0) i[1] (1,1,1;1,1,1;1,1,1)
  repeat {$!-2}
    r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
    q={round(($ss-1)/(1+sqrt(2))/2)}
    if {$r>0} repeat $r erode. [0],$2,$3 done fi
    if {$q>0} repeat $q erode. [1],$2,$3 done fi
  mv. 2 done rm[0,1] v +

#@cli erode_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary_conditions
#@cli : Erode selected images in the (X,Y,Z,I) space.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary_conditions=1'.
erode_threshold : check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
  e[^-1] "Erode image$? with mask $1x$2x$3, threshold $4 and "${arg\ $5,dirichlet,neumann}" boundary conditions."
  v - l[]
    dx1={int($1/2)} dx2={$1-$dx1-1}
    dy1={int($2/2)} dy2={$2-$dy1-1}
    dz1={int($3/2)} dz2={$3-$dz1-1}
    (-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) r $1,$2,$3,1,3 a c round r {w*h*d},3,1,1,-1 transpose.
    i.. 1,100%,1,1,254 1,100%,1,1,255 a x
    ({'{^}'}) rm.. replace_str "254,","(v=j(" replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,1e20))" list={t}
    rm
  endl
  f 'min($list)'
  v +

#@cli fft : _{ x | y | z }...{ x | y | z } : (+)
#@cli : Compute the direct fourier transform (real and imaginary parts) of selected images,
#@cli : optionally along the specified axes only.
#@cli : $ image.jpg luminance +fft append[-2,-1] c norm[-1] log[-1] shift[-1] 50%,50%,0,0,2
#@cli : $ image.jpg w2={int(w/2)} h2={int(h/2)} fft shift $w2,$h2,0,0,2 ellipse $w2,$h2,30,30,0,1,0 shift -$w2,-$h2,0,0,2 ifft remove[-1]
#@cli : $$

#@cli g : eq. to 'gradient'. : (+)

#@cli gradient : { x | y | z }...{ x | y | z },_scheme : (no arg) : (+)
#@cli : Compute the gradient components (first derivatives) of selected images.
#@cli : (eq. to 'g').\n
#@cli : 'scheme' can be { -1=backward | 0=centered | 1=forward | 2=sobel | 3=rotation-invariant (default) | 4=deriche | 5=vanvliet }.
#@cli : (no arg) compute all significant 2D/3D components.
#@cli : Default value: 'scheme=3'.
#@cli : $ image.jpg gradient
#@cli : $$

#@cli gradient_norm
#@cli : Compute gradient norm of selected images.
#@cli : $ image.jpg gradient_norm equalize
#@cli : $$
gradient_norm :
  e[^-1] "Compute gradient norm of image$?."
  v - repeat $! l[$>]
    +g x sqr.
    +g.. y sqr. +[-2,-1]
    g.. z sqr.. +[-2,-1]
    s={s} s. c +[-$s--1] sqrt.
  endl done v +

#@cli gradient_orientation : _dimension={1,2,3}
#@cli : Compute N-d gradient orientation of selected images.
#@cli : Default value: 'dimension=3'.
#@cli : $ image.jpg +gradient_orientation 2
gradient_orientation : check "${1=3}==1 || $1==2 || $1==3"
  e[^-1] "Compute $1-d gradient orientation of image$?."
  v - repeat $! l[$<]
    if {$1==1} g x +abs. +. 1e-8 -/
    elif {$1==2} g xy +sqr +[-2,-1] +. 1e-8 sqrt. /... . /[-2,-1]
    else g xyz +sqr +[-3--1] +. 1e-8 sqrt. /[-4,-3] . /[-2,-1]
    fi
  endl done v +

#@cli guided : [guide],radius[%]>=0,regularization[%]>=0 : radius[%]>=0,regularization[%]>=0 : (+)
#@cli : Blur selected images by guided image filtering.
#@cli : If a guide image is provided, it is used to drive the smoothing process.
#@cli : A guide image must be of the same xyz-size as the selected images.
#@cli : This command implements the filtering algorithm described in:
#@cli : He, Kaiming; Sun, Jian; Tang, Xiaoou, "Guided Image Filtering," Pattern Analysis and Machine Intelligence,
#@cli : IEEE Transactions on , vol.35, no.6, pp.1397,1409, June 2013
#@cli : $ image.jpg +guided 5,400

#@cli haar : scale>0
#@cli : Compute the direct haar multiscale wavelet transform of selected images.
#@cli : $$
haar : check "isint(${1=1}) && $1>=0"
  e[^-1] "Compute haar transform of image$? with $1 scales."
  v - repeat $! l[$>]
    _haar
    repeat {$1-1}
      w={max(0,round(w/2^(1+$>))-1)}
      h={max(0,round(h/2^(1+$>))-1)}
      d={max(0,round(d/2^(1+$>))-1)}
      +z 0,0,0,$w,$h,$d _haar. j.. . rm.
    done
  endl done v +

_haar : # Mono-scale direct haar transform.
  _haar_x _haar_y _haar_z

_haar_x : # Direct haar transform along the x-axis.
  if {w<=1} return fi
  if {w%2} v + error[0--6] "Command 'haar': Invalid image width="{w}" (is not even)." fi
  +shift -1 r 50% +-[1] [0] +[0,1] / {sqrt(2)} a x

_haar_y : # Direct haar transform along the y-axis.
  if {h<=1} return fi
  if {h%2} v + error[0--6] "Command 'haar': Invalid image height="{h}" (is not even)." fi
  +shift 0,-1 r 100%,50% +-[1] [0] +[0,1] / {sqrt(2)} a y

_haar_z : # Direct haar transform along the z-axis.
  if {d<=1} return fi
  if {d%2} v + error[0--6] "Command 'haar': Invalid image depth="{h}" (is not even)." fi
  +shift 0,0,-1 r 100%,100%,50% +-[1] [0] +[0,1] / {sqrt(2)} a z

#@cli heat_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the heat flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@cli : $ image.jpg +heat_flow 20
heat_flow : skip ${1=10},${2=30},${3=0}
  e[^-1] "Apply $1 iterations of the heat flow on image$?, with time step $2."
  v - pde_flow $1,$2,laplacian,$3 v +

#@cli hessian : { xx | xy | xz | yy | yz | zz }...{ xx | xy | xz | yy | yz | zz } : (no arg) : (+)
#@cli : Compute the hessian components (second derivatives) of selected images.
#@cli : (no arg) compute all significant components.
#@cli : $ image.jpg hessian

#@cli idct : _{ x | y | z }...{ x | y | z } : (no arg)
#@cli : Compute the inverse discrete cosine transform of selected images,
#@cli : optionally along the specified axes only.
#@cli : Default values: (no arg)
#@cli : $$ _dct-and-idct
idct : skip ${1=0}
  v - ({'"$1"'})
  is_axes={im>=_'x'" && "iM<=_'z'}
  if $is_axes
    v + e[0--3] "Compute inverse discrete cosine transform of image$? along axes '$1'." v -
    repeat {w}
      axis={i[$>]}
      if {$axis==_'x'} repeat {$!-1} l[$>] if {w>1} _idct fi endl done
      elif {$axis==_'y'} repeat {$!-1} l[$>] if {h>1} permute yxzc _idct permute yxzc fi endl done
      elif {$axis==_'z'} repeat {$!-1} l[$>] if {d>1} permute zxyc _idct permute yzxc fi endl done
      fi
    done
  else
    rm.
    v + e[0--3] "Compute inverse discrete cosine transform of image$?." v -
    noarg
    repeat $! l[$>]
      if {w>1} _idct fi
      if {h>1} permute yxzc _idct permute yxzc fi
      if {d>1} permute zxyc _idct permute yzxc fi
    endl done
  fi
  v +

# 1D inverse transform (DCT-III) for a single image.
_idct :
  is_odd={w%2}
  / {sqrt(2/w)} +z[0] 0,0 *. {sqrt(2)} j.. .,0,0,0 rm. # Make the transform orthogonal.
  if $is_odd r {w+1},100%,100%,100%,0,0 fi
  +mirror x shift. 1 *. -1
  100%,1,1,1,cos(x*pi/(2*w))
  100%,1,1,1,sin(x*pi/(2*w))
  +*[0,3] +*[1,2] +[-2,-1]
  *[0,2] *[1,2] -[0,1]
  ifft x k[0] / 2
  s x,2 mirror. x
  r[0] 200%,100%,1,100%,4,0,0
  r[1] 200%,100%,1,100%,4,0,1
  +
  if $is_odd r {w-1},100%,100%,100%,0 fi

#@cli iee
#@cli : Compute gradient-orthogonal-directed 2nd derivative of image(s).
#@cli : $ image.jpg iee
iee :
  e[^-1] "Compute gradient-orthogonal-directed 2nd derivative of image$?."
  v - repeat $! l[$>]
    if {d==1}
      +g xy,0 hessian... xxxyyy      # ixx ixy iyy ix iy
      *... .. *[-4] . *[-4] -2       # ixx -2iyixy ixiyy ix iy
      +[-4,-3] *... ..               # ixx -2ixiyixy+ix^2iyy ix iy
      sqr[-2,-1] *[-4] . +[-4,-3]    # iy^2ixx-2ixiyixy+ix^2iyy ix^2 iy^2
      +[-2,-1] +. 1e-8 /             # (iy^2ixx+2ixiyixy+ix^2iyy)/(ix^2+iy^2)
    else
      +inn laplacian.. -
    fi
  endl done v +

#@cli ifft : _{ x | y | z }...{ x | y | z } : (+)
#@cli : Compute the inverse fourier transform (real and imaginary parts) of selected images.
#@cli : optionally along the specified axes only.
#@cli : $$ _fft

#@cli ihaar : scale>0
#@cli : Compute the inverse haar multiscale wavelet transform of selected images.
ihaar : check "isint(${1=1}) && $1>=0"
  e[^-1] "Compute inverse haar transform of image$? with $1 scales."
  v - repeat $! l[$>]
    repeat {$1-1}
      w={max(0,round(w/2^(1+$<))-1)}
      h={max(0,round(h/2^(1+$<))-1)}
      d={max(0,round(d/2^(1+$<))-1)}
      +z 0,0,0,$w,$h,$d _ihaar. j.. . rm.
    done
    _ihaar
  endl done v +

_ihaar : # Mono-scale inverse haar transform.
  _ihaar_x _ihaar_y _ihaar_z

_ihaar_x : # Inverse haar transform along the x-axis.
  if {w<=1} return fi
  if {w%2} v + error[0--6] "Command 'ihaar': Invalid image width="{w}" (is not even)." fi
  s x,2 r 200% (-1,1) *[-2,-1] + / {sqrt(2)}

_ihaar_y : # Inverse haar transform along the y-axis.
  if {h<=1} return fi
  if {h%2} v + error "Command 'ihaar': Invalid image height="{h}" (is not even)." fi
  s y,2 r 100%,200% (-1;1) r. {-2,w} *[-2,-1] + / {sqrt(2)}

_ihaar_z : # Inverse haar transform along the z-axis.
  if {d<=1} return fi
  if {d%2} v + error "Command 'ihaar': Invalid image depth="{h}" (is not even)." fi
  s z,2 r 100%,100%,200% (-1/1) r. {-2,w},{-2,h} *[-2,-1] + / {sqrt(2)}

#@cli ilaplacian : { nb_iterations>0 | 0 },_time_step>0,_[initial_estimate]
#@cli : Invert selected Laplacian images.
#@cli : If given 'nb_iterations' is '0', inversion is done in Fourier space (single iteration),
#@cli : otherwise, by applying 'nb_iterations' of a Laplacian-inversion PDE flow (with specified 'time_step').
#@cli : Note that the resulting inversions are just estimation of possible/approximated solutions.
#@cli : Default values: 'nb_iterations=0','time_step=10' and '[initial_estimated]=(undefined)'.
#@cli : $ image.jpg +laplacian +ilaplacian[-1] 0
ilaplacian : check "${1=0}>=0 && ${2=10}>0" skip "${3=}"
  v - is_estimate=${"is_image_arg $3"} nb_iter={round($1)}
  if {!$nb_iter} # Inversion in Fourier space
    if $is_estimate
      v + e[0--4] "Invert Laplacian image$? in Fourier space, with initial estimate $3." v -
      pass$3 1 ia=${-average_colors} rm.
    else
      v + e[0--4] "Invert Laplacian image$? in Fourier space." v -
      ia=0
    fi
    repeat $! l[$>]
      fft 100%,100%,1,1,"2*(cos(x*2*pi/w) + cos(y*2*pi/h)) - 4" =. 1
      /[-3,-2] . rm.
      = 0 ifft rm.
    endl done + 'begin(S=resize([$ia],s,0));S'

  else # Inversion with PDE-flow
    if $is_estimate
      v + e[0--4] "Invert Laplacian image$? using $1 iterations of PDE flow, with time step $2 and initial estimate $3." v -
      repeat $! pass$3 0 l[$>,-1]
        repeat $1 +laplacian. -. ... *. {$2/max(abs(im),abs(iM))} +[^0] done k.
      endl done
    else
      v + e[0--4] "Invert Laplacian image$? using $1 iterations of PDE flow, with time step $2." v -
      repeat $! l[$>] +f 0
        repeat $1 +laplacian. -. ... *. {$2/max(abs(im),abs(iM))} +[^0] done k.
      endl done
    fi
  fi
  v +

#@cli inn
#@cli : Compute gradient-directed 2nd derivative of image(s).
#@cli : $ image.jpg inn
inn :
  e[^-1] "Compute gradient-directed 2nd derivative of image$?."
  v - repeat $! l[$>]
    if {d==1}
      +g xy,0 hessian... xxxyyy      # ixx ixy iyy ix iy
      *[-5] .. *[-4] . *[-4] 2       # ixixx 2iyixy iyy ix iy
      +[-5,-4] *[-4] ..              # ix^2ixx+2ixiyixy iyy ix iy
      sqr[-2,-1] *... . +[-4,-3]     # ix^2ixx+2ixiyixy+iy^2iyy ix^2 iy^2
      +[-2,-1] +. 1e-8 /             # (ix^2ixx+2ixiyixy+iy^2iyy)/(ix^2+iy^2)
    else
      +g xyz,0 hessian[-4] xxxyxzyyyzzz               # ixx ixy ixz iyy iyz izz ix iy iz
      *[-9] ... *[-8] .. *[-8] 2 *[-7] . *[-7] 2      # ixixx 2iyixy 2izixz iyy iyz izz ix iy iz
      +[-9--7] *[-7] ...                              # ix^2ixx+2ixiyixy+2ixizixy iyy iyz izz ix iy iz
      *[-6] .. *[-5] . *[-5] 2                        # ix^2ixx+2ixiyixy+2ixizixy iyiyy 2iziyz izz ix iy iz
      +[-6,-5] *[-5] .. +[-6,-5]                      # ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz izz ix iy iz
      sqr[-3--1] *[-4] . +[-5,-4]                     # ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz+iz^2izz ix^2 iy^2 iz^2
      +[-3--1] +. 1e-8 /                              # (ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz+iz^2izz)/(ix^2+iy^2+iz^2)
    fi
  endl done v +

#@cli inpaint : [mask] : [mask],0,_fast_method : [mask],_patch_size>=1,_lookup_size>=1,_lookup_factor>=0,_lookup_increment!=0,_blend_size>=0,0<=_blend_threshold<=1,_blend_decay>=0,_blend_scales>=1,_is_blend_outer={ 0 | 1 } : (+)
#@cli : Inpaint selected images by specified mask.
#@cli : If no patch size (or 0) is specified, inpainting is done using a fast average or median algorithm.
#@cli : Otherwise, it used a patch-based reconstruction method, that can be very time consuming.
#@cli : 'fast_method' can be { 0=low-connectivity average | 1=high-connectivity average | 2=low-connectivity median | 3=high-connectivity median }.
#@cli : Default values: 'patch_size=0', 'fast_method=1', 'lookup_size=22', 'lookup_factor=0.5', 'lookup_increment=1', 'blend_size=0', 'blend_threshold=0', 'blend_decay=0.05', 'blend_scales=10' and 'is_blend_outer=1'.
#@cli : $ image.jpg 100%,100% ellipse 50%,50%,30,30,0,1,255 ellipse 20%,20%,30,10,0,1,255 +inpaint[-2] [-1] remove[-2]
#@cli : $ image.jpg 100%,100% circle 30%,30%,30,1,255,0,255 circle 70%,70%,50,1,255,0,255 +inpaint[0] [1],5,15,0.5,1,9,0 remove[1]

#@cli inpaint_diffusion : [mask],_nb_scales[%]>=0,_diffusion_type={ 0=isotropic | 1=delaunay-guided | 2=edge-guided | 3=mask-guided },_diffusion_iter>=0
#@cli : Inpaint selected images by specified mask using a multiscale transport-diffusion algorithm.
#@cli : If 'diffusion type==3', non-zero values of the mask (e.g. a distance function) are used to guide the diffusion process.
#@cli : Default values: 'nb_scales=75%', 'diffusion_type=1' and 'diffusion_iter=20'.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 +inpaint_diffusion[0] [1]
inpaint_diffusion : check ${is_image_arg\ $1}" && ${2=75%}>=0 && isint(${3=1}) && $3>=0 && $3<=3 && ${4=20}>=0"
  v - s0="isotropic" s1="delaunay-guided" s2="edge-guided" s3="mask-guided"
  v + e[^-1] "Inpaint image$? by mask $1, using a multiscale diffusion algorithm with $2 scales and $4 iterations of "${s$3}" diffusion." v -
  repeat $! nm={n} pass$1 l[$>,-1]
    nb_scalesM={ceil(log2(max(w,h,d)))}
    nb_scales={round(${"is_percent $2"}?$nb_scalesM*$2:$2)}
    nb_scales={max(1,min($nb_scales,$nb_scalesM))}
    nb_iter={max(5,$4)}

    repeat $nb_scales
      {0,"S = 2^"$<"; round([ max(1,w/S), max(1,h/S), max(1,d/S), s ])"}
      100%,100%,100%
      eval[1] "const wl1 = w#-1 - 1;    const hl1 = h#-1 - 1;    const dl1 = d#-1 - 1;
               const w1 = max(1,w - 1); const h1 = max(1,h - 1); const d1 = max(1,d - 1);
               !i?(
                 X = round(x*wl1/w1); Y = round(y*hl1/h1); Z = round(z*dl1/d1);
                 I(#-2,X,Y,Z) += I(#0,x,y,z);
                 ++i(#-1,X,Y,Z)
               );I"
      +max. 1 /[-3,-1] !=. 0

      if {!$>} # First scale: Initialize by value propagation
        im={-2,im} +-.. {$im-1} *. ..
        +distance.. 1 *. -1 watershed.. . rm.
        +. {$im-1} mv. -3
      fi

      if {$>>0" || "$nb_scales==1}

        # Apply diffusion iterations.
        r... ..,3
        if {$3==0} # Isotropic diffusion
          repeat $nb_iter j... ..,0,0,0,0,1,. b... 0.5 done

        elif {$3==1} # Delaunay-guided
          +distance. 1 100%,100%,100%,{d==1?2:3}
          eval.. "* # Apply specific gradient scheme for distance function
            const boundary = 1;
            maxabs(a,b) = (abs(a)>abs(b)?a:b);
            ix = maxabs(j(1) - i,i - j(-1));
            iy = maxabs(j(0,1) - i,i - j(0,-1));
            d>1?(
              iz = maxabs(j(0,0,1) - i,i - j(0,0,-1));
              copy(I(#-1),[ ix,iy,iz ],3,whd);
            ):copy(I(#-1),[ ix,iy ],2,whd)"
          rm.. orientation.
          repeat {$nb_iter}
            j[-4] ...,0,0,0,0,1,..
            +warp[-4] .,1,2,1 *.. -1 warp[-5] ..,1,2,1 +[-5,-1] /[-4] 2
          done
          rm.

        elif {$3==2} # Edge-guided
          repeat $nb_iter
            +diffusiontensors... 0,1,1.5,0.5
            j[-4] ...,0,0,0,0,1,..
            smooth[-4] .,1,10,0 rm.
          done

        else # Mask-guided
          +r[1] .,2 g. a[-{d==1?2:3}--1] c orientation.
          repeat $nb_iter
            j[-4] ...,0,0,0,0,1,..
            +warp[-4] .,1,2,1 *.. -1 warp[-5] ..,1,2,1 +[-5,-1] /[-4] 2
          done rm.
        fi
        j... ..,0,0,0,0,1,.
      fi
      rm[-2,-1]
    done
    nm. $nm rv[0,-1] rm.
  endl rm. done v +

#@cli inpaint_flow : [mask],_nb_global_iter>=0,_nb_local_iter>=0,_dt>0,_alpha>=0,_sigma>=0
#@cli : Apply iteration of the inpainting flow on selected images.
#@cli : Default values: 'nb_global_iter=4', 'nb_global_iter=15', 'dt=10', 'alpha=1' and 'sigma=3'.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 inpaint_flow[0] [1]
inpaint_flow : check ${is_image_arg\ $1}" && ${2=10}>=0 && ${3=100}>=0 && ${4=5}>0 && ${5=1}>=0 && ${6=3}>=0"
  e[^-1] "Apply $2x$3 iterations of the inpainting flow on image$?, with mask $1, time step $4, alpha $5 and sigma $6."
  v - repeat $! pass$1 0 l[$>,-1]
    r. [0],[0],[0],1,0 inpaint.. [1]
    repeat $2
      progress {100*$>/($2-1)}
      +diffusiontensors.. 0,1,$5,$6,0 *. .. smooth... .,$3,$4,0 rm.
    done
    progress 100
  endl rm. done v +

#@cli inpaint_holes : maximal_area[%]>=0,_tolerance>=0,_is_high_connectivity={ 0 | 1 }
#@cli : Inpaint all connected regions having an area less than specified value.
#@cli : Default values: 'maximal_area=4', 'tolerance=0' and 'is_high_connectivity=0'.
#@cli : $ image.jpg noise 5%,2 +inpaint_holes 8,40
inpaint_holes : check "${1=4}>=0 && ${2=0}>=0" skip ${3=0}
  e[^-1] "Inpaint holes with area less than $1 pixels in image$?, with tolerance $2 and "${arg\ 1+!$3,high,low}" connectivity."
  v - repeat $! l[$>]
    100%,100%,100%
    area={if(${is_percent\ $1},$1*w*h*d,$1)}
    repeat {0,s} sh[0] $> +area. $2,$3 <=. $1 -|[1,-1] rm. done
    if {im} k[0] whd={w},{h},{d} r 1,1,1,100%,2 r $whd,100%
    else inpaint[0] [1],0,{2*!$2+!!$3} k[0] fi
  endl done v +

#@cli inpaint_morpho : [mask]
#@cli : Inpaint selected images by specified mask using morphological operators.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 +inpaint_morpho[0] [1]
inpaint_morpho : check ${is_image_arg\ $1}
  e[^-1] "Inpaint image$? by mask $1, using morphological operators."
  v - repeat $! pass$1 0 l[$>,-1]
    nm={0,n} im={0,im} iM={0,iM} im1={$im-1} iM1={$iM+1}
    channels. 0 ==. 0
    +f[0] $im1 j. [0],0,0,0,0,1,..
    do
      +dilate. 3
      replace.. $im1,$iM1
      erode.. 3
      replace.. $iM1,$im1
      +[-2,-1] /. 2
      j. ...,0,0,0,0,1,..
    while {im==$im1}
    k. nm $nm
  endl done v +

#@cli inpaint_matchpatch : [mask],_nb_scales={ 0=auto | >0 },_patch_size>0,_nb_iterations_per_scale>0,_blend_size>=0,_allow_outer_blending={ 0 | 1 },_is_already_initialized={ 0 | 1 }
#@cli : Inpaint selected images by specified binary mask, using a multi-scale matchpatch algorithm.
#@cli : Default values: 'nb_scales=0', 'patch_size=9', 'nb_iterations_per_scale=10', 'blend_size=5', 'allow_outer_blending=1' and 'is_already_initialized=0'.
#@cli : $ image.jpg 100%,100% ellipse[-1] 30%,30%,40,30,0,1,255 +inpaint_matchpatch[0] [1]
inpaint_matchpatch : check ${is_image_arg\ $1}"&& ${2=0}>=0 && isint(${3=9}) && $3>0 && isint(${4=10}) && $4>0 && isint(${5=5}) && $5>=0" skip ${6=1},${7=0}
  e[^-1] "Inpaint image$? with mask $1, using a multiscale patch-matching algorithm with "${"v - if $2 u \"$2 \" else u auto- fi v +"}\
          "scales, $3x$3 patches, $4 iterations per scale and blending size $5."
  v - repeat $! pass$1 0 l[$>,-1]

    # Init variables and images.
    nm={0,n} nm img,mask
    nb_scales={max(1,round(if($2,$2,log2(min(w,h)/16)),1,1))}
    visu_size=${fitscreen[]" "{0,w},{0,h},1,25%,50%}
    slices[img] 0 r[mask] [img],[img],1,1,0 !=[mask] 0
    if {!$7} inpaint_diffusion[img] [mask],75% fi # Quick first estimate.
    im={img,im} -[img] $im

    first_iter=1 iter=0
    repeat $nb_scales
      scale={100*(0.5^$<)}
      v + e[] "> Process scale "{1+$>}"/"$nb_scales" -> "$scale% v -
      progress {100*$>/max(1,$nb_scales-1)}

      # Compute image and mask at current scales.
      +r[img,mask] $scale%,$scale%,1,100%,2 nm[-2,-1] scaled_img,scaled_mask
      >=[scaled_mask] 0.95
      if {scaled_mask,!iM} rm[scaled_img,scaled_mask] continue fi # Skip scale (if too low).
      +f[scaled_img] -4096 +j[scaled_img] .,0,0,0,0,1,[scaled_mask] rm.. nm. scaled_reference

      coef={0.5^($nb_scales-$iter)}
      patch_size={v=round(max(min($3,5),$3*$coef));v+(1-(v%2))}
      patch_size={min(w,h,$patch_size)}
      blend_size={v=if($5,round(max(3,$5*$coef)));v+(1-(v%2))}
      iter+=1
      ==[scaled_mask] 0

      if $first_iter # First iteration.

        # Estimate initial correspondence map.
        100%,100%,1,1,x +f. y mv[scaled_mask] $! a[-3--1] c
        matchpatch[scaled_img] [scaled_reference],$patch_size,$patch_size,1,4,4,0,0,.
        rm[scaled_reference,-1]
        nm. correspondence
        first_iter=0

      else # Standard iteration.

        # Upscale correspondence map from previous scale.
        *[correspondence] 2 r[correspondence] 200%,200%,1,2 r[correspondence] [scaled_img],[scaled_img],1,2,0,1
        100%,100%,1,1,x +f. y a[-2,-1] c
        f[scaled_mask] "*if(i,1,
                           upc = i(#"$correspondence",x-1,y,0,0); vpc = i(#"$correspondence",x-1,y,0,1);
                           ucp = i(#"$correspondence",x,y-1,0,0); vcp = i(#"$correspondence",x,y-1,0,1);
                           ucc = i(#"$correspondence",x,y,0,0); vcc = i(#"$correspondence",x,y,0,1);
                           i(#-1,x,y,0,0) = (ucc==upc && vcc==vpc)?upc + 1:ucc;
                           i(#-1,x,y,0,1) = (ucc==ucp && vcc==vcp)?vcp + 1:vcc;
                           0)"
        rm[correspondence] nm. correspondence
        a[correspondence] [scaled_mask],c

        # Refine correspondence map iteratively with matchpatch.
        nbs1={max(1,$nb_scales-1)}
        nb_iter={round(max(1,$4*(($<+1)/$nbs1)^2))}

        repeat $nb_iter
          _inpaint_matchpatch[scaled_img] [correspondence],[scaled_mask],$blend_size,$6
          +matchpatch[scaled_img] [scaled_reference],$patch_size,$patch_size,1,4,4,0,0,[correspondence]
          j[correspondence] . rm.
          if {*1} w1[scaled_img] $visu_size,0 fi
          if {*2} w2[correspondence] $visu_size,1 fi
        done
        rm[scaled_img,scaled_mask,scaled_reference] channels[correspondence] 0,1
      fi

    done
    progress 100

    # Generate final result.
    if $correspondence
      ==[mask] 0
      _inpaint_matchpatch[img] [correspondence],[mask],$5,$6
      rm[correspondence]
    fi
    +[img] $im
  endl rm[mask] done v +

# _inpaint_matchpatch : [correspondence_map],[mask],blend_size>0,_allow_outer_blending={ 0 | 1 }
_inpaint_matchpatch :
  pass$1 1 pass$2 {!$3" || "!$4}
  if {!$3}
    warp[0] [1],0,0,1
  else
    if $4 erode. $3 fi
    f[0] "*begin(
      boundary = 1;
      const patch_size = $3;
      const p2 = int(patch_size/2);
      const p1 = patch_size - p2 - 1;
      avg = resize([0],s#0);

      # Pre-compute gaussian kernel for patch blending.
      wpq = resize([0],patch_size^2);
      g = 0;
      for (q = -p1, q<=p2, ++q,
        for (p = -p1, p<=p2, ++p,
          wpq[g++] = exp(-(p^2 + q^2)/(2*(0.3*patch_size)^2));
        );
      );
    );
    if (i#2,I,
      g = 0;
      avg = 0;
      norm = 0;
      for (q = -p1, q<=p2, ++q,
        for (p = -p1, p<=p2, ++p,
          U = I(#1,x + p,y + q);
          w = wpq[g++];
          norm+=w;
          avg+=w*I(#0,U[0,2] - [p,q]);
        );
      );
      avg/norm)"
  fi
  k[0]

# _inpaint_warping2d : fill-in zero-valued vectors in absolute 2d warping field (works even when 'spectrum>2').
_inpaint_warping2d :
  repeat $! l[$>]
    100%,100%,100%,2,"> begin(const S = s#0; zero0 = vectorS(); zero1 = [0,0]; N = 0); I(#-1)==zero0?zero1:[++N,1]"
    s. c distance. 1 *. -1
    watershed.. . rm.

    # Propagate offsets in each distinct voronoi cell.
    repeat 2
      f.. ">i?I:( # Forward propagation
        nP = vectors();
        const sP = size(nP);
        r = i(#-1);
        (P = J(-1,-1))[0] && j(#-1,-1,-1)==r?(nP[0] = ++P[0]; nP[1] = ++P[1]; sP>2?copy(nP[2],P[2],sP-2)):
        (P = J(0,-1))[0] && j(#-1,0,-1)==r  ?(nP[0] = P[0];   nP[1] = ++P[1]; sP>2?copy(nP[2],P[2],sP-2)):
        (P = J(1,-1))[0] && j(#-1,1,-1)==r  ?(nP[0] = --P[0]; nP[1] = ++P[1]; sP>2?copy(nP[2],P[2],sP-2)):
        (P = J(-1,0))[0] && j(#-1,-1,0)==r  ?(nP[0] = ++P[0]; nP[1] = P[1]; sP>2?copy(nP[2],P[2],sP-2));
        nP)"
      f.. "<i?I:( # Backward propagation
        nP = vectors();
        const sP = size(nP);
        r = i(#-1);
        (P = J(1,1))[0] && j(#-1,1,1)==r  ?(nP[0] = --P[0]; nP[1] = --P[1]; sP>2?copy(nP[2],P[2],sP-2)):
        (P = J(0,1))[0] && j(#-1,0,1)==r  ?(nP[0] = P[0];   nP[1] = --P[1]; sP>2?copy(nP[2],P[2],sP-2)):
        (P = J(-1,1))[0] && j(#-1,-1,1)==r?(nP[0] = ++P[0]; nP[1] = --P[1]; sP>2?copy(nP[2],P[2],sP-2)):
        (P = J(1,0))[0] && j(#-1,1,0)==r  ?(nP[0] = --P[0]; nP[1] = P[1]; sP>2?copy(nP[2],P[2],sP-2));
        nP)"
    done
    rm.
  endl done

#@cli kuwahara : size>0
#@cli : Apply Kuwahara filter of specified size on selected images.
#@cli : $ image.jpg +kuwahara 5
kuwahara : check $1>0
  e[^-1] "Apply Kuwahara filter of size $1 on image$?."
  v - repeat $! l[$>]
    s={s}
    +dilate $1 compose_channels. min
    +erode[0] $1 compose_channels. max
    -[-2,-1]
    $1,1,1,1,{1/$1} convolve[0] . transpose. convolve[0] . rm.
    p={int($1/2)}
    a[-2,-1] c
    f "v1=i(x-"$p",y-"$p",0,"$s",0,1); \
       v2=i(x+"$p",y-"$p",0,"$s",0,1); \
       v3=i(x-"$p",y+"$p",0,"$s",0,1); \
       v4=i(x+"$p",y+"$p",0,"$s",0,1); \
       vm=min(v1,v2,v3,v4); \
       if(c>="$s",i, \
         if(vm==v1,i(x-"$p",y-"$p",0,c,0,1),
           if(vm==v2,i(x+"$p",y-"$p",0,c,0,1),
             if(vm==v3,i(x-"$p",y+"$p",0,c,0,1),
               i(x+"$p",y+"$p",0,c,0,1)))))"
    channels 0,{s-2}
  endl done v +

#@cli laplacian
#@cli : Compute Laplacian of selected images.
#@cli : $ image.jpg laplacian
laplacian :
  e[^-1] "Compute Laplacian of image$?."
  v - repeat $! l[$>]
    hessian ${arg\ 1+(d==1),xxyyzz,xxyy} +
  endl done v +

#@cli lic : _amplitude>0,_channels>0
#@cli : Render LIC representation of selected vector fields.
#@cli : Default values: 'amplitude=30' and 'channels=1'.
#@cli : $ 400,400,1,2,'if(c==0,x-w/2,y-h/2)' +lic 200,3 quiver[-2] [-2],10,1,1,1,255
lic : skip ${1=30},${2=1}
  e[^-1] "Render LIC representation of 2D vector field$?, with amplitude $1 and $2 channel(s)."
  v - repeat $! l[$>] nm={0,n}
     channels 0,1 / {max(abs(im),abs(iM))} vector2tensor
     100%,100%,100%,$2 rand. 0,255 smooth. ..,$1 rm..
     equalize
  nm $nm endl done v +

#@cli map_tones : _threshold>=0,_gamma>=0,_smoothness>=0,nb_iter>=0
#@cli : Apply tone mapping operator on selected images, based on Poisson equation.
#@cli : Default values: 'threshold=0.1', 'gamma=0.8', 'smoothness=0.5' and 'nb_iter=30'.
#@cli : $ image.jpg +map_tones ,
map_tones : skip ${1=0.1},${2=0.8},${3=0.5},${4=30}
  e[^-1] "Apply tone mapping operator on image$?, with threshold $1, gamma $2, smoothness $3 and $4 iterations."
  v - repeat $! l[$>]

    # Estimate target divergence for each channel.
    +l s c repeat $! l[$>]
      g xy,1 a c +norm orientation..
      m={im} M={iM} b. $3 n. $m,$M
      *. 'alpha=$1*iM;(alpha/(1e-10+i))*(i/(1e-10+alpha))^$2'
      * s c g.. x,-1 g. y,-1 +
    endl done a c * 0.25 endl

   # Start Poisson-PDE iterations
    repeat $4 +laplacian.. *. 0.25 +. ... -. .. *. 800 +[-3,-1] /.. 801 c.. 0,255 done rm.

  endl done  v +

#@cli map_tones_fast : _radius[%]>=0,_power>=0
#@cli : Apply fast tone mapping operator on selected images.
#@cli : Default values: 'radius=3%' and 'power=0.3'.
#@cli : $ image.jpg +map_tones_fast ,
map_tones_fast : check "${1=3%}>=0 && ${2=0.3}>=0"
  e[^-1] "Apply fast tone mapping operator on image$?, with radius $1 and power $2."
  v - repeat $! l[$>]
    +luminance b. $1 n 0,1
    +*. 2 -. 1 abs. *. {$2*log(10)} exp.
    <=.. 0.5 r. ...
    +*... -1 +. 1 ^. .. *. -1 +. 1 *. ...
    ^[-4,-2] ==.. 0 *[-3,-2] +
  endl done n 0,255 v +

#@cli meancurvature_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the mean curvature flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@cli : $ image.jpg +meancurvature_flow 20
meancurvature_flow : skip ${1=10},${2=30},${3=0}
  e[^-1] "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
  v - pde_flow $1,$2,iee,$3 v +

#@cli median : size>=0,_threshold>0 : (+)
#@cli : Apply (opt. thresholded) median filter on selected images with structuring element size x size.
#@cli : $ image.jpg +median 5

#@cli nlmeans : [guide],_patch_radius>0,_spatial_bandwidth>0,_tonal_bandwidth>0,_patch_measure_command : _patch_radius>0,_spatial_bandwidth>0,_tonal_bandwidth>0,_patch_measure_command
#@cli : Apply non local means denoising of Buades et al, 2005. on selected images.
#@cli : The patch is a gaussian function of 'std _patch_radius'.
#@cli : The spatial kernel is a rectangle of radius 'spatial_bandwidth'.
#@cli : The tonal kernel is exponential (exp(-d^2/_tonal_bandwidth^2))
#@cli : with d the euclidiean distance between image patches.
#@cli : Default values: 'patch_radius=4', 'spatial_bandwidth=4', 'tonal_bandwidth=10' and 'patch_measure_command=-norm'.
#@cli : $ image.jpg +noise 10 nlmeans[-1] 4,4,{0.6*${-std_noise}}
nlmeans:
  v -
  if ${"is_image_arg $1"}

    # Guided-filtering
    check "${2=4}>0 && ${3=4}>0 && ${4=10}>0" skip "${5=-norm}"
    e[^-1] "Apply non-local means denoising on image$?, with guide $1, patch size $2, spatial bandwidth $3, tonal bandwidth $4 and patch measure command '$5'."
    pass$1 0 l. $5 k[0] endl # [1] preprocessed image used to compute weights.
    repeat {$!-1} l[$>,-1]
      100%,100%,100%,100%,{-1.0/($4*$4)} # [2] compute a scaling.
      nlmeans_core[0] [1],[2],$2,$3 rm. # Apply the NLM denoising with image 1 and 2 as parameter.
    endl done
    rm.

  else

    # Non-guided filtering
    check "${1=4}>0 && ${2=4}>0 && ${3=10}>0" skip "${4=-norm}"
    e[^-1] "Apply non-local means denoising on image$?, with patch size $1, spatial bandwidth $2, tonal bandwidth $3 and patch measure command '$4'."
    repeat $! l[$>]
      +l $4 k[0] endl # [1] preprocessed image used to compute weights.
      100%,100%,100%,100%,{-1.0/($3*$3)} # [2] compute a scaling.
      nlmeans_core[0] [1],[2],$1,$2 k[0] # Apply the NLM denoising with image 1 and 2 as parameter.
    endl done

  fi v +

#@cli nlmeans_core: _reference_image,_scaling_map,_patch_radius>0,_spatial_bandwidth>0
#@cli : Apply non local means denoising using a image for weight and a map for scaling
nlmeans_core : check ${is_image_arg\ $1}" && "${is_image_arg\ $2}" && $3>0 && $4>0"
  e[^-1] "Apply non-local means denoising using weight images $1, scaling map $2, patch size $3 and spatial bandwidth $4."
  v - pass$1 0 pass$2 0
  repeat {$!-2} l[$>,-1,-2]
    # [0] original, [1] weights, [2] scaling [3] sum(weights * patch), [4] sum(weights), [5] max(weights)
    100%,100%,100%,{0,s},0 100%,100%,100%,{1,s},0 100%,100%,100%,{1,s},0
    if {{0,d}==1}
      repeat {2*$4+1} j={$>-$4} repeat {2*$4+1} i={$>-$4}
        if {$i!=0||$j!=0}
          # Compute shifted images [6] and weight [7]
          +shift[0,1] $i,$j,0,0,2 -[7] [1]
          sqr[7] b[7] $3 *[7] [2] exp[7]
          # Accumulate weights
          *[6] [7] max[5] [7] +[4,7] +[3,6]
        fi
      done done
    else
      repeat {2*$4+1} k={$>-$4} repeat {2*$4+1} j={$>-$4} repeat {2*$4+1} i={$>-$4}
        if {$i!=0||$j!=0||$k!=0}
          # Compute shifted images [6] and weight [7]
          +shift[0,1] $i,$j,0,0,2 -[7] [1]
          sqr[7] b[7] $3 *[7] [2] exp[7]
          # Accumulate weights
          *[6] [7] max[5] [7] +[4,7] +[3,6]
        fi
      done done done
    fi
    max[5] 1e-6 rm[1,2]
    *[0] [3] +[1,0] +[1,2] # Add central patch
    / # Normalize
  endl done v +

#@cli normalize_local : _amplitude>=0,_radius>0,_n_smooth>=0[%],_a_smooth>=0[%],_is_cut={ 0 | 1 },_min=0,_max=255
#@cli : Normalize selected images locally.
#@cli : Default values: 'amplitude=3', 'radius=16', 'n_smooth=4%', 'a_smooth=2%', 'is_cut=1', 'min=0' and 'max=255'.
#@cli : $ image.jpg normalize_local 8,10
normalize_local :
  check "${1=3}>=0 && ${2=16}>0 && isbool(${5=1})" skip ${3=4%},${4=2%},${6=0},${7=255}
  e[^-1] "Normalize image$? locally, with amplitude $1, radius $2, neighborhood smoothness $3 and average smoothness $4."
  v - repeat $! l[$>]
    +l erode {2*$2+1} s c min endl
    +l.. dilate {2*$2+1} s c max endl
    +b... $4 b[-3,-2] $3
    +-.. ... +. 0.01 -[-5] [-4] /[-5,-1]
    *[-3,-2] {$1+1} *. -$1 +... . +[-2,-1]
    if $5 max.. $6 min. $7 fi
    -. .. *[-3,-1] +
    if $5 c $6,$7 fi
  endl done v +

#@cli normalized_cross_correlation : [mask]
#@cli : Compute normalized cross-correlation of selected images with specified mask.
#@cli : $ image.jpg +shift -30,-20 +normalized_cross_correlation[0] [1]
normalized_cross_correlation : check ${is_image_arg\ $1}
  e[^-1] "Compute normalized cross-correlation of image$? with mask $1."
  v - pass$1 0 norm repeat {$!-1} . l[$>,-1]
    fft.. fft. [-2,-1] *.. [-5] *. [-6]
    -[-2,-1] *[-5,-3] *[-3,-2] +[-3,-2] [-2,-1] a[-2,-1] c norm.
    /... . /[-2,-1] ifft rm.
  endl done rm. v +

#@cli peronamalik_flow : K_factor>0,_nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the Perona-Malik flow on selected images.
#@cli : Default values: 'K_factor=20', 'nb_iter=5', 'dt=5' and 'keep_sequence=0'.
#@cli : $ image.jpg +heat_flow 20
peronamalik_flow : check "${1=20}>0 && ${2=5}>=0" skip ${3=5},${4=0}
  e[^-1] "Apply $2 iterations of the Perona-Malik flow on image$?, with K factor $1 and time step $3."
  v -
  m "_peronamalik_flow :
   +gradient xy,0 a[-2,-1] c norm. b. 0.8 /. $1 sqr. *. -1 exp. a[-2,-1] c
   f. '\"s1=s-1;
          C=i(x,y,z,s-1);
          if(c>=s1,0,
           (C+i(x+1,y,z,s-1,0,1))*(j(1,0,0,0,0,1)-i) -
           (C+i(x-1,y,z,s-1,0,1))*(i-j(-1,0,0,0,0,1)) +
           (C+i(x,y+1,z,s-1,0,1))*(j(0,1,0,0,0,1)-i) -
           (C+i(x,y-1,z,s-1,0,1))*(i-j(0,-1,0,0,0,1)))\"'"
  pde_flow $2,$3,_peronamalik_flow,$4
  uncommand _peronamalik_flow
  v +

#@cli phase_correlation : [destination]
#@cli : Estimate translation vector between selected source images and specified destination.
#@cli : $ image.jpg +shift -30,-20 +phase_correlation[0] [1] unroll[-1] y
phase_correlation : check ${is_image_arg\ $1}
  e[^-1] "Estimate shift between source image$? and destination $1."
  v - repeat $! pass$1
    normalized_cross_correlation[$>] . rm.
    l[$>]
      ({[xM,yM,zM,cM]}) *. 2 s. x rm.
      if {{-3,^}>{-4,w}} -... {-4,w} -... {-4,w} fi
      if {{-2,^}>{-4,h}} -.. {-4,h} -.. {-4,h} fi
      if {{^}>{-4,d}} -. {-4,d} -. {-4,d} fi
      a[-3--1] c rm.. / 2 * -1
      nm [phase\ correlation]
  endl done v +

#@cli pde_flow : _nb_iter>=0,_dt,_velocity_command,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of a generic PDE flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30', 'velocity_command=laplacian' and 'keep_sequence=0'.
#@cli : $ image.jpg +pde_flow 20
pde_flow : skip ${1=10},${2=30},${3=laplacian},${4=0}
  e[^-1] "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
  v - repeat $! l[$<]
    repeat $1
      +$3. *. {$2/(0.01+max(abs(im),abs(iM)))}
      if $4 +. .. else +[-2,-1] fi
    done
    if $4 rm[0] fi
    a x
  endl done
  if $4 s x,$1 fi v +

#@cli periodize_poisson
#@cli : Periodize selected images using a Poisson solver in Fourier space.
#@cli : $ image.jpg +periodize_poisson array 2,2,2
periodize_poisson :
  e[^-1] "Periodize image$? using Poisson solver in Fourier space."
  v - repeat $! l[$>]
    s c repeat $! l[$>]
      mM={[im,iM]} sum={0,ia}
      laplacian ilaplacian 0 + $sum c $mM
    endl done a c
  endl done v +

#@cli red_eye : 0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1
#@cli : Attenuate red-eye effect in selected images.
#@cli : Default values: 'threshold=75', 'smoothness=3.5' and 'attenuation=0.1'.
#@cli : $ image.jpg +red_eye ,
red_eye : skip ${1=75},${2=3.5},${3=0.1}
  e[^-1] "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
  v - to_rgb rgb2ycbcr repeat $! l[$>]
    s c -. 128 +>=. $1% b. $2 sqrt. *. -1 +. 1
    n. $3,1 *[-2,-1] +. 128 a c ycbcr2rgb
  endl done v +

#@cli remove_hotpixels : _mask_size>0, _threshold[%]>0
#@cli : Remove hot pixels in selected images.
#@cli : Default values: 'mask_size=3' and 'threshold=10%'.
#@cli : $ image.jpg noise 10,2 +remove_hotpixels ,
remove_hotpixels : check ${1=3}>0 skip ${2=10%}
  e[^-1] "Remove hot pixels in image$?, with mask size $1 and threshold $2."
  v - repeat $! l[$>]
    +median $1 +- abs. >=. $2
    *.. . ==. 0 *[-3,-1] +
  endl done v +

#@cli remove_pixels : number_of_pixels[%]>=0
#@cli : Remove specified number of pixels (i.e. set them to 0) from the set of non-zero pixels in selected images.
#@cli : $ image.jpg +remove_pixels 50%
remove_pixels : check "$1>=0"
  e[^-1] "Remove $1 of the non-zero pixels in image$?."
  v - repeat $! l[$>]
    +norm !=. 0
    N={is}                                      # Number of non-zero pixels.
    n={round(if(${"is_percent $1"},$N*$1,$1))} # Number of pixels to remove.
    if {$n<=0} rm.         # No pixels to remove.
    elif {$n>=$N} rm. f 0 # All pixels to remove.
    elif {$n>int($N/2)}     # More pixels to remove than to keep.
      remove_pixels. {$N-$n} ==. 0 *
    else                       # Less pixels to remove than to keep.
      d={d} r 100%,{d*h},1,100%,-1  # Force image to be in 2D.

      # Retrieve coordinates of all non-zero pixels.
      100%,1,1,1,x 1,{-2,h},1,1,y +[-2,-1] 1 r[-2,-1] ..,.
      *[-2,-1] ... rm...
      y[-2,-1] a[-2,-1] x discard. y,0

      # Generate a 1xN vector with at least n non-zero pixels.
      do
        1,100%,1,1 rand. 0,{h} <=. {$n*1.25}
        if {is>=$n} break else rm. fi
      while 1

      # Generate a 1xn vector of coordinates to 'remove'.
      r. 2 *[-2,-1] discard. y,0
      i.. 1,100% rand.. 0,1 a[-2,-1] x sort. +,y
      rows. 0,{$n-1} -. 1 z. 1,3

      # Set those pixels to 0 using a 3D object.
      i.. ({'CImg3d'},{h},{h})
      1,100%,1,1,1 1,100%,1,1,y a[-2,-1] x
      3,100% 1,100%,1,1,1 y[-5--1] a[-5--1] y
      if {0,s<=3} j3d.. .,0,0,0,1,0,0,0,0
      else [0],[0],1,1,1 j3d. ..,0,0,0,1,0,0,0,0 *[0,-1]
      fi
      rm.

      r 100%,{h/$d},$d,100%,-1  # Resize to original dimension (eventually 3D).
    fi
  endl done v +

#@cli rolling_guidance : std_deviation_s[%]>=0,std_deviation_r[%]>=0,_precision>=0
#@cli : Apply the rolling guidance filter on selected image.
#@cli : Rolling guidance filter is a fast image abstraction filter, described in:
#@cli : "Rolling Guidance Filter", Qi Zhang Xiaoyong, Shen Li, Xu Jiaya Jia, ECCV'2014.
#@cli : Default values: 'std_deviation_s=4', 'std_deviation_r=10' and 'precision=0.5'.
#@cli : $ image.jpg +rolling_guidance , +-
rolling_guidance : check "${1=4}>=0 && ${2=10}>=0 && ${3=0.5}>=0"
  e[^-1] "Apply rolling guidance filter on image$?, with standard deviations ($1,$2) and precision $3."
  v - precision={2^-$3}
  repeat $! l[$>]
    +b $1
    repeat 100
      if {c>1} +norm. +bilateral... .,$1,$2 rm..
      else +bilateral.. .,$1,$2
      fi
      -.. . std={-2,sqrt(iv)} rm..
      if {$std<$precision} break fi
    done
    k.
  endl done v +

#@cli sharpen : amplitude>=0 : amplitude>=0,edge>=0,_alpha,_sigma : (+)
#@cli : Sharpen selected images by inverse diffusion or shock filters methods.
#@cli : 'edge' must be specified to enable shock-filter method.
#@cli : Default values: 'alpha=0' and 'sigma=0'.
#@cli : $ image.jpg sharpen 300
#@cli : $ image.jpg blur 5 sharpen 300,1

#@cli smooth : amplitude[%]>=0,_sharpness>=0,0<=_anisotropy<=1,_alpha[%],_sigma[%],_dl>0,_da>0,_precision>0,interpolation,_fast_approx={ 0 | 1 } : nb_iterations>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dt>0,0 : [tensor_field],_amplitude>=0,_dl>0,_da>0,_precision>0,_interpolation,_fast_approx={ 0 | 1 } : [tensor_field],_nb_iters>=0,_dt>0,0 : (+)
#@cli : Smooth selected images anisotropically using diffusion PDE's, with specified field of
#@cli : diffusion tensors.
#@cli : 'interpolation' can be { 0=nearest | 1=linear | 2=runge-kutta }.
#@cli : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1', 'dl=0.8', 'da=30', 'precision=2', 'interpolation=0' and 'fast_approx=1'.
#@cli : $ image.jpg repeat 3 smooth 40,0,1,1,2 done
#@cli : $ image.jpg 100%,100%,1,2 rand[-1] -100,100 repeat 2 smooth[-1] 100,0.2,1,4,4 done warp[0] [-1],1,1
#@cli : $$

#@cli split_freq : smoothness>0[%]
#@cli : Split selected images into low and high frequency parts.
#@cli : $ image.jpg split_freq 2%
split_freq :
  e[^-1] "Split image$? into low and high frequency parts, with smoothness $1."
  v - repeat $! l[$>] +b $1 -[0] [1] rv endl done v +

#@cli solve_poisson : "laplacian_command",_nb_iterations>=0,_time_step>0,_nb_scales>=0
#@cli : Solve Poisson equation so that applying 'laplacian[n]' is close to the result of 'laplacian_command[n]'.
#@cli : Solving is performed using a multi-scale gradient descent algorithm.
#@cli : If 'nb_scales=0', the number of scales is automatically determined.
#@cli : Default values: 'nb_iterations=60', 'dt=5' and 'nb_scales=0'.
#@cli : $ image.jpg command "foo : gradient x" +solve_poisson foo +foo[0] +laplacian[1]
solve_poisson : check "${2=60}>=0 && ${3=5}>0 && ${4=0}>=0"
  e[^-1] "Solve Poisson equation for image$?, for laplacian command '$1', with $2 iterations, time step $3 and "${arg\ 1+($4==0),$4,auto}" scales."
  v - repeat $! l[$>]
    [0]
    repeat {if($4,$4,int(max(log2(max(w,h))-1,1)))}
      f={2^$<}
      r[1] {0,max(1,w/$f)},{0,max(1,h/$f)},1,100%,3
      +r[0] [1],2 l. -$1 k[0] endl
      repeat $2 +laplacian.. -. .. *. {$3/max(1e-8,abs(im),abs(iM))} +[-3,-1] done
      rm.
    done
    rm[0]
  endl done v +

#@cli split_details : _nb_scales>0,_base_scale[%]>=0,_detail_scale[%]>=0
#@cli : Split selected images into 'nb_scales' detail scales.
#@cli : If 'base_scale'=='detail_scale'==0, the image decomposition is done with 'a trous' wavelets.
#@cli : Otherwise, it uses laplacian pyramids with linear standard deviations.
#@cli : Default values: 'nb_scales=4', 'base_scale=0' and 'detail_scale=0'.
#@cli : $ image.jpg split_details ,
split_details : check "isint(${1=4}) && $1>0 && ${2=0}>=0 && ${3=0}>=0"
  if {($2)==0" && "($3)==0}
    e[^-1] "Split image$? using $1 spatial scales and 'a trous' wavelets."
    v - repeat $! l[$<]
      repeat {$1-1}
        +f. "begin(interpolation = 0; boundary = 1; d = 2^"$>"; d2 = d*2);
              i(x - d2) + i(x + d2) + 4*i(x - d) + 4*i(x + d) + 6*i;"
        /. 16
        if {h>1}
          f. "begin(interpolation = 0; boundary = 1; d = 2^"$>"; d2 = d*2);
               i(x,y - d2) + i(x,y + d2) + 4*i(x,y - d) + 4*i(x,y + d) + 6*i;"
          /. 16
        fi
        if {d>1}
          f. "begin(interpolation = 0; boundary = 1; d = 2^"$>"; d2 = d*2);
               i(x,y,z - d2) + i(x,y,z + d2) + 4*i(x,y,z - d) + 4*i(x,y,z + d) + 6*i;"
          /. 16
        fi
        -.. .
      done rv
    endl done v +
  else
    e[^-1] "Split image$? using $1 spatial scales with base scale $2 and detail scale $3."
    v - repeat $! l[$<]
      ss={max(0.3,if(${is_percent\ $2},$2*max(w,h),$2))}
      se={max(0.3,if(${is_percent\ $3},$3*max(w,h),$3))}
      ds={$se-$ss}
      repeat {$1-1} +b. {$ss+$>*$ds/max(1,$1-2)} -.. . rv[-2,-1] done
    endl done v +
  fi

#@cli structuretensors : _scheme={ 0=centered | 1=forward/backward } : (+)
#@cli : Compute the structure tensor field of selected images.
#@cli : Default value: 'scheme=1'.
#@cli : $ image.jpg structuretensors abs pow 0.2
#@cli : $$

#@cli solidify : _smoothness[%]>=0,_diffusion_type={ 0=isotropic | 1=delaunay-oriented | 2=edge-oriented },_diffusion_iter>=0
#@cli : Solidify selected transparent images.
#@cli : Default values: 'smoothness=75%', 'diffusion_type=1' and 'diffusion_iter=20'.
#@cli : $ image.jpg 100%,100% circle[-1] 50%,50%,25%,1,255 append c +solidify , display_rgba
solidify : check "${1=75%}>=0 && isint(${2=1}) && $2>=0 && $2<=2 && ${3=20}>=0"
  v - s0="isotropic" s1="delaunay-oriented" s2="edge-oriented"
  v + e[^-1] "Solidify transparent image$? with smoothness $1 and $3 iterations of "${s$2}" diffusion." v -
  repeat $! l[$>] split_opacity
    if {$!>1} <=. 128 inpaint_diffusion.. [1],${1-3} rm. c 0,255 fi
  endl done v +

#@cli syntexturize : _width[%]>0,_height[%]>0
#@cli : Resynthetize 'width'x'height' versions of selected micro-textures by phase randomization.
#@cli : The texture synthesis algorithm is a straightforward implementation of the method described in :
#@cli : http://www.ipol.im/pub/art/2011/ggm_rpn/
#@cli : Default values: 'width=height=100%'.
#@cli : $ image.jpg crop 2,282,50,328 +syntexturize 320,320
syntexturize : check "${1=100%}>0 && ${2=$1}>0"
  e[^-1] "Resynthetize $1x$2 versions of texture$? by phase randomization."
  v - repeat $! l[$>]

    # Prepare input image data.
    mM={[im,iM]} repeat {s} sh. $> sum$>={is} var$>={iv} rm. done  # Retrieve some stats for post-normalization.
    nw={if(${is_percent\ $1},$1*w,$1)}
    nh={if(${is_percent\ $2},$2*h,$2)}
    repeat {s} sum$>*={$nw*$nh/(w*h)} done # Re-estimate output (0,0) frequency.

    if {$nw>w||$nh>h} # Spot extension required when rendering on bigger image.
      periodize_poisson
      100%,100% rectangle. 5,5,{w-6},{h-6},1,1 b. 2 n. 0,1
      $nw,$nh,1,{-2,s} fc. ${average_colors...}
      j. ...,{(w-{-2,w})/2},{(h-{-2,h})/2},0,0,1,..
      rm[-3,-2]
    else
      r $nw,$nh,1,100%,0,0,0.5,0.5
      periodize_poisson
    fi
    fft

    # Compute coherent random phase.
    100%,100% rand. {-pi},{pi}
    =. 0
    if {!(w%2)} =. {(u<0.5)*pi},{int(w/2)} fi
    if {!(h%2)} =. {(u<0.5)*pi},0,{int(h/2)} fi
    if {!(h%2)&&!(h%2)} =. {(u<0.5)*pi},{int(w/2)},{int(h/2)} fi

    # Add random phase to fft of input image.
    +sin. cos..
    +*[-4,-1] +*[-4,-3] +[-2,-1]
    *[-5,-3] *[-3,-2] -[-3,-2]

    # Get synthetized result and normalize it.
    repeat {s} =.. ${sum$>},0,0,0,$> =. 0,0,0,0,$> done
    ifft rm.
    repeat {s} sh. $> avg={ia} -. $avg *. {sqrt(${var$>}/if(iv,iv,1))} +. $avg rm. done
    c $mM

  endl done v +

#@cli syntexturize_matchpatch : _width[%]>0,_height[%]>0,_nb_scales>=0,_patch_size>0,_blending_size>=0,_precision>=0
#@cli : Resynthetize 'width'x'height' versions of selected micro-textures using a patch-matching algorithm.
#@cli : If 'nbscales==0', the number of scales used is estimated from the image size.
#@cli : Default values: 'width=height=100%', 'nb_scales=0', 'patch_size=7', 'blending_size=5' and 'precision=1'.
#@cli : $ image.jpg crop 25%,25%,75%,75% syntexturize_matchpatch 512,512
syntexturize_matchpatch : check "${1=100%}>0 && ${2=$1}>0 && isint(${3=0}) && $3>=0 && isint(${4=7}) && $4>0 && ${5=5}>=0 && ${6=1}>=0"
  e[^-1] "Resynthetize $1x$2 version(s) of texture$? using a patch-matching algorithm with "${"v - if $3 u \"$3 \" else u auto- fi v +"}"scales, $4x$4 patches, blending size $5 and precision $6."
  v - repeat $! l[$>]
    nb_scales={round(if($3,$3,log2(min(w,h)/16)),1,1)}
    width={if(${"is_percent $1"},round(w*$1,1,1),$1)}
    height={if(${"is_percent $2"},round(h*$2,1,1),$2)}

    repeat $nb_scales
      scale={100*(0.5^$<)}
      +r[0] $scale%,$scale%,1,3,2

      if {!$>}

        # Initialization.
        {1+round(w*$width/{0,w},1,1)},{1+round(h*$height/{0,h},1,1)},1,1

        noise. 0.2,2 ==. 1 +distance. 1 *. -1
        label_fg.. 0 watershed.. . rm.

        100%,100%,1,1,x +f. y a[-2,-1] c channels. 0,2
        +blend. ..,shapeaverage -.. . rm.
        channels. 0,1

        {-2,iM+1} rand. 0,{-4,w} +rand. 0,{-4,h} a[-2,-1] c
        map... . rm. +[-2,-1] round.
        s. c %.. {-3,w} %. {-3,h} a[-2,-1] c

      else

        # Upscale.
        rv[-2,-1] channels. 0,1
        *. 2 r. 200%,200%,1,2,1
        f. "*upc = i(x - 1,y,0,0);
             vpc = i(x - 1,y,0,1);
             ucp = i(x,y - 1,0,0);
             vcp = i(x,y - 1,0,1);
             ucc = i(x,y,0,0);
             vcc = i(x,y,0,1);
             if (ucc==upc && vcc==vpc && c==0, upc + 1,
             if (ucc==ucp && vcc==vcp && c==1, vcp + 1,i))"
      fi

      # Synthesis.
      psize={-2,min(w,h,$4)}
      repeat {1+$6*$<}
        psynth={int(max(3,$5*$scale%))}
        +warp_patch.. .,$psynth
        matchpatch. ...,$psize,$psize,1,4,4,0,0,.. rm..
      done
      rm..

    done
    warp_patch.. .,$5
    rm. r $width,$height,1,100%,0,0,0.5,0.5
  endl done v +

# _syntexturize_matchpatch : [correspondence_map],blend_size>0
_syntexturize_matchpatch : check ${is_image_arg\ $1}" && isint(${2=3}) && $2>=0"
  if {$2<=1} pass$1 warp[^-1] .,0 rm.
  else repeat $! pass$1 l[$>,-1]
    [1],[1],1,[0]
    f. "*begin(
          boundary = 1;
          const patch_size = $2;
          const p2 = int(patch_size/2);
          const p1 = patch_size - p2 - 1;
          avg = resize([0],s#0);

          # Pre-compute gaussian kernel.
          wpq = resize([0],patch_size^2);
          g = 0;
          for (q = -p1, q<=p2, ++q,
            for (p = -p1, p<=p2, ++p,
              wpq[g++] = exp(-(p^2 + q^2)/(2*(0.3*patch_size)^2));
            );
          );
        );
        g = 0;
        avg = 0;
        norm = 0;
        for (q = -p1, q<=p2, ++q,
          for (p = -p1, p<=p2, ++p,
            U = I(#1,x + p,y + q);
            w = wpq[g++];
            avg+=w*I(#0,U - [p,q]);
            norm+=w;
          );
        );
        avg/norm"
    k.
  endl done fi

#@cli tv_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@cli : Apply iterations of the total variation flow on selected images.
#@cli : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@cli : $ image.jpg +tv_flow 40
tv_flow : skip ${1=10},${2=30},${3=0}
  e[^-1] "Apply $1 iterations of the total variation flow on image$?, with time step $2."
  v - pde_flow $1,$2,curvature,$3 v +

#@cli unsharp : radius[%]>=0,_amount>=0,_threshold[%]>=0
#@cli : Apply unsharp mask on selected images.
#@cli : Default values: 'amount=2' and 'threshold=0'.
#@cli : $ image.jpg blur 3 +unsharp 1.5,15 cut 0,255
unsharp : check "${2=2}>=0" skip ${3=0}
  e[^-1] "Apply unsharp mask on image$?, with radius $1, amount $2 and threshold $3."
  v - repeat $!
    +b[$>] $1 -. [$>]
    if $3 +norm. >=. $3 *[-2,-1] fi
    *. $2 -[$>,-1]
  done v +

#@cli unsharp_octave : _nb_scales>0,_radius[%]>=0,_amount>=0,threshold[%]>=0
#@cli : Apply octave sharpening on selected images.
#@cli : Default values: 'nb_scales=4', 'radius=1', 'amount=2' and 'threshold=0'.
#@cli : $ image.jpg blur 3 +unsharp_octave 4,5,15 cut 0,255
unsharp_octave : check "${1=4}>0 && ${3=2}>=0" skip ${2=1},${4=0}
  e[^-1] "Apply octave sharpening on image$?, with $1 scales, radius $2, amount $3 and threshold $4."
  v - repeat $! l[$>] nm={0,n}
    +f 0 weight=0
    repeat $1
      +unsharp[0] {$2*2^-$<},$3,$4 *. {2^-$>}
      weight+={2^-$>}
      +[1,-1]
    done
    rm[0] / $weight
  nm $nm endl done v +

#@cli vanvliet : std_deviation>=0[%],order={ 0 | 1 | 2 | 3 },axis={ x | y | z | c },_boundary_conditions : (+)
#@cli : Apply Vanvliet recursive filter on selected images, along specified axis and with
#@cli : specified standard deviation, order and boundary conditions.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann }.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg +vanvliet 3,1,x
#@cli : $ image.jpg +vanvliet 30,0,x vanvliet[-2] 30,0,y add

#@cli voronoi
#@cli : Compute the discrete Voronoi diagram of non-zero pixels in selected images.
#@cli : $ 400,400 noise 0.2,2 eq 1 +label_fg 0 voronoi[-1] +gradient[-1] xy,1 append[-2,-1] c norm[-1] ==[-1] 0 map[-2] 2,2 mul[-2,-1] normalize[-2] 0,255 dilate_circ[-2] 4 reverse max
voronoi :
  e[^-1] "Compute the discrete Voronoi diagram of non-zero pixels in image$?."
  v - repeat $! l[$>] s c repeat $! l[$>]
    +!=. 0 distance. 1 *. -1
    watershed.. . rm.
  endl done a c endl done v +

#@cli watermark_fourier : text,_size>0
#@cli : Add a textual watermark in the frequency domain of selected images.
#@cli : Default value: 'size=33'.
#@cli : $ image.jpg +watermark_fourier "Watermarked!" +display_fft remove[-3,-1] normalize 0,255 append[-4,-2] y append[-2,-1] y
watermark_fourier : check ${2=33}>0
  e[^-1] "Add textual watermark '$1' with size $2 in the frequency domain of image$?."
  v - i[0] 0 t[0] "$1",0,0,$2,1,1 >=[0] 0.5 autocrop[0] 0
  repeat {$!-1} w2={int(w/2)} h2={int(h/2)}
    fft.
    shift[-2,-1] $w2,$h2,0,0,2
    [0],[0],1,{s}
    j[-3,-2] .,3,3,0,0,1,[0]
    mirror[0] x
    j[-3,-2] .,{{-2,w}-2-{0,w}},3,0,0,1,[0]
    mirror[0] y
    j[-3,-2] .,{{-2,w}-2-{0,w}},{{-2,h}-2-{0,h}},0,0,1,[0]
    mirror[0] x
    j[-3,-2] .,3,{{-2,h}-2-{0,h}},0,0,1,[0]
    mirror[0] y
    rm.
    shift[-2,-1] -$w2,-$h2,0,0,2
    ifft[-2,-1] rm.
  mv. 1 done
  rm[0] v +

#@cli watershed : [priority_image],_is_high_connectivity={ 0 | 1 } : (+)
#@cli : Compute the watershed transform of selected images.
#@cli : Default value: 'is_high_connectivity=1'.
#@cli : $ 400,400 noise 0.2,2 eq 1 +distance 1 mul[-1] -1 label[-2] watershed[-2] [-1] mod[-2] 256 map[-2] 0 reverse

#---------------------------------
#
#@cli :: Features Extraction
#
#---------------------------------

#@cli area : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@cli : Compute area of connected components in selected images.
#@cli : Default values: 'is_high_connectivity=0'.
#@cli : $ image.jpg luminance stencil[-1] 1 +area 0
#@cli : $$
area : check "$1>=0" skip ${2=0}
  e[^-1] "Compute area of connected components in image$?, with tolerance $1 and "${arg\ 1+!$2,high,low}" connectivity."
  v - repeat $! l[$>] s c
    repeat $! label[$>] $1,$2 nb={$>,1+iM} +histogram[$>] $nb,0,{$nb-1} map[$>] . rm. done
  a c endl done v +

#@cli area_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@cli : Compute area of connected components for non-zero values in selected images.
#@cli : Similar to 'area' except that 0-valued pixels are not considered.
#@cli : Default values: 'is_high_connectivity=0'.
#@cli : $ image.jpg luminance stencil[-1] 1 +area_fg 0
area_fg : check "$1>=0" skip ${2=0}
  e[^-1] "Compute area of foreground connected components in image$?, with tolerance $1 and "${arg\ 1+!$2,high,low}" connectivity."
  v - repeat $! l[$>] s c
    repeat $! label_fg[$>] $1,$2 nb={$>,1+iM} +histogram[$>] $nb,0,{$nb-1} =. 0 map[$>] . rm. done
  a c endl done v +

#@cli at_line : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%]
#@cli : Retrieve pixels of the selected images belonging to the specified line (x0,y0,z0)-(x1,y1,z1).
#@cli : $ image.jpg +at_line 0,0,0,100%,100%,0
at_line : check ${7=100%}>=0
  e[^-1] "Retrieve pixels of image$?, belonging to line ($1,$2,$3)-($4,$5,$6)."
  v - repeat $! l[$>]
    x0={if(${is_percent\ $1},(w-1)*$1,$1)}
    y0={if(${is_percent\ $2},(h-1)*$2,$2)}
    z0={if(${is_percent\ $3},(d-1)*$3,$3)}
    x1={if(${is_percent\ $4},(w-1)*$4,$4)}
    y1={if(${is_percent\ $5},(h-1)*$5,$5)}
    z1={if(${is_percent\ $6},(d-1)*$6,$6)}
    ($x0,$x1^$y0,$y1^$z0,$z1)
    r. {1+max(abs($x1-$x0),abs($y1-$y0),abs($z1-$z0))},1,1,3,3
    round. 1 warp[0] .,0,0,0 rm.
  endl done v +

#@cli at_quadrangle : x0[%],y0[%],x1[%],y1[%],x2[%],y2[%],x3[%],y3[%],_interpolation,_boundary_conditions : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%],x2[%],y2[%],z2[%],x3[%],y3[%],z3[%],_interpolation,_boundary_conditions
#@cli : Retrieve pixels of the selected images belonging to the specified 2D or 3D quadrangle.
#@cli : 'interpolation' can be { 0=nearest-neighbor | 1=linear | 2=cubic }.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : $ image.jpg params=5%,5%,95%,5%,60%,95%,40%,95% +at_quadrangle $params polygon.. 4,$params,0.5,255
at_quadrangle : check "$#>=8 && $#<=14 && $#!=11"
  _at_quadrangle{$#<12?2:3} $*

_at_quadrangle2 : check "${9=1}>=0 && $9<=2 && ${10=0}>=0 && $10<=3"
  repeat $! l[$>]
    x0={round(${"is_percent $1"}?(w-1)*$1:$1)}
    y0={round(${"is_percent $2"}?(h-1)*$2:$2)}
    x1={round(${"is_percent $3"}?(w-1)*$3:$3)}
    y1={round(${"is_percent $4"}?(h-1)*$4:$4)}
    x2={round(${"is_percent $5"}?(w-1)*$5:$5)}
    y2={round(${"is_percent $6"}?(h-1)*$6:$6)}
    x3={round(${"is_percent $7"}?(w-1)*$7:$7)}
    y3={round(${"is_percent $8"}?(h-1)*$8:$8)}
    ($x0,$x1;$x3,$x2^$y0,$y1;$y3,$y2)
    r. {P0=[$x0,$y0];P1=[$x1,$y1];P2=[$x2,$y2];P3=[$x3,$y3];1+round([max(norm(P1-P0),norm(P3-P2)),max(norm(P3-P0),norm(P2-P1))])},1,2,3
    warp.. .,0,$9,$10 rm.
  endl done

_at_quadrangle3 : check "${13=1}>=0 && $13<=2 && ${14=0}>=0 && $14<=3"
  repeat $! l[$>]
    x0={round(${"is_percent $1"}?(w-1)*$1:$1)}
    y0={round(${"is_percent $2"}?(h-1)*$2:$2)}
    z0={round(${"is_percent $3"}?(h-1)*$3:$3)}
    x1={round(${"is_percent $4"}?(w-1)*$4:$4)}
    y1={round(${"is_percent $5"}?(h-1)*$5:$5)}
    z1={round(${"is_percent $6"}?(h-1)*$6:$6)}
    x2={round(${"is_percent $7"}?(w-1)*$7:$7)}
    y2={round(${"is_percent $8"}?(h-1)*$8:$8)}
    z2={round(${"is_percent $9"}?(h-1)*$9:$9)}
    x3={round(${"is_percent $10"}?(w-1)*$10:$10)}
    y3={round(${"is_percent $11"}?(h-1)*$11:$11)}
    z3={round(${"is_percent $12"}?(h-1)*$12:$12)}
    ($x0,$x1;$x3,$x2^$y0,$y1;$y3,$y2^$z0,$z1;$z3,$z2)
    r. {P0=[$x0,$y0,$z0];P1=[$x1,$y1,$z1];P2=[$x2,$y2,$z2];P3=[$x3,$y3,$z2];1+round([max(norm(P1-P0),norm(P3-P2)),max(norm(P3-P0),norm(P2-P1))])},1,3,3
    warp.. .,0,$13,$14 rm.
  endl done

#@cli barycenter
#@cli : Compute the barycenter vector of pixel values.
#@cli : $ 256,256 ellipse 50%,50%,20%,20%,0,1,1 deform 20 +barycenter +ellipse[-2] {@0,1},5,5,0,10
barycenter :
  e[^-1] "Compute the barycenter vector of pixel values of image$?."
  v - norm repeat $! l[$>] nm={0,b}
    sum={is}
    if {$sum>0}
      if {d>1} +* 'z' z={is} rm. else z=0 fi
      if {h>1} +* 'y' y={is} rm. else y=0 fi
      * 'x' x={is} rm.
      ({$x/$sum};{$y/$sum};{$z/$sum})
    else ({w/2},{h/2},{d/2}) rm..
    fi
  nm "[barycenter of '"$nm"']" endl done v +

#@cli delaunay
#@cli : Generate discrete 2D Delaunay triangulation of non-zero pixels in selected images.
#@cli : Input images must be scalar.
#@cli : Each pixel of the output image is a triplet (a,b,c) meaning the pixel belongs to
#@cli : the Delaunay triangle 'ABC' where 'a','b','c' are the labels of the pixels 'A','B','C'.
#@cli : $ 400,400 rand 32,255 100%,100% noise. 0.4,2 eq. 1 mul +delaunay
#@cli : $ image.jpg b 1% 100%,100% noise. 0.8,2 eq. 1 mul +delaunay channels 0,2
delaunay :
  e[^-1] "Generate discrete 2D Delaunay triangulation of non-zero pixels in image$?."
  v - repeat $! l[$>]

    # Retrieve point coordinates.
    +slices 0 norm. !=. 0 {is+1},1,1,2 +f.. ">begin(p = 0); i?(I[#-1,++p] = [x,y]; p):0"

    # Compute voronoi diagram of point cloud.
    distance... 1 *... -1 watershed. ... rm...

    # Detect delaunay triangles.
    100%,100%,1,3
    _delaunay 1,0,0,1 _delaunay -1,0,0,-1 _delaunay -1,0,0,1 _delaunay 0,-1,1,0 rm..

    # Map initial labels.
    s. c +warp[0] [1],0,0 point. 0,0 map[-4--2] . rm. a[-3--1] c
    k.
  endl done v +

_delaunay :
  f.. "*
     const boundary = 1;
     p0 = i;
     p1 = j($1,$2);
     p2 = j($3,$4);
     if (p0!=p1 && p0!=p2 && p1!=p2,
       P0 = I[#-3,p0];
       P1 = I[#-3,p1];
       P2 = I[#-3,p2];
       polygon(#-1,3,P0,P1,P2,1,[p0,p1,p2]);
    ); i"

#@cli detect_skin : 0<=tolerance<=1,_skin_x,_skin_y,_skin_radius>=0
#@cli : Detect skin in selected color images and output an appartenance probability map.
#@cli : Detection is performed using CbCr chromaticity data of skin pixels.
#@cli : If arguments 'skin_x', 'skin_y' and 'skin_radius' are provided, skin pixels are learnt
#@cli : from the sample pixels inside the circle located at ('skin_x','skin_y') with radius 'skin_radius'.
#@cli : Default value: 'tolerance=0.5' and 'skin_x=skiny=radius=-1'.
detect_skin : check "${1=0.5}>=0 && $1<=1" skip ${2=-1},${3=-1},${4=-1}
  if {$2<0||$3<=0||$4<=0}
    e[0--3] "Detect skin in image$?, using tolerance $1."
    v -
    m0=120.9292108800069
    m1=142.5745272918084
    A=0.09749985486268997
    B=0.06388871371746063
    C=0.05250053107738495
    to_rgb srgb2rgb rgb2ycbcr channels 1,2
    repeat $! l[$>]
      whd={w},{h},{d} r {w*h*d},2,1,1,-1
      s y -[0] $m0 -[1] $m1 a y
      i[0] ($A,$B;$B,$C) +m* rm[0]
      * s y + *. {$1-1} exp.
      r $whd,1,-1
    endl done
  else
    e[0--3] "Detect skin in image$?, using tolerance $1 and target circle at ($2,$3) with radius $4."
    v -
    to_rgb srgb2rgb rgb2ycbcr channels 1,2
    repeat $! l[$>]
      100%,100% circle[1] $2,$3,$4,1,1 +f[1] 'if(i,y,-1)' f[1] 'if(i,x,-1)' discard[1,2] -1 a[1,2] c
      +warp[0] [1],0,0 rm[1]
      s[1] c
      m0={1,ia} -[1] $m0
      m1={2,ia} -[2] $m1
      M={h} a[1,2] x +transpose[1] rv[1,2] m*[1,2] /[1] $M invert[1]
      rv whd={w},{h},{d} r[1] {w*h*d},2,1,1,-1
      s[1] y -[1] $m0 -[2] $m1 a[1,2] y +m* rm[0]
      * s y + *. {$1-1} exp.
      r $whd,1,-1
    endl done
  fi
  v +

#@cli displacement : [source_image],_smoothness,_precision>=0,_nb_scales>=0,_iteration_max>=0,is_backward={ 0 | 1 },_[guide] : (+)
#@cli : Estimate displacement field between specified source and selected target images.
#@cli : If 'smoothness>=0', regularization type is set to isotropic, else to anisotropic.
#@cli : If 'nbscales==0', the number of scales used is estimated from the image size.
#@cli : Default values: 'smoothness=0.1', 'precision=5', 'nb_scales=0', 'iteration_max=10000', 'is_backward=1' and '[guide]=(unused)'.
#@cli : $ image.jpg +rotate 3,1,0,50%,50% +displacement[-1] [-2] quiver[-1] [-1],15,1,1,1,{1.5*iM}

#@cli distance : isovalue[%],_metric : isovalue[%],[metric],_method : (+)
#@cli : Compute the unsigned distance function to specified isovalue, opt. according to a custom metric.
#@cli : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean | 3=squared-euclidean }.
#@cli : 'method' can be { 0=fast-marching | 1=low-connectivity dijkstra | 2=high-connectivity dijkstra | 3=1+return path | 4=2+return path }.
#@cli : Default value: 'metric=2' and 'method=0'.
#@cli : $ image.jpg threshold 20% distance 0 pow 0.3
#@cli : $ 400,400 set 1,50%,50% +distance[0] 1,2 +distance[0] 1,1 distance[0] 1,0 mod 32 threshold 16 append c
#@cli : $$

#@cli fftpolar
#@cli : Compute fourier transform of selected images, as centered magnitude/phase images.
#@cli : $ image.jpg fftpolar ellipse 50%,50%,10,10,0,1,0 ifftpolar
fftpolar :
  e[^-1] "Compute fourier transform of image$?, as centered magnitude/phase images."
  v - repeat $! l[$<]
    fft complex2polar shift {-round(w/2)},{-round(h/2)},{-round(d/2)},0,2
  endl done v +

#@cli histogram : _nb_levels>0[%],_value0[%],_value1[%] : (+)
#@cli : Compute the histogram of selected images.
#@cli : If value range is set, the histogram is estimated only for pixels in the specified
#@cli : value range. Argument 'value1' must be specified if 'value0' is set.
#@cli : Default values: 'nb_levels=256', 'value0=0%' and 'value1=100%'.
#@cli : $ image.jpg +histogram 64 display_graph[-1] 400,300,3

#@cli histogram_nd : nb_levels>0[%],_value0[%],_value1[%]
#@cli : Compute the 1D,2D or 3D histogram of selected multi-channels images (having 1,2 or 3 channels).
#@cli : If value range is set, the histogram is estimated only for pixels in the specified
#@cli : value range.
#@cli : Default values: 'value0=0%' and 'value1=100%'.
#@cli : $ image.jpg channels 0,1 +histogram_nd 256
histogram_nd : check $1>0 skip ${2=0%},${3=100%}
  e[^-1] "Compute histogram of multi-channels image$?, using $1 levels in range [$1,$2]."
  v -
  percent_nblevels=${"is_percent $1"}
  percent_min=${"is_percent $2"}
  percent_max=${"is_percent $3"}
  repeat $! l[$>] s={s}
    r {w*h*d},{min(3,s)},1,1,-1
    vmin=$2 vmax=$3
    if {$percent_min||$percent_max}
      im={im} iM={iM}
      vmin={if($percent_min,$im+($iM-$im)*$2,$2)}
      vmax={if($percent_max,$im+($iM-$im)*$3,$3)}
    fi
    dv={$vmax-$vmin}
    nb_levels={max(1,round(if($percent_nblevels,$1*(1+$vmax-$vmin),$1)))}
    f 'if(i>=$vmin&&i<=$vmax,if(i==$vmax,$nb_levels-1,int((i-$vmin)*$nb_levels/($vmax-$vmin))),-1)'
    pointcloud 1,$nb_levels,{if($s>1,$nb_levels,1)},{if($s>2,$nb_levels,1)}
  endl done v +

#@cli histogram_cumul : _nb_levels>0,_is_normalized={ 0 | 1 },_val0[%],_val1[%]
#@cli : Compute cumulative histogram of selected images.
#@cli : Default values: 'nb_levels=256', 'is_normalized=0', 'val0=0%' and 'val1=100%'.
#@cli : $ image.jpg +histogram_cumul 256 histogram[0] 256 display_graph 400,300,3
histogram_cumul : check ${1=256}>0 skip ${2=0},${3=0%},${4=100%}
  arg 1+!$2,"normalized ",""
  e[^-1] "Compute "${}"cumulative histogram of image$?, using $1 levels."
  v - histogram $1,$3,$4 cumulate if $2 repeat $! /[$>] {$>,iM} done fi v +

#@cli histogram_pointwise : nb_levels>0[%],_value0[%],_value1[%]
#@cli : Compute the histogram of each vector-valued point of selected images.
#@cli : If value range is set, the histogram is estimated only for values in the specified
#@cli : value range.
#@cli : Default values: 'value0=0%' and 'value1=100%'.
histogram_pointwise : skip ${2=0%},${3=100%}
  e[^-1] "Compute the pointwise histogram of vector-valued points in image$?, with $1 levels."
  v - repeat $! l[$>] nm={0,n}
    nb_levels={round(if(${is_percent\ $1},(iM-im)*$1,$1))}
    value0={if(${is_percent\ $2},im+(iM-im)*$2,$2)}
    value1={if(${is_percent\ $3},im+(iM-im)*$3,$3)}
    - $value0 * {$nb_levels/max(1,abs($value1-$value0))} c 0,{$nb_levels-1} round
    w={w} h={h} d={d} r {w*h*d},{s},1,1,-1
    i.. (0,{w-1}) r.. .,.,1,1,3 round..
    r[-2,-1] 300%,100%,1,1,4 shift. 1 +[-2,-1] y.
    i.. ({'CImg3d'},{h/3},{h/3})
    (1,0;1,{h/3-1}) r. 2,{-2,h/3},1,1,3 round.
    3,100%,1,1,1 1,100%,1,1,-1 y[-5,-3,-2] a[-5--1] y
    {$w*$h*$d},$nb_levels j3d. ..,0,0,0,1,0,0,0 rm..
    r $w,$h,$d,$nb_levels,-1
  nm $nm endl done v +

#@cli hough : _width>0,_height>0,gradient_norm_voting={ 0 | 1 }
#@cli : Compute hough transform (theta,rho) of selected images.
#@cli : Default values: 'width=512', 'height=width' and 'gradient_norm_voting=1'.
#@cli : $ image.jpg +blur 1.5 hough[-1] 400,400 blur[-1] 0.5 add[-1] 1 log[-1]
hough : check "${1=512}>0 && ${2=$1}>0" skip ${3=1}
  e[^-1] "Compute $1x$2 hough transform of image$?, "${arg\ 1+!$3,with,without}" gradient norm voting."
  v - slices 50% luminance repeat $! l[$>] nm={0,n}
    rhomax={sqrt(w^2+h^2)/2}
    g (0,{w-1}) (0;{{-2,h}-1}) r[-2,-1] {-3,w},{-3,h},1,1,3 -.. {w/2} -. {h/2}
    complex2polar[-4--1] -. ... polar2complex[-2,-1] rm.
    +<. 0 *. {pi} +[-3,-1] abs. %.. {2*pi}
    *. {$2/$rhomax} *.. {0.5*$1/pi}
    y[-3--1] x {w} mv[-4] $! if {!$3} f. 1 fi
    a y pointcloud 1 r $1,$2,1,1,0
  nm $nm endl done v +

#@cli ifftpolar
#@cli : Compute inverse fourier transform of selected images, from centered magnitude/phase images.
ifftpolar :
  e[^-1] "Compute inverse fourier transform of image$?, from centered magnitude/phase images."
  v - repeat {int($!/2)} l[$>,{$>+1}]
    shift {round(w/2)},{round(h/2)},{round(d/2)},0,2 polar2complex ifft rm.
  endl done v +

#@cli isophotes : _nb_levels>0
#@cli : Render isophotes of selected images on a transparent background.
#@cli : Default value: 'nb_levels=64'
#@cli : $ image.jpg blur 2 isophotes 6 dilate_circ 5 display_rgba
isophotes : skip ${1=64}
  e[^-1] "Render isophote maps from images$?, with $1 levels."
  v - to_rgba repeat $! l[$>]
    +luminance repeat $1 +isoline3d[1] {$>*255/($1-1)} done rm[1] +3d[^0] col3d. 1
    [0],[0] j3d. ..,0,0,0,1,0,0,0 rm.. *
  endl done v +

#@cli label : _tolerance>=0,is_high_connectivity={ 0 | 1 } : (+)
#@cli : Label connected components in selected images.
#@cli : Default values: 'tolerance=0' and 'is_high_connectivity=0'.
#@cli : $ image.jpg luminance threshold 60% label normalize 0,255 map 0
#@cli : $ 400,400 set 1,50%,50% distance 1 mod 16 threshold 8 label mod 255 map 2
#@cli : $$

#@cli label_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@cli : Label connected components for non-zero values (foreground) in selected images.
#@cli : Similar to 'label' except that 0-valued pixels are not labeled.
#@cli : Default value: 'is_high_connectivity=0'.
label_fg : check "$1>=0" skip ${2=0}
  e[^-1] "Label foreground connected components on image [1], with tolerance $1 and "${arg\ 1+!$2,high,low}" connectivity."
  v - repeat $! l[$>]
    if {d>1} +z -1,-1,-1,{w-1},{h-1},{d-1} label. $1,$2 z. 1,1,1,{w-1},{h-1},{d-1}
    else +z -1,-1,{w-1},{h-1} label. $1,$2 z. 1,1,{w-1},{h-1}
    fi
    !=.. 0 * +histogram {1+iM} =. 0
    >. 0 cumulate. map.. . rm.
  endl done v +

#@cli max_patch : _patch_size>=1
#@cli : Return locations of maximal values in local patch-based neighborhood of given size for selected images.
#@cli : Default value: 'patch_size=16'.
#@cli : $ image.jpg norm +max_patch 16
max_patch : check "isint(${1=16}) && $1>=1"
  e[^-1] "Return locations of maximal values in local patch neighborhood of size $1, in image$?."
  v - repeat $! +dilate[$>] $1 ==[$>,-1] done v +

#@cli min_patch : _patch_size>=1
#@cli : Return locations of minimal values in local patch-based neighborhood of given size for selected images.
#@cli : Default value: 'patch_size=16'.
#@cli : $ image.jpg norm +min_patch 16
min_patch : check "isint(${1=16}) && $1>=1"
  e[^-1] "Return locations of minimal values in local patch neighborhood of size $1, in image$?."
  v - repeat $! +erode[$>] $1 ==[$>,-1] done v +

#@cli minimal_path : x0[%]>=0,y0[%]>=0,z0[%]>=0,x1[%]>=0,y1[%]>=0,z1[%]>=0,_is_high_connectivity={ 0 | 1 }
#@cli : Compute minimal path between two points on selected potential maps.
#@cli : Default value: 'is_high_connectivity=0'.
#@cli : $ image.jpg +gradient_norm fill[-1] 1/(1+i) minimal_path[-1] 0,0,0,100%,100%,0 pointcloud[-1] 0 *[-1] 280 to_rgb[-1] resize[-1] [-2],0 or
minimal_path : check "$1>=0 && $2>=0 && $3>=0" skip ${7=0}
  e[^-1] "Compute minimal path between points ($1,$2,$3) and ($4,$5,$6) for potential map$?, with "${arg\ 1+$7,low,high}" connectivity."
  v - repeat $! l[$>] nm={0,n}
    - {im} + {iM/100}
    100%,100% = 1,${4-6} distance. 1,[0],{if($7,4,3)} k.
    x={round(if(${is_percent\ $1},$1*(w-1),$1))}
    y={round(if(${is_percent\ $2},$2*(h-1),$2))}
    z={round(if(${is_percent\ $3},$3*(d-1),$3))}
    ($x;$y;$z)
    do
      p={0,i($x,$y,$z)}
      if {$p&1} x-=1
      elif {$p&2} x+=1
      fi
      if {$p&4} y-=1
      elif {$p&8} y+=1
      fi
      if {$p&16} z-=1
      elif {$p&32} z+=1
      fi
      ($x;$y;$z)
    while $p
    rm[0,-1] a x
  nm $nm endl done v +

#@cli mse : : (+)
#@cli : Compute MSE (Mean-Squared Error) matrix between selected images.
#@cli : $ image.jpg +noise 30 +noise[0] 35 +noise[0] 38 cut. 0,255 mse

#@cli patches : patch_width>0,patch_height>0,patch_depth>0,x0,y0,z0,_x1,_y1,_z1,...,_xN,_yN,_zN
#@cli : Extract N+1 patches from selected images, centered at specified locations.
#@cli : $ image.jpg +patches 64,64,1,153,124,0,184,240,0,217,126,0,275,38,0
patches : check "isint($1) && $1>0 && isint($2) && $2>0 && isint($3) && $3>0"
  e[^-1] "Extract $1x$2x$3 patches from image$?, at locations (${4--1})."
  v -
  (${4--1}) r. 3,{w/3},1,1,-1 permute. yzcx N={w}
  H={int(sqrt(w))} W={round(w/$H,1,1)} r. {$W*$H},1,1,3,0 r. $W,$H,1,3,-1
  r. {w*$1},{h*$2},{d*$3}
  $1,$2,$3,1,x-{int($1/2)} +f. y-{int($2/2)} +f. z-{int($3/2)} a[-3--1] c r. ..,0,2 +[-2,-1]
  repeat {$!-1} warp[$>] .,0,0,0 done rm.
  repeat $! l[$<] s y,$H s x,$W k[0-{$N-1}] endl done
  v +

#@cli matchpatch : [patch_image],patch_width>=1,_patch_height>=1,_patch_depth>=1,_nb_iterations>=0,_nb_randoms>=0,_occ_penalization,_output_score={ 0 | 1 },_[guide] : (+)
#@cli : Estimate correspondence map between selected images and specified patch image, using
#@cli : a patch-matching algorithm.
#@cli : Each pixel of the returned correspondence map gives the location (p,q) of the closest patch in
#@cli : the specified patch image. If 'output_score=1', the third channel also gives the corresponding
#@cli : matching score for each patch as well.
#@cli : Default values: 'patch_height=patch_width', 'patch_depth=1', 'nb_iterations=5', 'nb_randoms=5', 'occ_penalization=0', 'output_score=0' and 'guide=(undefined)'.
#@cli : $ image.jpg sample ? to_rgb +matchpatch[0] [1],3 +warp[-2] [-1],0

#@cli plot2value
#@cli : Retrieve values from selected 2D graph plots.
#@cli : $ 400,300,1,1,'if(y>300*abs(cos(x/10+2*u)),1,0)' +plot2value +display_graph[-1] 400,300
plot2value :
  e[^-1] "Retrieve values from 2D graph plot$?."
  v - repeat $! l[$>]
    s c >= 50%
    repeat $! l[$>] (1,{w}) r[1] [0],3 * histogram {w},1,{w} endl done
    a c
  endl done v +

#@cli pointcloud : _type = { -X=-X-opacity | 0=binary | 1=cumulative | 2=label | 3=retrieve coordinates },_width,_height>0,_depth>0
#@cli : Render a set of point coordinates, as a point cloud in a 1D/2D or 3D binary image
#@cli : (or do the reverse, i.e. retrieve coordinates of non-zero points from a rendered point cloud).
#@cli : Input point coordinates can be a NxMx1x1, Nx1x1xM or 1xNx1xM image, where 'N' is the number of points,
#@cli : and M the point coordinates.
#@cli : If 'M'>3, the 3-to-M components sets the (M-3)-dimensional color at each point.
#@cli : Parameters 'width','height' and 'depth' are related to the size of the final image :
#@cli :   - If set to 0, the size is automatically set along the specified axis.
#@cli :   - If set to N>0, the size along the specified axis is N.
#@cli :   - If set to N<0, the size along the specified axis is at most N.
#@cli : Points with coordinates that are negative or higher than specified ('width','height','depth')
#@cli : are not plotted.
#@cli : Default values: 'type=0' and 'max_width=max_height=max_depth=0'.
#@cli : $ 3000,2 rand 0,400 +pointcloud 0 dilate[-1] 3
#@cli : $ 3000,2 rand 0,400 {w} {w},3 rand[-1] 0,255 append y +pointcloud 0 dilate[-1] 3
pointcloud : check "${1=0}<=3 && ${2=0}>=0 && ${3=0}>=0 && ${4=0}>=0"
  e[^-1] "Convert image$? to point clouds, in "${arg\ 2+($1>=0)*$1-($1<0),{-$1}-opacity,binary,cumulative,labeling}" mode,"\
          "with dimensions $2x$3x$4."
  v - repeat $! l[$>] nm={0,n}
    if {$1!=3} # Render point cloud image from set of point coordinates

      # Force input data to be of size Nx1x1xM.
      if {"d>1 || (w>1 && h>1 && s>1)"} v + error "Command '$0': Invalid input image "{w}x{h}x{d}x{s}". Should be NxMx1x1, Nx1x1xM or 1xNx1xM." fi
      if {"w>1 && h>1 && s==1"} r 100%,1,1,{h},-1  # NxMx1x1 -> Nx1x1xM
      elif {"w==1 && h>1 && s>1"} r {h},1,1,{s},-1 # 1xNx1xM -> Nx1x1xM
      fi

      # Retrieve coordinates and color info.
      if {s<3} channels 0,2 fi
      if {s<4} 100%,1,1,1,1 a[-2,-1] c fi
      sh. 0   round. siz_x={!$2?iM+1:$2}
      sh.. 1  round. siz_y={!$3?iM+1:$3}
      sh... 2 round. siz_z={!$4?iM+1:$4}
      rm[-3--1]

      # Draw point cloud.
      $siz_x,$siz_y,$siz_z,{$1!=2?s-3:1}
      if {$1<0} # -X-opacity
        f.. ">V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) = (1+$1)*I(#-1,P) - $1*C; V"
      elif {$1==0} # Binary
        f.. ">V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) = C; V"
      elif {$1==1} # Cumulative
        f.. ">V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) += C; V"
      else # Label
        f.. ">begin(l = 0); V = I; P = V[0,3]; C = V[3,size(V) - 3]; I(#-1,P) = ++l; V"
      fi

    else # Retrieve set of point coordinates from rendered point cloud image
      16,1,1,{s+3}
      f.. ">
        begin(N = 0; zero = vectors(0));
        I!=zero?I[#-1,N++] = [ x,y,z,I ];
        N>=w(#-1)?resize(#-1,1.5*w(#-1),1,1,s#-1,0);
        end(resize(#-1,N,1,1,s#-1,0));
        I"
    fi
  k. nm $nm endl done v +

#@cli psnr : _max_value
#@cli : Compute PSNR (Peak Signal-to-Noise Ratio) matrix between selected images.
#@cli : Default value: 'max_value=255'.
#@cli : $ image.jpg +noise 30 +noise[0] 35 +noise[0] 38 cut[-1] 0,255 psnr 255 replace_inf 0
psnr : skip "${1=}"
  if {isval("$1")}
    e[0--3] "Compute the "$!x$!" matrix of PSNR values, from image$? with maximum value $1."
    v - mse log10 - {log10(($1)^2)}
  else
    e[0--3] "Compute the "$!x$!" matrix of PSNR values, from image$?."
    v - noarg
    if {$!}
      $! repeat {$!-1} =. {$>,iM},$> done
      mse[^-1] sqr. log10 -.. 'max(i[#-1,x],i[#-1,y])' rm.
    fi
  fi
  * -10 nm [PSNR] v +

#@cli segment_watershed : _threshold>=0
#@cli : Apply watershed segmentation on selected images.
#@cli : Default values: 'threshold=2'.
#@cli : $ image.jpg segment_watershed 2
segment_watershed : check "${1=2}>=0"
  e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
  v - repeat $! l[$>]
    min={im}
    + {1+$min} +gradient_norm
    +f. "i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && (d<=1?1:i<j(0,0,1) && i<j(0,0,-1))"
    *[-3,-1] *. -1 watershed.. . rm.
    - {1+$min}
  endl done v +

#@cli shape2bump : _resolution>=0,0<=_weight_avg_max_avg<=1,_dilation,_smoothness>=0
#@cli : Estimate bumpmap from binary shape in selected images.
#@cli : Default value: 'resolution=256', 'weight_avg_max=0.75', 'dilation=0' and 'smoothness=100'.
shape2bump : check "isint(${1=256}) && $1>=0 && ${2=0.75}>=0 && $2<=1 && isval(${3=0}) && ${4=100}>=0"
  e[^-1] "Estimate bumpmap from binary shape in image$?, using "${"v - if $1 u \"resolution $1\" else u \"full resolution\" fi v +"}", avg/max weight $2, dilation $3 and smoothness $4."
  v - repeat $!
    +l[$>]
      norm > 0
      siz={[w,h]}

      # Generate skeleton.
      distance 0 + $3
      +f. "const boundary = 1; (i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"

      # Downsize for faster computation.
      is_resized=0
      if {$1" && "max(w,h)>$1} rr2d $1,$1,0,2 gt. 0 thinning. 1 *.. {$1/max($siz)} is_resized=1 fi

      # Generate z-map.
      +f. 0 .x2
      f[1] "*if (i,
        r = i(#0,x,y);
        ir = floor(r);
        r2 = r^2;
        for (q = -ir, q<=ir, ++q,
          Y = y + q;
          for (p = -ir, p<=ir, ++p,
            X = x + p;
            dist = norm(p,q);
            if (dist<r,
              elev = sqrt(r2 - dist^2);
              i(#2,X,Y) = max(i(#2,X,Y),elev);
              if ($2<1, i(#3,X,Y) += elev; ++i(#4,X,Y));
            );
          )
        );
      ); i"

      if {$2<1} M={-3,iM} max. 1 /[-2,-1] n. 0,$M j. ..,0,0,0,0,$2
      else rm[-2,-1]
      fi
      k.
      if $is_resized *. {max([$siz]/[w,h])} r $siz,1,1,5 c 0,100% fi
    endl
    if $4 M={iM} (1^0^1) r. [0],[0] !=[0] 0 *. [0] smooth.. .,$4,0.1,0 rm. b. 0.5 n. 0,$M fi # Smooth bumpmap
    k.
  done v +

#@cli skeleton : _boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Compute skeleton of binary shapes using distance transform and constrained thinning.
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg threshold 50% +skeleton 0
skeleton : check "!isval(${1=1}) || ($1>=0 && $1<=1)"
  v -
  if {isval($1)} bc=$1 else bc=1 noarg fi
  v + e[^-1] "Compute skeleton of binary image$? with "${"arg 1+"$bc",dirichlet,neumann"}" boundary conditions." v -
  repeat $! l[$>] s c repeat $! l[$>]
                    # [0] = 2D binary shape
    1,16,1,2        # [1] = List of boundary pixels
    1,16,1,2        # [2] = List of boundary pixels (next iteration)

    # [3] = Pixels on median axis.
    +distance[0] 0
    f. "const boundary = 1; (i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"

    # Extract boundary pixels.
    f[0] ">"${-math_lib}"const boundary = "$bc"; i && (!j(-1) || !j(1) || !j(0,-1) || !j(0,1))?dar_insert(#1,[x,y]); i;"

    # Run thinning algorithm.
    eval ${-math_lib}"
      const boundary = "$bc";

      # Lookup tables for detecting the simple points.
      is_removable = [ 0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0 ];
      dotm = [ 128,64,32,16,0,8,4,2,1 ];
      is_removed = 1;

      # Start thinning iterations.
      while (is_removed,
        is_removed = 0;
        N = dar_size(#1);
        for (n = 0, n<N, ++n,
          xc = i(#1,0,n,0,0);
          yc = i(#1,0,n,0,1);
          icc = i(#0,xc,yc);
          (icc && !i(#3,xc,yc))?(
            xp = xc - 1; yp = yc - 1;
            xn = xc + 1; yn = yc + 1;
            V = crop(#0,xp,yp,3,3);
            val = dot(dotm,V>0);
            is_removable[val]?(
              i(#0,xc,yc) = 0;
              is_removed = 1;
              V[3]==1?(dar_insert(#2,[xp,yc]); i(#0,xp,yc) = 2);
              V[5]==1?(dar_insert(#2,[xn,yc]); i(#0,xn,yc) = 2);
              V[1]==1?(dar_insert(#2,[xc,yp]); i(#0,xc,yp) = 2);
              V[7]==1?(dar_insert(#2,[xc,yn]); i(#0,xc,yn) = 2);
            ):(dar_insert(#2,[xc,yc]); i(#0,xc,yc) = 2);
          )
        );
        resize(#1,1,h(#2),1,2,0);
        copy(i(#1),i(#2),2*h(#2));
        i[#2,h(#2)-1] = 0;
      );"
    k[0] > 0 thinning
  endl done a c endl done v +

skeleton_v236 : check ${1=0}>=0
  e[^-1] "Compute skeleton of binary image$?."
  v - distance 0 b $1 sharpen 1e10 >= 100%
  repeat $! +erode[$>] 2 -[$>,-1] done v +

#@cli slic : size>0,_regularity>=0,_nb_iterations>0
#@cli : Segment selected 2D images with superpixels, using the SLIC algorithm (Simple Linear Iterative Clustering).
#@cli : Scalar images of increasingly labeled pixels are returned.
#@cli : Reference paper: Achanta, R., Shaji, A., Smith, K., Lucchi, A., Fua, P., & Süsstrunk, S. (2010). Slic superpixels (No. EPFL-REPORT-149300).
#@cli : Default values: 'size=16', 'regularity=10' and 'nb_iterations=10'.
#@cli : $ image.jpg +srgb2lab slic[-1] 16 +blend shapeaverage f[-2] "j(1,0)==i && j(0,1)==i" *[-1] [-2]
slic : check "${1=16}>0 && ${2=10}>=0 && ${3=10}>0"
  e[^-1] "Segment image$? using SLIC superpixels, with size $1, regularity $2 and $3 iterations."
  v -
  S,m,nb_iter=${1-3}
  repeat $! l[$>] slices 50%

    # Initialize superpixel centers Ck.
    {[max(1,round(w/$S)),max(1,round(h/$S))]},1,2,"round(([x,y]+=0.5)*="$S")"

    # Pertub the Ck towards low gradient positions.
    if {$S>=3}
      +b[0] 0.7 g. xy,1 a[-2,-1] c norm. # Gradient norm with forward differences
      f.. "
        const n = round("$S"/3);
        const n1 = int(n/2);
        pos = argmin(crop(#-1,i0 - n1,i1 - n1,n,n,1));
        dxy = [pos%n,int(pos/n)] - n1;
        [ cut(i0 + dxy[0],0,w#0-1), cut(i1 + dxy[1],0,h#0-1) ]"
      rm.
    fi
    r. {wh},1,1,2,-1
    100%,1,1,{0,s},"I(#0,I#1)" a[-2,-1] c # Add superpixels colors
    [0],[0],1,2 f.. "I(#-1,i0,i1) = [ x + 1,1 ];I" s. c distance. 1 *. -1 watershed.. . rm. channels. 0,1

    # Start iteration loop.
    repeat $nb_iter

      # Assign best superpixel to each pixel.
      sh[2] 1 f. inf rm.
      f[1] "
        const m = "$m";
        const S = "$S";
        k = x;
        xk = i0;
        yk = i1;
        Ik = (I)[2,s#0];
        x0 = max(xk - S,0);
        x1 = min(xk + S,w#0 - 1);
        y0 = max(yk - S,0);
        y1 = min(yk + S,h#0 - 1);
        for (y = y0, y<=y1, ++y,
          for (x = x0, x<=x1, ++x,
            delta_c = norm(I(#0,x,y) - Ik);
            delta_s = norm(x - xk, y - yk);
            delta = delta_c + m/S*delta_s;
            if (delta<i(#-1,x,y,0,1),
              I(#-1,x,y) = [ k,delta ];
            );
          )
        );
      I"

      # Update superpixels.
      f[1] 0 channels[1] 0,{-2,s}
      f[2] "I[#1,i0]+=[ x,y,I#0,1 ];I"
      s[1] c,-{1,s-1} max[2] 1 /[1,2]

    done

    # Remove small and isolated regions (surrounded by pixels all having the same label).
    k[2] channels 0 label. 0,0
    +area 0,0 <. {$S^2/8}
    {0,iM+1},1,1,1,x
    f[0] ">
      const boundary = 1;
      if (i[#-1,i]>=0,
        N = [ j(-1,0),j(0,-1),j(1,0),j(0,1) ];
        for (k = 0, k<size(N), ++k,
          if (N[k]!=i,
            i[#-1,i] = i[#-1,i]==i || i[#-1,i]==N[k]?N[k]:-1
          );
        );
      );
    i"
    f. "i<0?0:1" +map[0] . rm.. or[-2,-1]

    +[0] 1 100%,100% j[0] .,0,0,0,0,1,.. rm.
    distance. 0 *. -1 watershed.. . rm.
    label. 0,0
  endl done v +

#@cli ssd_patch : [patch],_use_fourier={ 0 | 1 },_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Compute fields of SSD between selected images and specified patch.
#@cli : Argument 'boundary_conditions' is valid only when 'use_fourier=0'.
#@cli : Default value: 'use_fourier=0' and 'boundary_conditions=0'.
#@cli : $ image.jpg +crop 20%,20%,35%,35% +ssd_patch[0] [1],0,0
ssd_patch : check ${is_image_arg\ $1} skip ${2=0},${3=0}
  e[^-1] "Compute field of SSD between image$? and patch $1 using "${arg\ 1+!$2,fourier,spatial}" mode."
  v - repeat $! pass$1 0 l[$>,-1]
    r 100%,100%,100%,${-max_s} s c
    repeat {$!/2} l[$>,{-1-$<}]
      +sqr[1] val={is} rm. # Sum J(p,q)^2
      +sqr[0] +f[1] 1
      if $2
        convolve_fft.. . rm. # Sum I(x+p,y+q)^2
        mirror[1] xyz convolve_fft[0] [1] rm[1]  # Sum I(x+p,y+q).J(p,q)
      else
        correlate.. .,$3 rm. # Sum I(x+p,y+q)^2
        correlate[0] [1],$3 rm[1] # Sum I(x+p,y+q).J(p,q)
      fi
      *[0] -2 +[0,1] + $val
    endl done +
  endl done v +

#@cli thinning : _boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Compute skeleton of binary shapes using morphological thinning
#@cli : (beware, this is a quite slow iterative process)
#@cli : Default value: 'boundary_conditions=1'.
#@cli : $ image.jpg threshold 50% +thinning
thinning : check "!isval(${1=1}) || ($1>=0 && $1<=1)"
  v -
  if {isval($1)} bc=$1 else bc=1 noarg fi
  v + e[^-1] "Apply morphological thinning to binary image$? with "${"arg 1+"$bc",dirichlet,neumann"}" boundary conditions." v -
  repeat $! l[$>] s c repeat $! l[$>]
                    # [0] = 2D binary shape (current iteration)
    1,16,1,2        # [1] = List of boundary pixels (current iteration)
    1,16,1,2        # [2] = List of pixels to remove (current iteration)
    1,16,1,2        # [3] = List of boundary pixels (for next iteration)

    # Extract boundary pixels.
    f[0] ">"${-math_lib}"const boundary = "$bc"; i && (!j(-1) || !j(1) || !j(0,-1) || !j(0,1))?dar_insert(#1,[x,y]); i;"

    # Run thinning algorithm.
    eval ${-math_lib}"
      const boundary = "$bc";

      # Lookup tables for detecting the 8 3x3 hit&miss.
      hm_and = [ 231,189,231,189,122,91,94,218 ];
      hm_eq = [ 7,148,224,41,18,80,72,10 ];

      # Start thinning iterations.
      dotm = [ 128,64,32,16,0,8,4,2,1 ];
      is_removed = vector8(0);
      ind = 1;
      nind = 3;
      it = 0;
      do (
        N = dar_size(#ind);
        it8 = it%8;
        is_removed[it8] = 0;

        # Find removable contour points.
        for (n = 0, n<N, ++n,
          xc = i(#ind,0,n,0,0);
          yc = i(#ind,0,n,0,1);
          icc = i(#0,xc,yc);
          icc?(
            xp = xc - 1; yp = yc - 1;
            xn = xc + 1; yn = yc + 1;
            V = crop(#0,xp,yp,3,3);
            val = dot(dotm,V>0);
            (val & hm_and[it8])==hm_eq[it8]?(
              dar_insert(#2,[xc,yc]);
              is_removed[it8] = 1;
              V[3]==1?(dar_insert(#nind,[xp,yc]); i(#0,xp,yc) = 2);
              V[5]==1?(dar_insert(#nind,[xn,yc]); i(#0,xn,yc) = 2);
              V[1]==1?(dar_insert(#nind,[xc,yp]); i(#0,xc,yp) = 2);
              V[7]==1?(dar_insert(#nind,[xc,yn]); i(#0,xc,yn) = 2);
            ):(dar_insert(#nind,[xc,yc]); i(#0,xc,yc) = 2);
          );
        );

        # Re-assign value '1' to contour points.
        N = dar_size(#nind);
        for (n = 0, n<N, ++n, i(#0,i[#nind,n],i[#nind,n + h(#nind)]) = 1);
        _tmp = ind; ind = nind; nind = _tmp;
        i[#nind,h(#nind)-1] = 0;

        # Remove matching contour points.
        N = dar_size(#2);
        for (n = 0, n<N, ++n, i(#0,I[#2,n]) = 0);
        i[#2,h(#2)-1] = 0;
        ++it;
        _(while), max(is_removed)
      );"
    k[0]
  endl done a c endl done v +

#@cli tones : N>0
#@cli : Get N tones masks from selected images.
#@cli : $ image.jpg +tones 3
tones : check $1>0
  e[^-1] "Get $1 tones masks from image$?."
  v - norm n 0,{$1-1} round 1 repeat $! l[$<]
    repeat {$1-1} +==[0] {1+$>} done ==[0] 0
  endl done v +

#@cli topographic_map : _nb_levels>0,_smoothness
#@cli : Render selected images as topographic maps.
#@cli : Default values: 'nb_levels=16' and 'smoothness=2'.
#@cli : $ image.jpg topographic_map 10
topographic_map : check "isint(${1=16}) && $1>0" skip ${2=2}
  e[^-1] "Render topographic maps from image$?, with $1 levels and smoothness $2."
  v - repeat $! l[$>]
    +b $2 isophotes. $1 compose_channels. + ==. 0 blend shapeaverage0
  endl done v +

#@cli tsp : _precision>=0
#@cli : Try to solve the 'travelling salesman' problem, using a combination of greedy search and 2-opt algorithms.
#@cli : Selected images must have dimensions Nx1x1xC to represent N cities each with C-dimensional coordinates.
#@cli : This command re-order the selected data along the x-axis so that the point sequence becomes a shortest path.
#@cli : Default values: 'precision=256'.
#@cli : $ 256,1,1,2 rand 0,512 tsp , 512,512,1,3 repeat {0,w} circle[-1] {0,I[$>]},2,1,255,255,255 line[-1] {0,boundary=2;[I[$>],I[$>+1]]},1,255,128,0 done keep[-1]
tsp : check "${1=256}>=0"
  e[^-1] "Try to solve the 'travelling salesman' problem for pointcloud$?, with precision $1."
  v - repeat $! l[$>] n={n}
    if {h>1" || "d>1} error[0--4] "Selected image '"{n}"' has invalid dimensions ("{[w,h,d,s]}")." fi

    # Find initial estimate, using greedy nearest neighbor algorithm.
    eval "
      is_used = vectorw(0);
      next = vectorw(-1);
      n_initial = n_current = round(u(0,w-1));
      do (
        is_used[n_current] = 1;
        P_current = I[n_current];
        n_next = -1; dmin = inf;
        for (n = 0, n<w, ++n,
          if (!is_used[n],
            d = norm(I[n] - P_current);
            if (d<dmin, dmin = d; n_next = n);
          );
        );
        if (n_next<0, next[n_current] = n_initial; break());
        next[n_current] = n_next;
        n_current = n_next;
        _(while), 1
      );
      resize(#-1,w,1,1,s+1,0);
      copy(i(0,0,0,s),next,w)"
    100%,1,1,{s-1},">begin(ind = 0); val = I[#0,ind]; ind = val[s]; val" rm..

    # Improving initial estimate iteratively by 2-opt algorithm.
    eval "
      is_improved = 1;
      while (is_improved,
        is_improved = 0;
        nb_try = $1*w;
        for (try = 0, try<nb_try, ++try,
          r = round(max(8,0.5*w*(try/nb_try)^0.25));
          i = round(u(0,w-1));
          ni = (i+1)%w;
          pi = (i-1)%w;
          do (j = (i + round(u(-r,r)))%w; _(while), j==i || j==ni || j==pi);
          nj = (j+1)%w;
          P_i = I[i];
          P_ni = I[ni];
          P_j = I[j];
          P_nj = I[nj];
          dist_ini = norm(P_ni - P_i);
          dist_jnj = norm(P_nj - P_j);
          dist_ij = norm(P_j - P_i);
          dist_ninj = norm(P_nj - P_ni);
          if (dist_ij + dist_ninj<dist_ini + dist_jnj,
            mi = (min(i,j) + 1)%w;
            mj = max(i,j);
            oi = min(mi,mj);
            oj = max(mi,mj);
            delta = oj - oi + 1;
            for (c = 0, c<s, ++c, copy(i(oi,0,0,c),i(oj,0,0,c),delta,1,-1));  # Reverse path between nodes.
            is_improved = 1;
          );
        );
      )"
    nm $n
  endl done v +

#@cli variance_patch : _patch_size>=1
#@cli : Compute variance of each images patch centered at (x,y), in selected images.
#@cli : Default value: 'patch_size=16'
#@cli : $ image.jpg +variance_patch
variance_patch : check "isint(${1=16}) && $1>=1"
  e[^-1] "Compute variance of image patches in image$?, with patch size $1."
  v -
  $1,$1,1,1,1 normalize_sum.
  repeat {$!-1} l[$>,-1]
    +sqr[0] convolve[0,2] [1]
    sqr[0] rv[0,2] -[0,2] max[0] 0
  endl done rm. v +

#---------------------------------
#
#@cli :: Image Drawing
#
#---------------------------------

#@cli arrow : x0[%],y0[%],x1[%],y1[%],_thickness[%]>=0,_head_length[%]>=0,_head_thickness[%]>=0,_opacity,_pattern,_color1,...
#@cli : Draw specified arrow on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the arrow is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'thickness=1%', 'head_length=10%', 'head_thickness=3%', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ 400,400,1,3 repeat 100 arrow 50%,50%,{u(100)}%,{u(100)}%,3,20,10,0.3,${-RGB} done
arrow : check "${5=1%}>=0 && ${6=10%}>=0 && ${7=3%}" skip ${8=1}
  e[^-1] "Draw arrow in image$?, from ($1,$2) to ($3,$4), with thickness $5, head length $6, head_thickness $7 and opacity $8."
  v - repeat $! l[$>]
    polygon. 7,{"
      x0 = "${"is_percent $1"}"?(w-1)*$1:$1;
      y0 = "${"is_percent $2"}"?(h-1)*$2:$2;
      x1 = "${"is_percent $3"}"?(w-1)*$3:$3;
      y1 = "${"is_percent $4"}"?(h-1)*$4:$4;
      p0 = [x0,y0];
      dp = [x1,y1]-=p0;
      l = norm2(dp);                       # arrow length
      t = "${"is_percent $5"}"?l*$5:$5;   # thickness
      hl = "${"is_percent $6"}"?l*$6:$6;  # head length
      ht = "${"is_percent $7"}"?l*$7:$7;  # head thickness
      lmhl = l - hl;
      X = mul([0,-t,lmhl,-t,lmhl,-ht,l,0,lmhl,ht,lmhl,t,0,t],rot(-180*atan2(dp[1],dp[0])/pi),2);
      X+=[p0,p0,p0,p0,p0,p0,p0]"},${8--1}
  endl done v +

#@cli axes : x0,x1,y0,y1,_font_height>=0,_opacity,_pattern,_color1,...
#@cli : Draw xy-axes on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : To draw only one x-axis at row Y, set both 'y0' and 'y1' to Y.
#@cli : To draw only one y-axis at column X, set both 'x0' and 'x1' to X.
#@cli : Default values: 'font_height=14', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ 400,400,1,3,255 axes -1,1,1,-1
axes : check "isint(${5=14}) && $5>=0 && ${6=1}>=0" skip ${7=0},${8=0}
  if ${"is_pattern \"$7\""}
    e[0--3] "Draw xy-axes on image$?, with x-range ($1,$2), y-range ($3,$4), font height $5, opacity $6, pattern $7 and color (${8--1})."
    v - pattern=$7 color=${8--1}
  else
    e[0--3] "Draw xy-axes on image$?, with x-range ($1,$2), y-range ($3,$4), font height $5, opacity $6 and color (${7--1})."
    v - pattern=0xFFFFFFFF color=${7--1}
  fi
  if {!$5" || "!$6} v + return fi
  mx={min($1,$2)} Mx={max($1,$2)}
  my={min($3,$4)} My={max($3,$4)}

  # Start drawing axes on selected images.
  repeat $! l[$>]
    w1={0,w-1} h1={0,h-1}

    # Determine number of axes tick marks.
    if {$1!=$2} u=${"_axes[] $1,$2,{0.3*w/$5}"} offx={arg(1,$u)} deltax={arg(2,$u)} fi
    if {$3!=$4} u=${"_axes[] $3,$4,{0.3*h/$5}"} offy={arg(1,$u)} deltay={arg(2,$u)} fi

    # Draw x-axis.
    is_0x=0
    if {$3==$4} y0=$3 else y0={v=-($my)*$h1/($My-$my);if($4>=$3,v,$h1-v)} fi
    sty={if($y0>$h1-$5,-1,1)}

    if {$1!=$2" && "$y0>=0" && "$y0<=$h1}
      line 0,$y0,$w1,$y0,$6,$pattern,$color
      4,4,1,1,x<=y +mirror. y rows. 1,3 a[-2,-1] y .,.,1,[0] fc. $color
      if {$2>=$1} j[0] .,{$w1-3},{$y0-3},0,0,$6,..
      else mirror.. x j[0] .,0,{$y0-3},0,0,$6,..
      fi
      rm[-2,-1]

      i=0 do
        val={_$offx+$i*$deltax} i+=1
        if {$val>=$mx" && "$val<=$Mx}
          x={v=($val-$mx)*$w1/($Mx-$mx);if($2>=$1,v,$w1-v)}
          line $x,{$y0-1},$x,{$y0+1},$6,$pattern,$color
          if $val
            0 t. $val,0,0,$5,1,1 100%,100%,1,[0] fc. $color
            j[0] .,{max(0,min($w1-w,$x-w/2))},{if($sty>0,$y0+3,$y0-h-3)},0,0,$6,.. rm[-2,-1]
          else is_0x=1
          fi
        fi
      while {$val<$Mx}
    fi

    # Draw y-axis.
    is_0y=0
    if {$1==$2} x0=$1 else x0={v=-($mx)*$w1/($Mx-$mx);if($2>=$1,v,$w1-v)} fi
    stx={if($x0>$w1-$5,-1,1)}

    if {$3!=$4" && "$x0>=0" && "$x0<=$w1}
      line $x0,0,$x0,$h1,$6,$pattern,$color
      4,4,1,1,x>=y +mirror. x z. 1,3 a[-2,-1] x .,.,1,[0] fc. $color
      if {$4>=$3} j[0] .,{$x0-3},{$h1-3},0,0,$6,..
      else mirror.. y j[0] .,{$x0-3},0,0,0,$6,..
      fi
      rm[-2,-1]

      i=0 do
        val={_$offy+$i*$deltay} i+=1
        if {$val>=$my" && "$val<=$My}
          y={v=($val-$my)*$h1/($My-$my);if($4>=$3,v,$h1-v)}
          line {$x0-1},$y,{$x0+1},$y,$6,$pattern,$color
          if $val
            0 t. $val,0,0,$5,1,1 100%,100%,1,[0] fc. $color
            j[0] .,{if($stx>0,$x0+6,$x0-w-6)},{max(0,min($h1-h,$y-h/2))},0,0,$6,.. rm[-2,-1]
          else is_0y=1
          fi
        fi
      while {$val<$My}
    fi

    # Draw origin, if necessary.
    if {$is_0x" || "$is_0y}
      0 t. 0,0,0,$5,1,1 100%,100%,1,[0] fc. $color
      j[0] .,{if($stx>0,$x0+6,$x0-w-6)},{if($sty>0,$y0+3,$y0-h-3)},0,0,$6,.. rm[-2,-1]
    fi

  endl done
  v +

# Return optimal (offset0,scale) to display input (min,max) values.
# $1 = min value, $2 = max value, $3 = max number of tags(>=1).
_axes :
  n={max(1,round($3))}
  d={abs($2-$1)/($n-1)}
  s={10^round(log10($d))}
  m={round(min($1,$2),$s,-1)}
  M={round(max($1,$2),$s,1)}
  do N={1+round(($M-$m)/$s,1,1)} s={2*$s} while {$N>$n}
  u $m,{$s/2}

#@cli ball : _size>0, _R,_G,_B,0<=_specular_light<=8,0<=_specular_size<=8,_shadow>=0
#@cli : Input a 2D RGBA colored ball sprite.
#@cli : Default values: 'size=64', 'R=255', 'G=R', 'B=R', 'specular_light=0.8', 'specular_size=1' and 'shading=1.5'.
#@cli : $ repeat 9 ball {1.5^($>+2)},${-RGB} done append x
ball : check "${1=64}>0 && ${5=0.8}>=0 && $5<=8 && ${6=1}>=0 && $6<=8 && ${7=1.5}>=0" skip ${2=255},${3=$2},${4=$3}
  e[^-1] "Input $1x$1 ball with color (${2-4}), specular light $5, specular size $6 and shadow factor $7."
  v - l[]
  {2*$1},{2*$1} = 1,65%,30% distance 1 * -1
  +n 0,1 ^[1] $7 *[1] 1.4 +*[1] $3 +*[1] $4 *[1] $2 a[^0] c
  >=[0] {100-10*$6}% b[0] {3*$6}% n[0] 0,{$5*255} rv + c 0,255
  100%,100% circle[1] 50%,50%,34%,1,1 *[0] [1] *. 255 a c
  r $1,$1,1,4,2
  endl v +

# chromeball64x64 : Output a 64x64 GreyA chrome ball sprite.
# ${1-3} = R,G,B
chromeball64x64 :
  base642img[] "MiB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KNjQgNjQgMSAyICMzMzY0CnicxZl5VJNnvsfT0mM7ntPp9N7paefe6ZzOmWlnemfGmTpzer0dO1WRnQCBQPZ9TwhhDQkYwyKQAAlbEjZBthgRRBahFamAggp1KS7QIgKyk7DIpoCQd54XtComyPLH/f7xvn/k/Xyf3/N7n+X35EUgLOqN9z/DHcqtaW69cqEmK8z7s3csP2ZZO/7ILGzpHhwaHBzoHxgA9/vt55M8fvPaxuh37NOu9AyNjBpNY+PjE+OmkYGuOzfb73XURu1589X0zx2PXu8ZMo0Dbnh41DQxMT5mHO7vam/v7O5sUH35Cgebvyiaf+g3jRuHB/oGjeMPpqamHkyMDvb3g3iG+7tvnjm8a71e/Af+5PXOYdPo4MCwaWr24cO5ubnZ2ekHY6PDgwNDRtNQT9u3mRirqXztt5Laa10jo0N9fcaZ+UWghflHwGBudnpywjTUNzjcd/faN3kBH1vGX98VWdd6b2B4oKt3fH7JbF5+vDC/ADQPm0xPTRr779/vuNZUdUzyT0t9eON/5Webb3f8eOdqW9/Eo2XI/Gh6auYxbAMMHsIO48OD/TcvnCvNltjbvIz/I/RMXVPTlaa6xrauwbG55eU5wAObpZmJialpoJnpSZCZ63WV+rRgxzfW9n0Xr/RsZVX1mdOV9a237o3OLT+amJw3Q9DS3IRxdNQ4NmYcn4YN7l8+U5ybIDq4pgsf4fPrjhcWFhScqL54vWt0Zn5++sHcotkMLc1OjptGR4yjw6MPZqbBu+yoLyvURfjueQF/z1V98YRGo8vWV128PTTzeGlpeWkZtA5B5sVHczNTD4CmZ+Zmp8b6Oy7XFB9NDOV+8hz+1j7Jt9+kKVIyC0433DItmiHzCvtEZvPSit/j+bnpsYGbF6tL8tIiRfRn4+C1PzGKWwuVCRm5xWevDS5CVmRemp0Y6m1rqCrOT1eKBS4/peA/XZKu1mkVKVn5ZQ0/TJmt8dDSeO8PNy6fK9fnZqllIu4fnuA2u4VnO0rU8WmZheUN9x5ZxaHFwatN9bVnSgtzstKOBAkIO1b595007W25CQkpmUUwb7V981T3pXM1VWXFBUcztcpQIWfX6rj9G6nqXotGmZCUDvjO2cWFhWXL/OTdK9/WlJ8yFORkalXhIt5qAL/4l/hSz8UUhVKlKyiv7xibmRibsxzDo77vL56tKDXk52TqUuQiAetTmP/USXm1pzFZoVADvuHOkGlocGzJIr881tlaV1kC+KwMXZS/gI0Er+DNL7zUV+9d1CgUqvTC8gsdIyO9vabHljMwP3S7sbr0eN7R7KN5sf4CLu2XIHv7MXFX7rZmg/jTCysutBuNvT2j81Yy+OBea22ZIe9YblFpPOAZuxGIXQd9ws/fbTMoFIm6/NPfXu8Z6e8bsZIAEMCtxqoSvf54WbUK5pEIm332nsJTP7RXqRSJaTkl3zS13e3pG5mxnABoebKrpe5MWXllXXUc4JnEn73tZo+kpH9/u+FofGJSpr6ytvlGR49VHloytrfW19bVXy6RifgcJuXXv8E6OKIP1d9oOa1JUGtyT5yuvXyza8gqDz0e6/zuUvOVCxkhfjwOk/znv1Id7d0Z+ZcvNeiTEsEELK6qb7kzMG2Vh5ZMP95ovXIqOsCXx2aQ93zFdbZz8ZKX19bX5CSqtbmG01+f/+6u0eokBKNo4PZ3X6cG+/G5LDrZ1t3fzdbBjZqgLz97KkOdmlVUUl7deKN7fNHqNFgauX0+O9zfl8dh0chIfCjazs4ZxY07WlxWlKXRZBcYSmsab9wzPlxcsmzxeKhFHx0oFHDZTBoJxZARHA46ItG86IxCg/5Yhi47/3hpdX1L293eQdP0/Mse5ocdlUlhAQKQPTqV6MmNYSDt7J3d0dzIjAKDoSA3J6/wRGlV9dfnGi5dvdU1MDa9ZjbO99bnxAGey2bQyHiUUCVEO9k5unp4sw9r8/XHiwoLi/T6E8XFJWUV1bUXWm/c6TbNLS4/DWN5prvpZDrMc1gMKgmHZGskZHdHeyekhxctVJVTdBzIcBy20RtOlFR8Xdf43Z2eQePk9KPHy0vzk73f158u0MaGBwhA78lErAMxK5qHQdo7OiM90ARfeVoewE+A5oEMer3hZFnVuebrt37s6ukb6Ou80VRbebIgKzkmPIDPolNJeMy/XHJVEgba2cEJGHhhqP6RqcdAwydLTpVXlJWcMBiKSyrONjRdam48X1dzSl+QBy8d8VHSAB6LRiHhvP/+xVHNkQCKm5PjioEPjuYXrtTmFukNJWWnSk8CA8PJU2WlhsLcrAxtilqVmJAQHxd9ONSfx6BRyVj0xx+mZKkihBgXJydnFzcPT28snswSSaMTkjOOFR4HPSgqKsjNTE2Ii4mOlB+WyQ7LwfWQNNiPS6fRKViv99+JyNaqZCwvV8C7url7on2weBKFwRUGS+VH4hRKpTI2SiYVBwXCCgoODgkJDg4KFAk4DCabhkHtQHDS0zPigyhebq6urkg3d5SXNwZHIJKpNPAAl8fj8/krFz5fIPAV+MISCAQ8LpvN51N99iMQX4J9QxslJPt4uiNh3tMLhIDDE0kUKpVGpzOYLBaLvSIOEHxnsZhMFs8vwI/s80cE4r9CFGk6VbiAjPP2RHl4oFBeXmhvDHAgEElkMmxCg22eiQ7E5PmFSPwIaHgPJUmOJCVGifl08Dp90F5eIABvHwwWi3tqQQEmK6I9EZ3FFYllMi7uILz+/40TEBkXJfXns8GIIOJxGB9v72cGRBKRBExgARtgRaMzuQJ/SUS0mIb9aGXzxzOE4TIJWE/4YErCrxW4AAEcTyAQSLBWcAqVQgX54Pj6B4VHxcoFBORqFfQ5nswPDPL35cLpFfBXXOg0Gtzac4JRFofL9w2UhMuiFTEhVPyTQvAtNAbDEAj5bI6vn5/IPyAwQOQH+/B4XM5q5tnwKwAo+DU4TB4dHaOIk7II7k+LsD97uLmTWWwGnSMQ+geGhIaKxWCYgMESFBTgD8tPKBSKwA8SqVQep1QqYqOlXCLuw6f1h42DowMSR6WQaWy+UBQUKpWAB8ElFHYSiyVhEnCXyCIjo6JiVMlqRbRczCUTv3pWP/3C1fagiw/INoXJEwiD4KclUglMAwupTA4GvTwyVhGfqErVpSnB7GGTSd4/e64A+/jg/v0O7j44YMDhCQNDACgGAx0oRCyVRUYdiYlVqlN1uvRMTZxUxKURiPj/fqEA3PPVflsndx8Chc7h8EXB0jAgqXjFAPBH4hLUKdrMLF1aYmQwj0HCk6l/ebH+tLHbe8DBHUOiMUCeRSHhh+UR0dERMqBDkXHxquRUjS5dl5oYLRawqAQsjbMXsUav79t7wBlNoIM3xfUNORyjUCYmJ6mTU5ISkmBUk5qckhgVyqdRiBgMU2T7cgX/+sEvv3JGE+nwdBNKY1O06ZnpWm16SoIqJS01Me5IpCyYSyHgfbywfMna6nlV/2e31xlLptEoZDpfHJWoyy3ILyjIzdKoosOCgvxYVCyYFyhPilj+hSUa6BOXvUgKk4rxROMYAWFH1FpNSnJ8ZFiwL5OC9/ZCodAoT4JYEfuJFRyBeNfDwZnEpHq7ubhj6Twhn8nkMYk+aA83Dx8Sm0OlsMK12ohPreJAn5FcPMg0vJu9vbMXDuPh5unuam9r6+BJF/n5R6Tk5aei3loPRyB22vliUHgqztV23wEHuwOObo62SAyJzpfEZxflpBI/WJ+G9ZZdmIxL9EG5OhzYb4ckEJnCUHmMUp2uVXj/6tX0iv6Hmp6nUYaHHkrUKmLjlOq0rOwU6u4dG6RX9ME+ukydW1FZXl6kCafs+91mWKCdu7Hqijvj8JY9dadajf3w1cgzvUutWVhbdnQl/XOD9J9y5iwXTp2itzdAF1s+PKxoTPoKh7eTXwr8RZlo6+H7e9anYTX82hptE7FO6M80ibKM7yzfCA1kllvC32veIA5U+PL5/722jeMWDHY2bgaHoGNr+JLN4RAU/gIeulkcMiOfwz9/xaixJNOzcfDmzc3jEHTmJ/7QVnAI8n6CfzC7Nb7vyZ9pmVvDIUi4OnK2kLwnAaysiJFbxSEInsw2A1vnLwF+39ZxCALLcvp2eAkCsY3wIagJ8fvt4NDCTuy2eGifent8YMX2eN2mlq2XdXZwe/w2m4d6/r/5DW1Z6/DbDKClZXt8RfH2eHXE9nim2/b43e9tC596HbGlveepKhGIbSWACgq2beAL74IF+PrW+TJ4/2BtnbeH+R19W8VbVvfPgK3yzk/Kh+6t4c1P6wfUlvCF3T8VIKVb4ROe1U+/7N88fu3549CXm64hJv+AeF6CTeILTmsK0NhN4WYmYq02Y2DmvIQjEHLrH37WBk+1gCMQRCtfHdZq0s4ijkD8tXMj+P2PrODg+JXx6u3kzLpH8C+urU93e69HA9ng2q3TfbwNfIFGOFda7sUF0kZP8L8S1K05Ay80hP52g/CqdnzOTa1o6QFqqdb57dlp7bl/A5UFagkxIDQ1IDEgMSAjNTIKeJxz941i0M/Iz03VTykpTs4ozS3Qd0ktzi7JL9BPzigCiscXF2SkFqXqFeSlMwAAcSYQbQ=="
  s. c +apply_gamma.. 0.05 b. 3 n. 0,150 n... 0,1 i[-4] 100%,100%,1,3 fc[-4] ${1-3} *[-4,-3] +[-3,-1] c.. 0,255 a[-2,-1] c

#@cli chessboard : size1>0,_size2>0,_offset1,_offset2,_angle,_opacity,_color1,...,_color2,...
#@cli : Draw chessboard on selected images.
#@cli : Default values: 'size2=size1', 'offset1=offset2=0', 'angle=0', 'opacity=1', 'color1=0' and 'color2=255'.
#@cli : $ image.jpg chessboard 32,32,0,0,25,0.3,255,128,0,0,128,255
chessboard : check "$1>0 && ${2=$1}>0" skip ${3=0},${4=0},${5=0},${6=1},${7=0},${8=255}
  e[^-1] "Draw chessboard on image$?, with sizes ($1,$2), offsets ($3,$4), angle $5 deg., opacity $6 and colors (${7--1})."
  v - i[0] (${7--1}) r[0] {{0,w}/2},1,1,2,-1 permute[0] cyzx
  repeat {$!-1}
    w={w} h={h} theta={$5*pi/180}
    ($3,{$3+$w-1};$3,{$3+$w-1}^$4,$4;{$4+$h-1},{$4+$h-1}) r. $w,$h,1,2,3
    r. {$w*$h},2,1,1,-1
    i.. ({cos($theta)},{-sin($theta)};{sin($theta)},{cos($theta)}) m*[-2,-1]
    r. $w,$h,1,2,-1
    %. {$1+$2} >=. $1 s. c xor[-2,-1] map. [0] r. 100%,100%,1,..
    j.. .,0,0,0,0,$6 rm.
  mv. 1 done rm[0] v +

#@cli cie1931
#@cli : Draw CIE-1931 chromaticity diagram on selected images.
#@cli : $ 500,400,1,3 cie1931
cie1931 :
  e[^-1] "Draw CIE-1931 chromaticity diagram on image$?."
  v -

  # Generate convex hull of visible colors, as a 3D object.
  (67.5;73.5;109.5;103.5;51.5;100.5;37;36)  # Header
  (280,420,0;171,829,0;158,820,0;153,816,0;147,811,0;140,804,0;132,794,0;121,776,0;106,747,0;88,701,0;\  # Vertices.
  65,633,0;42,539,0;20,421,0;5,295,0;0,179,0;4,115,0;10,83,0;16,61,0;25,38,0;35,21,0;47,10,0;58,3,0;\
  71,0,0;92,1,0;111,7,0;151,28,0;189,52,0;226,79,0;262,109,0;298,141,0;334,175,0;370,209,0;405,244,0;\
  441,279,0;475,313,0;509,347,0;731,568,0)
  xM=731 yM=829
  2,{h-1},1,1,3,0 1,{h},1,1,'y' ++. 1 %. {h} +[-2,-1] 1 a[-3--1] x  # Primitives.
  3,{h},1,1,160 1,{h},1,1,1  # Colors + opacities.
  y[-4--2] a[-5--1] y mv. 0

  # Generate RGB triangle of displayable colors.
  xR=636 yR=504 xG=297 yG=234 xB=147 yB=774
  512,512,1,3 triangle_shade. 0,0,{w-1},0,0,{h-1},""255,0,0,""0,255,0,""0,0,255 rgb2srgb.
  +compose_channels. max +. 1e-8 /[-2,-1] *. 255
  i.. (67.5;73.5;109.5;103.5;51.5;100.5;3;1;$xR;$yR;-0.01;$xG;$yG;-0.01;$xB;$yB;-0.01;9;0;1;2;0;0;511;0;0;511;-128;512;512;3)
  y. (1) a[-3--1] y mv. 1

  # Draw chroma diagram.
  repeat {$!-2}
    to_rgb. fc. 255,255,255 grid. 10%,10%,0,0,0.3,0xCCCCCCCC,1,0
    100%,100%,1,3
    +*3d[0,1] {(w-8)/$xM},{(h-32)/$yM}
    j3d... .,2,30,0,1,2
    +!=... 0 distance. 1 *. -1 watershed[-4] . rm. /... 1.5
    j3d... .,2,30,0,1,2
    p3d. 1 p3d. 2 col3d. 128 j3d... .,2,30,0,1,1 rm.
    {-2,w},{-2,h} j3d. ..,2,30,0,1,2 rm..
    +erode. 4 -. .. ==. 0 *[-3,-1]
    a[-2,-1] c blend[-2,-1] alpha
    100%,100%,1,1,255 axes. 0,0.75,0.85,0,14,1 +erode. 3 negate. to_rgb..
    j... ..,0,0,0,0,1,.,400 rm[-2,-1]
  mv. 2 done rm[0,1] v +

#@cli circle : x[%],y[%],R[%],_opacity,_pattern,_color1,...
#@cli : Draw specified colored circle on selected images.
#@cli : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the circle is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 300 circle {u(100)}%,{u(100)}%,{u(30)},0.3,${-RGB} done circle 50%,50%,100,0.7,255
circle : skip ${4=1},${5=0},${6=0}
  if ${"is_pattern \"$5\""}
    e[0--3] "Draw outlined circle at ($1,$2) with radius $3 on image$?, with opacity $4, pattern $5 and color (${6--1})."
  else
    e[0--3] "Draw filled circle at ($1,$2) with radius $3 on image$?, with opacity $4 and color (${5--1})."
  fi
  v - ellipse $1,$2,$3,$3,0,${4--1} v +

#@cli close_binary : 0<=_endpoint_rate<=100,_endpoint_connectivity>=0,_spline_distmax>=0,_segment_distmax>=0,0<=_spline_anglemax<=180,_spline_roundness>=0,_area_min>=0,_allow_self_intersection={ 0 | 1 }
#@cli : Automatically close open shapes in binary images (defining white strokes on black background).
#@cli : Default values: 'endpoint_rate=75', 'endpoint_connectivity=2', 'spline_distmax=80', 'segment_distmax=20', 'spline_anglemax=90', 'spline_roundness=1','area_min=100', 'allow_self_intersection=1'.
close_binary :
  check "${1=75}>=0 && $1<=100 && ${2=2}>=0 && ${3=80}>=0 && ${4=20}>=0 && ${5=90}>=0 && $5<=180 && ${6=1}>=0 && ${7=100}>=0 && isval(${8=1})"
  e[^-1] "Close open shapes in binary image$?, with endpoint rate $1, endpoint connectivity $2, spline max distance $3, segment max distance $4, spline max angle $5, "\
          "spline roundness $6, area min $7 and self intersections "${"arg 1+!$8,allowed,\"not allowed\""}"."

  # Set algorithm parameters.
  v -
  endpoint_threshold={100-$1}       # in [0,100]
  endpoint_connectivity={round($2)}
  spline_distmax=$3                 # in px
  segment_distmax=$4                # in px
  spline_anglemax=$5                # in deg
  spline_roundness=$6
  area_min=$7                       # in px
  allow_self_intersections={!!$8}   # 0 or 1

  # Define useful functions to navigate through edgels.
  _edgel_lib="
    begin(
      pn = [ 0,1,1,1,-1,0,-1,1,0,-1,-1,-1,1,0,1,-1 ];
      pp = [ 0,-1,1,-1,1,0,1,1,0,1,-1,1,-1,0,-1,-1 ];
    );

    next(img,p) = ( # Used when shape is made of '!=0' (in 8-connexity)
      p0 = p#[0,2] + pn[4*p#[2],2];
      p1 = p#[0,2] + pn[4*p#[2] + 2,2];
      case = !!i(#img,p0[0],p0[1],0,0) + 2*!!i(#img,p1[0],p1[1],0,0);
      !case?[ p[0],p[1],(p[2]+1)%4 ]:case==1?[ p0[0],p0[1],p[2] ]:[ p1[0],p1[1],(p[2]-1)%4 ];
    );

    previous(img,p) = ( # Used when shape is made of '!=0' (in 8-connexity)
      p0 = p#[0,2] + pp[4*p#[2],2];
      p1 = p#[0,2] + pp[4*p#[2] + 2,2];
      case = !!i(#img,p0[0],p0[1],0,0) + 2*!!i(#img,p1[0],p1[1],0,0);
      !case?[ p[0],p[1],(p[2]-1)%4 ]:case==1?[ p0[0],p0[1],p[2] ]:[ p1[0],p1[1],(p[2]+1)%4 ];
    );

    next2(img,p) = ( # Used when shape is made of '{ 0 | 4 }' (in 4-connexity)
      p0 = p#[0,2] + pn[4*p#[2],2];
      p1 = p#[0,2] + pn[4*p#[2] + 2,2];
      case = !(i(#img,p0[0],p0[1],0,0)&3) + 2*!(i(#img,p1[0],p1[1],0,0)&3);
      case==1?[ p0[0],p0[1],p[2] ]:case==3?[ p1[0],p1[1],(p[2]-1)%4 ]:[ p[0],p[1],(p[2]+1)%4 ];
    );

    next3(img,p) = ( # Used when shape is made of '{ 1 | 2 }' (in 4-connexity)
      p0 = p#[0,2] + pn[4*p#[2],2];
      p1 = p#[0,2] + pn[4*p#[2] + 2,2];
      val1 = i(#img,p0[0],p0[1],0,0);
      val2 = i(#img,p1[0],p1[1],0,0);
      case = (val1==1 || val1==2) + 2*(val2==1 || val2==2);
      case==1?[ p0[0],p0[1],p[2] ]:case==3?[ p1[0],p1[1],(p[2]-1)%4 ]:[ p[0],p[1],(p[2]+1)%4 ];
    );

    vec(p) = (
      ang = i(p[0],p[1],0,p[2])*pi/180;
      [ cos(ang), sin(ang) ];
    );"

  repeat $! l[$>] nm={n}

    # Ensure input is a 2D binary image.
    slices 50% channels 0 > 0
    nm. strokes

    # Extract primary edgel normals.
    i[e_normals] 100%,100%,1,4,"
      N = crop(#"$strokes",x - 1,y - 1,0,0,3,3,1,1,1);
      N[4]?[ N[5]?-2:0, N[7]?-2:90, N[3]?-2:180, N[1]?-2:270 ]:[-2,-2,-2,-2];
    "

    # Smooth edgel normals.
    f[e_normals] $_edgel_lib"
      const boundary = 1;
      i<-1?-2:(
        ppos = npos = pos = [ x,y,c ];
        u = vec(pos);
        for (t = 1, t<=5, ++t,
          ppos = previous(#"$strokes",ppos);
          npos = next(#"$strokes",npos);
          if (ppos==npos, break());
          w = exp(-t^2/30);
          u+=w*vec(ppos);
          u+=w*vec(npos);
        );
        ang = (atan2(u[1],u[0])*180/pi)%360;
      )"

    # Estimate edgel curvatures.
    +f[e_normals] $_edgel_lib"
      const boundary = 1;
      i<-1?-2:(
        pos = [ x,y,c ];
        ppos = previous(#"$strokes",pos);
        npos = next(#"$strokes",pos);
        pu = vec(ppos);
        nu = vec(npos);
        du = (nu - pu)/2;
        cr = cross([vec(pos),0],[du,0]);
        norm(du)*sign(cr[2]);
      )"
    nm. e_curvatures

    # Smooth edgel curvatures.
    +f[e_curvatures] $_edgel_lib"
      const boundary = 1;
      i<-1?-2:(
        ppos = npos = pos = [ x,y,c ];
        val = i; sumw = 1;
        for (t = 1, t<=5, ++t,
          ppos = previous(#"$strokes",ppos);
          npos = next(#"$strokes",npos);
          if (ppos==npos, break());
          w = exp(-t^2/30);
          val+=w*i(ppos[0],ppos[1],0,ppos[2]);
          val+=w*i(npos[0],npos[1],0,npos[2]);
          sumw+=2*w;
        );
        val/sumw;
      )"
    nm. e_smooth_curvatures

    # Estimate stroke radius.
    +distance[strokes] 0
    f. "
      i<1-0.01||i>1+0.01?0:(
        p = x; q = y; d = 1;
        for (is_better = 1, is_better && d<32,
          next_p = p;
          next_q = q;
          is_better = 0;
          pp = p - 1;
          np = p + 1;
          pq = q - 1;
          nq = q + 1;
          (nd = i(pp,pq))>d?(d = nd; next_p = pp; next_q = pq; is_better = 1);
          (nd = i(p, pq))>d?(d = nd; next_p = p;  next_q = pq; is_better = 1);
          (nd = i(np,pq))>d?(d = nd; next_p = np; next_q = pq; is_better = 1);
          (nd = i(pp,q))>d?(d = nd; next_p = pp; next_q = q; is_better = 1);
          (nd = i(np,q))>d?(d = nd; next_p = np; next_q = q; is_better = 1);
          (nd = i(pp,nq))>d?(d = nd; next_p = pp; next_q = nq; is_better = 1);
          (nd = i(p, nq))>d?(d = nd; next_p = p;  next_q = nq; is_better = 1);
          (nd = i(np,nq))>d?(d = nd; next_p = np; next_q = nq; is_better = 1);
          p = next_p;
          q = next_q;
        );
        d)"
    nm. stroke_radii

    # Detect end points.
    compose_channels[e_smooth_curvatures] max nm[e_smooth_curvatures] smooth_curvatures
    +compose_channels[e_curvatures] max nm. curvatures

    f. "i(#"$smooth_curvatures")>=("$endpoint_threshold"%)/(max(1,i(#"$stroke_radii"))) || i>=max(0.25,"$endpoint_threshold"%)"
    label_fg. 0,1 nm. keypoints
    if {iM>0}
      {iM},1,1,3,-1 nm. keycoords
      f[keypoints] "> # Keep only a single point on connected regions of high curvatures.
        ret = 0;
        if (i,
          j = i - 1;
          old_max = I[#"$keycoords",j];
          kappa = i(#"$smooth_curvatures");
          if (kappa>old_max[2],
            I[#"$keycoords",j] = [ x,y,kappa ];
            i(#"$keypoints",old_max[0],old_max[1]) = 0;
            ret = 1;
          );
        ); ret"
      channels[keycoords] 0,3 # Channels 2,3 = number of connexions and normal angle for each keypoint.
    fi
    rm[smooth_curvatures,stroke_radii,keypoints]

    # Estimate point normals.
    if {!narg($keycoords)}
      rm[e_normals,e_curvatures] i[new_strokes] [strokes]
    else
      f[keycoords] "
        P = (I)[0,2];
        angles = I(#"$e_normals",P);
        U = [ 0,0 ];
        for (k = 0, k<size(angles), ++k,
          if (angles[k]>=0,
            w = max(1e-8,i(#"$e_curvatures",P[0],P[1],0,k))^2;
            ang = angles[k]*pi/180;
            U += w*[ cos(ang),sin(ang) ];
          );
        );
        [ P,0,(atan2(U[1],U[0])*180/pi)%360 ]"
      rm[e_normals,e_curvatures]

      # Detect pairs of keypoints preserving the spline constraints.
      i[keypairs] 256,1,1,3
      f[keycoords] ">
        begin(ind = 0);
        for (nx = x + 1, nx<w, ++nx,
          const cosmin = cos("$spline_anglemax"*pi/180);
          Ic = I[x];
          In = I[nx];
          S = Ic[0,2];
          T = In[0,2];
          angS = Ic[3]*pi/180;
          angT = In[3]*pi/180;
          NS = [ cos(angS),sin(angS) ];
          NT = [ cos(angT),sin(angT) ];
          ST = T - S;
          dist = norm(ST);
          cosN = dot(NS,-NT);
          angN = acos(cosN)*180/pi;
          quality = max(0,1 - dist/"$spline_distmax") * max(0,dot(NS,ST) - dot(NT,ST))/dist * max(0,cosN - cosmin);
          if (quality>0,
            if (ind>=w(#"$keypairs"), resize(#"$keypairs",2*ind,1,1,3,0));
            I[#"$keypairs",ind++] = [ quality,x,nx ];
          );
        );
        end(resize(#"$keypairs",ind,1,1,3,0));
        I"
      if {keypairs,w} sort[keypairs] -,x
      else rm[keypairs]
      fi

      # Find and connect splines.
      i[new_strokes] [strokes]
      ind_strokes={$allow_self_intersections?$strokes:$new_strokes}

      if {narg($keypairs)}
        f[keypairs] ">"$_edgel_lib"
          for_spline(code) = for (t = 0, t<=1, t+=dt,
            t3 = t*(t2 = t*t);
            P = round(mul([t3,t2,t,1],C,2));
            code#;
            dP = abs(mul([3*t2,2*t,1,0],C,2)) + 1e-8;
            dt = min(dtmin,0.75/max(dP));
          );

          Ic = I;
          indS = Ic[1];
          indT = Ic[2];
          if (i(#"$keycoords",indS,0,0,2)<"$endpoint_connectivity" && i(#"$keycoords",indT,0,0,2)<"$endpoint_connectivity",
            S = I(#"$keycoords",indS)[0,2];
            T = I(#"$keycoords",indT)[0,2];
            angS = i(#"$keycoords",indS,0,0,3)*pi/180;
            angT = i(#"$keycoords",indT,0,0,3)*pi/180;
            ST = T - S;
            dist = "$spline_roundness"*norm(ST);
            NS = [ cos(angS),sin(angS) ];
            NT = [ cos(angT),sin(angT) ];
            tmax = max(abs(ST));
            is_cond = 1;
            C = mul([ 2,-2,1,1,-3,3,-2,-1,0,0,1,0,1,0,0,0 ],[ S,T,dist*NS,-dist*NT ],2);
            dt = dtmin = 1/max(abs(T - S));
            current_val = 1;
            nb_switches = 0;
            for_spline(
              if (i(#"$ind_strokes",P,0,0)!=current_val, ++nb_switches; current_val=!current_val);
              if (nb_switches>2, is_cond = 0; break())
            );
            if (is_cond,

              # Check that the new spline did not create small closed regions.
              const area_max_threshold = "$area_min";
              const area_min_threshold = 5;
              const max_edgels = 2*(area_max_threshold + 1);

              if (area_max_threshold<=0,
                for_spline(i(#"$new_strokes",P)=1);
              , #else
                for_spline(i(#"$new_strokes",P)|=2);
                for_spline(
                  if (i(#"$new_strokes",P[0] + 1,P[1])==0,
                    edgels = area = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                    if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                  );
                  if (i(#"$new_strokes",P[0],P[1] + 1)==0,
                    edgels = area = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                    if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                  );
                  if (i(#"$new_strokes",P[0] - 1,P[1])==0,
                    edgels = area = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                    if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                  );
                  if (i(#"$new_strokes",P[0],P[1] - 1)==0,
                    edgels = area = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 4; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                    if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                  );
                0);

                # Set or unset spline, and clean temp points used for local area estimations.
                for_spline(
                  if (i(#"$new_strokes",P[0] + 1,P[1])==4,
                    edgels = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                  );
                  if (i(#"$new_strokes",P[0],P[1] + 1)==4,
                    edgels = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                  );
                  if (i(#"$new_strokes",P[0] - 1,P[1])==4,
                    edgels = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                  );
                  if (i(#"$new_strokes",P[0],P[1] - 1)==4,
                    edgels = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
                    do (i(#"$new_strokes",Q[0],Q[1]) = 0; Q = next2(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                  );
                0);
                for_spline(i(#"$new_strokes",P) = is_cond?1:(i(#"$new_strokes",P)&1));
                if (is_cond,
                  ++i(#"$keycoords",indS,0,0,2);
                  ++i(#"$keycoords",indT,0,0,2);
                );
              );
            );
          ); I"
        rm[keypairs]
      fi

      # Find and connect segments.
      ==[new_strokes] 0 # Negate values to consider boundary pixels (0) as strokes.

      f[keycoords] ">"$_edgel_lib"
        for_segment(code) = for (t = 0, t<=tmax, ++t,
          P = round(S + t*ST);
          code#;
        );

        if (i(#"$keycoords",x,0,0,2)<"$endpoint_connectivity",
          S = I(#"$keycoords",x)[0,2];
          angS = i(#"$keycoords",x,0,0,3)*pi/180;
          NS = [ cos(angS),sin(angS) ];
          ST = round(NS*"$segment_distmax");
          tmax = max(abs(ST));
          ST/=tmax;
          is_cond = 0;
          current_val = 0;
          nb_switches = 0;
          for_segment(
            if (i(#"$new_strokes",P,0,0)!=current_val, ++nb_switches; current_val=1 - current_val);
            if (nb_switches==2,is_cond = 1; break(););
          );
          tmax = t;
          if (is_cond,

            # Check that the new segment did not create small closed regions.
            const area_max_threshold = "$area_min";
            const area_min_threshold = 5;
            const max_edgels = 2*(area_max_threshold + 1);
            if (area_max_threshold<=0,
              for_segment(i(#"$new_strokes",P)=0);
            , #else
              for_segment(i(#"$new_strokes",P)|=4);
              for_segment(
                if (i(#"$new_strokes",P[0] + 1,P[1])==1,
                  edgels = area = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                  if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                );
                if (i(#"$new_strokes",P[0],P[1] + 1)==1,
                  edgels = area = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                  if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                );
                if (i(#"$new_strokes",P[0] - 1,P[1])==1,
                  edgels = area = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                  if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                );
                if (i(#"$new_strokes",P[0],P[1] - 1)==1,
                  edgels = area = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 2; area+=(Q[2]&1?0:1-Q[2])*(Q[0]+!Q[2]); Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels);
                  if (edgels<=max_edgels && area>=area_min_threshold && area<area_max_threshold, is_cond = 0; break());
                );
              0);

              # Set or unset segment, and clean temp points used for local area estimations.
              for_segment(
                if (i(#"$new_strokes",P[0] + 1,P[1])==2,
                  edgels = 0; Q0 = Q = [ P[0] + 1,P[1],2 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                );
                if (i(#"$new_strokes",P[0],P[1] + 1)==2,
                  edgels = 0; Q0 = Q = [ P[0],P[1] + 1,3 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                );
                if (i(#"$new_strokes",P[0] - 1,P[1])==2,
                  edgels = 0; Q0 = Q = [ P[0] - 1,P[1],0 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                );
                if (i(#"$new_strokes",P[0],P[1] - 1)==2,
                  edgels = 0; Q0 = Q = [ P[0],P[1] - 1,1 ];
                  do (i(#"$new_strokes",Q[0],Q[1]) = 1; Q = next3(#"$new_strokes",Q), Q!=Q0 && ++edgels<=max_edgels)
                );
              0);
              for_segment(i(#"$new_strokes",P) = is_cond?0:i(#"$new_strokes",P)&3);
              if (is_cond, ++i(#"$keycoords",x,0,0,2));
            );
          );
        ); I"
      ==[new_strokes] 0
      if {!0$_keep_keycoords} rm[keycoords] fi # Small hack used by the plug-in preview.
    fi
    rm[strokes]
    nm[new_strokes] $nm
  endl done v +

#@cli ellipse : x[%],y[%],R[%],r[%],_angle,_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified colored ellipse on selected images.
#@cli : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the ellipse is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 300 ellipse {u(100)}%,{u(100)}%,{u(30)},{u(30)},{u(180)},0.3,${-RGB} done ellipse 50%,50%,100,100,0,0.7,255

#@cli flood : x[%],_y[%],_z[%],_tolerance>=0,_is_high_connectivity={ 0 | 1 },_opacity,_color1,... : (+)
#@cli : Flood-fill selected images using specified value and tolerance.
#@cli : Default values: 'y=z=0', 'tolerance=0', 'is_high_connectivity=0', 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg repeat 1000 flood {u(100)}%,{u(100)}%,0,20,0,1,${-RGB} done

#@cli gaussian : _sigma1[%],_sigma2[%],_angle
#@cli : Draw a centered gaussian on selected images, with specified standard deviations and orientation.
#@cli : Default values: 'sigma1=3', 'sigma2=sigma1' and 'angle=0'.
#@cli : $ 400,400 gaussian 100,30,45
#@cli : $$
gaussian : skip ${1=3},${2=$1},${3=0}
  e[^-1] "Draw centered gaussian on image$? with standard deviations ($1,$2) and angle $3 deg."
  v -
  u={cos($3*pi/180)}
  v={sin($3*pi/180)}
  dmax={max(w,h)}
  if {isval($1)} l1=$1 else l1={${1}10000*$dmax/100} fi
  if {isval($2)} l2=$2 else l2={${2}10000*$dmax/100} fi
  l1={1/(2*max(1/3,$l1)^2)}
  l2={1/(2*max(1/3,$l2)^2)}
  A={$l1*$u*$u+$l2*$v*$v}
  B={($l1-$l2)*$u*$v}
  C={$l1*$v*$v+$l2*$u*$u}
  repeat $! l[$>] nm={0,n}
    w={w} h={h} ds={d},{s} rm
    $w,$h,1,1,'X=x-{($w-1)/2};Y=y-{($h-1)/2};$A*X*X+2*$B*X*Y+$C*Y*Y'
    * -1 exp r $w,$h,$ds
  nm $nm endl done v +

#@cli graph : [function_image],_plot_type,_vertex_type,_ymin,_ymax,_opacity,_pattern,_color1,... : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified function graph on selected images.
#@cli : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@cli : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : Default values: 'plot_type=1', 'vertex_type=1', 'ymin=ymax=0 (auto)', 'opacity=1', 'pattern=(undefined)'
#@cli : and 'color1=0'.
#@cli : $ image.jpg +rows 50% blur[-1] 3 split[-1] c div[0] 1.5 graph[0] [1],2,0,0,0,1,255,0,0 graph[0] [2],2,0,0,0,1,0,255,0 graph[0] [3],2,0,0,0,1,0,0,255 keep[0]

#@cli grid : size_x[%]>=0,size_y[%]>=0,_offset_x[%],_offset_y[%],_opacity,_pattern,_color1,...
#@cli : Draw xy-grid on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : Default values: 'offset_x=offset_y=0', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg grid 10%,10%,0,0,0.5,255
#@cli : $ 400,400,1,3,255 grid 10%,10%,0,0,0.3,0xCCCCCCCC,128,32,16
grid : check "$1>=0 && $2>=0" skip ${3=0},${4=0},${5=1},${6=0},${7=$6}
  if ${"is_pattern \"$6\""}
    e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, pattern $6 and color (${7--1})."
    v - pattern=$6 color=${7--1}
  else
    e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, and color (${6--1})."
    v - pattern=0xFFFFFFFF color=${6--1}
  fi
  eval "
    is_percent(str) = (unref(_is_pct); _is_pct=['#str']; _is_pct[size(_is_pct) - 1]==_'%');
    for (k = 0, k<l, ++k,

      # Horizontal lines.
      size = is_percent($1)?max(1,w#k*$1):$1;
      size>=1?(
        off = (is_percent($3)?size*$3:$3)%size;
        for (x = off, x<w#k, x+=size, polygon(#k,-2,x,0,x,h - 1,$5,"$pattern","$color"));
      );

      # Vertical lines.
      size = is_percent($2)?max(1,h#k*$2):$2;
      size>=1?(
        off = (is_percent($4)?size*$4:$4)%size;
        for (y = off, y<h#k, y+=size, polygon(#k,-2,0,y,w - 1,y,$5,"$pattern","$color"));
      )
    )"
  v +

#@cli j : eq. to 'image'. : (+)

#@cli image : [sprite],_x[%],_y[%],_z[%],_c[%],_opacity,_[opacity_mask],_max_opacity_mask : (+)
#@cli : Draw specified sprite image on selected images.
#@cli : (eq. to 'j').
#@cli : Default values: 'x=y=z=c=0', 'opacity=1', 'opacity_mask=(undefined)' and 'max_opacity_mask=1'.
#@cli : $ image.jpg +crop 40%,40%,60%,60% resize[-1] 200%,200%,1,3,5 frame[-1] 2,2,0 image[0] [-1],30%,30% keep[0]

#@cli line : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified colored line on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 500 line 50%,50%,{u(w)},{u(h)},0.5,${-RGB} done line 0,0,100%,100%,1,0xCCCCCCCC,255 line 100%,0,0,100%,1,0xCCCCCCCC,255

#@cli linethick : x0[%],y0[%],x1[%],y1[%],_thickness,_opacity,_color1
#@cli : Draw specified colored thick line on selected images.
#@cli : Default values: 'thickness=2', 'opacity=1' and 'color1=0'.
#@cli : $ 400,400,1,3 repeat 100 linethick {u([w,h,w,h,5])},0.5,${-RGB} done
linethick : check "${5=2}>=0 && isval(${6=1}) && isval(${7=0})"
  e[^-1] "Draw thick line ($1,$2) - ($3,$4) on image$?, with thickness $5, opacity $6 and color (${7--1})."
  v -
  if {!$5} line ${1-4},${6--1}
  else repeat $! l[$>]
    x0={${"is_percent $1"}?(w-1)*$1:$1}
    y0={${"is_percent $2"}?(h-1)*$2:$2}
    x1={${"is_percent $3"}?(w-1)*$3:$3}
    y1={${"is_percent $4"}?(h-1)*$4:$4}
    coords={"
      const th = "$5";
      P0 = [ "$x0","$y0" ];
      P1 = [ "$x1","$y1" ];
      dP = P1 - P0;
      n = [ -dP[1],dP[0] ]/max(1e-8,norm(dP))*th/2;
      round([ P0 - n, P0 + n, P1 + n, P1 - n ]);
    "}
    polygon 4,$coords,${6--1}
  endl done fi
  v +

#@cli mandelbrot : z0r,z0i,z1r,z1i,_iteration_max>=0,_is_julia={ 0 | 1 },_c0r,_c0i,_opacity : (+)
#@cli : Draw mandelbrot/julia fractal on selected images.
#@cli : Default values: 'iteration_max=100', 'is_julia=0', 'c0r=c0i=0' and 'opacity=1'.
#@cli : $ 400,400 mandelbrot -2.5,-2,2,2,1024 map 0 +blur 2 elevation3d[-1] -0.2

#@cli marble : _image_weight,_pattern_weight,_angle,_amplitude,_sharpness>=0,_anisotropy>=0,_alpha,_sigma,_cut_low>=0,_cut_high>=0
#@cli : Render marble like pattern on selected images.
#@cli : Default values: 'image_weight=0.2', 'pattern_weight=0.1', 'angle=45', 'amplitude=0', 'sharpness=0.4', 'anisotropy=0.8',
#@cli : 'alpha=0.6', 'sigma=1.1' and 'cut_low=cut_high=0'.
#@cli : $ image.jpg +marble ,
marble : skip ${1=0.2},${2=0.1},${3=45},${4=0},${5=0.4},${6=0.8},${7=0.6},${8=1.1},${9=0%},${10=100%}
  e[^-1] "Render marble like pattern on image$?, with image weight $1, pattern weight $2, angle $3 deg., amplitude $4, "\
          "sharpness $5, anisotropy $6, alpha $7, sigma $8, and cut ($9,$10)."
  v - sx={$2*sin($3*pi/180)} sy={$2*cos($3*pi/180)} f sin(x*$sx+y*$sy+i*$1)
  if {$4} smooth $4,$5,$6,$7,$8 fi
  c $9,$10 n 0,255
  v +

#@cli maze : _width>0,_height>0,_cell_size>0
#@cli : Input maze with specified size.
#@cli : $ maze 30,20 negate normalize 0,255
maze : check "isint(${1=15}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=24}) && $3>0"
  e[^-1] "Input $1x$2 maze."
  v -
  ({round(u($1-1))},{round(u($2-1))})  # Starting cell.
  $1,$2,1,1,15 +f. 0 a[-2,-1] c   # Starting maze data.
  _generate_maze $1,$2
  _render_maze. $3 nm. [maze]
  v +

_generate_maze :

  # Start opening walls.
  do
    x={-2,@-2} y={-2,@-1} # Coords of the current cell.
    =. 1,$x,$y,0,1       # Mark current cell as visited.

    # Check for neighboring cells that are candidate for opening wall, and select one random.
    is_candidate=0
    up=-1 if {i($x,$y)&8" && "$y>0" && "!i($x,$y-1,0,1)} up=$x,{$y-1},8 is_candidate=1 fi          # Up.
    down=-1 if {i($x,$y)&4" && "$y<$2-1" && "!i($x,$y+1,0,1)} down=$x,{$y+1},4 is_candidate=1 fi   # Down.
    left=-1 if {i($x,$y)&2" && "$x>0" && "!i($x-1,$y,0,1)} left={$x-1},$y,2 is_candidate=1 fi      # Left.
    right=-1 if {i($x,$y)&1" && "$x<$1-1" && "!i($x+1,$y,0,1)} right={$x+1},$y,1 is_candidate=1 fi # Right.
    if $is_candidate
      ($up,$down,$left,$right) discard. -1 r. 3,{h/3},1,1,-1 shift. 0,{round(u(4))},0,0,2 rows. 0,0 mv. -2
    fi

    # Remove wall between the current and chosen neighboring cells.
    if $is_candidate
      if {{-2,@-1}==8}   =. {i($x,$y)&7},$x,$y =. {i($x,$y-1)&11},$x,{$y-1}   # Remove up wall.
      elif {{-2,@-1}==4} =. {i($x,$y)&11},$x,$y =. {i($x,$y+1)&7},$x,{$y+1}   # Remove down wall.
      elif {{-2,@-1}==2} =. {i($x,$y)&13},$x,$y =. {i($x-1,$y)&14},{$x-1},$y  # Remove left wall.
      else               =. {i($x,$y)&14},$x,$y =. {i($x+1,$y)&13},{$x+1},$y  # Remove right wall.
      fi
      z.. 0,1 a[-3,-2] y  # Add neighboring cell to stack of cells to explore.
    else # No candidate : remove current cell from cells to explore.
      if {{-2,h}==1} break fi
      rows.. 0,{{-2,h}-2}
    fi
  while 1
  rm.. channels. 0

_render_maze :
  # Create the 16 configurations of walls.
  i[0] $1,$1 i[1] [0]x15
  line[8-15] 0,0,100%,0,1,1
  line[4-7,12-15] 0,100%,100%,100%,1,1
  line[2-3,6-7,10-11,14-15] 0,0,0,100%,1,1
  line[1-15:2] 100%,0,100%,100%,1,1
  # Map the wall data with them.
  a[0-15] x r. {w*$1},{h*$1} *. $1 channels. 0,1
  $1,$1,1,1,x $1,$1,1,1,y a[-2,-1] c r. ..,..,1,2,0,2 +[-2,-1]
  warp.. .,0,0,0 rm.

#@cli maze_mask : _cellsize>0
#@cli : Input maze according to size and shape of selected mask images.
#@cli : Mask may contain disconnected shapes.
#@cli : $ 0 text "G'MIC",0,0,53,1,1 dilate 3 autocrop 0 frame 1,1,0 maze_mask 8 dilate 3 negate mul 255
maze_mask : check "isint(${1=24}) && $1>0"
  e[^-1] "Input masked maze from image$? with cell size $1."
  v - compose_channels + >= 50% repeat $! l[$>]
    do
      +rand[0] 0,1 *. [0] ({[xM,yM]}) rm..  # Select one starting point in the mask.
      +flood[0] {^},0,0,0,1,2 >=. 2 +negate. *.. 15 a[-2,-1] c
      flood[0] {-2,^},0,0,0,1,0
      _generate_maze {w},{h}
    while {0,iM}
    rm[0] + _render_maze. $1 nm. [maze]
  endl done v +

#@cli j3d : eq. to 'object3d'. : (+)

#@cli object3d : [object3d],_x[%],_y[%],_z,_opacity,_rendering_mode,_is_double_sided={ 0 | 1 },_is_zbuffer={ 0 | 1 },_focale,_light_x,_light_y,_light_z,_specular_lightness,_specular_shininess : (+)
#@cli : Draw specified 3D object on selected images.
#@cli : (eq. to 'j3d').\n
#@cli : 'rendering_mode' can be { 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@cli : Default values: 'x=y=z=0', 'opacity=1' and 'is_zbuffer=1'. All other arguments take their default values from the 3D environment variables.
#@cli : $ image.jpg torus3d 100,10 cone3d 30,-120 add3d[-2,-1] rotate3d. 1,1,0,60 object3d[0] [-1],50%,50% keep[0]

#@cli pack_sprites : _nb_scales>=0,0<=_min_scale<=100,_allow_rotation={ 0=0 deg. | 1=180 deg. | 2=90 deg. | 3=any },_spacing,_precision>=0,max_iterations>=0
#@cli : Try to randomly pack as many sprites as possible onto the 'empty' areas of an image.
#@cli : Sprites can be eventually rotated and scaled during the packing process.
#@cli : First selected image is the canvas that will be filled with the sprites.
#@cli : Its last channel must be a binary mask whose zero values represent potential locations for drawing the sprites.
#@cli : All other selected images represent the sprites considered for packing.
#@cli : Their last channel must be a binary mask that represents the sprite shape (i.e. a 8-connected component).
#@cli : The order of sprite packing follows the order of specified sprites in the image list.
#@cli : Sprite packing is done on random locations and iteratively with decreasing scales.
#@cli : 'nb_scales' sets the number of decreasing scales considered for all specified sprites to be packed.
#@cli : 'min_scale' (in %) sets the minimal size considered for packing (specified as a percentage of the original sprite size).
#@cli : 'spacing' can be positive or negative.
#@cli : 'precision' tells about the desired number of failed trials before ending the filling process.
#@cli : Default values: 'nb_scales=5', 'min_scale=25', 'allow_rotation=3', 'spacing=1', 'precision=7' and 'max_iterations=256'.
#@cli : $ 512,512,1,3,"min(255,y*c/2)" 100%,100% circle 50%,50%,100,1,255 append c image.jpg resize2dy[-1] 24 to_rgba pack_sprites 3,25
pack_sprites : check "isint(${1=5}) && $1>=0 && ${2=25}>=0 && $2<=100 && isint(${3=3}) && $3>=0 && $3<=3 && isint(${4=1}) && isint(${5=7}) && $5>=0 && isint(${6=256}) && $6>=0"
  e[^-1] "Randomly pack image$? with $1 scales, minimum scale $2%, "${arg\ 1+$3,no,180\"\ \"deg.,90\"\ \"deg.,any}" rotation, spacing $4, precision $5 and $6 maximum iterations."
  v - N={$!-1} is_first_time=1
  repeat $! r[$>] 100%,100%,1,{$>,max(2,s)} done   # Ensure all images have a binary shape mask.

  # Start iterations over scales.
  repeat $1
    rprogress {$>*100/$1}
    nb_attempts=0

    # Generate all sprites for current scale.
    ratio={if($1>1,$2+(100-$2)*$</($1-1),100)}%
    repeat $N +l[{1+$>}]
      w={w*$ratio} h={h*$ratio}
      if {$w<1||$h<1} rm
      else r $w,$h,1,100%,2 sh. 100% !=. 0 area{1+$>}={is} rm.
      fi
    endl done

    # Pack rescaled sprites together.
    l[0,{$N+1}--1] repeat $6

      # Compute reference sprite.
      ind={1+($>%$N)} area=${area$ind}
      if {$3==0} [$ind]
      elif {$3==1} +rotate[$ind] {round(u)*180}
      elif {$3==2} +rotate[$ind] {round(u(3))*90}
      else +rotate[$ind] {u*360} sh. 100% !=. 0 area={is} rm.
      fi

      # Get binary map of possible locations.
      +channels[0] 100% ==. 0
      if {$4>1} erode. {2*$4-1}
      elif {$4<1} dilate. {-2*$4+3}
      fi

      # Generate random skeleton-oriented point cloud.
      +rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
      if $is_first_time noise. 0.1,2 ==. 1 fi
      distance. 0 noise. 1,1
      max_patch. {$ind,round(1.5*max(w,h))}
      *. .. pointcloud3d.

      # Subdivide point cloud if multiple sprites.
      if {$N>1} l.
        s3d /[1] $N round[1] max[1] 1 n={1,@0}
        r[2] 3,{{2,h}/3},1,1,-1
        i[2] 1,{2,h} rand[2] 0,1 a[2,3] x sort[2] +,y z[2] 1,3 r[2] 3,$n,1,1 y[2]
        r[3] 1,{2*$n},1,1,0 r[4] 1,{3*$n},1,1,0 r[5] 1,$n,1,1,0 a y
      endl fi

      # Create 3D cloud of sprites.
      n={@7}
      if $n
        s3d. rm[-2,-1]
        if {$3==0} # No rotation allowed.
          [-6] i.. (-128;{w};{h};{s})
          if {$n>1} 4,{$n-1},1,1,-128,0,0,0 fi
          +channels.. 100% i.. (-128;{w};{h};{s})
          if {$n>1} ... fi
        elif {$3==1} # 180 deg. rotation allowed.
          +rotate[-6] {round(u(1))*180} i.. (-128;{w};{h};{s})
          if {$n>1} +rotate. 180 i.. (-128;{w};{h};{s}) fi
          if {$n>2} 4,{$n-2},1,1,-128,0,0,0 1,100% rand. 0,1 round. 1 j.. .,1 rm. fi
          +channels[-4] 100% i.. (-128;{w};{h};{s})
          if {$n>1} +channels[-4] 100% i.. (-128;{w};{h};{s}) fi
          if {$n>2} [-5] fi
        else # 90 deg. rotation (or more) allowed.
          +rotate[-6] {round(u(3))*90} i.. (-128;{w};{h};{s})
          if {$n>1} +rotate. 90 i.. (-128;{w};{h};{s}) fi
          if {$n>2} +rotate. 90 i.. (-128;{w};{h};{s}) fi
          if {$n>3} +rotate. 90 i.. (-128;{w};{h};{s}) fi
          if {$n>4} 4,{$n-4},1,1,-128,0,0,0 1,100% rand. 0,3 round. 1 j.. .,1 rm. fi
          +channels[-8] 100% i.. (-128;{w};{h};{s})
          if {$n>1} +channels[-8] 100% i.. (-128;{w};{h};{s}) fi
          if {$n>2} +channels[-8] 100% i.. (-128;{w};{h};{s}) fi
          if {$n>3} +channels[-8] 100% i.. (-128;{w};{h};{s}) fi
          if {$n>4} [-9] fi
        fi
        y[{$N+3}--1] a[{$N+3}--1] y
      fi
      rm... # Delete reference sprite.

      # Draw cloud and detect non-intersecting sprites.
      [0] sh. 100% f. 1 -. [-4]
      j3d.. ...,0,0,0,1,2,0,0 rm[-3,-1]
      sh. 100% area_fg. 0,1 ==. $area
      *. ... rm... sh.. 0,{-2,s-2} *. .. rm.

      # Draw selected sprites on rendering image.
      if {iM} j[0] ..,0,0,0,0,1,. rm[-2,-1]
      else
        rm[-2,-1]
        nb_attempts+=1
        if {$nb_attempts>$5} break else continue fi
      fi

    done k[0] endl

  done k[0] v +

#@cli piechart : label_height>=0,label_R,label_G,label_B,"label1",value1,R1,G1,B1,...,"labelN",valueN,RN,GN,BN
#@cli : Draw pie chart on selected (RGB) images.
#@cli : $ image.jpg piechart 25,0,0,0,"Red",55,255,0,0,"Green",40,0,255,0,"Blue",30,128,128,255,"Other",5,128,128,128
piechart : check $1>=0
  e[^-1] "Draw pie chart on image$?, with label height $1 and color ($2,$3,$4)."
  v - $=arg repeat $! l[$>]
    ellipse 50%,50%,{w/2-1},{h/2-1},0,1,1
    ellipse 50%,50%,{w/2-1},{h/2-1},0,1,0xFFFFFFFF
    (${6--1:5}) normalize_sum.
    theta=0
    if {w>1} repeat {w}
      xe={0.5*{-2,w}*(1+cos($theta))}
      ye={0.5*{-2,h}*(1+sin($theta))}
      line.. 50%,50%,$xe,$ye
      theta-={2*pi*i($>)}
    done fi
    theta=0
    repeat {w} if {i($>)}
      ntheta={$theta-2*pi*i($>)}
      xc={0.5*{-2,w}*(1+0.5*cos(0.5*($ntheta+$theta)))}
      yc={0.5*{-2,h}*(1+0.5*sin(0.5*($ntheta+$theta)))}
      xf={0.5*{-2,w}*(1+0.8*cos(0.5*($ntheta+$theta)))}
      yf={0.5*{-2,h}*(1+0.8*sin(0.5*($ntheta+$theta)))}
      flood.. $xf,$yf,0,0,0,1,${arg{7+5*$>}},${arg{8+5*$>}},${arg{9+5*$>}}
      if {abs($ntheta-$theta)>0.1}
        0 t. ${arg{5+5*$>}},0,0,$1,1,1
        ($2^$3^$4) r. ..,..,1,3 *. ..
        j[-4] .,{$xc-w/2},{$yc-h/2},0,0,1,..
        rm[-2,-1]
      fi
      theta=$ntheta
    fi done
    rm.
  endl done v +

#@cli plasma : _alpha,_beta,_scale>=0 : (+)
#@cli : Draw a random colored plasma fractal on selected images.
#@cli : This command implements the so-called 'Diamond-Square' algorithm.
#@cli : Default values: 'alpha=1', 'beta=1' and 'scale=8'.
#@cli : $ 400,400,1,3 plasma
#@cli : $$

#@cli point : x[%],y[%],_z[%],_opacity,_color1,... : (+)
#@cli : Set specified colored pixel on selected images.
#@cli : Default values: 'z=0', 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg repeat 10000 point {u(100)}%,{u(100)}%,0,1,${-RGB} done

#@cli polka_dots : diameter>=0,_density,_offset1,_offset2,_angle,_aliasing,_shading,_opacity,_color,...
#@cli : Draw dots pattern on selected images.
#@cli : Default values: 'density=20', 'offset1=offset2=50', 'angle=0', 'aliasing=10', 'shading=1', 'opacity=1' and 'color=255'.
#@cli : $ image.jpg polka_dots 10,15,0,0,20,10,1,0.5,0,128,255
polka_dots : check $1>=0 skip ${2=20},${3=50},${4=50},${5=0},${6=10},${7=1},${8=1},${9=255}
  e[^-1] "Draw polka dots on image$?, with diameter $1, density $2, angle $3 deg., shift ($4,$5), aliasing $6 and shading $7."
  v - theta={$5*pi/180} ct={cos($theta)} st={sin($theta)} mid1={$1/2} mid2={$2/2}
  i[0] (${9--1}) y[0] c
  repeat {$!-1}
    WH={max(w,h)}
    100%,100%,100%,1,"xn = 100*x/"$WH"-$3; yn = 100*y/"$WH"-$4; \
                      xr = xn*"$ct"-yn*"$st"; yr = xn*"$st"+yn*"$ct"; \
                      xc = xr%$2-"$mid2"; yc = yr%$2-"$mid2"; \
                      "$mid1"-sqrt(xc*xc+yc*yc)"
    *. $6 c. 0,$7 n. 0,$8 (${9--1}) y. c r. ..,..,..
    j... .,0,0,0,0,1,.. rm[-2,-1]
  mv. 1 done rm[0] v +

#@cli polygon : N>=1,x1[%],y1[%],...,xN[%],yN[%],_opacity,_pattern,_color1,... : (+)
#@cli : Draw specified colored N-vertices polygon on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the polygon is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,0.3,0,255,0 polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,1,0xCCCCCCCC,255
#@cli : $ image.jpg 2,16,1,1,'u(if(x,{h},{w}))' polygon[-2] {h},{^},0.6,255,0,255 remove[-1]

#@cli quiver : [function_image],_sampling[%]>0,_factor>=0,_is_arrow={ 0 | 1 },_opacity,_color1,...
#@cli : Draw specified 2D vector/orientation field on selected images.
#@cli : Default values: 'sampling=5%', 'factor=1', 'is_arrow=1', 'opacity=1', 'pattern=(undefined)'
#@cli : and 'color1=0'.
#@cli : $ 100,100,1,2,'if(c==0,x-w/2,y-h/2)' 500,500,1,3,255 quiver[-1] [-2],10
#@cli : $ image.jpg +resize2dy 600 luminance[0] gradient[0] mul[1] -1 reverse[0,1] append[0,1] c blur[0] 8 orientation[0] quiver[1] [0],20,1,1,0.8,255
quiver : check ${"is_image_arg $1"}" && ${2=5%}>0 && ${3=1}>=0 && isbool(${4=1})" skip "${5=1},${6=0}"
  e[^-1] "Draw 2D vector field $1 on image$?, with sampling $2, factor $3, arrows "${"arg 1+$4,disabled,enabled"}", opacity $5 and color (${6--1})."
  v - pass$1 repeat {$!-1} l[$>,-1]
    eval ${-math_lib}"
      s_sampling = ['$2'];
      sampling = s_sampling[size(s_sampling) - 1 ]==_'%'?min(w#0,h#0)*$2:$2;
      vmax = max(abs(im),abs(iM));
      vmax = vmax?vmax:1;
      fact = $3*sampling/vmax;
      for (y = sampling/2, y<h#0, y+=sampling,
        for (x = sampling/2, x<w#0, x+=sampling,
          X = round(x*w/w#0); Y = round(y*h/h#0);
          u = i(X,Y,0,0)*fact; v = i(X,Y,0,1)*fact;
          if ($4,
            arrow(#0,[x,y],[x + u,y + v],45,sampling/4,$5,[${6--1}]),
            polygon(#0,2,[x - 0.5*u,y - 0.5*v],[x + 0.5*u,y + 0.5*v],$5,[${6--1}]);
          );
        );
      );
    "
  endl done rm. v +

#@cli rectangle : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,...
#@cli : Draw specified colored rectangle on selected images.
#@cli : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@cli : even if a color is specified. If a pattern is specified, the rectangle is
#@cli : drawn outlined instead of filled.
#@cli : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@cli : $ image.jpg repeat 30 rectangle {u(100)}%,{u(100)}%,{u(100)}%,{u(100)}%,0.3,${-RGB} done
rectangle : skip ${5=1},${6=0},${7=$6}
  if ${"is_pattern \"$5\""}
    e[0--3] "Draw outlined rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${7--1})."
  else
    e[0--3] "Draw filled rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${6--1})."
  fi
  v - polygon 4,$1,$2,$3,$2,$3,$4,$1,$4,${5--1} v +

#@cli rorschach : 'smoothness[%]>=0','mirroring={ 0=none | 1=x | 2=y | 3=xy }
#@cli : Render rorschach-like inkblots on selected images.
#@cli : Default values: 'smoothness=5%' and 'mirroring=1'.
#@cli : $ 400,400 rorschach 3%
rorschach : check "${1=5%}>=0 && isint(${2=1}) && $2>=0 && $2<=3"
  e[^-1] "Render rorschach-like inkblots on image$?, with smoothness $1 and "${arg\ 1+$2,no,x,y,xy}"-mirroring."
  v -
  if {$2==0} # No mirroring.
   rand -1,1 b $1 >= 0
  elif {$2==1} # X-mirroring.
    repeat $! l[$>]
      w={w}
      columns 0,{w/2-1} rand -1,1 b $1 >= 0
      +mirror x if {$w%2} columns. 1,100% fi a x
    endl done
  elif {$2==2} # Y-mirroring.
    repeat $! l[$>]
      h={h}
      rows 0,{h/2-1} rand -1,1 b $1 >= 0
      +mirror y if {$h%2} rows. 1,100% fi a y
    endl done
  elif {$2==3} # XY-mirroring.
    repeat $! l[$>]
      w={w} h={h}
      z 0,0,{w/2-1},{h/2-1} rand -1,1 b $1 >= 0
      +mirror x if {$w%2} columns. 1,100% fi a x
      +mirror y if {$h%2} rows. 1,100% fi a y
    endl done
  fi
  v +

#@cli sierpinski : recursion_level>=0
#@cli : Draw Sierpinski triangle on selected images.
#@cli : Default value: 'recursion_level=7'.
#@cli : $ image.jpg sierpinski 7
sierpinski : check ${1=7}>=0 skip ${2=50},${3=0},${4=0},${5=100},${6=100},${7=100}
  e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
  v - _sierpinski ${2-7},$1  v +

_sierpinski :
  if {$7<=0} polygon 3,$1%,$2%,$3%,$4%,$5%,$6%,1,255 return fi
  _sierpinski $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},{$7-1}
  _sierpinski {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},{$7-1}
  _sierpinski {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},{$7-1}

#@cli spiralbw
#@cli : Draw (squared) spiral on selected images.
#@cli : $ 16,16 spiralbw
spiralbw :
  e[^-1] "Draw (squared) black and white spiral on image$?."
  v - channels 0
  f "r=min(x,y,w-1-x,h-1-y); 2*r*(w+h-2*r-1) + if(min(x,h-1-y)>=min(w-1-x,y),x+y,2*(w+h-2-2*r)-x-y)"
  v +

#@cli spline : x0[%],y0[%],u0[%],v0[%],x1[%],y1[%],u1[%],v1[%],_opacity,_color1,...
#@cli : Draw specified colored spline curve on selected images (cubic hermite spline).
#@cli : Default values: 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg repeat 30 spline {u(100)}%,{u(100)}%,{u(-600,600)},{u(-600,600)},{u(100)}%,{u(100)}%,{u(-600,600)},{u(-600,600)},0.6,255 done
spline : skip ${9=1},${10=0}
  e[^-1] "Draw spline from ($1,$2) [$3,$4] to ($5,$6) [$7,$8] on image$?, with opacity $9 and color (${10--1})."
  v -
  repeat $! l[$>]
    x0={if(${"is_percent $1"},$1*(w-1),$1)}
    y0={if(${"is_percent $2"},$2*(h-1),$2)}
    u0={if(${"is_percent $3"},$3*(w-1),$3)}
    v0={if(${"is_percent $4"},$4*(h-1),$4)}
    x1={if(${"is_percent $5"},$5*(w-1),$5)}
    y1={if(${"is_percent $6"},$6*(h-1),$6)}
    u1={if(${"is_percent $7"},$7*(w-1),$7)}
    v1={if(${"is_percent $8"},$8*(h-1),$8)}
    eval ${-math_lib}"spline(#0,["$x0","$y0"],["$u0","$v0"],["$x1","$y1"],["$u1","$v1"],$9,[${10--1}])"
  endl done v +

#@cli tetraedron_shade : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,...,R3,G3,B3,...
#@cli : Draw tetraedron with interpolated colors on selected (volumetric) images.
tetraedron_shade :
  e[^-1] "Draw tetraderon ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12) with interpolated colors in image$?."
  v -

  # Find bounding box.
  xm={round(min($1,$4,$7,$10),1,-1)} xM={round(max($1,$4,$7,$10),1,1)}
  ym={round(min($2,$5,$8,$11),1,-1)} yM={round(max($2,$5,$8,$11),1,1)}
  zm={round(min($3,$6,$9,$12),1,-1)} zM={round(max($3,$6,$9,$12),1,1)}

  # Find color mapping coefficients for each vertex.
  l[] (${1-3},1;${4-6},1;${7-9},1;${10-12},1) (${13--1}) r. {w/4},4,1,1,-1 s. x solve[^0] [0] rm[0] a c endl

  # Draw tetraedron on selected images.
  f[^-1] "*
  begin(
    x0 = $1; y0 = $2; z0 = $3;
    x1 = $4; y1 = $5; z1 = $6;
    x2 = $7; y2 = $8; z2 = $9;
    x3 = $10; y3 = $11; z3 = $12;
    u01 = x1 - x0; v01 = y1 - y0; w01 = z1 - z0;
    u02 = x2 - x0; v02 = y2 - y0; w02 = z2 - z0;
    u03 = x3 - x0; v03 = y3 - y0; w03 = z3 - z0;
    u12 = x2 - x1; v12 = y2 - y1; w12 = z2 - z1;
    u13 = x3 - x1; v13 = y3 - y1; w13 = z3 - z1;
    u23 = x3 - x2; v23 = y3 - y2; w23 = z3 - z2;
    nx012 = v01*w02 - w01*v02; ny012 = w01*u02 - u01*w02; nz012 = u01*v02 - v01*u02;
    if (nx012*u03 + ny012*v03 + nz012*w03<0, nx012*=-1; ny012*=-1; nz012*=-1);
    nx013 = v01*w03 - w01*v03; ny013 = w01*u03 - u01*w03; nz013 = u01*v03 - v01*u03;
    if (nx013*u02 + ny013*v02 + nz013*w02<0, nx013*=-1; ny013*=-1; nz013*=-1);
    nx023 = v02*w03 - w02*v03; ny023 = w02*u03 - u02*w03; nz023 = u02*v03 - v02*u03;
    if (nx023*u01 + ny023*v01 + nz023*w01<0, nx023*=-1; ny023*=-1; nz023*=-1);
    nx123 = v12*w13 - w12*v13; ny123 = w12*u13 - u12*w13; nz123 = u12*v13 - v12*u13;
    if (-nx123*u01 - ny123*v01 - nz123*w01<0, nx123*=-1; ny123*=-1; nz123*=-1);
  );
  if (x<"$xm" || x>"$xM" || y<"$ym" || y>"$yM" || z<"$zm" || z>"$zM",i,
    dx0 = x - x0; dy0 = y - y0; dz0 = z - z0;
    dx1 = x - x1; dy1 = y - y1; dz1 = z - z1;
    is_in = dx0*nx012 + dy0*ny012 + dz0*nz012>=0 &&
    dx0*nx013 + dy0*ny013 + dz0*nz013>=0 &&
    dx0*nx023 + dy0*ny023 + dz0*nz023>=0 &&
    dx1*nx123 + dy1*ny123 + dz1*nz123>=0;
    is_in? i(#-1,0,0,0)*x + i(#-1,0,1,0)*y + i(#-1,0,2,0)*z + i(#-1,0,3,0) :i
  )
"
  rm.
  v +

#@cli t : eq. to 'text'. : (+)

#@cli text : text,_x[%],_y[%],_font_height[%]>=0,_opacity,_color1,... : (+)
#@cli : Draw specified colored text string on selected images.
#@cli : (eq. to 't').\n
#@cli : Sizes '13' and '128' are special and correspond to binary fonts (no-antialiasing).
#@cli : Any other font size is rendered with anti-aliasing.
#@cli : Specifying an empty target image resizes it to new dimensions such that the image contains
#@cli : the entire text string.
#@cli : Default values: 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg resize2dy 600 y=0 repeat 30 text {2*$>}" : This is a nice text, isn't it ?",10,$y,{2*$>},0.9,255 y+={2*$>} done
#@cli : $ 0 text "G'MIC",0,0,23,1,255

#@cli to : eq. to 'text_outline'.
to : skip ${2=1%}
  _text_outline "$1",${2--1}

#@cli text_outline : text,_x[%],_y[%],_font_height[%]>0,_outline>=0,_opacity,_color1,...
#@cli : Draw specified colored and outlined text string on selected images.
#@cli : Default values: 'x=y=1%', 'font_height=7.5%', 'outline=2', 'opacity=1' and 'color1=255'.
#@cli : $ image.jpg text_outline "Hi there!",10,10,63,3
text_outline : skip ${2=1%}
  _text_outline "$1",${2--1}

_text_outline : skip ${3=1%},${4=7.5%},${5=2},${6=1},${7=255}
  e[0--3] "Draw outlined text '$1' at position ($2,$3) on image$?, with font height $4, outline $5, opacity $6 and color ${7--1}."
  v - if $5
    repeat $! l[$>]
      0 t. "$1",0,0,{-2,${"is_percent $4"}?h*$4:$4},1,${7--1},1 expand_xy. {1+$5},0
      s. c,{-narg(${7--1})} dilate. {2*$5+1}
      if {0,w} r[1] 100%,100%,1,{0,s},0,1 j[0] [1],$2,$3,0,0,$6,[2]
      else rm[0] i[0] [0] fi
      rm[-2,-1]
    endl done
  else t "$1",${2-4},${6--1}
  fi v +

#@cli triangle_shade : x0,y0,x1,y1,x2,y2,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,...
#@cli : Draw triangle with interpolated colors on selected images.
#@cli : $ image.jpg triangle_shade 20,20,400,100,120,200,255,0,0,0,255,0,0,0,255
triangle_shade :
  e[^-1] "Draw triangle ($1,$2)-($3,$4)-($5,$6) with interpolated colors on image$?."
  v -
  # Find color mapping coefficients for each vertex.
  l[] ($1,$2,1;$3,$4,1;$5,$6,1) (${7--1}) r. {w/3},3,1,1,-1 s. x solve[^0] [0] rm[0] a c endl

  # Pre-compute coefs to test point inside triangle.
  invarea={(-$4*$5+$2*(-$3+$5)+$1*($2-$6)+$3*$6)^-1}
  s1={$2*$5-$1*$6} s2={$6-$2} s3={$1-$5}
  t1={$1*$4-$2*$3} t2={$2-$4} t3={$3-$1}

  # Begin drawing on each selected image.
  repeat {$!-1} l[$>,-1] repeat {0,s}
    a={i(0,0,0,$>)} b={i(0,1,0,$>)} c={i(0,2,0,$>)}
    sh[0] $>
    f. "s = "$invarea"*("$s1" + "$s2"*x + "$s3"*y); t = "$invarea"*("$t1" + "$t2"*x + "$t3"*y); s>=0 && t>=0 && t+s<=1 ? "$a"*x+"$b"*y+"$c":i"
    rm.
  done endl done
  rm. v +

#@cli truchet : _scale>0,_radius>=0,_pattern_type={ 0=straight | 1=curved }
#@cli : Fill selected images with random truchet patterns.
#@cli : Default values: 'scale=32', 'radius=5' and 'pattern_type=1'.
#@cli : $ 400,300 truchet ,
truchet : check "isint(${1=32}) && $1>0 && ${2=3}>=0" skip ${3=1}
  e[^-1] "Render "${arg\ 1+!$3,curved,straight}" truchet patterns in image$?, with scale $1 and radius $2."
  v - repeat $! l[$>] nm={0,n}
    w={w} h={h} s={s} rm
    $1,$1 = 1,0,0 = 1,100%,100% distance 1,{1+$3} M={int(iM/2)} # Generate truchet pattern and its mirrored version.
    ir {$M-$2/2-($1%2)},{$M+$2/2} +mirror y a x
    {round($w/$1,1,1)},{round($h/$1,1,1)} rand. 0,1 >=. 50% r. {w*$1},{h*$1} *. $1
    channels. 0,1 (0,{$1-1}) r. $1,$1,1,1,3 +transpose. a[-2,-1] c r. ..,0,2 +[-2,-1]
    warp.. . rm. >= 50% r $w,$h,1,1,0 r 100%,100%,1,$s
  nm $nm endl done v +

#@cli turbulence : _radius>0,_octaves={1,2,3...,12},_alpha>0,_difference={-10,10},_mode={0,1,2,3}
#@cli : Render fractal noise or turbulence on selected images.
#@cli : Default values: 'radius=32', 'octaves=6', 'alpha=3', 'difference=0' and 'mode=0'.
#@cli : $ 400,400,1,3 turbulence 16
#@cli : $$
turbulence : check "${1=32}>0 && ${2=6}>0" skip ${3=3},${4=0},${5=0}
  e[^-1] "Render fractal noise or turbulence on image$?, with radius $1, octaves $2, damping per octave $3, difference $4 and mode $5."
  v - repeat $! l[$>] nm={0,n}
    if {$4} . fi
    f. 0 +noise. 10,0 b. $1,0
    if {$5==0||$5==1} -. {ia} abs.
    elif {$5==3||$5==4} ^. 2
    elif {$5==5} ^. 3
    fi
    repeat {$2-1}
      +noise.. 10,0 b. {$1/2^$>},0
      if {$5==0} -. {ia} abs.
      elif {$5==4} ^. 2
      elif {$5==5} ^. 3
      fi
      *.. $3 +[-2--1]
    done
    n. 0,255
    rm..
    if {$4} *. $4 mv.. 2 - n. 0,255 fi
  nm $nm endl done v +

#@cli yinyang
#@cli : Draw a yin-yang symbol on selected images.
#@cli : $ 400,400 yinyang
yinyang :
  e[^-1] "Draw yin-yang symbol on image$?."
  v - f 0 repeat $! l[$>]
    s={s} channels 0
    r={round(0.95*min(w,h)/4)}
    +line 50%,0,50%,50%,1,2 ellipse. 50%,{h/2-$r},$r,$r,0,1,2
    line. 50%,50%,50%,100%,1,1 ellipse. 50%,{h/2+$r},$r,$r,0,1,1
    flood. {w/2-$r},50%,0,0,0,1,2
    flood. {w/2+$r},50%,0,0,0,1,1
    ellipse.. 50%,50%,{2*$r},{2*$r},0,1,1
    *
    ellipse. 50%,{h/2-$r},{$r/3},{$r/3},0,1,1
    ellipse. 50%,{h/2+$r},{$r/3},{$r/3},0,1,2
    r 100%,100%,1,$s
  endl done v +

#---------------------------------
#
#@cli :: Matrix Computation
#
#---------------------------------

#@cli dijkstra : starting_node>=0,ending_node>=0 : (+)
#@cli : Compute minimal distances and paths from specified adjacency matrices by the Dijkstra algorithm.

#@cli eigen : (+)
#@cli : Compute the eigenvalues and eigenvectors of selected symmetric matrices or matrix fields.
#@cli : If one selected image has 3 or 6 channels, it is regarded as a field of 2x2 or 3x3 symmetric matrices,
#@cli : whose eigen elements are computed at each point of the field.
#@cli : $ (1,0,0;0,2,0;0,0,3) +eigen
#@cli : $ image.jpg structuretensors blur 2 eigen split[0] c
#@cli : $$

#@cli invert : (+)
#@cli : Compute the inverse of the selected matrices.
#@cli : $ (0,1,0;0,0,1;1,0,0) +invert

#@cli solve : [image] : (+)
#@cli : Solve linear system AX = B for selected B-matrices and specified A-matrix.
#@cli : If the system is under- or over-determined, the least square solution is returned.
#@cli : $ (0,1,0;1,0,0;0,0,1) (1;2;3) +solve[-1] [-2]

#@cli svd : (+)
#@cli : Compute SVD decomposition of selected matrices.
#@cli : $ 10,10,1,1,'if(x==y,x+u(-0.2,0.2),0)' +svd

#@cli transpose
#@cli : Transpose selected matrices.
#@cli : $ image.jpg +transpose
transpose :
  e[^-1] "Transpose image$?."
  v - permute yxzc v +

#@cli trisolve : [image] : (+)
#@cli : Solve tridiagonal system AX = B for selected B-vectors and specified tridiagonal A-matrix.
#@cli : Tridiagonal matrix must be stored as a 3 column vector, where 2nd column contains the
#@cli : diagonal coefficients, while 1st and 3rd columns contain the left and right coefficients.
#@cli : $ (0,0,1;1,0,0;0,1,0) (1;2;3) +trisolve[-1] [-2]

#---------------------------------
#
#@cli :: 3D Rendering
#
#---------------------------------

#@cli +3d : eq. to 'add3d'. : (+)

#@cli add3d : tx,_ty,_tz : [object3d] : (no arg) : (+)
#@cli : Shift selected 3D objects with specified displacement vector, or merge them with specified
#@cli : 3D object, or merge all selected 3D objects together.
#@cli : (eq. to '+3d').
#@cli : Default values: 'ty=tz=0'.
#@cli : $ sphere3d 10 repeat 5 +add3d[-1] 10,{u(-10,10)},0 color3d[-1] ${-RGB} done add3d
#@cli : $ repeat 20 torus3d 15,2 color3d[-1] ${-RGB} mul3d[-1] 0.5,1 if {$>%2} rotate3d[-1] 0,1,0,90 fi add3d[-1] 70 add3d rotate3d[-1] 0,0,1,18 done double3d 0

#@cli animate3d : _width>0,_height>0,_angle_dx,_angle_dy,_angle_dz,_zoom_factor>=0,_filename
#@cli : Animate selected 3D objects in a window.
#@cli : If argument 'filename' is provided, each frame of the animation is saved as a numbered filename.
#@cli : Default values: 'width=640', 'height=480', 'angle_dx=0', 'angle_dy=1', 'angle_dz=0', 'zoom_factor=1' and 'filename=(undefined)'.
animate3d : skip ${1=640},${2=480},${3=0},${4=1},${5=0},"${7=""}" check ${6=1}>=0
  e[^-1] "Animate 3D object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
  v - is_multi={$!>1} repeat $! +l[$>]
    n3d *3d {$6*min($1,$2)/1.5} c3d
    ax=0 ay=0 az=0 frame=0 vfact=1
    do
       +r3d 1,0,0,$ax r3d. 0,1,0,$ay r3d. 0,0,1,$az
       ax+=$3 ay+=$4 az+=$5
       $1,$2,1,3,-1 j3d. ..,50%,50%,0,1
       if {narg("$7")}
         to_rgba. replace_color. 0,0,-1,-1,-1,255,64,64,64,0
         if $is_multi filename=${filename\ "$7",$>,$frame} else filename=${filename\ "$7",$frame} fi
         o. $filename frame+=1
       else
         replace. -1,64
       fi
       w. {$vfact*w},{$vfact*h},0,0,-1,-1,{0,n} wait 20 k[0]
       if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-D}} vfact=1.5 fi # Increase window size.
       if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-C}} vfact={1/1.5} fi # Decrease window size.
       if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-R}} vfact=1 fi # Decrease window size.
    while {{*}" && "!{*,ESC}" && "!{*,Q}} rm w 0
  endl done v +

#@cli apply_camera3d : pos_x,pos_y,pos_z,target_x,target_y,target_z,up_x,up_y,up_z
#@cli : Apply 3D camera matrix to selected 3D objects.
#@cli : Default values: 'target_x=0', 'target_y=0', 'target_z=0', 'up_x=0', 'up_y=-1' and 'up_z=0'.
apply_camera3d : skip ${4=0},${5=0},${6=0},${7=0},${8=-1},${9=0}
  e[^-1] "Apply 3D camera matrix to 3D object$?, with camera position ($1,$2,$3), target position ($4,$5,$6) and up-vector ($7,$8,$9)."
  v -
  ({$4-$1}^{$5-$2}^{$6-$3})  # f.
  ($7^$8^$9)                 # up.
  orientation[-2,-1]         # f/|f| and up/|up|.
  _cross3d {-2,^},{^}        # s = f x up
  _cross3d {^},{-3,^}        # u = s x f
  rm... y[-3--1] x mv[-2,-1] -3
  a[-3--1] y z. 0,3  # Rotation matrix R.
  -3d[^-1] $1,$2,$3 pose3d[^-1] {^} rm. -3d 0,0,800
  v +

_cross3d :
  ({$2*$6-$3*$5}^{$3*$4-$1*$6}^{$1*$5-$2*$4}) orientation. y.

#@cli apply_matrix3d : a11,a12,a13,...,a31,a32,a33
#@cli : Apply specified 3D rotation matrix to selected 3D objects.
#@cli : $ torus3d 10,1 +apply_matrix3d {mul(rot(1,0,1,-15),[1,0,0,0,2,0,0,0,8],3)} double3d 0
apply_matrix3d :
  e[^-1] "Apply 3x3 matrix (${1-3};${4-6};${7-9}) to 3D object$?."
  v - repeat $! l[$>]
    nbp={i[6]} sh 8,{8+3*$nbp-1},0,0 r. 3,$nbp,1,1,-1 3,3,1,1,$* transpose. m*[-2,-1] rm.
  endl done v +

#@cli array3d : size_x>=1,_size_y>=1,_size_z>=1,_offset_x[%],_offset_y[%],_offset_y[%]
#@cli : Duplicate a 3D object along the X,Y and Z axes.
#@cli : Default values: 'size_y=1', 'size_z=1' and 'offset_x=offset_y=offset_z=100%'.
#@cli : $ torus3d 10,1 +array3d 5,5,5,110%,110%,300%
array3d : check "isint($1) && $1>0 && isint(${2=1}) && $2>0 && isint(${3=1}) && $3>0" skip ${4=100%},${5=100%},${6=100%}
  e[^-1] "Duplicate 3D object$? along X,Y,Z axes with factors ($1,$2,$3) and offsets ($4,$5,$6)."
  v - repeat $! l[$>]

    # Retrieve object dimensions.
    +rows 8,{8+3*i[6]} r. 3,{h/3},1,1,-1 s. x,3
    dx={-3,if(${is_percent\ $4},$4*(iM-im),$4)}
    dy={-2,if(${is_percent\ $5},$5*(iM-im),$5)}
    dz={if(${is_percent\ $6},$6*(iM-im),$6)}
    rm[-3--1]

    # Duplicate along X.
    off=0 repeat {int(log2($1))}
      ++3d. {2^$>*$dx} +3d. ..
      if {!($1&(2^$>))} rm.. else +3d.. $off off+={2^$>*$dx} fi
    done +3d. $off +3d

    # Duplicate along Y.
    off=0 repeat {int(log2($2))}
      ++3d. 0,{2^$>*$dy} +3d. ..
      if {!($2&(2^$>))} rm.. else +3d.. 0,$off off+={2^$>*$dy} fi
    done +3d. 0,$off +3d

    # Duplicate along Z.
    off=0 repeat {int(log2($3))}
      ++3d. 0,0,{2^$>*$dz} +3d. ..
      if {!($3&(2^$>))} rm.. else +3d.. 0,0,$off off+={2^$>*$dz} fi
    done +3d. 0,0,$off +3d
  endl done v +

#@cli arrow3d : x0,y0,z0,x1,y1,z1,_radius[%]>=0,_head_length[%]>=0,_head_radius[%]>=0
#@cli : Input 3D arrow with specified starting and ending 3D points.
#@cli : Default values: 'radius=5%', 'head_length=25%' and 'head_radius=15%'.
#@cli : $ repeat 10 a={$>*2*pi/10} arrow3d 0,0,0,{cos($a)},{sin($a)},-0.5 done +3d
arrow3d : check "${7=5%}>=0 && ${8=25%}>=0 && ${9=15%}>=0"
  e[^-1] "Input 3D arrow, from (${1-3}) to (${4-6}), with radius $7, head length $8 and head radius $9."
  v -

  # Create 3D object.
  L={sqrt(($4-$1)^2+($5-$2)^2+($6-$3)^2)}
  R={if(${is_percent\ $7},$7*$L,$7)}
  l={if(${is_percent\ $8},$8*$L,$8)}
  r={if(${is_percent\ $9},$9*$L,$9)}
  L-=$l cylinder3d $R,$L cone3d $r,$l +3d. 0,0,$L +3d[-2,-1]

  # Compute rotation matrix for arrow orientation.
  ({$4-$1}^{$5-$2}^{$6-$3}) (0.01^-0.02^0.03) orientation[-2,-1]
  _cross3d {-2,^},{^} _cross3d {^},{-3,^} rm... y[-3--1] x mv[-2,-1] -3
  a[-3--1] y

  # Rotate and translate the arrow at specified coordinates.
  s3d.. r[-5] 3,{-5,h/3},1,1,-1 m*[-5,-1]
  y[-4] a[-6--1] y +3d. ${1-3} rv3d.
  v +

#@cli axes3d : _size_x,_size_y,_size_z,_font_size>0,_label_x,_label_y,_label_z
#@cli : Input 3D axes with specified sizes along the x,y and z orientations.
#@cli : Default values: 'size_x=size_y=size_z=1', 'font_size=23', 'label_x=X', 'label_y=Y' and 'label_z=Z'.
#@cli : $ axes3d ,
axes3d : check ${4=23}>0 skip ${1=1},${2=$1},${3=$2},"${5=X},${6=Y},${7=Z}"
  e[^-1] "Input 3D axes with sizes ($1,$2,$3)."
  v - l[]
  m={max(abs($1),abs($2),abs($3))/40} m2={2*$m} m3={1.2*$m2}
  _axes3d "O",$4 -3d. $m3,$m3,$m3
  if $1
    line3d 0,0,0,$1,0,0
    cone3d $m,{2*$m},16 r3d. 0,1,0,90 +3d. {$1-$m2},0,0
    _axes3d "$5",$4 +3d. {$1+$m3},0,0
  fi
  if $2
    line3d 0,0,0,0,$2,0
    cone3d $m,{2*$m},16 r3d. 1,0,0,-90 +3d. 0,{$2-$m2},0
    _axes3d "$6",$4 +3d. 0,{$2+$m3},0
  fi
  if $3
    line3d 0,0,0,0,0,$3
    cone3d $m,{2*$m},16 +3d. 0,0,{$3-$m2}
    _axes3d "$7",$4 +3d. 0,0,{$3+$m3}
  fi
  +3d nm [3d\ axes]
  endl v +

_axes3d :
  0 t. "$1",2,0,$2,1,1 +dilate. 3 *.. 255 r.. 100%,100%,1,3
  i... (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};3)
  i.. (-128;{w};{h};1) y[-3,-1] a[-4--1] y

#@cli box3d : _size_x,_size_y,_size_z
#@cli : Input 3D box at (0,0,0), with specified geometry.
#@cli : Default values: 'size_x=1' and 'size_z=size_y=size_x'.
#@cli : $ box3d 100,40,30 +primitives3d 1 color3d[-2] ${-RGB}
box3d : skip ${1=1},${2=$1},${3=$2}
  e[^-1] "Input 3D box, with size ($1,$2,$3)."
  v -
  1,86,1,1,\
  67.5,73.5,109.5,103.5,51.5,100.5,8,6,\
  0,0,0,$1,0,0,$1,$2,0,0,$2,0,\
  0,0,$3,$1,0,$3,$1,$2,$3,0,$2,$3,\
  4,0,3,2,1,4,4,5,6,7,4,0,1,5,4,4,3,7,6,2,4,0,4,7,3,4,1,2,6,5,\
  200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,\
  1,1,1,1,1,1
  nm. [3D\ box]
  v +

#@cli c3d : eq. to 'center3d'.
c3d :
  _center3d

#@cli center3d
#@cli : Center selected 3D objects at (0,0,0).
#@cli : (eq. to 'c3d').
#@cli : $ repeat 100 circle3d {u(100)},{u(100)},{u(100)},2 done add3d color3d[-1] 255,0,0 +center3d color3d[-1] 0,255,0 add3d
center3d :
  _$0

_center3d :
  e[0--3] "Center 3D object$?."
  v - check3d 0 repeat $! l[$>]
    if {i[6]}
      s3d r[2] 3,{2,h/3},1,1,-1 s[2] x
      -[2] {2,(iM+im)/2} -[3] {3,(iM+im)/2} -[4] {4,(iM+im)/2}
      a[2-4] x y[2] a y
    fi
  endl done v +

#@cli circle3d : _x0,_y0,_z0,_radius>=0
#@cli : Input 3D circle at specified coordinates.
#@cli : Default values: 'x0=y0=z0=0' and 'radius=1'.
#@cli : $ repeat 500 a={$>*pi/250} circle3d {cos(3*$a)},{sin(2*$a)},0,{$a/50} color3d[-1] ${-RGB},0.4 done add3d
circle3d : skip ${1=0},${2=0},${3=0},${4=1}
  e[^-1] "Input 3D circle at position ($1,$2,$3) with radius $4."
  v -
  r={$4/sqrt(3)}
  1,24,1,1,\
  67.5,73.5,109.5,103.5,51.5,100.5,2,1,\
  {$1-$r},{$2-$r},{$3-$r},\
  {$1+$r},{$2+$r},{$3+$r},\
  5,0,1,0,0,0,200,200,200,1
  nm. [3D\ circle]
  v +

#@cli circles3d : _radius>=0,_is_filled={ 0 | 1 }
#@cli : Convert specified 3D objects to sets of 3D circles with specified radius.
#@cli : Default values: 'radius=1' and 'is_filled=1'.
#@cli : $ image.jpg luminance resize2dy 40 threshold 50% * 255 pointcloud3d color3d[-1] 255,255,255 circles3d 0.7
circles3d : check ${1=1}>=0 skip ${2=1}
  e[^-1] "Convert 3D object$? to sets of 3D "${arg\ 1+$2,wireframe,filled}" circles with radius $1."
  v - p3d 0 repeat $! l[$>]
    nbv={@6} nbp={@7}
    if {$nbv&&$nbp}
      -3d {$1/2},0,0 ++3d $1,0,0 +3d nbp2={@7}
      s3d =[1] $nbp,0,1
      r[3] 2,$nbp2,1,1,-1 columns[3] 1,1 s[3] y,2 i[3] 1,$nbp,1,1,5
      i[6] 1,$nbp,1,1,{!$2} a[3-6] x columns[3] 0,5
      y[3]
      rows[4] 0,{3*$nbp-1} rows[5] 0,{$nbp-1} a y
    fi
  endl done v +

#@cli col3d : eq. to 'color3d'. : (+)

#@cli color3d : R,_G,_B,_opacity : (+)
#@cli : Set color and opacity of selected 3D objects.
#@cli : (eq. to 'col3d').
#@cli : Default value: 'B=G=R' and 'opacity=(undefined)'.
#@cli : $ torus3d 100,10 double3d 0 repeat 7 +rotate3d[-1] 1,0,0,20 color3d[-1] ${-RGB} done add3d

#@cli colorcube3d
#@cli : Input 3D color cube.
#@cli : $ colorcube3d mode3d 2 +primitives3d 1
colorcube3d :
  e[^-1] "Input 3D RGB-color cube."
  v -
  (67.5;73.5;109.5;103.5;51.5;100.5;8;6)
  (0;0;0;\
   255;0;0;\
   255;255;0;\
   0;255;0;\
   0;0;255;\
   255;0;255;\
   255;255;255;\
   0;255;255)
  (12;0;3;2;1;0;0;0;63;63;63;63;0;\
   12;1;2;6;5;0;0;0;63;63;63;63;0;\
   12;0;4;7;3;0;0;63;0;63;63;0;63;\
   12;4;5;6;7;0;0;63;0;63;63;0;63;\
   12;0;1;5;4;0;0;63;0;63;63;0;63;\
   12;3;7;6;2;0;0;0;63;63;63;63;0)
  (0,255;0,255^0,0;255,255^0,0;0,0)
  (255,255;255,255^0,0;255,255^0,255;0,255)
  (0,0;0,0^0,0;255,255^0,255;0,255)
  (0,255;0,255^0,0;255,255^255,255;255,255)
  (0,255;0,255^0,0;0,0^0,0;255,255)
  (0,255;0,255^255,255;255,255^0,0;255,255)
  r[-6--1] 64,64,1,3,3 round[-6--1] y[-6--1] i[-7--2] (-128;64;64;3)
  (1;1;1;1;1;1)
  a[-16--1] y nm. [3D\ colorcube]
  v +

#@cli cone3d : _radius,_height,_nb_subdivisions>0
#@cli : Input 3D cone at (0,0,0), with specified geometry.
#@cli : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@cli : $ cone3d 10,40 +primitives3d 1 color3d[-2] ${-RGB}
cone3d : check ${3=24}>0 skip ${1=1},${2=1}
  e[^-1] "Input 3D cone, with radius $1, height $2 and $3 subdivisions."
  v -
  # Header.
  (67.5;73.5;109.5;103.5;51.5;100.5)
  ({$3+2};{2*$3})

  # Vertices.
  (0,0,0;0,0,$2)
  (0;{2*pi}) r. 1,{$3+1},1,1,3 rows. 0,{$3-1} +sin. cos.. *[-2,-1] $1 a[-2,-1] x z. 0,2 a[-2,-1] y

  # Primitives.
  1,$3,1,1,'y' +shift. 0,-1 +[-2,-1] 2
  2,$3,1,1,3,0 .. [-4] a[-3--1] x
  i[-4] 2,$3,1,1,3,1 a[-4--2] x
  a[-2,-1] y

  # Colors / opacities.
  3,{h},1,1,200
  1,{h},1,1,1
  y[-4--2] a[-6--1] y nm. [3D\ cone]
  v +

#@cli cubes3d : _size>=0
#@cli : Convert specified 3D objects to sets of 3D cubes with specified size.
#@cli : Default value: 'size=1'.
#@cli : $ image.jpg luminance resize2dy 40 threshold 50% * 255 pointcloud3d color3d[-1] 255,255,255 cubes3d 1
cubes3d : check ${1=1}>=0
  e[^-1] "Convert 3D object$? to sets of 3D cubes with size $1."
  v - p3d 0 repeat $! l[$>]
    nbv={@6} nbp={@7}
    if {$nbv&&$nbp}
      s3d
      l[1] = {8*i[0]} = {6*i[1]},0,1 endl  # Header.
      l[2] r 3,{h/3},1,1,-1                  # Vertices.
      half={$1/2}
      - '$half,0,0' ++ '$1,0,0' a x
      - '0,$half,0' ++ '0,$1,0' a x
      - '0,0,$half' ++ '0,0,$1' a x
      endl
      l[3] r 2,{h/2},1,1,-1                  # Primitives.
      z 1,1 * 8 r 4,100% i[0] 1,100%,1,1,4 a x [-1]x5 a x
      + '"0,0,2,3,1, 0,4,5,7,6, 0,0,1,5,4, 0,2,6,7,3, 0,0,4,6,2, 0,1,3,7,5"'
      endl
      l[4] r 3,{h/3},1,1,-1 r 18,100%,1,1,0,2 endl r[5] 6,100% # Colors & opacities.
      y a y
    fi
  endl done v +

#@cli cup3d : _resolution>0
#@cli : Input 3D cup object.
#@cli : $ cup3d ,
cup3d : check ${1=128}>0
  e[^-1] "Input 3D cup, with resolution $1."
  v -
  100,200
  ellipse. 0%,0%,40%,40%,0,1,1
  ellipse. 0,0,35%,35%,0,1,0
  polygon. 4,0,45%,8%,45%,20%,90%,0,90%,1,1
  ellipse. 0%,100%,30%,10%,0,1,1 b. 0.1%
  lathe3d. $1,2 nm. [3D\ cup]
  v +

#@cli cylinder3d : _radius,_height,_nb_subdivisions>0
#@cli : Input 3D cylinder at (0,0,0), with specified geometry.
#@cli : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@cli : $ cylinder3d 10,40 +primitives3d 1 color3d[-2] ${-RGB}
cylinder3d : check ${3=24}>0 skip ${1=1},${2=1}
  e[^-1] "Input 3D cylinder, with radius $1, height $2 and $3 subdivisions."
  v -
  # Header.
  (67.5;73.5;109.5;103.5;51.5;100.5)
  ({2*$3+2};{3*$3})

  # Vertices.
  (0,0,0;0,0,$2)
  (0;{2*pi}) r. 1,{$3+1},1,1,3 rows. 0,{$3-1} +sin. cos.. *[-2,-1] $1 a[-2,-1] x
  +z. 0,2 1,$3,1,1,$2 a[-3,-1] x
  a[-3--1] y

  # Primitives.
  1,$3,1,1,'y' +shift. 0,-1 +[-2,-1] 2
  2,$3,1,1,3,1 ... ... a[-3--1] x
  2,$3,1,1,3,0 ... [-5] +[-2,-1] $3 a[-3--1] x
  ++[-4,-3] $3 i[-7] 1,$3,1,1,4 rv[-6,-5] a[-7--5,-2,-1] x

  # Colors / opacities.
  3,{3*$3},1,1,200
  1,{h},1,1,1
  y[-6--2] a[-8--1] y nm. [3D\ cylinder]
  v +

#@cli delaunay3d
#@cli : Generate 3D delaunay triangulations from selected images.
#@cli : One assumes that the selected input images are binary images containing the set of points to mesh.
#@cli : The output 3D object is a mesh composed of non-oriented triangles.
#@cli : $ 500,500 noise 0.05,2 eq 1 * 255 +delaunay3d color3d[1] 255,128,0 dilate_circ[0] 5 to_rgb[0] +object3d[0] [1],0,0,0,1,1 max[-1] [0]
delaunay3d :
  e[^-1] "Generate 3D delaunay triangulation from image$?."
  v - repeat $! l[$>]
    channels 0 != 0

    # Label each point separately
    whd={w},{h},{d} +r 1,{w*h*d},1,1,-1 cumulate. *. .. r. $whd,1,-1

    # Compute voronoi diagram of point cloud.
    +distance[0] 1 *[2] -1 watershed[1] [2] rm[2]

    # Get redondant set of delaunay triangles from the voronoi diagram.
    r[1] 100%,100%,100%,3
    if {d>1} # Add detection cases for 3D images.
      +_delaunay3d[1] 1,0,0,0,0,1 +_delaunay3d[1] -1,0,0,0,0,-1
      +_delaunay3d[1] 0,1,0,0,0,1 +_delaunay3d[1] 0,-1,0,0,0,-1
    fi
    +_delaunay3d[1] 1,0,0,0,1,0 _delaunay3d[1] -1,0,0,0,-1,0 # 2D detection.
    a[^0] x transpose. -. 1

    # Build 3D mesh.
    pointcloud3d[0]
    s3d[0] rm[3-5] i.. 1,100%,1,1,3 a[-2,-1] x
    3,100%,1,1,200 1,100%,1,1,1 =[1] {h},0,1 y a y
  endl done v +

_delaunay3d :
  f. "A=j($1,$2,$3,0,0,1); B=j($4,$5,$6,0,0,1);
      if(i!=A && i!=B && A!=B, kth(1+c,i,A,B),0)"
  discard. 0 r. {h/3},3,1,1,-1

#@cli distribution3d
#@cli : Get 3D color distribution of selected images.
#@cli : $ image.jpg distribution3d colorcube3d primitives3d[-1] 1 add3d
distribution3d :
  e[^-1] "Get 3D color distribution of image$?."
  v - to_rgb permute "cxyz" y
  repeat $! l[$>]
    nbp={round(h/3)}
    i.. (67.5;73.5;109.5;103.5;51.5;100.5;\    # Magick number for CImg3d.
         $nbp;$nbp)                            # Number of vertices and primitives.
    1,$nbp,1,1,1 +f. y a[-2,-1] x y.           # Primitives.
    ..                                         # Colors.
    1,$nbp,1,1,1                               # Opacities.
    a y nm. [3D\ distribution]                 # Build 3D object.
  endl done v +

#@cli /3d : eq. to 'div3d'. : (+)

#@cli div3d : factor : factor_x,factor_y,_factor_z : (+)
#@cli : Scale selected 3D objects isotropically or anisotropically, with the inverse of specified
#@cli : factors.
#@cli : (eq. to '/3d').
#@cli : Default value: 'factor_z=0'.
#@cli : $ torus3d 5,2 repeat 5 +add3d[-1] 12,0,0 div3d[-1] 1.2 color3d[-1] ${-RGB} done add3d

#@cli db3d : eq. to 'double3d'. : (+)

#@cli double3d : _is_double_sided={ 0 | 1 } : (+)
#@cli : Enable/disable double-sided mode for 3D rendering.
#@cli : (eq. to 'db3d').
#@cli : Default value: 'is_double_sided=1'.
#@cli : $ mode3d 1 repeat 2 torus3d 100,30 rotate3d[-1] 1,1,0,60 double3d $> snapshot3d[-1] 400 done

#@cli elevation3d : z-factor : [elevation_map] : 'formula' : (no arg) : (+)
#@cli : Build 3D elevation of selected images, with a specified elevation map.
#@cli : When invoked with (no arg) or 'z-factor', the elevation map is computed as the pointwise L2 norm of the
#@cli : pixel values. Otherwise, the elevation map is taken from the specified image or formula.
#@cli : $ image.jpg blur 5 elevation3d 0.5
#@cli : $ 128,128,1,3,u(255) plasma 10,3 blur 4 sharpen 10000 elevation3d[-1] 'X=(x-64)/6;Y=(y-64)/6;-100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'

#@cli empty3d
#@cli : Input empty 3D object.
#@cli : $ empty3d
empty3d :
  e[^-1] "Input empty 3D object."
  v - (67.5;73.5;109.5;103.5;51.5;100.5;0;0) nm. [3D\ empty] v +

#@cli extrude3d : _depth>0,_resolution>0,_smoothness[%]>=0
#@cli : Generate extruded 3D object from selected binary XY-profiles.
#@cli : Default values: 'depth=16', 'resolution=1024' and 'smoothness=0.5%'.
#@cli : $ image.jpg threshold 50% extrude3d 16
extrude3d : check "${1=16}>0 && ${2=1024}>0 && ${3=0.5%}>=0"
  e[^-1] "Generate extruded 3D object from XY-profile$?, with depth $1, resolution $2 and smoothness $3."
  v - norm n 0,1 autocrop 0 repeat $! l[$>] nm={0,n}
    wr={round(max(1,if(w>h,min($2,w),min($2,h)*w/h)))}
    hr={round(max(1,if(w>h,min($2,w)*h/w,min($2,h))))}
    fact={$1/max(w/$wr,h/$hr)}
    b $3,0 r $wr,$hr,1,1,2 expand_xyz 1,0
    isosurface3d 50% *3d 1,1,$fact rv3d
  nm $nm endl done v +

#@cli f3d : eq. to 'focale3d'. : (+)

#@cli focale3d : focale : (+)
#@cli : Set 3D focale.
#@cli : (eq. to 'f3d').\n
#@cli : Set 'focale' to 0 to enable parallel projection (instead of perspective).
#@cli : Set negative 'focale' will disable 3D sprite zooming.
#@cli : Default value: 'focale=700'.
#@cli : $ repeat 5 torus3d 100,30 rotate3d[-1] 1,1,0,60 focale3d {$<*90} snapshot3d[-1] 400 done remove[0]

#@cli gaussians3d : _size>0,_opacity
#@cli : Convert selected 3D objects into set of 3D gaussian-shaped sprites.
#@cli : $ image.jpg r2dy 32 distribution3d gaussians3d 20 colorcube3d primitives3d[-1] 1 +3d
gaussians3d : check "${1=32}>0" skip ${2=0.3}
  e[^-1] "Convert 3D object$? into sets of gaussian-shaped 3D sprites, with size $1 and opacity $2."
  v - p3d 2 p3d 0 repeat $! l[$>] nm={0,n} s3d
    nbv={h} rm. (-128;$1;$1;1)
    $1,$1 gaussian. 35%,35%,0 c. 30%,100% n. 0,$2 y. a[-2,-1] y      # First opacity is generated.
    if {$nbv>1} 4,{$nbv-1},1,1,-128,0,0,0 y[-2,-1] a[-2,-1] y fi   # Other ones are shared copies of the first one.
    a y
  nm $nm endl done v +

#@cli gmic3d
#@cli : Input a 3D G'MIC logo.
#@cli : $ gmic3d +primitives3d 1
gmic3d :
  e[^-1] "Input 3D G\47MIC logo."
  v -
  text3d G,60,20,2 col3d. 16,64,255
  text3d \',60,20,2 +3d. 40 col3d. 64,128,255
  text3d M,60,20,2 +3d. 50 col3d. 96,196,255
  text3d I,60,20,2 +3d. 90 col3d. 64,128,255
  text3d C,60,20,2 +3d. 100 col3d. 16,64,255
  sphere3d 8 +3d. 102,-3,20 col3d. 192,128,255
  +3d[-6--1] c3d.
  repeat 30
    box3d {min(3+$</2,10)} col3d. {30*$>},{20+80*$>},{10*$>},0.5
    r3d. 1,1,1,{$>*12}
    +3d. {80*cos(0.5+1.02*$>*12*pi/180)},{30*sin(0.8+$>*12*pi/180)},{2*$>-60}
  done
  +3d[-30--1] +3d. 0,5,30 +3d[-2--1] nm. [3d\ gmic]
  v +

#@cli gyroid3d : _resolution>0,_zoom
#@cli : Input 3D gyroid at (0,0,0), with specified resolution.
#@cli : Default values: 'resolution=32' and 'zoom=5'.
#@cli : $ gyroid3d 48 +primitives3d 1
gyroid3d : check ${1=32}>0 skip ${2=5}
  e[^-1] "Input 3D gyroid, with resolution $1 and range $2."
  v -
  isosurface3d "'0.49*(\
    cos( 2*x + y + z - pi) + cos( 2*x - y + z - pi)\
    + cos(- 2*x + y - z - pi) + cos(- 2*x - y - z - pi)\
    + cos( x + 2*y + z - pi) + cos( x + 2*y - z - pi)\
    + cos(- x - 2*y + z - pi) + cos(- x - 2*y - z - pi)\
    + cos( x + y + 2*z - pi) + cos(- x + y + 2*z - pi)\
    + cos( x - y - 2*z - pi) + cos(- x - y - 2*z - pi)\
    + cos(- 2*x + y + z) + cos( 2*x + y - z)\
    + cos(- 2*x - y + z) + cos( 2*x - y - z)\
    + cos(- x + 2*y + z) + cos( x - 2*y + z)\
    + cos(- x + 2*y - z) + cos( x - 2*y - z)\
    + cos( x - y + 2*z) + cos( x + y - 2*z)\
    + cos(- x - y + 2*z) + cos(- x + y - 2*z)\
    ) + 0.27*( \
    cos(- 2*x + 2*y - pi) + cos( 2*x - 2*y - pi)\
    + cos( 2*x + 2*y - pi) + cos(- 2*x - 2*y - pi)\
    + cos(- 2*y + 2*z - pi) + cos( 2*y - 2*z - pi)\
    + cos( 2*y + 2*z - pi) + cos(- 2*y - 2*z - pi)\
    + cos(- 2*z + 2*x - pi) + cos( 2*z - 2*x - pi)\
    + cos( 2*z + 2*x - pi) + cos(- 2*z - 2*x - pi)\
    ) - 0.69'",0,{-$2},{-$2},{-$2},$2,$2,$2,$1,$1,$1
  c3d. n3d. nm. [3D\ gyroid]
  v +

#@cli histogram3d
#@cli : Get 3D color histogram of selected images.
#@cli : $ image.jpg histogram3d colorcube3d primitives3d[-1] 1 add3d
histogram3d :
  e[^-1] "Get 3D color histogram of image$?."
  v - to_rgb repeat $! l[$>]
    r {w*h},3,1,1,-1 pointcloud 1 n 0,255 map 3 pointcloud3d nm "[3D histogram]"
  endl done v +

#@cli image6cube3d
#@cli : Generate 3D mapped cubes from 6-sets of selected images.
#@cli : $ image.jpg animate flower,"30,0","30,5",6 image6cube3d
image6cube3d :
  e[^-1] "Generate 3D mapped cubes from image$?."
  v - M={max(${-max_wh})} r $M,$M,1,3 imageplane3d n3d c3d
  repeat {int($!/6)} l[$>-{$>+5}]
    +3d[0] 0,0,-0.5
    r3d[1] 0,1,0,90 +3d[1] -0.5,0,0
    r3d[2] 0,1,0,180 +3d[2] 0,0,0.5
    r3d[3] 0,1,0,270 +3d[3] 0.5,0,0
    r3d[4] 1,0,0,90 +3d[4] 0,0.5,0
    r3d[5] 1,0,0,270 +3d[5] 0,-0.5,0
    +3d nm "[3D image cube]"
  endl done v +

#@cli imageblocks3d : _maximum_elevation,_smoothness[%]>=0
#@cli : Generate 3D blocks from selected images.
#@cli : Transparency of selected images is taken into account.
#@cli : Default values: 'maximum_elevation=10' and 'smoothness=0'.
#@cli : $ image.jpg resize2dy 32 imageblocks3d -20 mode3d 3
imageblocks3d : check ${2=0}>=0 skip ${1=10},${3=0}
  e[^-1] "Generate 3D blocks from image$?, with maximum elevation $1 and smoothness $2."
  v - repeat $! l[$>]
    w={w} h={h}
    split_opacity to_rgb[0] is_opacity={$!==2}

    # Create 3D object template.
    l[] box3d 1,1,0
    repeat {$w-1} ++3d. 1,0,0 done +3d
    repeat {$h-1} ++3d. 0,1,0 done +3d
    endl
    s3d.

    # Set vertex altitudes.
    +norm[0] b. $2
    y. n. 0,$1
    r[-5] 24,{-5,round(w*h/24)},1,1,-1
    if {$1<0} j[-5] .,2 j[-5] .,5 j[-5] .,8 j[-5] .,11
    else j[-5] .,14 j[-5] .,17 j[-5] .,20 j[-5] .,23
    fi
    rm. y[-4]

    # Set primitive colors.
    rm.. r[0] {0,wh},1,1,100%,-1 permute[0] cxyz r[0] 600%,100%,1,1,0,2 y[0] mv[0] -1

    # Set primitive opacities.
    if $is_opacity rm. mv[0] $! /. 255 y. r. 6,100%,1,1 y. fi

    a y
  endl done v +

#@cli imagecube3d
#@cli : Generate 3D mapped cubes from selected images.
#@cli : $ image.jpg imagecube3d
imagecube3d :
  e[^-1] "Generate 3D mapped cubes from image$?."
  v - slices 50% to_rgb repeat $! l[$>] nm={0,n}
    i.. (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
         8;6;\                               # Number of vertices and primitives.
         -0.5;-0.5;-0.5;\                    # Vertex coordinates.
         0.5;-0.5;-0.5;\
         0.5;0.5;-0.5;\
         -0.5;0.5;-0.5;\
         -0.5;-0.5;0.5;\
         0.5;-0.5;0.5;\
         0.5;0.5;0.5;\
         -0.5;0.5;0.5;\
         12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\    # Primitives description.
         12;1;2;6;5;0;0;0;{h};{w};{h};{w};0;\
         12;5;6;7;4;0;0;0;{h};{w};{h};{w};0;\
         12;4;7;3;0;0;0;0;{h};{w};{h};{w};0;\
         12;4;0;1;5;0;0;0;{h};{w};{h};{w};0;\
         12;3;7;6;2;0;0;0;{h};{w};{h};{w};0;\
         -128;{w};{h};{s})       # Texture map for the first face.
    y.
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1;1)  # Other faces and opacities.
    a y
  nm $nm endl done v +

#@cli imageplane3d
#@cli : Generate 3D mapped planes from selected images.
#@cli : $ image.jpg imageplane3d
imageplane3d :
  e[^-1] "Generate 3D mapped planes from image$?."
  v - slices 50% to_color repeat $! l[$>] nm={0,n}
    i.. (67.5;73.5;109.5;103.5;51.5;100.5;\   # Magick number for CImg3d.
         4;1;\                                # Number of vertices and primitives.
         0;0;0;\                              # Vertex coordinates.
         {w};0;0;\
         {w};{h};0;\
         {0};{h};0;\
         12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\ # Primitives description.
         -128;{w};{h};{s})                    # Texture map.
    y.
    (1)  # Opacity.
    a y
  nm $nm endl done v +

#@cli imagepyramid3d
#@cli : Generate 3D mapped pyramids from selected images.
#@cli : $ image.jpg imagepyramid3d
imagepyramid3d :
  e[^-1] "Generate 3D mapped pyramids from image$?."
  v - to_rgb repeat $! l[$>] nm={0,n}
    w2={w/2}
    i.. (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
         5;5;\                               # Number of vertices and primitives.
         -0.5;-0.5;-0.5;\                    # Vertex coordinates.
         0.5;-0.5;-0.5;\
         0.5;0.5;-0.5;\
         -0.5;0.5;-0.5;\
         0;0;0.5;\
         12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\    # Primitives description.
         9;0;4;3;0;{h};$w2;0;{w};{h};\
         9;1;4;0;0;{h};$w2;0;{w};{h};\
         9;2;4;1;0;{h};$w2;0;{w};{h};\
         9;3;4;2;0;{h};$w2;0;{w};{h};\
         -128;{w};{h};{s})                   # Texture map for the first face.
    y.
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1)  # Other faces and opacities.
    a y
  nm $nm endl done v +

#@cli imagerubik3d : _xy_tiles>=1,0<=xy_shift<=100,0<=z_shift<=100
#@cli : Generate 3D mapped rubik's cubes from selected images.
#@cli : Default values: 'xy_tiles=3', 'xy_shift=5' and 'z_shift=5'.
#@cli : $ image.jpg imagerubik3d ,
imagerubik3d : check "${1=3}>=1 && ${2=5}>=0 && $2<=100 && ${3=5}>=0 && $3<=100"
  e[^-1] "Generate 3D mapped rubik\47s cubes from image$? with $1 xy-tiles, xy-shift $2 and z-shift $3."
  v - repeat $! l[$>] nm={0,n}
    # Generate primary 3D side.
    ({'CImg3d'}) +. 0.5
    (8,5)
    (0,0,0;\
     100,0,0;\
     100,100,0;\
     0,100,0;\
     $2,$2,{-$3};\
     {100-$2},$2,{-$3};\
     {100-$2},{100-$2},{-$3};\
     $2,{100-$2},{-$3})
    (4,4,7,6,5;\
     4,0,4,5,1;\
     4,3,2,6,7;\
     4,0,3,7,4;\
     4,1,5,6,2)
    3,5,1,1,200
    1,5,1,1,1
    y[-6--1] a[-6--1] y
    repeat {$1-1} ++3d. 100 done +3d[-$1--1]   # Duplicate along X
    repeat {$1-1} ++3d. 0,100 done +3d[-$1--1] # Duplicate along Y
    t3d. .. rm..
    /3d. $1 -3d. 50,50,50
    +r3d. 0,1,0,-90 +r3d. 0,1,0,-90 +r3d. 0,1,0,-90  # Generate the 5 other sides.
    +r3d. 0,0,1,-90 +r3d. 0,0,1,180
    +3d
  nm $nm endl done v +

#@cli imagesphere3d : _resolution1>=3,_resolution2>=3
#@cli : Generate 3D mapped sphere from selected images.
#@cli : Default values: 'resolution1=32' and 'resolutions2=16'.
#@cli : $ image.jpg imagesphere3d 32,16
imagesphere3d : check "${1=32}>=3 && ${2=16}>=3"
  e[^-1] "Generate 3D mapped sphere from image$?, with resolutions ($1,$2)."
  v - to_rgb repeat $! l[$>] nm={0,n}

    # Generate object header.
    tw={w-1} th={h-1}                    # Maximum texture xy-coordinates.
    nbv={2+$1*($2-2)}                    # Number of vertices.
    nbp={$1*($2-1)}                      # Number of primitives.
    (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
     $nbv;$nbp)                          # Number of vertices and primitives.

    # Define sphere vertices.
    (0;0;1) (0;0;-1) (0,{2*pi};0,{2*pi}^0,0;{pi},{pi})
    r. {$1+1},$2,1,2,3 z. 0,1,{w-2},{h-2} s. c
    +sin. +sin... *[-2,-1] +cos.. sin... cos[-4] *[-4,-3]
    a[-3--1] c permute. cxyz y. a[-3--1] y

    # Define sphere primitives (triangles and quadrangles).
    repeat $1,v
      tx0={$v*$tw/$1} tx1={($v+1)*$tw/$1} ty1={$th/($2-1)}
      (9;0;{2+$v};{2+($v+1)%$1};{$tw/2};0;$tx0;$ty1;$tx1;$ty1) # Textured triangle from 1st pole.
      repeat {$2-3},u
        ty0=$ty1 ty1={($u+2)*$th/($2-1)} i0={2+$u*$1+$v} i1={2+$u*$1+($v+1)%$1}
        (12;$i0;{$i0+$1};{$i1+$1};$i1;$tx0;$ty0;$tx0;$ty1;$tx1;$ty1;$tx1;$ty0) # Textured quadrangle.
      done
      (9;1;{2+$1*($2-3)+($v+1)%$1};{2+$1*($2-3)+$v};{$tw/2};$th;$tx1;$ty1;$tx0;$ty1) # Textured triangle from 2nd pole.
    done
    a[-$nbp--1] y

    # Define sphere textures, opacities and generate object.
    mv[-4] $! i.. (-128;{w};{h};3) y. 1,{4*($nbp-1)},1,1,-128,0,0,0 1,$nbp,1,1,1 a y
  nm $nm endl done v +

#@cli isoline3d : isovalue[%] : 'formula',value,_x0,_y0,_x1,_y1,_size_x>0[%],_size_y>0[%] : (+)
#@cli : Extract 3D isolines with specified value from selected images or from specified formula.
#@cli : Default values: 'x0=y0=-3', 'x1=y1=3' and 'size_x=size_y=256'.
#@cli : $ image.jpg blur 1 isoline3d 50%
#@cli : $ isoline3d 'X=x-w/2;Y=y-h/2;(X^2+Y^2)%20',10,-10,-10,10,10

#@cli isosurface3d : isovalue[%] : 'formula',value,_x0,_y0,_z0,_x1,_y1,_z1,_size_x>0[%],_size_y>0[%],_size_z>0[%] : (+)
#@cli : Extract 3D isosurfaces with specified value from selected images or from specified formula.
#@cli : Default values: 'x0=y0=z0=-3', 'x1=y1=z1=3' and 'size_x=size_y=size_z=32'.
#@cli : $ image.jpg resize2dy 128 luminance threshold 50% expand_z 2,0 blur 1 isosurface3d 50% mul3d 1,1,30
#@cli : $ isosurface3d 'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))',3

#@cli label3d : "text",font_height>=0,_opacity,_color1,...
#@cli : Generate 3D text label.
#@cli : Default values: 'font_height=13', 'opacity=1' and 'color=255,255,255'.
label3d : check ${2=13}>=0 skip ${3=1},${4=255},${5=$4},${6=$5}
  e[^-1] "Generate 3D label '$1' with font height $2, opacity $3 and color (${4--1})."
  v - l[] 0 t "$1",0,0,$2,1,${4--1},255 sprite3d endl v +

#@cli label_points3d : _label_size>0,_opacity
#@cli : Add a numbered label to all vertices of selected 3D objects.
#@cli : Default values: 'label_size=13' and 'opacity=0.8'.
#@cli : $ torus3d 100,40,6,6 label_points3d 23,1 mode3d 1
label_points3d : check ${1=13}>0 skip ${2=0.8}
  e[^-1] "Label vertices of 3D object$?."
  v - repeat $!
    +p3d[$>] 0 l. s3d rm[-3--1]
    nbp={-2,@0} =.. $nbp,0,1                               # Set correct number of primitives
    (1,0;1,{$nbp-1}) r. 2,$nbp,1,1,3 r. 1,{2*h},1,1,-1    # Create new primitive data
    repeat $nbp                                            # Create texture labels as primitive colors.
      0 t. $>,0,0,$1,1,255,255,255 autocrop. 0
      i.. (-128;{w};{h};3) y.
    done
    repeat $nbp                                            # Create texture masks as primitive opacities.
      0 t. $>,0,0,$1,1,$2 autocrop. 0
      i.. (-128;{w};{h};1) y.
    done
    a y  # Merge final object data.
    endl
    +3d[$>,-1]
  done v +

#@cli lathe3d : _resolution>0,_smoothness[%]>=0,_max_angle>=0
#@cli : Generate 3D object from selected binary XY-profiles.
#@cli : Default values: 'resolution=128', 'smoothness=0.5%' and 'max_angle=361'.
#@cli : $ 300,300 rand -1,1 blur 40 sign normalize 0,255 lathe3d ,
lathe3d : check "${1=128}>0 && ${2=0.5%}>=0 && ${3=361}>=0"
  e[^-1] "Generate lathed 3D object from XY-profile$?, with resolution $1, smoothness $2 and maximum angle $3 deg."
  v - tmax={($3-180)*pi/180} norm n 0,1 autocrop 0
  repeat $! l[$>]
    wr={max(1,w2=2*w;if(w2>h,min($1,w2),min($1,h)*w2/h))}
    hr={max(1,w2=2*w;if(w2>h,min($1,w2)*h/w2,min($1,h)))}
    rmax={sqrt(($wr)^2+($hr)^2)/2}
    $wr,1,$wr,1,"xc = x - w/2; zc = z - d/2; t = atan2(zc,xc); if(t>"$tmax","$rmax",sqrt(xc*xc+zc*zc))"
    *. {2*({-2,w}-1)/(w-1)} r. $wr,$hr,$wr
    (0;{{-2,h}-1}) r. $wr,$hr,$wr,1,3 a[-2--1] c
    warp.. .,0,1,0 rm.
    expand_xyz 10,0 b $2 isosurface3d 50% rv3d
  endl done v +

#@cli l3d : eq. to 'light3d'. : (+)

#@cli light3d : position_x,position_y,position_z : [texture] : (no arg) : (+)
#@cli : Set the light coordinates or the light texture for 3D rendering.
#@cli : (eq. to 'l3d').\n
#@cli : (no arg) resets the 3D light to default.
#@cli : $ torus3d 100,30 double3d 0 specs3d 1.2 repeat 5 light3d {$>*100},0,-300 +snapshot3d[0] 400 done remove[0]

#@cli line3d : x0,y0,z0,x1,y1,z1
#@cli : Input 3D line at specified coordinates.
#@cli : $ repeat 100 a={$>*pi/50} line3d 0,0,0,{cos(3*$a)},{sin(2*$a)},0 color3d. ${-RGB} done add3d
line3d :
  e[^-1] "Input 3D line (${1-3})-(${4-6})."
  v - 1,21,1,1,67.5,73.5,109.5,103.5,51.5,100.5,2,1,${1-6},2,0,1,200,200,200,1 nm. [3D\ line] v +

#@cli lissajous3d : resolution>1,a,A,b,B,c,C
#@cli : Input 3D lissajous curves (x(t)=sin(a*t+A*2*pi),y(t)=sin(b*t+B*2*pi),z(t)=sin(c*t+C*2*pi)).
#@cli : Default values: 'resolution=1024', 'a=2', 'A=0', 'b=1', 'B=0', 'c=0' and 'C=0'.
#@cli : $ lissajous3d ,
lissajous3d : check ${1=1024}>1 skip ${2=2},${3=0},${4=1},${5=0},${6=0},${7=0}
  e[^-1] "Input 3D lissajous curve, with resolution $1, (a,A)=($2,$3), (b,B)=($4,$5) and (c,C)=($6,$7)."
  v -
  res={round($1)}

  # Define object header and vertices.
  (67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
  (0,{2*pi}) r. $res,1,1,1,3 [-1]x2
  *... $2 +... {$3*2*pi} *.. $4 +.. {$5*2*pi} *. $6 +. {$7*2*pi}
  a[-3--1] y sin. transpose. r. 1,{w*h},1,1,-1

  # Define object primitives, colors and opacities.
  1,{$res-1},1,1,2 (0;{$res-2}) r. 1,{$res-1},1,1,3 ++. 1 a[-3--1] x round. 1 r. 1,{w*h},1,1,-1
  1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 a[-5--1] y nm. [3D\ lissajou]
  v +

#@cli m3d : eq. to 'mode3d'. : (+)

#@cli mode3d : _mode : (+)
#@cli : Set static 3D rendering mode.
#@cli : (eq. to 'm3d').\n
#@cli : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.");
#@cli : Bounding-box mode ('mode==-1') is active only for the interactive 3D viewer.
#@cli : Default value: 'mode=4'.
#@cli : $ (0,1,2,3,4,5) double3d 0 repeat {w} torus3d 100,30 rotate3d[-1] 1,1,0,60 mode3d {0,@$>} snapshot3d[-1] 300 done remove[0]

#@cli md3d : eq. to 'moded3d'. : (+)

#@cli moded3d : _mode : (+)
#@cli : Set dynamic 3D rendering mode for interactive 3D viewer.
#@cli : (eq. to 'md3d').\n
#@cli : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@cli : Default value: 'mode=-1'.

#@cli *3d : eq. to 'mul3d'. : (+)

#@cli mul3d : factor : factor_x,factor_y,_factor_z : (+)
#@cli : Scale selected 3D objects isotropically or anisotropically, with specified factors.
#@cli : (eq. to '*3d').
#@cli : Default value: 'factor_z=0'.
#@cli : $ torus3d 5,2 repeat 5 +add3d[-1] 10,0,0 mul3d[-1] 1.2 color3d[-1] ${-RGB} done add3d

#@cli n3d : eq. to 'normalize3d'.
n3d :
  _normalize3d

#@cli normalize3d
#@cli : Normalize selected 3D objects to unit size.
#@cli : (eq. to 'n3d').
#@cli : $ repeat 100 circle3d {u(3)},{u(3)},{u(3)},0.1 done add3d color3d[-1] 255,0,0 +normalize3d[-1] color3d[-1] 0,255,0 add3d
normalize3d :
  _$0

_normalize3d :
  e[0--3] "Normalize size of 3D object$?."
  v - check3d 0 repeat $! l[$>]
    if {i[6]}
      s3d r[2] 3,{2,h/3},1,1,-1 s[2] x
      factor={v=max({2,iM-im},{3,iM-im},{4,iM-im});if(v,v,1)}
      a[2-4] x /[2] $factor y[2] a y
    fi
  endl done v +

#@cli o3d : eq. to 'opacity3d'. : (+)

#@cli opacity3d : _opacity : (+)
#@cli : Set opacity of selected 3D objects.
#@cli : (eq. to 'o3d').
#@cli : Default value: 'opacity=1'.
#@cli : $ torus3d 100,10 double3d 0 repeat 7 +rotate3d[-1] 1,0,0,20 opacity3d[-1] {u} done add3d

#@cli parametric3d : _x(a,b),_y(a,b),_z(a,b),_amin,_amax,_bmin,_bmax,_res_a>0,_res_b>0,_res_x>0,_res_y>0,_res_z>0,_smoothness>=0,_isovalue>=0
#@cli : Input 3D object from specified parametric surface (x(a,b),y(a,b),z(a,b)).
#@cli : Default values: 'x=(2+cos(b))*sin(a)', 'y=(2+cos(b))*cos(a)', 'c=sin(b)', 'amin=-pi', 'amax='pi', 'bmin=-pi', 'bmax='pi',
#@cli : 'res_a=512', 'res_b=res_a', 'res_x=64', 'res_y=res_x', 'res_z=res_y', 'smoothness=2%' and 'isovalue=10%'.
#@cli : $ parametric3d ,
parametric3d : skip "${1=(2+cos(b))*sin(a)}","${2=(2+cos(b))*cos(a)}","${3=sin(b)}"
               skip ${4={-pi}},${5={pi}},${6={-pi}},${7={pi}}
               check "${8=512}>0 && ${9=$8}>0 && ${10=64}>0 && ${11=$10}>0 && ${12=$11}>0 && \
                       ${13=2%}>=0 && ${14=10%}>=0"
  e[^-1] "Input 3D object from parametric surface ($1,$2,$3)."
  v -
  # Compute (x(a,b),y(a,b),z(a,b)) and normalize it.
  ($4,$5;$4,$5^$6,$6;$7,$7) r. $8,$9,1,2,3 channels. 0,2
  f. "a=i(x,y,0,0);b=i(x,y,0,1);if(c==0,$1,if(c==1,$2,$3))"
  sh. 0 xmin={im} xmax={iM} n. 16,{$10-17} rm.
  sh. 1 ymin={im} ymax={iM} n. 16,{$11-17} rm.
  sh. 2 zmin={im} zmax={iM} n. 16,{$12-17} rm.
  r. {w*h},3,1,1,-1

  # Extract 3D surface.
  pointcloud. 1 r. $10,$11,$12,1,0 b. $13,0
  isosurface3d. $14
  c3d. n3d. *3d. {$xmax-$xmin},{$ymax-$ymin},{$zmax-$zmin} nm. [3D\ parametric]
  v +

#@cli pca_patch3d : _patch_size>0,_M>0,_N>0,_normalize_input={ 0 | 1 },_normalize_output={ 0 | 1 },_lambda_xy
#@cli : Get 3D patch-pca representation of selected images.
#@cli : The 3D patch-pca is estimated from M patches on the input image, and displayed as a cloud of N 3D points.
#@cli : Default values: 'patch_size=7', 'M=1000', 'N=3000', 'normalize_input=1', 'normalize_output=0', and 'lambda_xy=0'.
#@cli : $ image.jpg pca_patch3d 7
pca_patch3d : check "isint(${1=7}) && $1>0 && isint(${2=1000}) && $2>0 && isint(${3=3000}) && $3>0" skip ${4=1},${5=0},${6=0}
  e[^-1] "Get 3D patch-pca representation"${arg\ 1+($!>1),s,""}" of image$?, from $2 $1x$1 input patches, "\
          "with $3 output patches, input normalization "${arg\ 1+!$4,enabled,disabled}", output normalization "\
          ${arg\ 1+!$5,enabled,disabled}" and lambda_xy $6."
  v -
  P1={int($1/2)}       # Backward half-patch size.
  P2={$1-$P1-1}        # Forward half-patch size.

  n 0,255 round 1
  repeat $! l[$>] nm={0,n}
    s={s}

    # Pick set of M random located patches.
    1,$2 rand. 0,{0,w-1} +rand. 0,{0,h-1} +f. 0 a[-3--1] x round. 1 +patches[0] $1,$1,1,{^} y[2--1] a[2--1] x
    z[1] 0,1 transpose[1] *[1] $6 a[1,2] y s[^0] x

    # Normalize patch coordinates by using average and standard deviation.
    ++[^0] /. $2 -[1--2] . rm.
    a[^0] x
    if $4 l. s y / 'sqrt(1e-8+iv)' a y endl fi

    # Do PCA for dimension reduction.
    +transpose. m*[-2,-1]
    eigen. rows.. 0,2 columns. 0,2 transpose.
    if $5 sqrt.. /.. {-2,iM} r.. . /. .. fi
    rm..

    # Pick set of N random located patches.
    repeat $3
      x={round(u({0,w}))}
      y={round(u({0,h}))}
      ({$6*$x};{$6*$y})
      +z[0] {$x-$P1},{$y-$P1},{$x+$P2},{$y+$P2},1
      y. a[-2,-1] y
    done

    # Generate 3D representation of the projected patch set.
    +a[2--1] x m*[1,-1] transpose[1]                    # Vertex coordinates.
    rows[2--1] 2,100%                                     # Colors
    if {$s!=3}
      r[2--1] $1,$1,1,{min(3,$s)},-1
      r[2--1] $1,$1,1,3,{if($s!=1,0,1)}
      y[2--1]
    fi
    i[2--2] (-128;$1;$1;3) a[2--1] y
    rm[0]                                                 # Remove input image (now useless).
    i[0] ({'CImg3d'})                                     # Header.
    i[1] ($3;$3)                                          # Geometry.
    i[3] 2,$3,1,1,if(x==0,1,y)                            # Primitives.
    1,$3,1,1,1                                             # Opacities.
    y a[-6--1] y                                         # Merge as a 3D object.

  nm $nm endl done v +

#@cli plane3d : _size_x,_size_y,_nb_subdivisions_x>0,_nb_subdisivions_y>0
#@cli : Input 3D plane at (0,0,0), with specified geometry.
#@cli : Default values: 'size_x=1', 'size_y=size_x' and 'nb_subdivisions_x=nb_subdivisions_y=24'.
#@cli : $ plane3d 50,30 +primitives3d 1 color3d[-2] ${-RGB}
plane3d : check "${3=24}>0 && ${4=24}>0" skip ${1=1},${2=$1}
  e[^-1] "Input 3D plane, with size (${1,2}) and subdivisions (${3,4})."
  v - {$3+1},{$4+1} elevation3d. 0 *3d. {$1/$3},{$2/$4} col3d. 200 nm. [3D\ plane] v +

#@cli point3d : x0,y0,z0
#@cli : Input 3D point at specified coordinates.
#@cli : $ repeat 1000 a={$>*pi/500} point3d {cos(3*$a)},{sin(2*$a)},0 color3d[-1] ${-RGB} done add3d
point3d :
  e[^-1] "Input 3D point ($1,$2,$3)."
  v - 1,17,1,1,67.5,73.5,109.5,103.5,51.5,100.5,1,1,${1-3},1,0,200,200,200,1 nm. [3D\ point] v +

#@cli pointcloud3d
#@cli : Convert selected planar or volumetric images to 3D point clouds.
#@cli : $ image.jpg luminance resize2dy 100 threshold 50% mul 255 pointcloud3d color3d[-1] 255,255,255
pointcloud3d :
  e[^-1] "Convert image$? to 3D point cloud."
  v - repeat $! l[$>] nm={0,n}
    s z repeat $! l[$>]
      +norm !=. 0
      i.. (1,{w};1,{w}^1,1;{h},{h}) r.. .,.,1,2,3 *[-2,-1] round. permute. cxyz
      l. s -,0 a y is_points=$! endl
      if $is_points
        -. 1 r. 2,{h/2},1,1,-1 permute. cyzx +warp.. .,0,0 rm...
        permute.. cyzx i.. 1,{h},1,1,$> a[-3,-2] x    # Coordinates.
        i... ({'CImg3d'}) i... ({h},{h})               # Header and size.
        i.. 1,{h},1,1,1 i.. 1,{h},1,1,y a[-3,-2] x    # Primitives.
        permute. cyzx                                   # Colors.
        if {w==1} r. 3,{h},1,1
        elif {w>3} i.. 4,{h},1,1,-128,1,1,{w} a[-2,-1] x
        else r. 3,{h},1,1,0
        fi
        1,{h},1,1,1                                      # Opacities.
        y[-6--1] a[-6--1] y
      else rm empty3d
      fi
      endl done
    +3d
  nm $nm endl done v +

#@cli pose3d : p1,...,p12
#@cli : Apply 3D pose matrix to selected 3D objects.
#@cli : $ torus3d 100,20 pose3d 0.152437,1.20666,-0.546366,0,-0.535962,0.559129,1.08531,0,1.21132,0.0955431,0.548966,0,0,0,-206,1 snapshot3d 400
pose3d :
  e[^-1] "Apply 3D pose matrix [ $1,$2,$3,$4; $5,$6,$7,$8; $9,$10,$11,$12 ] to 3D object$?."
  v - repeat $! l[$>] if ${-_is_3d}
    s3d r[2] 3,{2,h/3},1,1,-1 i[3] 1,{2,h},1,1,1 a[2,3] x
    i[3] ($1,$5,$9;$2,$6,$10;$3,$7,$11;$4,$8,$12) m*[2,3]
    r[2] 1,{2,3*h},1,1,-1 a y
  else v + error "Command '$0': Image ["{$!-$>-1}"] does not represent a 3D object."
  fi endl done v +

#@cli p3d : eq. to 'primitives3d'. : (+)
p3d : check "isint($1) && $1>=0 && $1<=2"
  _primitives3d $*

#@cli primitives3d : mode
#@cli : Convert primitives of selected 3D objects.
#@cli : (eq. to 'p3d').\n
#@cli : 'mode' can be { 0=points | 1=outlines | 2=non-textured }.
#@cli : $ sphere3d 30 primitives3d 1 torus3d 50,10 color3d[-1] ${-RGB} add3d
primitives3d : check "isint($1) && $1>=0 && $1<=2"
  _$0 $*

_primitives3d :
  e[0--3] "Convert primitives of 3D object$? to "${"arg 1+$1,points,outlines,non-textured"}"."
  v - repeat $! l[$>]
    s3d 1,64 .x2
    eval "
      const mode = $1;

      # Read a RGBA color from the current primitive material.
      get_RGBA(tx,ty,goto_next) = (
        R = i[#4,pc];
        R!=-128?( # RGB color
          G = i[#4,pc+1];
          B = i[#4,pc+2];
          goto_next?(pc+=3);
        ):( # Texture
          W = i[#4,pc+1]; H = i[#4,pc+2]; S = i[#4,pc+3]; WH = W*H;
          WH?( # Non-shared texture
            off = pc + (ty%H)*W + (tx%W) + 4;
            goto_next?(pc+=WH*S + 4);
          ):( # Shared texture
            off = pcol[W];
            i[#4,off]==-128?(
              ++off;
              W = i[#4,off++]; H = i[#4,off++]; S = i[#4,off++]; WH = W*H;
              off += (ty%H)*W + (tx%W);
            ):(WH=1);
            goto_next?(pc+=4);
          );
          R = i[#4,off];
          S==1?(G = B = R):(
            G = i[#4,off + WH];
            S==2?(B = 0):(
              B = i[#4,off + 2*WH];
            );
          );
        );

        A = i[#5,po];
        A==-128?( # Texture
          W = i[#5,po+1]; H = i[#5,po+2]; S = i[#5,po+3]; WH = W*H;
          WH?( # Non-shared texture
            off = po + (ty%H)*W + (tx%W) + 4;
            goto_next?(po+=WH*S + 4);
          ):( # Shared texture
            off = popa[W];
            i[#5,off]==-128?(
              ++off;
              W = i[#5,off++]; H = i[#5,off++]; S = i[#5,off++]; WH = W*H;
              off += (ty%H)*W + (tx%W);
            );
            goto_next?(po+=4);
          );
          A = i[#5,off];
        );
      );

      # Copy material of current primitives 'nb' times.
      copy_material(nb) = (
        R = i[#4,pc++]; G = i[#4,pc++]; B = i[#4,pc++];
        R!=-128?( # RGB color
          unref(data); data = [ R,G,B ];
          for (k = 0, k<nb, ++k, copy(i[#-2,qc],data,3); qc+=3);
        ):(
          W = G; H = B; S = i[#4,pc++]; WHS = W*H*S;
          WHS?( # Non-shared texture
            qc + WHS + 4*nb>=h(#-2)?resize(#-2,1,int(1.5*qc + WHS + 4*nb),1,1,0,0);
            copy(i[#-2,qc],i[#4,pc-4],WHS+4);
            pc+=WHS; qc+=WHS+4;
            unref(data); data = [-128,nq,0,0];
            for (k = 1, k<nb, ++k, copy(i[#-2,qc],data,4); qc+=4);
          ):( # Shared texture
            unref(data); data = [-128,pref[W],0,0];
            for (k = 0, k<nb, ++k, copy(i[#-2,qc],data,4); qc+=4);
          );
        );

        A = i[#5,po++];
        A!=-128?( # Opacity value
          for (k = 0, k<nb, ++k, i[#-1,qo++] = A);
        ):( # Texture
          W = i[#5,po++]; H = i[#5,po++]; S = i[#5,po++]; WHS = W*H*S;
          WHS?( # Non-shared texture
            qo + WHS + 4*nb>=h(#-1)?resize(#-1,1,int(1.5*qo + WHS + 4*nb),1,1,0,0);
            copy(i[#-1,qo],i[#5,po-4],WHS+4);
            po+=WHS; qo+=WHS+4;
            unref(data); data = [-128,nq,0,0];
            for (k = 1, k<nb, ++k, copy(i[#-1,qo],data,4); qo+=4);
          ):( # Shared texture
            unref(data); data = [ -128,pref[W],0,0 ];
            for (k = 0, k<nb, ++k, copy(i[#-1,qo],data,4); qo+=4);
          );
        );
      );

      # Add a new colored point primitive.
      add_point(ind,R,G,B,A) = (
        copy(i[#-3,qp],[1,ind],2); qp+=2;
        copy(i[#-2,qc],[R,G,B],3); qc+=3;
        i[#-1,qo++] = A;
        ++nq;
      );

      # Add a new colored segment primitive.
      add_segment(ind0,ind1,R,G,B,A) = (
        copy(i[#-3,qp],[2,ind0,ind1],3); qp+=3;
        copy(i[#-2,qc],[R,G,B],3); qc+=3;
        i[#-1,qo++] = A;
        ++nq;
      );

      pcol = popa = pref = vector"{i[#1,1]}"();
      for (pp = pc = po = qp = qc = qo = np = nq = 0, pp<h#3, ++np,
        qp + 28>=h(#-3)?resize(#-3,1,int(1.5*qp + 28),1,1,0,0);
        qc + 16>=h(#-2)?resize(#-2,1,int(1.5*qc + 16),1,1,0,0);
        qo + 4>=h(#-1)?resize(#-1,1,int(1.5*qo + 4),1,1,0,0);
        N = i[#3,pp++];
        pcol[np] = pc;
        popa[np] = po;
        pref[np] = nq;

        N==1?( # Colored point
          v0 = i[#3,pp++];
          get_RGBA(0,0,1);
          add_point(v0,R,G,B,A);

        ):N==2?( # Colored segment
          v0 = i[#3,pp++]; v1 = i[#3,pp++];
          get_RGBA(0,0,1);
          mode==0?(
            add_point(v0,R,G,B,A);
            add_point(v1,R,G,B,A);
          ):(
            add_segment(v0,v1,R,G,B,A);
          );

        ):N==3?( # Colored triangle
          v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++];
          get_RGBA(0,0,1);
          mode==0?(
            add_point(v0,R,G,B,A);
            add_point(v1,R,G,B,A);
            add_point(v2,R,G,B,A);
          ):mode==1?(
            add_segment(v0,v1,R,G,B,A);
            add_segment(v1,v2,R,G,B,A);
            add_segment(v2,v0,R,G,B,A);
          ):(
            copy(i[#-3,qp],i[#3,pp-4],4); qp+=4;
            copy(i[#-2,qc],i[#4,pc-3],3); qc+=3;
            i[#-1,qo++] = A;
            ++nq;
          );

        ):N==4?( # Colored quadrangle
          v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++]; v3 = i[#3,pp++];
          get_RGBA(0,0,1);
          mode==0?(
            add_point(v0,R,G,B,A);
            add_point(v1,R,G,B,A);
            add_point(v2,R,G,B,A);
            add_point(v3,R,G,B,A);
          ):mode==1?(
            add_segment(v0,v1,R,G,B,A);
            add_segment(v1,v2,R,G,B,A);
            add_segment(v2,v3,R,G,B,A);
            add_segment(v3,v0,R,G,B,A);
          ):(
            copy(i[#-3,qp],i[#3,pp-5],5); qp+=5;
            copy(i[#-2,qc],i[#4,pc-3],3); qc+=3;
            i[#-1,qo++] = A;
            ++nq;
          );

        ):N==5?( # Colored sphere
          v0 = i[#3,pp++]; v1 = i[#3,pp++]; i[#3,pp++] = (mode==1); v2 = i[#3,pp++]; v3 = i[#3,pp++];
          get_RGBA(0,0,1);
          mode==0?(
            x0 = i[#2,3*v0]; y0 = i[#2,3*v0+1]; z0 = i[#2,3*v0+2];
            x1 = i[#2,3*v1]; y1 = i[#2,3*v1+1]; z1 = i[#2,3*v1+2];
            copy(i[#2,3*v0],([ x0,y0,z0 ] + [ x1,y1,z1 ])/2,3);
            add_point(v0,R,G,B,A);
          ):(
            copy(i[#-3,qp],i[#3,pp-6],6); qp+=6;
            copy(i[#-2,qc],i[#4,pc-3],3); qc+=3;
            i[#-1,qo++] = A;
            ++nq;
          );

        ):N==6?( # Textured segment
          v0 = i[#3,pp++]; v1 = i[#3,pp++];
          tx0 = i[#3,pp++]; ty0 = i[#3,pp++]; tx1 = i[#3,pp++]; ty1 = i[#3,pp++];
          mode==0?(
            get_RGBA(tx0,ty0,0); add_point(v0,R,G,B,A);
            get_RGBA(tx1,ty1,1); add_point(v1,R,G,B,A);
          ):mode==1?(
            copy(i[#-3,qp],i[#3,pp-7],7); qp+=7;
            copy_material(1);
            ++nq;
          ):(
            get_RGBA(tx0,ty0,0); R0 = R; G0 = G; B0 = B; A0 = A;
            get_RGBA(tx1,ty1,1); (R0+=R)/=2; (G0+=G)/=2; (B0+=B)/=2; (A0+=A)/=2;
            add_segment(v0,v1,R0,G0,B0,A0);
          );

        ):N==9?( # Textured triangle
          v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++];
          tx0 = i[#3,pp++]; ty0 = i[#3,pp++]; tx1 = i[#3,pp++]; ty1 = i[#3,pp++]; tx2 = i[#3,pp++]; ty2 = i[#3,pp++];
          mode==0?(
            get_RGBA(tx0,ty0,0); add_point(v0,R,G,B,A);
            get_RGBA(tx1,ty1,0); add_point(v1,R,G,B,A);
            get_RGBA(tx2,ty2,1); add_point(v2,R,G,B,A);
          ):mode==1?(
            copy(i[#-3,qp],[ 6,v0,v1,tx0,ty0,tx1,ty1,
                             6,v1,v2,tx1,ty1,tx2,ty2,
                             6,v2,v0,tx2,ty2,tx0,ty0 ],21); qp+=21;
            copy_material(3);
            nq+=3;
          ):(
            get_RGBA(tx0,ty0,0); R0 = R; G0 = G; B0 = B; A0 = A;
            get_RGBA(tx1,ty1,0); R0+=R; G0+=G; B0+=B; A0+=A;
            get_RGBA(tx2,ty2,2); (R0+=R)/=3; (G0+=G)/=3; (B0+=B)/=3; (A0+=A)/=3;
            copy(i[#-3,qp],[ 3,v0,v1,v2 ],4); qp+=4;
            copy(i[#-2,qc],[ R,G,B ],3); qc+=3;
            i[#-1,qo++] = A;
            ++nq;
          );

        ):N==12?( # Textured quadrangle
          v0 = i[#3,pp++]; v1 = i[#3,pp++]; v2 = i[#3,pp++]; v3 = i[#3,pp++];
          tx0 = i[#3,pp++]; ty0 = i[#3,pp++]; tx1 = i[#3,pp++]; ty1 = i[#3,pp++]; tx2 = i[#3,pp++]; ty2 = i[#3,pp++]; tx3 = i[#3,pp++]; ty3 = i[#3,pp++];
          mode==0?(
            get_RGBA(tx0,ty0,0); add_point(v0,R,G,B,A);
            get_RGBA(tx1,ty1,0); add_point(v1,R,G,B,A);
            get_RGBA(tx2,ty2,0); add_point(v2,R,G,B,A);
            get_RGBA(tx3,ty3,1); add_point(v3,R,G,B,A);
          ):mode==1?(
            copy(i[#-3,qp],[ 6,v0,v1,tx0,ty0,tx1,ty1,
                             6,v1,v2,tx1,ty1,tx2,ty2,
                             6,v2,v3,tx2,ty2,tx3,ty3,
                             6,v3,v0,tx3,ty3,tx0,ty0 ],28); qp+=28;
            copy_material(4);
            nq+=4;
          ):(
            get_RGBA(tx0,ty0,0); R0 = R; G0 = G; B0 = B; A0 = A;
            get_RGBA(tx1,ty1,0); R0+=R; G0+=G; B0+=B; A0+=A;
            get_RGBA(tx2,ty2,0); R0+=R; G0+=G; B0+=B; A0+=A;
            get_RGBA(tx3,ty3,2); (R0+=R)/=4; (G0+=G)/=4; (B0+=B)/=4; (A0+=A)/=4;
            copy(i[#-3,qp],[ 4,v0,v1,v2,v3 ],5); qp+=5;
            copy(i[#-2,qc],[ R,G,B ],3); qc+=3;
            i[#-1,qo++] = A;
            ++nq;
          );
        );
      );
      resize(#-3,1,qp,1,1,0,0);
      resize(#-2,1,qc,1,1,0,0);
      resize(#-1,1,qo,1,1,0,0);
      i[#1,1] = nq"

    rm[3-5] a y
  endl done v +

#@cli projections3d : _x[%],_y[%],_z[%],_is_bounding_box={ 0 | 1 }
#@cli : Generate 3D xy,xz,yz projection planes from specified volumetric images.
projections3d : skip ${1=50%},${2=50%},${3=50%},${4=1}
  e[^-1] "Generate 3D xy,xz,yz projection planes from image$?."
  v - n 0,255 repeat $! l[$>]
    w={w} h={h} d={d}
    x={if(${is_percent\ $1},$1*w,$1)}
    y={if(${is_percent\ $2},$2*h,$2)}
    z={if(${is_percent\ $3},$3*d,$3)}
    +rows $2,$2 r. {w},{d},1,100%,-1
    +columns.. $1,$1 permute. zyxc
    slices... $3,$3 r[-3--1] 100%,100%,1,3
    imageplane3d[-3--1]
    r3d. 0,1,0,-90 r3d.. 1,0,0,90
    +3d... 0,0,$z +3d.. 0,$y,0 +3d. $x,0,0
    +3d[-3--1] o3d. 0.8
    if $4 box3d $w,$h,$d p3d. 1 o3d. 0.4 +3d[-2,-1] fi
  endl done v +

#@cli pyramid3d : width,height
#@cli : Input 3D pyramid at (0,0,0), with specified geometry.
#@cli : $ pyramid3d 100,-100 +primitives3d 1 color3d[-2] ${-RGB}
pyramid3d :
  e[^-1] "Input new 3D pyramid, with width $1 and height $2."
  v -
  (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
   5;5;\                               # Number of vertices and primitives.
   {-$1/2};{-$1/2};{-$2/2};\           # Vertex coordinates.
   {$1/2};{-$1/2};{-$2/2};\
   {$1/2};{$1/2};{-$2/2};\
   {-$1/2};{$1/2};{-$2/2};\
   0;0;{$2/2};\
   4;0;3;2;1;\                         # Primitives description.
   3;0;4;3;\
   3;1;4;0;\
   3;2;4;1;\
   3;3;4;2)
  1,15,1,1,200 1,5,1,1,1 a[-3--1] y nm. [3D\ pyramid]
  v +

#@cli quadrangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3
#@cli : Input 3D quadrangle at specified coordinates.
#@cli : $ quadrangle3d -10,-10,10,10,-10,10,10,10,10,-10,10,10 repeat 10 +rotate3d[-1] 0,1,0,30 color3d[-1] ${-RGB},0.6 done add3d mode3d 2
quadrangle3d :
  e[^-1] "Input 3D quadrangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12)."
  v - 1,29,1,1,67.5,73.5,109.5,103.5,51.5,100.5,4,1,${1-12},4,0,1,2,3,200,200,200,1 nm. [3D\ quadrangle] v +

#@cli random3d : nb_points>=0
#@cli : Input random 3D point cloud in [0,1]^3.
#@cli : $ random3d 100 circles3d 0.1 opacity3d 0.5
random3d : check "$1>=0"
  e[^-1] "Input random 3D point cloud, with $1 points."
  v -
  if {$1<0.5} empty3d
  else l[]
    N={round($1)}
    ({'CImg3d'},$N,$N)
    3,$N rand. 0,1
    1,$N,1,1,1 1,$N,1,1,y a[-2,-1] x
    3,$N,1,1,200 1,$N,1,1,1
    y a y
  endl fi
  nm. [3D\ random\ pointcloud]
  v +

#@cli rv3d : eq. to 'reverse3d'. : (+)

#@cli reverse3d : (+)
#@cli : Reverse primitive orientations of selected 3D objects.
#@cli : (eq. to 'rv3d').
#@cli : $ torus3d 100,40 double3d 0 +reverse3d

#@cli r3d : eq. to 'rotate3d'. : (+)

#@cli rotate3d : u,v,w,angle : (+)
#@cli : Rotate selected 3D objects around specified axis with specified angle (in deg.).
#@cli : (eq. to 'r3d').
#@cli : $ torus3d 100,10 double3d 0 repeat 7 +rotate3d[-1] 1,0,0,20 done add3d

#@cli rotation3d : u,v,w,angle
#@cli : Input 3x3 rotation matrix with specified axis and angle (in deg).
#@cli : $ rotation3d 1,0,0,0 rotation3d 1,0,0,90 rotation3d 1,0,0,180
rotation3d :
  e[^-1] "Input 3D rotation matrix around axis ($1,$2,$3) with angle $4 deg."
  v - 3,3,1,1,{"rot(${1-4})"} nm. [3D\ rotation] v +

#@cli sierpinski3d : _recursion_level>=0,_width,_height
#@cli : Input 3d Sierpinski pyramid.
#@cli : $ sierpinski3d 3,100,-100 +primitives3d 1 color3d[-2] ${-RGB}
sierpinski3d : check ${1=4}>=0 skip ${2=1},${3=1}
-e[^-1] "Input 3D Sierpinski pyramid of degree $1, with width $2 and height $3."
  v - l[] _sierpinski3d {-$2/2},{-$2/2},{-$3/2},{$2/2},{-$2/2},{-$3/2},{$2/2},{$2/2},{-$3/2},{-$2/2},{$2/2},{-$3/2},0,0,{$3/2},$1 +3d endl
  nm. [3D\ sierpinski] v +

_sierpinski3d :
  if {$16<=0}
    (67.5;73.5;109.5;103.5;51.5;100.5;\
     5;5;\
     $1;$2;$3;\
     $4;$5;$6;\
     $7;$8;$9;\
     $10;$11;$12;\
     $13;$14;$15;\
     4;0;3;2;1;\
     3;0;4;3;\
     3;1;4;0;\
     3;2;4;1;\
     3;3;4;2)
    1,15,1,1,200 1,5,1,1,1 a[-3--1] y
  return fi
  _sierpinski3d $1,$2,$3,\
                 {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
                 {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
                 {$16-1}
  _sierpinski3d {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
                 $4,$5,$6,\
                 {($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
                 {$16-1}
  _sierpinski3d {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
                 $7,$8,$9,\
                 {($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
                 {($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
                 {$16-1}
  _sierpinski3d {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
                 $10,$11,$12,\
                 {($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
                 {$16-1}
  _sierpinski3d {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
                 {($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
                 {($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
                 {($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
                 $13,$14,$15,\
                 {$16-1}

#@cli size3d
#@cli : Return bounding box size of the last selected 3D object.
size3d :
  v - +rows. 8,{8+3*i[6]} r. 3,{h/3},1,1,-1 s. x,3
  u {-3,iM-im},{-2,iM-im},{iM-im}
  rm[-3--1] v +

#@cli skeleton3d : _metric,_frame_type={ 0=squares | 1=diamonds | 2=circles | 3=auto },_skeleton_opacity,_frame_opacity,_is_frame_wireframe={ 0 | 1 }
#@cli : Build 3D skeletal structure object from 2d binary shapes located in selected images.
#@cli : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean }.
#@cli : Default values: 'metric=2', 'bones_type=3', 'skeleton_opacity=1' and 'frame_opacity=0.1'.
#@cli : $ shape_cupid 480 +skeleton3d ,
skeleton3d : check "isint(${1=2}) && $1>=0 && $1<=2 && isint(${2=3}) && $2>=0 && $2<=3" skip ${3=1},${4=0.1},${5=1}
  e[^-1] "Build 3D skeletal structure object from image$?, with "${arg\ 1+$1,chebyshev,manhattan,euclidean}" metric, "\
          ${arg\ 1+$2,squares,diamonds,circles,auto}" bones, skeleton opacity $3 and frame opacity $4 ."
  v - repeat $! l[$>] channels 0

    # Construct skeleton representation.
    +distance 0,$1
    +f. "(i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"
    if $3 +slices. -1,0 isosurface3d. 0.5 o3d. $3 col3d. 255,0,0 fi
    *[0-2] pointcloud3d[0]

    # Construct bones from skeleton.
    if $4 l[0] s3d 1
      n={1,@0}
      if $n
        r[2] 3,$n,1,1,-1 r[3] 2,$n,1,1,-1 r[4] 3,$n,1,1,-1

        if {$2==0" || "($2==3" && "$1==0)} # Frame with squares.
          =[1] {4*$n}
          i[3] [2]x3 +z.. 0,1 z. 0,2 -[2] . +[4] .
          s. x *.. -1 a[-3--1] x +[3] . -[5,-1] a[2-5] x
          rm[3] 1,$n,1,1,4 +f. 4*y ++. 1 ++. 1 ++. 1 rv[-3,-1] a[-5--1] x mv. 3

        elif {$2==1" || "($2==3" && "$1==1)} # Frame with diamonds.
          =[1] {4*$n}
          i[3] [2]x3 +z.. 0,0 z. 0,2 -[2] . +[4] .
          shift. 1,0 -[3] . +[5,-1] a[2-5] x
          rm[3] 1,$n,1,1,4 +f. 4*y ++. 1 ++. 1 ++. 1 rv[-3,-1] a[-5--1] x mv. 3

        elif {$2==2" || "($2==3" && "$1==2)} # Frame with circles.
          =[1] {2*$n}
          +z[4] 0,0 z. 0,2 ++[2,-1] -[2,-2] a[2,-1] x
          rm[3] 1,$n,1,1,5 +f. 2*y ++. 1 3,100% a[-4--1] x mv. 3
        fi
        y a y o3d $4 if $5 p3d 1 fi col3d 200
      else rm empty3d fi
    endl else rm[0] fi
    +3d
  endl done v +

#@cli snapshot3d : _size>0,_zoom>=0,_backgroundR,_backgroundG,_backgroundB,_backgroundA : [background_image],zoom>=0
#@cli : Take 2d snapshots of selected 3D objects.
#@cli : Set 'zoom' to 0 to disable object auto-scaling.
#@cli : Default values: 'size=512', 'zoom=1' and '[background_image]=(default)'.
#@cli : $ torus3d 100,20 rotate3d 1,1,0,60 snapshot3d 400,1.2,128,64,32
#@cli : $ torus3d 100,20 rotate3d 1,1,0,60 sample ? +snapshot3d[0] [1],1.2
snapshot3d : check "${2=1}>=0" skip ${1=512},${3=""}
  if ${"is_image_arg $1"} # Background image specified.
    e[0--3] "Take $1x$1 snapshot$? of 3D object$?, with zoom factor $2 and background image $3."
    v - pass$1 0 to_color.
  elif {isval($3)} # Background color specified.
    e[0--3] "Take $1x$1 snapshot$? of 3D object$?, with zoom factor $2 and background color ${3--1}."
    v - (${3--1}) y. c r. $1,$1 to_color.
  else # Default background color.
    e[0--3] "Take $1x$1 snapshot$? of 3D object$?, with zoom factor $2 and default background."
    v - 1,2,1,3,32,64,32,116,64,96 r. $1,$1,1,3,3
  fi
  repeat {$!-1} . l[$>,-1]
    if {$2!=0} c3d[0] n3d[0] *3d[0] {3*min(w,h)*$2/4} fi
    if {s>3} # RGBA rendering.
      100%,100%,1,3,-1 j3d. [0],50%,50%,0,1
      to_rgba. replace_color. 0,0,-1,-1,-1,255,0,0,0,0 blend[-2,-1] alpha
    else # RGB rendering.
      j3d[1] [0],50%,50%,0,1
    fi
   nm[1] {-2,n} rm[0]
  endl done rm. v +

#@cli sl3d : eq. to 'specl3d'. : (+)

#@cli specl3d : value>=0 : (+)
#@cli : Set lightness of 3D specular light.
#@cli : (eq. to 'sl3d').
#@cli : Default value: 'value=0.15'.
#@cli : $ (0,0.3,0.6,0.9,1.2) repeat {w} torus3d 100,30 rotate3d[-1] 1,1,0,60 color3d[-1] 255,0,0 specl3d {0,@$>} snapshot3d[-1] 400 done remove[0]

#@cli ss3d : eq. to 'specs3d'. : (+)

#@cli specs3d : value>=0 : (+)
#@cli : Set shininess of 3D specular light.
#@cli : (eq. to 'ss3d').
#@cli : Default value: 'value=0.8'.
#@cli : $ (0,0.3,0.6,0.9,1.2) repeat {w} torus3d 100,30 rotate3d[-1] 1,1,0,60 color3d[-1] 255,0,0 specs3d {0,@$>} snapshot3d[-1] 400 done remove[0]

#@cli sphere3d : radius,_nb_recursions>=0 : (+)
#@cli : Input 3D sphere at (0,0,0), with specified geometry.
#@cli : Default value: 'nb_recursions=3'.
#@cli : $ sphere3d 100 +primitives3d 1 color3d[-2] ${-RGB}

#@cli spherical3d : _nb_azimuth>=3,_nb_zenith>=3,_radius_function(phi,theta)
#@cli : Input 3D spherical object at (0,0,0), with specified geometry.
#@cli : Default values: 'nb_zenith=nb_azimut=64' and 'radius_function="abs(1+0.5*cos(3*phi)*sin(4*theta))"'.
#@cli : $ spherical3d 64 +primitives3d 1
spherical3d : check "${1=64}>=3 && ${2=$1}>=3" skip "${3=abs(1+0.5*cos(3*phi)*sin(4*theta))}"
  e[^-1] "Input 3D spherical object, with subdivisions ($1,$2) and height function '$3'."
  v -
  ({'CImg3d'}) y. # Magic number.
  n1={round($1)} n2={round($2)}

  # Define 3D vertices.
  $n1,{$n2-1},1,3,"phi = 2*pi*(x+0.5)/w;\
                   theta = -pi/2+pi*(y+0.5)/h;\
                   cp = cos(phi);\
                   sp = sin(phi);\
                   ct = cos(theta);\
                   ($3)*if(c==0,ct*cp,if(c==1,ct*sp,sin(theta)))"
  r. {w*h},3,1,1,-1 permute. yxzc
  i.. (0,0,{phi=0;theta=-pi/2;-$3};0,0,{phi=0;theta=pi/2;$3}) a[-2,-1] y  # Add the two poles.
  nbv={h} y.

  # Define 3D primitives.
  $n1,{$n2-2},1,4,"nx=(x+1)%w;ny=(y+1);2+if(c==0,x+y*"$n1",if(c==1,nx+y*"$n1",if(c==2,nx+ny*"$n1",x+ny*"$n1")))"
  r. {w*h},4,1,1,-1 permute. yxzc i.. 1,{h},1,1,4 a[-2,-1] x
  2,$n1,1,1,3,0 1,$n1,1,1,'y' ++. 1 %. {h} 2,$n1,1,1,3,1 [-3,-2]  # Connect the two poles.
  +[-5,-4] 2 rv[-5,-4] +[-2,-1] {$nbv-$n1} a[-3--1] x a[-4--2] x
  nbp={h+{-2,h}+{-3,h}}
  y[-3--1] a[-3--1] y

  # Define other object information (properties, colors and opacities).
  i... ($nbv;$nbp)
  1,{3*$nbp},1,1,200 1,$nbp,1,1,1 a[-2,-1] y

  # Append as a 3D object.
  a[-5--1] y nm. "[3D spherical surface '$3']"
  v +

#@cli spline3d : x0[%],y0[%],z0[%],u0[%],v0[%],w0[%],x1[%],y1[%],z1[%],u1[%],v1[%],w1[%],_nb_vertices>=2
#@cli : Input 3D spline with specified geometry.
#@cli : Default values: 'nb_vertices=128'.
#@cli : $ repeat 100 spline3d {u},{u},{u},{u},{u},{u},{u},{u},{u},{u},{u},{u},128 color3d[-1] ${-RGB} done box3d 1 primitives3d[-1] 1 add3d
spline3d : check ${13=128}>=2
  e[^-1] "Input new 3D spline from (${1-3}) [${4-6}] to (${7-9}) [${10-12}] with $13 vertices."
  v -
  ({'CImg3d'}) +. 0.5   # Header.
  ($13;{$13-1})          # Nb vertices / primitives.
  # Define vertices.
  1,$13,1,1,1 (0;1) r. 1,$13,1,1,3 +sqr. +*[-2,-1] a[-4--1] x
  +*. '$2,$5,{3*(($8)-($2))-2*($5)-($11)},{($5)+($11)+2*(($2)-($8))}' l. s x + endl
  +*.. '$3,$6,{3*(($9)-($3))-2*($6)-($12)},{($6)+($12)+2*(($3)-($9))}' l. s x + endl
  *... '$1,$4,{3*(($7)-($1))-2*($4)-($10)},{($4)+($10)+2*(($1)-($7))}' l... s x + endl
  a[-3--1] x
  1,{$13-1},1,1,2 (0,1;{$13-2},{$13-1}) r. 2,..,1,1,3 round. a[-2,-1] x # Primitives.
  1,{3*($13-1)},1,1,200 1,{$13-1},1,1,1 # Colors / opacities.
  y[-3,-4,-6] a[-6--1] y
  v +

#@cli s3d : eq. to 'split3d'. : (+)

#@cli split3d : _keep_shared_data={ 0 | 1 } : (+)
#@cli : Split selected 3D objects into 6 feature vectors :
#@cli : { header, sizes, vertices, primitives, colors, opacities }.
#@cli : (eq. to 's3d').\n
#@cli : To recreate the 3D object, append these 6 images along the y-axis.
#@cli : Default value: 'keep_shared_data=1'.
#@cli : $ box3d 100 +split3d

#@cli sprite3d
#@cli : Convert selected images as 3D sprites.
#@cli : Selected images with alpha channels are managed.
#@cli : $ image.jpg sprite3d
sprite3d :
  e[^-1] "Convert image$? as 3D sprites."
  v - repeat $! l[$>] nm={0,n}
    split_opacity
    i[0] (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};{0,s}) y[1]
    if {$!==2} (1) a y
    else /. 255 i.. (-128;{w};{h};{s}) y.
    fi
    a y
  nm $nm endl done v +

#@cli sprites3d : [sprite],_sprite_has_alpha_channel={ 0 | 1 }
#@cli : Convert selected 3D objects as a sprite cloud.
#@cli : Set 'sprite_has_alpha_channel' to 1 to make the last channel of the selected sprite be a transparency mask.
#@cli : Default value: 'mask_has_alpha_channel=0'.
#@cli : $ torus3d 100,20 image.jpg resize2dy[-1] 64 100%,100% gaussian[-1] 30%,30% *[-1] 255 append[-2,-1] c +sprites3d[0] [1],1 display_rgba[-2]
sprites3d : check ${is_image_arg\ $1} skip ${2=0}
  e[^-1] "Convert image$? as 3D sprites clouds, using sprite $1 ("${"arg {1+!$2},with,without"}" alpha-channel)."
  v - repeat $!
    if {!{$>,i(0,7)}} continue fi # Do nothing if 3D object is empty.
    pass$1 0
    if {!w} empty3d rv[$>,-1] nm[$>] {n} rm. continue fi
    l[$>,-1]
    s3d[0] N={1,@0} =[1] $N,0,1
    rm[3-5] i[3] (1,0;1,{$N-1}) r[3] 2,$N,1,1,3 round[3]
    if $2 # With alpha-channel.
      if {s==1} # Only alpha-channel.
        i.. 3,$N,1,1,200 /. 255
        i.. (-128;{w};{h};1)
        if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 fi
      else # Image + alpha.
        s. c,-{s-1} /. 255
        i... (-128;{w};{h};{-2,s})
        if {$N>1} i.. 1,{4*($N-1)},1,1,-128,0,0,0 fi
        i.. (-128;{w};{h};1)
        if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 fi
      fi
    else  # Without alpha-channel.
      i.. (-128;{w};{h};{s}) y[-3,-1]
      if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 fi
      1,$N,1,1,1
    fi
    y a y
  endl done v +

#@cli star3d : _nb_branches>0,0<=_thickness<=1
#@cli : Input 3D star at (0,0,0), with specified geometry.
#@cli : Default values: 'nb_branches=5' and 'thickness=0.38'.
#@cli : $ star3d , +primitives3d 1 color3d[-2] ${-RGB}
star3d : check "${1=5}>0 && ${2=0.38}>=0 && $2<=1"
  e[^-1] "Input 3D star, with $1 branches and thickness $2."
  v -
  N={2*$1} ({'CImg3d'}) +. 0.5 ({$N+1};$N)
  ({-pi/2};{3*pi/2}) r. 1,{$N+1},1,1,3 rows. 0,{h-2} +sin. cos.. a[-2,-1] x
  (1,1;$2,$2) *[-2,-1] z. 0,2 r. 3,{h+1},1,1,0
  (3,$N,1,0;3,$N,$N,{$N-1}) r. 4,$N,1,1,3 round. =. 0,2,100%
  3,$N,1,1,200 1,$N,1,1,1 y[-6,-4--2] a[-6--1] y nm. [3D\ star]
  v +

#@cli streamline3d : x[%],y[%],z[%],_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : 'formula',x,y,z,_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : (+)
#@cli : Extract 3D streamlines from selected vector fields or from specified formula.
#@cli : 'interpolation' can be { 0=nearest integer | 1=1st-order | 2=2nd-order | 3=4th-order }.
#@cli : Default values: 'dl=0.1', 'interpolation=2', 'is_backward=0' and 'is_oriented=0'.
#@cli : $ 100,100,100,3 rand -10,10 blur 3 repeat 300 +streamline3d[0] {u(100)},{u(100)},{u(100)},1000,1,1 color3d[-1] ${-RGB} done remove[0] box3d 100 primitives3d[-1] 1 add3d

#@cli -3d : eq. to 'sub3d'. : (+)

#@cli sub3d : tx,_ty,_tz : (+)
#@cli : Shift selected 3D objects with the opposite of specified displacement vector.
#@cli : (eq. to '3d').
#@cli : Default values: 'ty=tz=0'.
#@cli : $ sphere3d 10 repeat 5 +sub3d[-1] 10,{u(-10,10)},0 color3d[-1] ${-RGB} done add3d

#@cli superformula3d : resolution>1,m>=1,n1,n2,n3
#@cli : Input 2D superformula curve as a 3D object.
#@cli : Default values: 'resolution=1024', 'm=8', 'n1=1', 'n2=5' and 'n3=8'.
#@cli : $ superformula3d ,
superformula3d : check "${1=1024}>1 && ${2=8}>=1" skip ${3=1},${4=5},${5=8}
  e[^-1] "Input 2D superformula curve, with resolution $1, m=$2 and (n1,n2,n3)=($3,$4,$5)."
  v -
  res={round($1)}

  # Define object header and vertices.
  (67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
  (0,{2*pi}) r. $res,1,1,1,3 .

  *. {$2/4} +sin. cos.. abs[-2,-1]
  ^.. $4 ^. $5 +[-2,-1] ^. {-1/$3}
  +sin.. cos... *. .. *[-3,-2] n[-2,-1] -1,1
  a[-2,-1] y rows. 0,2 transpose. r. 1,{w*h},1,1,-1

  # Define object primitives, colors and opacities.
  1,{$res-1},1,1,2 (0;{$res-2}) r. 1,{$res-1},1,1,3 ++. 1 a[-3--1] x round. 1 r. 1,{w*h},1,1,-1
  1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 a[-5--1] y nm. [3D\ superformula]
  v +

#@cli tensors3d : _radius_factor>=0,_shape={ 0=box | >=N=ellipsoid },_radius_min>=0
#@cli : Generate 3D tensor fields from selected images.
#@cli : when 'shape'>0, it gives the ellipsoid shape precision.
#@cli : Default values: 'radius_factor=1', 'shape=2' and 'radius_min=0.05'.
#@cli : $ 6,6,6,9,"U = [x,y,z] - [w,h,d]/2; U/=norm(U); mul(U,U,3) + 0.3*eye(3)" tensors3d 0.8
tensors3d : check "${1=1}>=0 && isint(${2=2}) && $2>=0 && ${3=0.05}>=0"
  e[^-1] "Generate 3D tensor field(s) from image$?, with radius factor $1, "\
          ${"v - if $2 u ellipsoid else u box fi v +"}" shape and radius min $3."
  v - repeat $! l[$>]

    # Check input image format.
    if {s==1} 100%,100%,100%,6,"[i#0,0,0,i#0,0,i#0]" k.
    elif {s==3} 100%,100%,100%,6,"[R#0,G#0,0,B#0,0,0]" k.
    elif {s==4} 100%,100%,100%,6,"[R#0,G#0,0,A#0,0,0]" k.
    elif {s==9} 100%,100%,100%,6,"I=I#0;[I[0],I[1],I[2],I[4],I[5],I[8]]" k.
    fi
    if {s!=6} error[0--4] "Command '$0': Image '"{n}"' has an invalid size (spectrum="{s}")." fi

    # Estimate eigenvalues/eigenvectors.
    100%,100%,100%,12,"
      T = I(#0);
      M = [ T[0], T[1], T[2], T[1], T[3], T[4], T[2], T[4], T[5] ];
      eig = eig(M);
      if (det(eig[3,9])<0, eig[3]*=-1; eig[4]*=-1; eig[5]*=-1);
      eig[0] = max(0,eig[0]);
      eig[1] = max(0,eig[1]);
      eig[2] = max(0,eig[2]);
      eig"
    k.

    # Create 3D object.
    if $2 sphere3d 1,{$2-1} else box3d 1 fi
    N,P={[i[6],i[7]]} siz={h} n3d. c3d. .x{0,whd-1}
    f[0] "
      const N = "$N";
      const P = "$P";
      const siz = "$siz";
      eig = I;
      const d = size(eig);
      ind = 1 + x + w*y + wh*z;
      L = eig[0,3];
      if (max(L)==0, # Empty tensor -> do not display
        i[#ind,6] = i[#ind,7] = 0;
        resize(#ind,1,8,1,1,0);
      _(else),
        L*=$1;
        L[0] = max($3,L[0]);
        L[1] = max($3,L[1]);
        L[2] = max($3,L[2]);
        R = eig[3,9];
        anisotropy = sqrt(((L[0] - L[1])^2 + (L[1] - L[2])^2 + (L[2] - L[0])^2)/(2*(L[0]^2 + L[1]^2 + L[2]^2)));

        pts = crop(#ind,0,8,0,0,1,3*N,1,1);
        pts *= resize(L,size(pts),0,2);
        pts = mul(pts,R,3);
        pts += resize([x,y,z],size(pts),0,2);
        draw(#ind,pts,0,8,0,0,1,size(pts),1,1);

        col0 = cut(255*anisotropy*abs([ R[0],R[1],R[2] ]) + (1-anisotropy)*200,0,255);
        col = resize(col0,3*P,0,2);
        const off = siz - 4*P;
        draw(#ind,col,0,off,0,0,1,size(col),1,1);
        0); I"
    rm[0] +3d
  endl done v +

#@cli text_pointcloud3d : _"text1",_"text2",_smoothness
#@cli : Input 3D text pointcloud from the two specified strings.
#@cli : Default values: 'text1="text1"', 'text2="text2"' and 'smoothness=1'.
#@cli : $ text_pointcloud3d "G'MIC","Rocks!"
text_pointcloud3d : skip "${1=text1}","${2=text2}",${3=1}
  e[^-1] "Input 3D pointcloud text object from strings '$1' and '$2', with smoothness $3."
  v -
  0 t. "$1",0,0,53,1,1
  0 t. "$2",0,0,53,1,1 mirror. y
  autocrop[-2,-1] 0
  expand_xy[-2,-1] 2,0 dilate[-2,-1] 2
  permute. zyxc r[-2,-1] ${-max_whd} &[-2,-1]

  100%,100% rand. 0,{{-2,d}-1} round. r. .. f. 'if(z==i,1,0)'
  distance. 1 +. 1 +f. 1 rv[-2,-1] /[-2,-1] *. ..
  +dilate. 0,0,{d} ==[-2,-1] *. ..

  1,100%,100% rand. 0,{{-2,w}-1} round. r. .. f. 'if(x==i,1,0)'
  distance. 1 +. 1 +f. 1 rv[-2,-1] /[-2,-1] *. ...
  +dilate. 0,0,{d} ==[-2,-1] *[-3,-1]

  -|[-2,-1]

  b. $3 isosurface3d. 25%
  c3d. n3d. nm. "[3D text pointcloud]" v +

#@cli text3d : text,_font_height>0,_depth>0,_smoothness
#@cli : Input a 3D text object from specified text.
#@cli : Default values: 'font_height=53', 'depth=10' and 'smoothness=1.5'.
#@cli : $ text3d "G'MIC as a\n3D logo!"
text3d : skip ${2=53},${3=10},${4=1.5}
  e[^-1] "Input 3D text object '$1' with size $2, depth $3 and smoothness $4."
  v - 0 t. "$1",0,0,$2,1,1 autocrop. 0 r. 100%,100%,$3 expand_xyz. 10,0
  b. $4 isosurface3d. 40% rv3d. nm. "[3D text '$1']" v +

#@cli t3d : eq. to 'texturize3d'.
t3d : check ${"is_image_arg $1"}" && (!narg(${2=}) || "${"is_image_arg $2"}")"
  e[^-1] "Texturize 3D object$? with texture $1"${"v - if {narg($2)} u \" and texture coordinates $2\" else u \"\" fi v +"}"."
  v - pass$1 0 slices. 0 if {s==1} to_rgb. else channels. 0,2 fi
  if {narg($2)} pass$2 else 0 fi
  _texturize3d
  v +

#@cli texturize3d : [ind_texture],_[ind_coords]
#@cli : Texturize selected 3D objects with specified texture and coordinates.
#@cli : (eq. to 't3d').\n
#@cli : When '[ind_coords]' is omitted, default XY texture projection is performed.
#@cli : Default value: 'ind_coords=(undefined)'.
#@cli : $ image.jpg torus3d 100,30 texturize3d[-1] [-2] keep[-1]
texturize3d : check ${"is_image_arg $1"}" && (!narg(${2=}) || "${"is_image_arg $2"}")"
  e[^-1] "Texturize 3D object$? with texture $1"${"v - if {narg($2)} u \" and texture coordinates $2\" else u \"\" fi v +"}"."
  v - pass$1 0 slices. 0 if {s==1} to_rgb. else channels. 0,2 fi
  if {narg($2)} pass$2 else 0 fi
  _$0
  v +

_texturize3d :
  repeat {$!-2} l[$>,-2,-1]
    s3d[0]

    # Retrieve texture coordinates for each vertex.
    if {!w}
      +r[2] 3,{2,round(h/3)},1,1,-1 s. x,3 rm.
      n.. 0,{6,w-1} n. 0,{6,h-1} a[-2,-1] x
      mv. -2
    fi

    # Texturize 3D object
    np={1,i[1]} 1,{2*$np} 1,{3*$np} 1,$np,1,1,1
    eval "
      add_material() = (
        ind_tex>=0?( # Shared texture
          copy(i[#-2,qc],[ -128,ind_tex,0,0 ],4); qc+=4
        ):( # Non-shared texture
          qc + whds#6 + 4>=h(#-2)?resize(#-2,1,int(1.5*qc + whds#6 + 4),1,1,0,0);
          copy(i[#-2,qc],[ -128,w#6,h#6,s#6 ],4); qc+=4;
          copy(i[#-2,qc],i(#6),whds#6); qc+=whds#6;
          ind_tex = np;
        );
      );

      ind_tex = -1;
      for (pp = pc = qp = qc = np = 0, pp<h#3, ++np,
        qp + 13>=h(#-3)?resize(#-3,1,int(1.5*qp + 13),1,1,0,0);
        qc + 3>=h(#-2)?resize(#-2,1,int(1.5*qc + 3),1,1,0,0);
        N = i[#3,pp++];

        N==1?( # Colored point
          v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
          R = i(#6,tx0,ty0,0,0); G = i(#6,tx0,ty0,0,1); B = i(#6,tx0,ty0,0,2);
          copy(i[#-3,qp],[ 1,v0 ],2); qp+=2;
          copy(i[#-2,qc],[ R,G,B ],3); qc+=3;

        ):(N==2 || N==6)?( # Colored segment
          v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
          v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
          N==6?(pp+=4);
          copy(i[#-3,qp],[ 6,v0,v1,tx0,ty0,tx1,ty1 ],7); qp+=7;
          add_material();

        ):(N==3 || N==9)?( # Colored triangle
          v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
          v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
          v2 = i[#3,pp++]; tx2 = i(#7,0,v2); ty2 = i(#7,1,v2);
          N==9?(pp+=6);
          copy(i[#-3,qp],[ 9,v0,v1,v2,tx0,ty0,tx1,ty1,tx2,ty2 ],10); qp+=10;
          add_material();

        ):(N==4 || N==12)?( # Colored quadrangle
          v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
          v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
          v2 = i[#3,pp++]; tx2 = i(#7,0,v2); ty2 = i(#7,1,v2);
          v3 = i[#3,pp++]; tx3 = i(#7,0,v3); ty3 = i(#7,1,v3);
          N==12?(pp+=8);
          copy(i[#-3,qp],[ 12,v0,v1,v2,v3,tx0,ty0,tx1,ty1,tx2,ty2,tx3,ty3 ],13); qp+=13;
          add_material();

        ):N==5?( # Colored sphere
          v0 = i[#3,pp++]; tx0 = i(#7,0,v0); ty0 = i(#7,1,v0);
          v1 = i[#3,pp++]; tx1 = i(#7,0,v1); ty1 = i(#7,1,v1);
          v2 = i[#3,pp++]; pp+=2;
          (tx0+=tx1)/=2; (ty0+=ty1)/=2;
          R = i(#6,tx0,ty0,0,0); G = i(#6,tx0,ty0,0,1); B = i(#6,tx0,ty0,0,2);
          copy(i[#-3,qp],[ 5,v0,v1,v2,0,0 ],6); qp+=6;
          copy(i[#-2,qc],[ R,G,B ],3); qc+=3;

        );
      );
      resize(#-3,1,qp,1,1,0,0);
      resize(#-2,1,qc,1,1,0,0)"

    rm[3-5] mv[-3--1] 3
    if {!w} rm.. fi
    a[0-5] y
  endl done rm[-2,-1]

#@cli torus3d : _radius1,_radius2,_nb_subdivisions1>2,_nb_subdivisions2>2
#@cli : Input 3D torus at (0,0,0), with specified geometry.
#@cli : Default values: 'radius1=1', 'radius2=0.3', 'nb_subdivisions1=24' and 'nb_subdivisions2=12'.
#@cli : $ torus3d 10,3 +primitives3d 1 color3d[-2] ${-RGB}
torus3d : check "${3=24}>2 && ${4=12}>2" skip ${1=1},${2=0.3}
  e[^-1] "Input 3D torus, with radii ($1,$2) and subdivisions ($3,$4)."
  v -
  # Header.
  nbp={$3*$4}
  1,8,1,1,67.5,73.5,109.5,103.5,51.5,100.5,$nbp,{$4*$3}

  # Vertices.
  (0;{2*pi}) +y. x
  r.. 1,{$3+1},1,1,3 z.. 0,0,0,{$3-1}
  r. {$4+1},1,1,1,3 z. 0,{$4-1}
  +sin[-2,-1] cos[-4,-3] r[-4--1] $4,$3
  *... $2 +... $1 *. $2 *[-4] ... *[-3,-2]
  y[-3--1] a[-3--1] x

  # Primitives.
  1,$3,1,1,'y' *. $4 +shift. 0,-1 $4,1,1,1,'x' +shift. -1 r[-4--1] $4,$3
  ++[-4,-1] +.. [-4] +[-5] ... +[-4,-3] y[-4--1] i[-5] 1,{h},1,1,4 a[-5--1] x

  # Colors / opacities.
  3,{h},1,1,200 1,{h},1,1,1 y[-4--2] a[-5--1] y
  nm. [3D\ torus]
  v +

#@cli triangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2
#@cli : Input 3D triangle at specified coordinates.
#@cli : $ repeat 100 a={$>*pi/50} triangle3d 0,0,0,0,0,3,{cos(3*$a)},{sin(2*$a)},0 color3d[-1] ${-RGB} done add3d
triangle3d :
  e[^-1] "Input 3D triangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)."
  v - 1,25,1,1,67.5,73.5,109.5,103.5,51.5,100.5,3,1,${1-9},3,0,1,2,200,200,200,1 nm. [3D\ triangle] v +

#@cli volume3d
#@cli : Transform selected 3D volumetric images as 3D parallelepipedic objects.
#@cli : $ image.jpg animate blur,0,5,30 append z volume3d
volume3d :
  e[^-1] "Transform image$? as 3D parallelepipedic objects."
  v - repeat $! l[$>]
    w={w} h={h} d={d}
    +slices 0 +slices[0] 100% mirror. y
    +columns[0] 0 +columns[0] 100% permute[-2,-1] zyxc mirror.. x
    +rows[0] 0 +rows[0] 100% permute[-2,-1] xzyc mirror.. y
    rm[0] image6cube3d *3d $w,$h,$d
  endl done v +

#@cli weird3d : _resolution>0
#@cli : Input 3D weird object at (0,0,0), with specified resolution.
#@cli : Default value: 'resolution=32'.
#@cli : $ weird3d 48 +primitives3d 1 color3d[-2] ${-RGB}
weird3d : skip ${1=32}
  e[^-1] "Input 3D weird object, with resolution $1."
  v -
  isosurface3d "'\
    T = 1.61803399;\
    2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x))\
    '",0,-4.7,-4.7,-4.7,4.7,4.7,4.7,$1,$1,$1
  c3d. n3d. nm. [3D\ weird]
  v +

#-------------------------------
#
#@cli :: Control Flow
#
#-------------------------------

#@cli ap : eq. to 'apply_parallel'.
ap :
  v - _gmic_s="$?" v +
  _apply_parallel "$*"

#@cli apply_parallel : "command"
#@cli : Apply specified command on each of the selected images, by parallelizing it for all image of the list.
#@cli : (eq. to 'ap').
#@cli : $ image.jpg +mirror x +mirror y apply_parallel "blur 3"
apply_parallel :
  v - _gmic_s="$?" v +
  _$0 "$*"

_apply_parallel :
  e[0--3] "Apply command '$*' on all image"$_gmic_s" in parallel, using "$_cpus" threads."
  v -
  if {$!" && "narg("$*")}
    m "_ap : repeat $! l[$>] $* if $! k[0] else 0 fi endl done"
    N={min($!,$_cpus)}
    commands= sep= repeat $N commands=$commands${sep}_ap[$>--1:$N] sep=, done
    parallel $commands
    uncommand _ap
  fi
  v +

#@cli apc : eq. to 'apply_parallel_channels'.
apc :
  v - _gmic_s="$?" v +
  _apply_parallel_channels "$*"

#@cli apply_parallel_channels : "command"
#@cli : Apply specified command on each of the selected images, by parallelizing it for all channel of the images independently.
#@cli : (eq. to 'apc').
#@cli : $ image.jpg apply_parallel_channels "blur 3"
apply_parallel_channels :
  v - _gmic_s="$?" v +
  _$0 "$*"

_apply_parallel_channels :
  e[0--3] "Apply command '$*' on all channels of image"$_gmic_s" in parallel, using "$_cpus" threads."
  v - N=$! repeat $N s$>={$>,s} done s c
  ap "$1"
  repeat $N a[$>-{$>+${s$>}-1}] c done v +

#@cli apo : eq. to 'apply_parallel_overlap'.
apo : check "${2=0}>=0 && isint(${3=0}) && $3>=0"
  v - _gmic_s="$?" v +
  _apply_parallel_overlap "$1",${2--1}

#@cli apply_parallel_overlap : "command",overlap[%],nb_threads={ 0=auto | 1 | 2 | 4 | 8 | 16 }
#@cli : Apply specified command on each of the selected images, by parallelizing it on 'nb_threads' overlapped sub-images.
#@cli : (eq. to 'apo').\n
#@cli : 'nb_threads' must be a power of 2.
#@cli : Default values: 'overlap=0','nb_threads=0'.
#@cli : $ image.jpg +apply_parallel_overlap "smooth 500,0,1",1
apply_parallel_overlap : check "${2=0}>=0 && isint(${3=0}) && $3>=0"
  v - _gmic_s="$?" v +
  _$0 "$1",${2--1}

_apply_parallel_overlap : check "${2=0}>=0 && isint(${3=0}) && $3>=0"
  v - N={if($3,max(1,round($3)),$_cpus)} N={2^int(log2(min(16,$N)))} v +
  e[0--3] "Apply parallelized command '$1' on image"$_gmic_s", with overlap $2 and "$N" threads."
  v -
  __apo_exception=""
  m "_check1 : if {$!!=1} rm 0 __apo_exception=\"Command 'apply_parallel_overlap': Specified command '$1' changes the size of the image stack.\" fi"
  repeat $! l[$>]
    _apply_parallel_overlap$N "$1",$2
  endl done
  uncommand _check1
  v +

_apply_parallel_overlap1 :
  $1
  if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi

_apply_parallel_overlap2 :
  if {w>=h}
    ovx={round(if(${"is_percent $2"},w*$2,$2))} w2={int(w/2)}
    +z[0] {$w2-$ovx},100% z[0] 0,{$w2+$ovx-1}
    parallel "l[0] $1 _check1 endl","l[1] $1 _check1 endl"
    if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi
    z[0] 0,{0,w-1-$ovx} z[1] $ovx,100% a x
  else
    ovy={round(if(${"is_percent $2"},h*$2,$2))} h2={int(h/2)}
    +rows[0] {$h2-$ovy},100% rows[0] 0,{$h2+$ovy-1}
    parallel "l[0] $1 _check1 endl","l[1] $1 _check1 endl"
    if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi
    rows[0] 0,{0,h-1-$ovy} rows[1] $ovy,100% a y
  fi

_apply_parallel_overlap4 :
  if {max(w,h)/min(w,h)>=3}
    _apply_parallel_overlap2 "_apply_parallel_overlap2 \"$1\",$2",$2
  else
    ovx={round(if(${"is_percent $2"},w*$2,$2))} w2={int(w/2)}
    ovy={round(if(${"is_percent $2"},h*$2,$2))} h2={int(h/2)}
    +z[0] {$w2-$ovx},0,100%,{$h2+$ovy-1} +z[0] 0,{$h2-$ovy},{$w2+$ovx-1},100%
    +z[0] {$w2-$ovx},{$h2-$ovy},100%,100% z[0] 0,0,{$w2+$ovx-1},{$h2+$ovy-1}
    parallel "l[0] $1 _check1 endl","l[1] $1 _check1 endl","l[2] $1 _check1 endl","l[3] $1 _check1 endl"
    if {narg($__apo_exception)} v + error[0--12] $__apo_exception fi
    z[0] 0,0,{0,w-1-$ovx},{0,h-1-$ovy} z[1] $ovx,0,100%,{1,h-1-$ovy}
    z[2] 0,$ovy,{2,w-1-$ovx},100% z[3] $ovx,$ovy,100%,100%
    a[0,1] x a[1,2] x a y
  fi

_apply_parallel_overlap8 :
  _apply_parallel_overlap2 "_apply_parallel_overlap4 \"$1\",$2",$2

_apply_parallel_overlap16 :
  _apply_parallel_overlap2 "_apply_parallel_overlap8 \"$1\",$2",$2

#@cli at : eq. to 'apply_tiles'.
at : check "${2=10%}>0 && ${3=10%}>0 && ${4=10%}>0 && ${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && isint(${8=1}) && $8>=0 && $8<=3"
  v - _gmic_s="$?" v +
  _apply_tiles "$1",${2--1}

#@cli apply_tiles : "command",_tile_width[%]>0,_tile_height[%]>0,_tile_depth[%]>0,_overlap_width[%]>=0,_overlap_height[%]>=0,_overlap_depth[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply specified command on each tile (neighborhood) of the selected images, eventually with overlapping tiles.
#@cli : (eq. to 'at').
#@cli : Default values: 'tile_width=tile_height=tile_depth=10%','overlap_width=overlap_height=overlap_depth=0' and 'boundary_conditions=1'.
#@cli : $ image.jpg +equalize[0] 256 +apply_tiles[0] "equalize 256",16,16,1,50%,50%
apply_tiles : check "${2=10%}>0 && ${3=10%}>0 && ${4=10%}>0 && ${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && isint(${8=1}) && $8>=0 && $8<=3"
  v - _gmic_s="$?" v +
  _$0 "$1",${2--1}

_apply_tiles :
  e[0--3] "Apply command '$1' on $2x$3x$4 tiles of image$?, with overlaps ($5,$6,$7) and "${"arg 1+$8,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! l[$>]
    bw={cut(round(${"is_percent $2"}?w*$2:$2),1,w)}
    bh={cut(round(${"is_percent $3"}?h*$3:$3),1,h)}
    bd={cut(round(${"is_percent $4"}?d*$4:$4),1,d)}
    ow={round(${"is_percent $5"}?$bw*$5:$5)}
    oh={round(${"is_percent $6"}?$bh*$6:$6)}
    od={round(${"is_percent $7"}?$bd*$7:$7)}
    sw={cut($bw-$ow,1,$bw)}
    sh={cut($bh-$oh,1,$bh)}
    sd={cut($bd-$od,1,$bd)}
    100%,100%,100%,{s+1} # Reconstructed image + weights
    if {$ow>0" || "$oh>0" || "$od>0} l[] # Generate gaussian weight in case of overlap
      $bw,1,1 1,$bh,1 1,1,$bd
      = 1,50%,50%,50% distance 1
      /[0] {0.3*$bw} /[1] {0.3*$bh} /[2] {0.3*$bd}
      sqr * -1 exp r $bw,$bh,$bd,1 *
    endl else $bw,$bh,$bd,1,1
    fi
    $bw,$bh,$bd,[0]
    m "__at : $1 k. r "$bw,$bh,$bd,{0,s},0
    eval "
      mask = crop(#2);
      for (z = 0, z<d#0, z+="$sd",
        for (y = 0, y<h#0, y+="$sh",
          for (x = 0, x<w#0, x+="$sw",
            draw(crop(#0,x,y,z,w,h,d,$8),0,0,0,0,w,h,d);
            ext('__at.');
            breakpoint();
            draw(#1,crop(#-1),x,y,z,0,w,h,d,s#0,-1,mask);
            draw(#1,mask,x,y,z,s#0,w,h,d,1,-1);
          )
        )
      )"
    rm[-2,-1]
    s. c,-{0,s} /[-2,-1] k.
    uncommand __at
  endl done v +

#@cli apply_timeout : "command",_timeout={ 0=no timeout | >0=with specified timeout (in seconds) }
#@cli : Apply a command with a timeout.
apply_timeout :
  if {!$2}
    e[0--3] "Apply command '$1' on image$?, with no timeout."
    v - $1 v +
  else
    e[0--3] "Apply command '$1' on image$?, with a timeout of $2 seconds."
    v -
    l[] ({'$/'}) id={is} rm endl
    __done$id=0 __is_timeout$id=0
    l
    parallel "$1 __done"$id"=1",\
             "do if {$|>$2} __is_timeout"$id"=1 error \"\" elif $__done"$id" break fi wait 100 while 1"
    onfail
      v +
      if ${__is_timeout$id} v + error[0--5] "Command '$0': Time out ($2 seconds) for command '$1'."
      else v + error[0--5] "Command '$0': "${}
      fi
    endl
    v +
  fi

#@cli check : expression : (+)
#@cli : Evaluate specified expression and display an error message if evaluated to false.
#@cli : If 'expression' is not a math expression, it is regarded as a filename and checked if it exists.

#@cli check3d : _is_full_check={ 0 | 1 } : (+)
#@cli : Check validity of selected 3D vector objects, and display an error message
#@cli : if one of the selected images is not a valid 3D vector object.
#@cli : Full 3D object check is slower but more precise.
#@cli : Default value: 'is_full_check=1'.

#@cli continue : (+)
#@cli : Go to end of current 'repeat...done', 'do...while' or 'local...endlocal' block.
#@cli : $ image.jpg repeat 10 blur 1 if {1==1} continue fi deform 10 done

#@cli break : (+)
#@cli : Break current 'repeat...done', 'do...while' or 'local...endlocal' block.
#@cli : $ image.jpg repeat 10 blur 1 if {1==1} break fi deform 10 done

#@cli do : (+)
#@cli : Start a 'do...while' block.
#@cli : $ image.jpg luminance i={ia+2} do set 255,{u(100)}%,{u(100)}% while {ia<$i}

#@cli done : (+)
#@cli : End a 'repeat/for...done' block, and go to associated 'repeat/for' position, if iterations remain.

#@cli elif : boolean : filename : (+)
#@cli : Start a 'elif...[else]...fi' block if previous 'if' was not verified
#@cli : and test if specified boolean is true, or if specified filename exists.
#@cli : 'boolean' can be a float number standing for { 0=false | other=true }.

#@cli else : (+)
#@cli : Execute following commands if previous 'if' or 'elif' conditions failed.

#@cli fi : eq. to 'endif'. : (+)

#@cli endif : (+)
#@cli : End a 'if...[elif]...[else]...endif' block.
#@cli : (eq. to 'fi').\n

#@cli endl : eq. to 'endlocal'. : (+)

#@cli endlocal : (+)
#@cli : End a 'local...endlocal' block.
#@cli : (eq. to 'endl').

#@cli error : message : (+)
#@cli : Print specified error message on the standard error (stderr) and exit interpreter, except
#@cli : if error is caught by a 'onfail' command.
#@cli : Command selection (if any) stands for displayed call stack subset instead of image indices.

#@cli eval : expression : (+)
#@cli : Evaluate specified math expression.
#@cli : - If no command selection is specified, the expression is evaluated once and its result is set to status.
#@cli : - If command selection is specified, the evaluation is looped over selected images. Status is not modified.
#@cli :   (in this latter case, 'eval' is similar to 'fill' without assigning the image values).

#@cli x : eq. to 'exec'. : (+)

#@cli exec : _is_verbose={ 0 | 1 },"command" : (+)
#@cli : Execute external command using a system call.
#@cli : The status value is then set to the error code returned by the system call.
#@cli : If 'is_verbose=1', the executed command is allowed to output on stdout/stderr.
#@cli : (eq. to 'x').
#@cli : Default value: 'is_verbose=1'.

#@cli for : condition : (+)
#@cli : Start a 'for...done' block.
#@cli : $ image.jpg resize2dy 32 400,400,1,3 x=0 for {$x<400} image[1] [0],$x,$x x+=40 done

#@cli if : boolean : filename : (+)
#@cli : Start a 'if...[elif]...[else]...fi' block and test if specified boolean is true,
#@cli : or if specified filename exists.
#@cli : 'boolean' can be a float number standing for { 0=false | other=true }.
#@cli : $ image.jpg if {ia<64} add 50% elif {ia<128} add 25% elif {ia<192} sub 25% else sub 50% fi cut 0,255

#@cli l : eq. to 'local'. : (+)

#@cli local : (+)
#@cli : Start a 'local...[onfail]...endlocal' block, with selected images.
#@cli : (eq. to 'l').
#@cli : $ image.jpg local[] 300,300,1,3 rand[0] 0,255 blur 4 sharpen 1000 endlocal
#@cli : $ image.jpg +local repeat 3 deform 20 done endlocal
#@cli : $$

#@cli mutex : index,_action={ 0=unlock | 1=lock } : (+)
#@cli : Lock or unlock specified mutex for multi-threaded programming.
#@cli : A locked mutex can be unlocked only by the same thread. All mutexes are unlocked by default.
#@cli : 'index' designates the mutex index, in [0,255].
#@cli : Default value: 'action=1'.

#@cli noarg : (+)
#@cli : Used in a custom command, 'noarg' tells the command that its argument list have not been used
#@cli : finally, and so they must be evaluated next in the G'MIC pipeline, just as if the custom
#@cli : command takes no arguments at all.
#@cli : Use this command to write a custom command which can decide if it takes arguments or not.

#@cli onfail : (+)
#@cli : Execute following commands when an error is encountered in the body of the 'local...endlocal' block.
#@cli : The status value is set with the corresponding error message.
#@cli : $ image.jpg +local blur -3 onfail mirror x endlocal

#@cli parallel : _wait_threads,"command1","command2",... : (+)
#@cli : Execute specified commands in parallel, each in a different thread.
#@cli : Parallel threads share the list of images.
#@cli : 'wait_threads' can be { 0=when current environment ends | 1=immediately }.
#@cli : Default value: 'wait_threads=1'.
#@cli : $ image.jpg [0] parallel "blur[0] 3","mirror[1] c"

# The implementation below allows to use parallel as a regular command with selections.
parallel : skip "${1=},${2=},${3=},${4=},${5=},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=}"
  if {$1==0||$1==1||$1==2} e[0--3] "Execute "{$#-1}" commands '${2--1}' in parallel on image$?."
  else e[0--3] "Execute "$#" commands '$*' in parallel on image$?."
  fi
  v - parallel $"*" v +

#@cli progress : 0<=value<=100 : -1 : (+)
#@cli : Set the progress index of the current processing pipeline.
#@cli : This command is useful only when G'MIC is used by an embedding application.

#@cli q : eq. to 'quit'. : (+)

#@cli quit : (+)
#@cli : Quit G'MIC interpreter.
#@cli : (eq. to 'q').

#@cli repeat : nb_iterations,_variable_name : (+)
#@cli : Start iterations of a 'repeat...done' block.
#@cli : $ image.jpg split y repeat $!,n shift[$n] $<,0,0,0,2 done append y
#@cli : $ image.jpg mode3d 2 repeat 4 imagecube3d rotate3d 1,1,0,40 snapshot3d 400,1.4 done
#@cli : $$

#@cli return : (+)
#@cli : Return from current custom command.

#@cli rprogress : 0<=value<=100 | -1 | "command",0<=value_min<=100,0<=value_max<=100
#@cli : Set the progress index of the current processing pipeline (relatively to
#@cli : previously defined progress bounds), or call the specified command with
#@cli : specified progress bounds.
rprogress : skip ${2=""}
  v -
  if {!narg($_progress_bounds)} _progress_bounds=0,100 fi
  m={arg(-2,$_progress_bounds)} M={arg(-1,$_progress_bounds)}
  if {$#==2&&!narg($2)} # 1 argument -> Set progress bar.
    v + e[0--3] "Set relative progress index to $1%." v -
    progress {if($1<0,-1,min(100,max(0,$m+($M-$m)*$1%)))}
  elif {$#==3} # 3 arguments -> Call command with specified bounds.
    nm={min($2,$-1)} nM={max($2,$-1)}
    v + e[0--3] "Call command '$1' with progress bounds ["$nm,$nM"]." v -
    progress $m _progress_bounds=$_progress_bounds,{$m+$nm*($M-$m)/100},{$m+$nM*($M-$m)/100}  # Push new bounds.
    run "$1"
    progress $M ($_progress_bounds) _progress_bounds={@0--3} rm. # Pop bounds.
  else v + error[0--3] "Command '$0': Invalid argument '$*'."
  fi
  v +

#@cli run : "G'MIC pipeline"
#@cli : Run specified G'MIC pipeline.
#@cli : This is only useful when used from a shell, e.g. to avoid shell substitutions to happen in argument.
run :
  $*

#@cli skip : item : (+)
#@cli : Do nothing but skip specified item.

#@cli u : eq. to 'status'. : (+)

#@cli status : status_string : (+)
#@cli : Set the current status. Used to define a returning value from a function.
#@cli : (eq. to 'u').
#@cli : $ image.jpg command "foo : u0=Dark u1=Bright status ${u{ia>=128}}" text_outline ${-foo},2,2,23,2,1,255

#@cli while : boolean : filename : (+)
#@cli : End a 'do...while' block and go back to associated 'do'
#@cli : if specified boolean is true or if specified filename exists.
#@cli : 'boolean' can be a float number standing for { 0=false | other=true }.

#----------------------------------
#
#@cli :: Arrays, Tiles and Frames
#
#----------------------------------

#@cli array : M>0,_N>0,_expand_type={ 0=min | 1=max | 2=all }
#@cli : Create MxN array from selected images.
#@cli : Default values: 'N=M' and 'expand_type=0'.
#@cli : $ image.jpg array 3,2,2
array : check "isint($1) && $1>0 && isint(${2=$1}) && $2>0" skip ${3=0}
  e[^-1] "Create $1x$2 array from image$?, with expand type $3."
  v - r0={100/max($1,$2)} r1={100/min($1,$2)} r2=100
  r ${r$3}%,${r$3}%,1,100%,2 r {$1*100}%,{$2*100}%,1,100%,0,2 v +

#@cli array_fade : M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0=min | 1=max | 2=all}
#@cli : Create MxN array from selected images.
#@cli : Default values: 'N=M', 'fade_start=60', 'fade_end=90' and 'expand_type=1'.
#@cli : $ image.jpg array_fade 3,2
array_fade : skip ${2=$1},${3=60},${4=90},${5=1}
  e[^-1] "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
  v - repeat $! l[$>] . shift.. {round(w/2)},{round(h/2)},1,1,2 fade_diamond $3,$4 endl done
  array $1,$2,$5
  v +

#@cli array_mirror : N>=0,_dir={ 0=x | 1=y | 2=xy | 3=tri-xy },_expand_type={ 0 | 1 }
#@cli : Create 2^Nx2^N array from selected images.
#@cli : Default values: 'dir=2' and 'expand_type=0'.
#@cli : $ image.jpg array_mirror 2
array_mirror : skip ${2=2},${3=0}
  e[^-1] "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
  v - repeat $1
    if {$3==0}
      if {$2>=3} r 33%,33%,100%,100%,2
      else r 50%,50%,100%,100%,2
      fi
    fi
    repeat $! l[$>]
      if {$2==0} +mirror x a x
      elif {$2==1} +mirror y a y
      else +mirror x a x +mirror y a y if {$2==3} r 150%,150%,1,100%,0,2,1,1 fi
      fi
    endl done
  done v +

#@cli array_random : Ms>0,_Ns>0,_Md>0,_Nd>0
#@cli : Create MdxNd array of tiles from selected MsxNs source arrays.
#@cli : Default values: 'Ns=Ms', 'Md=Ms' and 'Nd=Ns'.
#@cli : $ image.jpg +array_random 8,8,15,10
array_random : skip ${2=$1},${3=$1},${4=$2}
  e[^-1] "Create $3x$4 array of tiles from $1x$2 array$?."
  v - repeat $! l[$>] nm={0,n}
    split_tiles $1,$2
    repeat $3 repeat $4 [{u($1*$2-1)}] done done
    rm[0-{$1*$2-1}] append_tiles $3,$4
  nm $nm endl done v +

#@cli frame : eq. to 'frame_xy'.
frame : skip ${2=$1}>=0,${3=255},${4=$3},${5=$4},${6=255}
  v - _gmic_s="?" v +
  _frame_xy ${1--1}

#@cli frame_blur : _sharpness>0,_size>=0,_smoothness,_shading,_blur
#@cli : Draw RGBA-colored round frame in selected images.
#@cli : Default values: 'sharpness=10', 'size=30', 'smoothness=0', 'shading=1' and 'blur=3%'.
#@cli : $ image.jpg frame_blur 3,30,8,10%
frame_blur : skip ${1=10},${2=30},${3=0},${4=1},${5=3%}
  e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and blur $5."
  v - to_rgba repeat $! l[$>] nm={0,n}
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" >=. $2%
    if $4 distance. 1 n. 0,1 *. -1 +. 1 ^. {1/$4} fi
    b. $3 +b.. $5 mv. -3 blend_fade[0,1] . rm.
  nm $nm endl done v +

#@cli frame_cube : _depth>=0,_centering_x,_centering_y,_left_side={0=normal | 1=mirror-x | 2=mirror-y | 3=mirror-xy},_right_side,_lower_side,_upper_side
#@cli : Insert 3D frames in selected images.
#@cli : Default values: 'depth=1', 'centering_x=centering_y=0' and 'left_side=right_side,lower_side=upper_side=0'.
#@cli : $ image.jpg frame_cube ,
frame_cube : check "${1=1}>=0" skip ${2=0},${3=0},${4=0},${5=0},${6=0},${7=0}
  e[^-1] "Insert 3D frame in image$?, with depth $1, centering point ($2,$3) and orientations (${4--1})."
  v - repeat $! l[$>] nm={0,n} split_opacity
    if {$!==2} frame_cube ${1--1} a c  # Manage image with alpha-channel.
    else
      m={max(w,h)} w={w} h={h} s={s}
      imageplane3d c3d /3d. $w,$h,1
      +_frame_cube[0] $4 r3d. 0,1,0,-90 +3d. -0.5,0,-0.5  # Left side.
      +_frame_cube[0] $5 r3d. 0,1,0,90 +3d. 0.5,0,-0.5  # Right side.
      +_frame_cube[0] $6 r3d. 1,0,0,-90 +3d. 0,0.5,-0.5   # Lower side.
      +_frame_cube[0] $7 r3d. 1,0,0,90 +3d. 0,-0.5,-0.5 # Upper side.
      +3d 0,0,1 +3d *3d $w,$h,$m  # Append sides together.
      f=1000
      cx=$2*$w/2*($f+$m*$1)/$f
      cy=$3*$h/2*($f+$m*$1)/$f
      s3d r[2] 3,{{2,h}/3},1,1,-1
      f[2] "if(i(2,y)<0.5,i,i+if(x==0,"$cx",if(x==1,"$cy",($1-1)*"$m")))"
      y[2] a y
      *3d 2 {2*$w},{2*$h},1,$s f3d {2*$f}
      j3d. ..,50%,50%,0,1,2,0,0 rm..
      r $w,$h,1,100%,2
    fi
  nm $nm endl done
  v +

_frame_cube :
  if {$1==1} r3d. 0,1,0,180 rv3d.
  elif {$1==2} r3d. 1,0,0,180 rv3d.
  elif {$1==3} r3d. 0,0,1,180
  fi

#@cli frame_fuzzy : size_x[%]>=0,_size_y[%]>=0,_fuzzyness>=0,_smoothness[%]>=0,_R,_G,_B,_A
#@cli : Draw RGBA-colored fuzzy frame in selected images.
#@cli : Default values: 'size_y=size_x', 'fuzzyness=5', 'smoothness=1' and 'R=G=B=A=255'.
#@cli : $ image.jpg frame_fuzzy 20
frame_fuzzy : skip ${2=$1},${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
  e[^-1] "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
  v - to_rgba repeat $! l[$>]
    100%,100%,1,1,1
    padx={if(${"is_percent $1"},$1*(w-1)/2,$1)}
    pady={if(${"is_percent $2"},$2*(h-1)/2,$2)}
    rectangle. $padx,$pady,{w-1-$padx},{h-1-$pady}
    spread. $3 b. $4 100%,100%,1,4 fc. ${5-8}
    j[0] [2],0,0,0,0,1,[1] k[0]
  endl done v +

#@cli frame_painting : _size[%]>=0,0<=_contrast<=1,_profile_smoothness[%]>=0,_R,_G,_B,_vignette_size[%]>=0,_vignette_contrast>=0,_defects_contrast>=0,0<=_defects_density<=100,_defects_size>=0,_defects_smoothness[%]>=0,_serial_number
#@cli : Add a painting frame to selected images.
#@cli : Default values: 'size=10%', 'contrast=0.4', 'profile_smoothness=6%', 'R=225', 'G=200', 'B=120', 'vignette_size=2%', 'vignette_contrast=400', 'defects_contrast=50', 'defects_density=10', 'defects_size=1', 'defects_smoothness=0.5%' and 'serial_number=123456789'.
#@cli : $ image.jpg frame_painting ,
frame_painting :
  check "${1=10%}>=0 && ${2=0.4}>=0 && $2<=1 && ${3=6%}>=0 && ${7=2%}>=0 && ${8=400}>=0 && ${9=50}>=0 && ${10=10}>=0 && $10<=100 && ${11=1}>=0 && ${12=0.5%}>=0"
  skip ${4=225},${5=200},${6=120},${13=123456789}
  e[^-1] "Add painting frame to image$?, with size $1, contrast $2, profile smoothness $3, color (${4-6}), vignette size $7, "\
          "vignette strength $8, defects contrast $9, defects density $10, defects size $11, defects smoothness $12 and serial number $13."
  if {!$1} return fi
  v - repeat $! l[$>]
    $1,$1 s={max(w,h)} rm.                             # Determine size of the frame
    ({'${dec2bin\ $13}'}) -. {'0'} r. $s               # Generate frame profile from serial number
    transpose. b. $3 n. {1-$2},{1+$2}
    +r. {{-2,w}+2*$s},100%,1,1                         # Upper frame
    +mirror. y                                         # Lower frame
    mv... $! transpose. r. 100%,{-4,h+2*$s},1,1        # Left frame
    +mirror. x                                         # Right frame
    ...,...,1,1,1 polygon. 3,0,0,{$s-1},{$s-1},0,{$s-1},1,0 polygon. 3,100%,0,{w-$s},100%,100%,100%,1,0 # Upper/lower mask.
    ..,..,1,1,1 polygon. 3,1,0,100%,{$s-2},100%,0 polygon. 3,1,100%,100%,{h-$s+1},100%,100%,1,0 # Left/right mask.
    _frame_painting[-6--3] ${4-6},${9-12}                    # Add colors + defects.

    # Build full frame picture.
    {-7,w+2*$s},{-7,h+2*$s},1,3
    j. [-7],0,0,0,0,1,...,1 rm[-7] mirror... y
    j. [-6],0,{h-$s},0,0,1,...,1 rm[-6,-3]
    j. [-4],0,0,0,0,1,..,1 rm[-4] mirror.. x
    j. ...,{w-$s},0,0,0,1,..,1 rm[-3,-2]
    ..,..,1,1,-255 r. ..,..,1,1,0,0,0.5,0.5 +. 255 +b. $7 n. 0,$8 max[-2,-1] c. 0,255 # Frame opacity.
    a[-2--1] c
    r.. .,.,1,100%,0,0,0.5,0.5 blend alpha # Insert initial image into frame picture.
  endl done v +

_frame_painting : # Add color + texture to each frame part.
  repeat $! l[$>]
    +*. $2 +*.. $3 *... $1 a[-3--1] c
    100%,100%
    i=0 do rand. 0,1 remove_pixels. {100-$5}% b. $6 >=. 50% i+=1 while {"m=$5/200;(ia<m-0.2 || ia>m+0.2) && "$i"<10"}
    b. $7 g. +[-2,-1] n. -$4,$4
    +[-2,-1] c. 0,255
  endl done

#@cli frame_pattern : M>=3,_constrain_size={ 0 | 1 } : M>=3,_[frame_image],_constrain_size={ 0 | 1 }
#@cli : Insert selected pattern frame in selected images.
#@cli : Default values: 'pattern=0' and 'constrain_size=0'.
#@cli : $ image.jpg frame_pattern 8
frame_pattern : check $1>=3 skip ${2=0},${3=}
  v - to_colormode 0
  if ${"is_image_arg $2"} # Frame from specified image.
    v + e[^-1] "Insert $1x$1 pattern frame on image$?, using frame image$2." v -
    pass$2 0 repeat {$!-1} l[$>,-1]
      wh={0,w},{0,h}
      +r[1] {0,max(1,w/($1-2))},{0,max(1,h/($1-2))},1,100%,2
      r[0] {{0,w}+2*w},{{0,h}+2*h},1,100%,0,0,0.5,0.5
      [-1]x{$1+2} a[{-$1-2}--1] x j[0] .,0,0 j[0] .,0,{{0,h}-1-h} rm.
      [-1]x{$1+1} a[{-$1-2}--1] y j[0] .,0,0 j[0] .,{{0,w}-1-w} rm.
      if $3 r[0] $wh,1,100%,2 fi
    endl done rm.
  else # Self-frame.
    v + e[^-1] "Insert $1x$1 self-pattern frame on image$?." v -
    repeat $! l[$>]
      wh={w},{h}
      +r {max(1,w/($1-2))},{max(1,h/($1-2))},1,100%,2 r.. {$1*w},{$1*h},1,100%,0,0,0.5,0.5
      [-1]x{$1+2} a[{-$1-2}--1] x j... .,0,0 j... .,0,{{-3,h}-1-h} rm.
      [-1]x{$1+1} a[{-$1-2}--1] y j.. .,0,0 j.. .,{{-2,w}-1-w} rm.
      if $3 r $wh,1,100%,2 fi
    endl done
  fi
  v +

#@cli frame_round : _sharpness>0,_size>=0,_smoothness,_shading,_R,_G,_B,_A
#@cli : Draw RGBA-colored round frame in selected images.
#@cli : Default values: 'sharpness=10', 'size=10', 'smoothness=0', 'shading=0' and 'R=G=B=A=255'.
#@cli : $ image.jpg frame_round 10
frame_round : skip ${1=10},${2=10},${3=0},${4=0},${5=255},${6=$5},${7=$6},${8=255}
  e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and RGBA color ($5,$6,$7,$8)."
  v - to_rgba repeat $! l[$>] nm={0,n}
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" >=. $2%
    if $4 distance. 1 n. 0,1 *. -1 +. 1 ^. {1/$4} fi
    b. $3 i... 100%,100%,1,4 fc... $5,$6,$7,$8 blend_fade[0,1] . rm.
  nm $nm endl done v +

#@cli frame_seamless : frame_size>=0,_patch_size>0,_blend_size>=0,_frame_direction={ 0=inner (preserve image size) | 1=outer }
#@cli : Insert frame in selected images, so that tiling the resulting image makes less visible seams.
#@cli : Default values: 'patch_size=7', 'blend_size=5' and 'frame_direction=1'.
#@cli : $ image.jpg +frame_seamless 30 array 2,2
frame_seamless : check "$1>=0 && isint(${2=7}) && $2>0 && isint(${3=5}) && $3>=0" skip ${4=1}
  v - s0="inner" s1="outer"
  v + e[^-1] "Insert "${s{!!$4}}" seamless frame in image$?, with size $1, patch size $2 and blend size $3." v -
  repeat $! l[$>]
    w2={round(w/2)} h2={round(h/2)}
    w4={round(w/4)} h4={round(h/4)}
    if {!$4} r {max(1,w-$1)},{max(1,h-$1)},1,100%,0,0,0.5,0.5 fi
    100%,100%,1,1,-1 r[-2,-1] {w+$1},{h+$1},1,100%,0,0,0.5,0.5 n. 0,1
    shift -$w2,-$h2,0,0,2
    inpaint_matchpatch.. [1],0,$2,10,$3
    rectangle. $1,$1,{w-1-$1},{h-1-$1}
    shift -$w4,-$h4,0,0,2
    inpaint_matchpatch.. [1],0,$2,10,$3
    rm.
    shift {$w4+$w2},{$h4+$h2},0,0,2
  endl done v +

#@cli frame_x : size_x[%],_col1,...,_colN
#@cli : Insert colored frame along the x-axis in selected images.
#@cli : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@cli : $ image.jpg frame_x 20,255,0,255
frame_x : skip ${2=255},${3=$2},${4=$3},${5=255}
  e[^-1] "Insert $1 outer frame in image$? along the x-axis, with color (${2--1})."
  _frame $1,0,0,${2--1}

#@cli frame_xy : size_x[%],_size_y[%],_col1,...,_colN
#@cli : Insert colored frame along the x-axis in selected images.
#@cli : Default values: 'size_y=size_x', 'col1=col2=col3=255' and 'col4=255'.
#@cli : (eq. to 'frame').
#@cli : $ image.jpg frame_xy 1,1,0 frame_xy 20,10,255,0,255
frame_xy : skip ${2=$1},${3=255},${4=$3},${5=$4},${6=255}
  v - _gmic_s="$?" v +
  _$0 ${1--1}

_frame_xy :
  e[0--3] "Insert $1x$2 outer frame in image"$_gmic_s" along the xy-axes, with color (${3--1})."
  _frame $1,$2,0,${3--1}

#@cli frame_xyz : size_x[%],_size_y[%],_size_z[%]_col1,...,_colN
#@cli : Insert colored frame along the x-axis in selected images.
#@cli : Default values: 'size_y=size_x=size_z', 'col1=col2=col3=255' and 'col4=255'.
frame_xyz : skip ${2=$1},${3=$2},${4=255},${5=$4},${6=$5},${7=255}
  e[^-1] "Insert $1x$2x$3 outer frame in image$? along the xyz-axes, with color (${4--1})."
  _frame $1,$2,$3,${4--1}

#@cli frame_y : size_y[%],_col1,...,_colN
#@cli : Insert colored frame along the y-axis in selected images.
#@cli : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@cli : $ image.jpg frame_y 20,255,0,255
frame_y : skip ${2=255},${3=$2},${4=$3},${5=255}
  e[^-1] "Insert $1 outer frame in image$? along the y-axis, with color (${2--1})."
  _frame 0,$1,0,${2--1}

_frame :
  v - repeat $! l[$>]
    nm={0,n}
    w={round($1*if(${is_percent\ $1},w,1))}
    h={round($2*if(${is_percent\ $2},h,1))}
    d={round($3*if(${is_percent\ $3},d,1))}
    {w+2*$w},{h+2*$h},{d+2*$d},100% fc[1] ${4--1}
    j[1] [0],$w,$h,$d rm[0] nm $nm
  endl done v +

#@cli img2ascii : _charset,_analysis_scale>0,_analysis_smoothness[%]>=0,_synthesis_scale>0,_output_ascii_filename
#@cli : Render selected images as binary ascii art.
#@cli : This command returns the corresponding the list of widths and heights (expressed as a number of characters) for each selected image.
#@cli : Default values: 'charset=[ascii charset]', 'analysis_scale=16', 'analysis_smoothness=20%', 'synthesis_scale=16' and '_output_ascii_filename=[undefined]'.
#@cli : $ image.jpg img2ascii ,
img2ascii : skip "${1= !\042#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~}","${5=}" check "${2=16}>0 && ${3=20%}>=0 && ${4=16}>0"
  e[^-1] "Render image$? as binary ascii art, with charset '$1', analysis scale $2, analysis smoothness $3, synthesis scale $4 and output ascii filename '$5'."
  v -
  is_multi={$!>1}

  # Generate dictionnaries for image analysis and synthesis.
  l[]
    ({'"$1"'}) repeat {w}
      C={`92`}${dec2oct\ {0,@$>}}
      0 t. $C,0,0,$2,1,1
      0 t. $C,0,0,$4,1,1
    done rm[0]
    = -1 = -1,0,100% autocrop = 0 = 0,0,100%
    l[0--2:2] r {${-max_w}+1},100%,1,1,0,0,0.5 b $3 n 0,255 a z endl
    l[1--1] r {${-max_w}+1},100%,1,1,0,0,0.5 a z endl
  endl
  w={-2,w} h={-2,h}

  # Transform selected images to ascii art.
  repeat {$!-2} l[$>,-2,-1]
    luminance[0] n[0] 0,255
    nw={0,round(w/$w,1,1)}
    nh={0,round(h/$h,1,1)}
    if $> list_wh=$list_wh,$nw,$nh else list_wh=$nw,$nh fi

    s[0] y,-$h s[0--3] x,-$w r[0--3] $w,$h,1,1,0,0
    repeat {$!-2} l[$>,-2,-1]
      rprogress {$>*100/($!-2)}
      r[0] [1] -[0] [1] sqr[0] r[0] 1,1,100%,1,2 y[0]
      C={0,ym} rm[0]
      +slices[1] $C mv. 0
      if {narg("$5")} +f[0] $C a[0,-1] c fi
    endl done
    append_tiles[0--2] $nw,$nh

    if {narg("$5")} s[0] c l[1]  # Export as ascii file.
       r $nw,$nh,1,1,1
       ({'"$1"'}) map[0] . k[0]
       s y i[1-$!] ({'\n'})
       a x
       if $is_multi filename=${filename\ "$5",$>} else filename="$5" fi
       o raw:$filename,char rm
    endl fi

  endl done
  rm[-2,-1] u $list_wh v +

#@cli imagegrid : M>0,_N>0
#@cli : Create MxN image grid from selected images.
#@cli : Default value: 'N=M'.
#@cli : $ image.jpg imagegrid 16
imagegrid : skip ${2=$1}
  e[^-1] "Create $1x$2 image grid from image$?."
  v - repeat $! l[$>]
    ({w},{h}) ($1,$2) /[-2,-1] round. 1 r.. {^},..,..,2 rm.
    ({w},{h}) ($1,$2) *[-2,-1] r.. {^},..,..,2 rm.
    $1,$2,1,.,1 shift. 1,1 r. ..,0,2 *
  endl done v +

#@cli imagegrid_hexagonal : _resolution>0,0<=_outline<=1
#@cli : Create hexagonal grids from selected images.
#@cli : Default values: 'resolution=32', 'outline=0.1' and 'is_antialiased=1'.
#@cli : $ image.jpg imagegrid_hexagonal 24
imagegrid_hexagonal : check "isint(${1=32}) && $1>0 && ${2=0.1}>=0 && $2<=1"
  e[^-1] "Create hexagonal grid(s) from image$?, with resolution $1 and outline $2."
  v - repeat $! l[$>]

    # Generate hexagonal grid.
    l[]
      # Generate hexagon.
      ({'CImg3d'},6,6)
      (0;{2*pi}) -. {pi/2} r. 1,7,1,1,3 +sin. cos.. a[-2,-1] x rows. 0,5 z. 0,2
      2,6,1,1,3,0 1,100%,1,1,y ++. 1 %. 6 rv[-2,-1] a[-3--1] x
      3,100%,1,1,1 1,100%,1,1,1 y a y
      *3d. {1-$2}

      # Generate minimal pattern (2x2 hexagons).
      ++3d {sqrt(3)} ++3d {sqrt(3)/2},1.5
      col3d... 2 col3d.. 3 col3d. 4 +3d
      /3d 1.5
    endl

    # Duplicate it to get a grid with correct size.
    ny={1+round(0.5*$1,1,1)}
    nx={0,1+round($1*w/h*3/(sqrt(3)*4),1,1)}
    array3d. $nx,$ny,1,{4*sqrt(3)/3},2
    c3d. *3d. {0,h/$1}

    # Fill grid with image colors.
    [0],[0] j3d. ..,50%,50%,0,1,2,0,0 rm..
    blend shapeaverage0

  endl done v +

#@cli imagegrid_triangular : pattern_width>=1,_pattern_height>=1,_pattern_type,0<=_outline_opacity<=1,_outline_color1,...
#@cli : Create triangular grids from selected images.
#@cli : 'pattern type' can be { 0=horizontal | 1=vertical | 2=crossed | 3=cube | 4=decreasing | 5=increasing }.
#@cli : Default values: 'pattern_width=24', 'pattern_height=pattern_width', 'pattern_type=0', 'outline_opacity=0.1' and 'outline_color1=0'.
#@cli : $ image.jpg imagegrid_triangular 6,10,3,0.5
imagegrid_triangular : check "$1>=1 && ${2=$1}>=1 && isint(${3=0}) && $3>=0 && $3<=5" skip ${4=0},${5=0}
  v - s0="horizontal" s1="vertical" s2="crossed" s3="cube" v +
  e[^-1] "Create triangular grid(s) from image$?, with pattern width $1, height $2, pattern type '"${s$3}"', "\
          "outline opacity $4 and outline color (${5--1})."
  v -

  # Create triangular patterns and outlines (always square!).
  M={max($1,$2)}
  if {$3==4" || "$3==5} # Decreasing/Increasing.
    $M,$M,1,1,x>y ++. 2 a[-2,-1] x ++. 4 a[-2,-1] y
    $M,$M,1,1,"!x || !y || x==y" r. 200%,200%,1,1,0,2
    a[-2,-1] c
    if {$3==5} mirror. y fi
  elif {$3==3} # Cube.
    $M,$M,1,1,x>y 100%,100%,1,1,w-1-x>=y a[-2,-1] x ++. 2 mirror. y a[-2,-1] y
    ++. 4 =. 4,50%,50% =.. 2 a[-2,-1] x label. 0,0
    (2,2,2,0,1,2,1,1,3,3,3,1,1,0) map.. . rm.
    100%,100%,1,1
    line. 0,0,{$M-1},{$M-1},1,1 line. {$M-1},$M,0,100%,1,1
    line. {$M-1},{$M-1},{3*$M-1},{$M-1},1,1 line. {2*$M},0,0,0,1,1
    line. {2*$M},0,100%,100%,1,1 line. {2*$M},100%,100%,0,1,1
    a[-2,-1] c
  elif {$3==2} # Horizontal + vertical.
    $M,$M,1,1,x>y ++. 2 mirror. x a[-2,-1] x ++. 4 mirror. y a[-2,-1] y
    100%,100%,1,1,"!x || !y || x==int(w/2) || y==int(h/2) || x==y || w-1-x==y"
    a[-2,-1] c
  elif {$3==1} # Vertical.
    $M,$M,1,1,x>y 100%,100%,1,1,w-1-x<=y a[-2,-1] y ++. 2 mirror. x a[-2,-1] x
    100%,100%,1,1,"!x || x==int(w/2) || x==y || w-1-x==y"
    a[-2,-1] c
  else # Horizontal.
    $M,$M,1,1,x>y 100%,100%,1,1,w-1-x>=y a[-2,-1] x ++. 2 mirror. y a[-2,-1] y
    100%,100%,1,1,"!y || y==int(h/2) || x==y || w-1-x==y"
    a[-2,-1] c
  fi

  # Apply grid on images.
  repeat {$!-1}
    wh={$>,w},{$>,h}
    if {$1>$2} r[$>] 100%,{$>,$1*h/$2} elif {$1<$2} r[$>] {$>,$2*w/$1} fi
    +r. [$>],[$>],1,2,0,2,0.5,0.5
    s. c
    blend[$>,-2] shapeaverage
    +fc[$>] ${5--1} j[$>] .,0,0,0,0,$4,.. rm[-2,-1]
    r[$>] $wh,1,100%,2
  done
  rm.
  v +

#@cli linearize_tiles : M>0,_N>0
#@cli : Linearize MxN tiles on selected images.
#@cli : Default value: 'N=M'.
#@cli : $ image.jpg +linearize_tiles 16
linearize_tiles : check "$1>0 && ${2=$1}>0"
  e[^-1] "Linearize $1x$2 tiles on image$?."
  v - repeat $! l[$>] nm={0,n}
    s={s} split_tiles $1,$2 s c # Split as tiles for all channels.
    repeat $! l[$>]
      wh={w},{h}
      +f x +f. y +f. 1 y a[^0] x solve.. . rm.
      $wh,1,1,{@0}"*x + "{@1}"*y + "{@2} rm..
    endl done
    repeat {int($!/$s)} a[-$s--1] c mv. 0 done append_tiles $1,$2
  nm $nm endl done v +

#@cli map_sprites : _nb_sprites>=1,_allow_rotation={ 0=none | 1=90 deg. | 2=180 deg. }
#@cli : Map set of sprites (defined as the 'nb_sprites' latest images of the selection) to other selected images,
#@cli : according to the luminosity of their pixel values.
#@cli : $ image.jpg resize2dy 48 repeat 16 ball {8+2*$>},${-RGB} mul[-1] {(1+$>)/16} done map_sprites 16
map_sprites : check "isint($1) && $1>0 && isint(${2=0}) && $2>=0 && $2<=2"
  e[^-1] "Map set of $1 sprites to image selection$?."
  v - norm[0--{$1+1}] quantize[0--{$1+1}] $1,0,1
  slices[-$1--1] 0 r[-$1--1] ${max_wh[-$1--1]},1,100%,0,0,0.5,0.5
  if {$2==1}
    N={4*$1}
    repeat {$!-$1} *[$>] 4 +rand[$>] 0,3 round. +[$>,-1] done
    repeat $1 l[{1+$<}] +mirror xy +rotate 90 endl done
  elif {$2==2}
    N={2*$1}
    repeat {$!-$1} *[$>] 2 +rand[$>] 0,1 round. +[$>,-1] done
    repeat $1 l[{1+$<}] +mirror xy endl done
  else N=$1 fi
  r[-$N--1] 100%,100%,1,${max_s[-$N--1]} w={w} h={h} a[-$N--1] x
  r[^-1] ${w}00%,${h}00%,1,1 *[^-1] $w
  (0,{$w-1};0,{$w-1}^0,0;{$h-1},{$h-1}) r. $w,$h,1,2,3 round.
  repeat {$!-2} +r. [$>],[$>],1,2,0,2 r[$>] 100%,100%,1,2,0 +[$>,-1] +warp.. [$>],0,0 rv[$>,-1] rm. done rm[-2,-1] v +

#@cli pack : is_ratio_constraint={ 0 | 1 },_sort_criterion
#@cli : Pack selected images into a single image.
#@cli : The returned status contains the list of new (x,y) offsets for each input image.
#@cli : Parameter 'is_ratio_constraint' tells if the resulting image must tend to a square image.
#@cli : Default values: 'is_ratio_constraint=0' and 'sort_criterion=max(w,h)'.
#@cli : $ image.jpg repeat 10 +resize2dx[-1] 75% balance_gamma[-1] ${-RGB} done pack 0
pack : skip ${1=0},${2=max(w,h)}
  e[^-1] "Pack image$? into a single image."
  if {$!<2} return fi
  if {${-max_d}>1} error[0--3] "Command '$0': Selected images contain at least one volumetric image (depth>1). Should all be 2D." fi
  v -
  nm={0,n} to_colormode 0

  # Sort images by decreasing size.
  repeat $! nm$>={0,n} nm[$>] $> done
  sort_list -,"$2"

  # Start packing
  offsets{0,n}=0,0
  N=$!
  i[0] 0 # List of empty slots.

  do l[0,1,2]
    w1={1,w} h1={1,h} w2={2,w} h2={2,h}

    # Search an empty slot that fits.
    slot=-1 min_slot_area=inf
    repeat {0,h}
      x={0,i(0,$>)} y={0,i(1,$>)} w={0,i(2,$>)} h={0,i(3,$>)}
      slot_area={$w*$h}
      if {$w>=$w2" && "$h>=$h2" && "$slot_area<=$min_slot_area} # Found a fit.
        slot=$> min_slot_area=$slot_area
      fi
    done

    if {$slot>=0} # Empty slot found -> Use it.
      x={0,i(0,$slot)} y={0,i(1,$slot)} w={0,i(2,$slot)} h={0,i(3,$slot)}
      j[1] [2],$x,$y offsets{2,n}=$x,$y
      l[0]
        s y rm[$slot]
        area1={max(($w-$w2)*$h,$w2*($h-$h2))}
        area2={max(($w-$w2)*$h2,$w*($h-$h2))}
        if {$area1>=$area2} # Split - type1
          if {$w2<$w} i[$slot] ({$x+$w2},$y,{$w-$w2},$h) fi
          if {$h2<$h} i[$slot] ($x,{$y+$h2},$w2,{$h-$h2}) fi
        else # Split - type 2
          if {$w2<$w} i[$slot] ({$x+$w2},$y,{$w-$w2},$h2) fi
          if {$h2<$h} i[$slot] ($x,{$y+$h2},$w,{$h-$h2}) fi
        fi
        a y if {!$!} 0 fi
      endl
      rm[2]

    else # Empty slot not found -> Append horizontally or vertically.
      if $1
        metric_h={abs($w1+$w2-max($h1,$h2))}
        metric_v={abs($h1+$h2-max($w1,$w2))}
      else
        metric_h={if($h2<$h1,$w2*($h1-$h2),$w1*($h2-$h1))}
        metric_v={if($w2<$w1,($w1-$w2)*$h2,($w2-$w1)*$h1)}
      fi

      if {$metric_h<=$metric_v} # Append horizontally.
        offsets{2,n}=$w1,0
        a[1,2] x,0
        if {$h2<$h1} ($w1,$h2,$w2,{$h1-$h2}) a[0,-1] y
        elif {$h2>$h1} (0,$h1,$w1,{$h2-$h1}) a[0,-1] y
        fi
      else # Append vertically.
        offsets{2,n}=0,$h1
        a[1,2] y,0
        if {$w2<$w1} ($w2,$h1,{$w1-$w2},$h2) a[0,-1] y
        elif {$w2>$w1} ($w1,0,{$w2-$w1},$h1) a[0,-1] y
        fi
      fi
    fi

  endl while {$!>2}
  rm[0]

  # Return offsets.
  status=
  repeat $N if {narg($status)} status=$status,${offsets$>} else status=${offsets$>} fi done
  nm $nm u $status
  v +

#@cli puzzle : _width>0,_height>0,_M>=1,_N>=1,_curvature,_centering,_connectors_variability,_resolution>=1
#@cli : Input puzzle binary mask with specified size and geometry.
#@cli : Default values: 'width=height=512', 'M=N=5', 'curvature=0.5', 'centering=0.5', 'connectors_variability=0.5' and 'resolution=64'.
#@cli : $ puzzle ,
puzzle : check "isint(${1=512}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=5}) && $3>0 && isint(${4=$3}) && $4>0 && isint(${8=64}) && $8>0"
         skip ${5=0.5},${6=0.5},${7=0.5}
  e[^-1] "Draw $3x$4 puzzle pattern on image$?, with curvature $5, centering $6, connectors variability $7 and resolution $8."
  v - l[]
    if {$4>=2} _puzzle[] $3,{$4-1},${5-8} +3d. 0,1 fi
    if {$3>=2} _puzzle[] $4,{$3-1},${5-8} r3d. 0,0,1,-90 +3d. 1,$4 fi
    *3d {$1/$3},{$2/$4} quadrangle3d 0,0,0,{$1-1},0,0,{$1-1},{$2-1},0,0,{$2-1},0 p3d. 1 +3d col3d 1
    $1,$2 j3d. ..,0,0,0,1,1,0,0 rm..
  endl v +

_puzzle :
  R={$6*$1}
  repeat $2
    ({'CImg3d'},$R,{$R-1})
    repeat $1
      sign={if(u<=0.5,-1,1)}
      center={$4*u(-0.25,0.25)}
      knob={$5*u(-0.05,0.12)}
      ($>,0;\
       {0.2+$center+$>},{-$sign*$3*0.1};\
       {0.4+$center+$>},0;\
       {0.35+$center+$>},{0.1*$sign};\
       {0.45+$center+$>},{(0.15+$knob)*$sign};\
       {0.55+$center+$>},{(0.15+$knob)*$sign};\
       {0.65+$center+$>},{0.1*$sign};\
       {0.6+$center+$>},0;\
       {0.8+$center+$>},{-$sign*$3*0.1})
    done
    ($1,0) a[-{$1+1}--1] y r. 2,$R,1,1,5 z. 0,2
    (2,0,1;2,{$R-2},{$R-1}) r. 3,{$R-1},1,1,3 round.
    3,{h},1,1,255 1,{h},1,1,255 y[-5--1] y a[-5--1] y +3d. 0,$>
  done +3d

#@cli quadratize_tiles : M>0,_N>0
#@cli : Quadratize MxN tiles on selected images.
#@cli : Default value: 'N=M'.
#@cli : $ image.jpg +quadratize_tiles 16
quadratize_tiles : check "$1>0 && ${2=$1}>0"
  e[^-1] "Quadratize $1x$2 tiles on image$?."
  v - repeat $! l[$>] nm={0,n}
    s={s} split_tiles $1,$2 s c # Split as tiles for all channels.
    repeat $! l[$>]
      wh={w},{h}
      +f x^2 +f. y^2 +f. x*y +f. x +f. y +f. 1 y a[^0] x
      solve.. . rm.
      $wh,1,1,{@0}"*x^2 + "{@1}"*y^2 + "{@2}"*x*y +"{@3}"*x + "{@4}"*y + "{@5} rm..
    endl done
    repeat {int($!/$s)} a[-$s--1] c mv. 0 done append_tiles $1,$2
  nm $nm endl done v +

#@cli rotate_tiles : angle,_M>0,N>0
#@cli : Apply MxN tiled-rotation effect on selected images.
#@cli : Default values: 'M=8' and 'N=M'.
#@cli : $ image.jpg to_rgba rotate_tiles 10,8 drop_shadow 10,10 display_rgba
rotate_tiles : skip ${2=8},${3=$2}
  e[^-1] "Apply $2x$3 tiled-rotation effect on image$?, with angle $1 deg."
  v - split_tiles $2,$3,1 rotate $1 append_tiles $2,$3 v +

#@cli shift_tiles : M>0,_N>0,_amplitude
#@cli : Apply MxN tiled-shift effect on selected images.
#@cli : Default values: 'N=M' and 'amplitude=20'.
#@cli : $ image.jpg +shift_tiles 8,8,10
shift_tiles : check "${2=$1}>=0" skip ${3=20}
  e[^-1] "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
  v - repeat $! l[$>]
    $1,$2,1,2 noise. $3 r. ..,..,1,2 warp.. .,1,1,0 rm.
  endl done v +

#@cli taquin : M>0,_N>0,_remove_tile={ 0=none | 1=first | 2=last | 3=random },_relief,_border_thickness[%],_border_outline[%],_outline_color
#@cli : Create MxN taquin puzzle from selected images.
#@cli : Default value: 'N=M', 'relief=50', 'border_thickness=5', 'border_outline=0' and 'remove_tile=0'.
#@cli : $ image.jpg +taquin 8
taquin : check "isint($1) && $1>0 & isint(${2=$1}) && $2>0" skip ${3=0},${4=50},${5=5%},${6=0},${7=0},${8=$7},${9=$8},${10=255}
 e[^-1] "Create $1x$2 taquin puzzle from image$?, with relief $4, border thickness $5, border outline $6 and outline color (${7--1})."
 v - repeat $! l[$>] nm={0,n}
   split_tiles $1,$2 r ${-min_wh},100%,100%,0
   100%,100%,1,1,1
   if ${"is_percent $5"} rectangle. {100*$5/2}%,{100*$5/2}%,{100-50*$5}%,{100-50*$5}%,1,0
   else rectangle. $5,$5,{w-1-$5},{h-1-$5},1,0 fi
   *. '1-2*(x/w<y/h)' *. $4
   repeat {$!-1} l[$>,-1] split_opacity[0] +[0] . a[^-1] c endl done rm. c 0,255
   frame $6,$6,${7-10}
   if {$3==3} f. 0 fi
   repeat $! mv[$>] {u($!)} done
   if {$3==1} f[0] 0 elif {$3==2} f. 0 fi
   append_tiles $1,$2
 nm $nm endl done v +

#@cli tunnel : _level>=0,_factor>0,_centering_x,_centering_y,_opacity,_angle
#@cli : Apply tunnel effect on selected images.
#@cli : Default values: 'level=9', 'factor=80%', 'centering_x=centering_y=0.5', 'opacity=1' and 'angle=0'
#@cli : $ image.jpg tunnel 20
tunnel : check "${1=9}>=0 && ${2=80%}>0" skip ${3=0.5},${4=0.5},${5=0.1},${6=0}
  e[^-1] "Apply tunnel effect on image$?, with depth $1, factor $2, centering ($3,$4), opacity $5 and angle $6."
  v - repeat $! l[$>]
    repeat $1 +r. $2,$2,1,100%,5
    if $6 100%,100%,1,1,1 rotate[-2,-1] $6,1,0 erode. 3 j... ..,{({-3,w}-w)*$3},{({-3,h}-h)*$4},0,0,$5,. rm[-2,-1]
    else j.. .,{({-2,w}-w)*$3},{({-2,h}-h)*$4},0,0,$5 rm. fi
    done
  endl done c 0,255 v +

#-----------------------------
#
#@cli :: Artistic
#
#-----------------------------

#@cli boxfitting : _min_box_size>=1,_max_box_size>=0,_initial_density>=0,_nb_attempts>=1
#@cli : Apply box fitting effect on selected images, as displayed the web page:
#@cli : [http://www.complexification.net/gallery/machines/boxFittingImg/]
#@cli : Default values: 'min_box_size=1', 'max_box_size=0', 'initial_density=0.1' and 'nb_attempts=3'.
#@cli : $ image.jpg boxfitting ,
boxfitting : check "isint(${1=3}) && $1>=1 && isint(${2=0}) && $2>=0 && ${3=0.1}>=0 && isint(${4=3}) && $4>=1"
  e[^-1] "Apply box fitting effect on image$?, with box sizes ($1,$2), density $3 and $4 attempts."
  v -
  min_size=$1
  max_size={if($2,$2,max(w,h))}
  repeat $! l[$>]
    nb_attempts=0 prec=5
    100%,100%
    repeat 1e8

      # Add random non-intersecting squares with min size.
      if {$><1} # Takes random points for the first iteration.
        100%,100% noise. {max(1e-3,$3)},2 ==. 1
      else # Then, try to take points near the median axis of the distance function otherwise.
        +distance. 1 +rand. 0,1 *[-2,-1] max_patch. {round($prec*$min_size)}
        prec={max(1,$prec*0.9)}
      fi

      # Discard new squares that intersect something.
      dilate. $min_size area_fg. 0,1 ==. {($min_size)^2}
      +dilate.. 3 ==. 0 *[-2,-1] area_fg. 0,1 ==. {($min_size)^2}
      if {!iM} nb_attempts+=1 if {$nb_attempts>$4} rm. break fi # If no new squares have been placed.
      else nb_attempts=0 fi
      +[-2,-1]

      # Make current squares grown until max square size is reached.
      repeat {int(($max_size-$min_size)/2)}
        +dilate. 3 area_fg. 0,1 ==. {($min_size+2*$>+2)^2}
        if {!iM} rm. break fi  # No more squares to grow.
        -|[-2,-1]
      done

    done
    blend shapeaverage0
  endl done v +

#@cli brushify : [brush],_brush_nb_sizes>=1,0<=_brush_min_size_factor<=1,_brush_nb_orientations>=1,_brush_light_type,0<=_brush_light_strength<=1,_brush_opacity,_painting_density[%]>=0,0<=_painting_contours_coherence<=1,0<=_painting_orientation_coherence<=1,_painting_coherence_alpha[%]>=0,_painting_coherence_sigma[%]>=0,_painting_primary_angle,0<=_painting_angle_dispersion<=1
#@cli : Apply specified brush to create painterly versions of specified images.
#@cli : 'brush_light_type' can be { 0=none | 1=flat | 2=darken | 3=lighten | 4=full }.
#@cli : Default values: 'brush_nb_sizes=3', 'brush_min_size_factor=0.66', 'brush_nb_orientations=12', 'brush_light_type=0', 'brush_light_strength=0.25', 'brush_opacity=0.8', 'painting_density=20%', 'painting_contours_coherence=0.9', 'painting_orientation_coherence=0.9', 'painting_coherence_alpha=1', 'painting_coherence_sigma=1', 'painting_primary_angle=0', 'painting_angle_dispersion=0.2'
#@cli : $ image.jpg 40,40 gaussian[-1] 8,2 spread[-1] 4,0 +brushify[0] [1]
brushify : check ${"is_image_arg $1"}" &&"\         # $1: [brush]
                    "isint(${2=4}) && $2>=1 &&"\      # $2: brush_nb_sizes
                    "${3=0.25}>=0 && $3<=1 &&"\       # $3: brush_min_size_factor
                    "isint(${4=12}) && $4>=1 &&"\     # $4: brush_nb_orientations
                    "isint(${5=4}) && $5>=0 &&"\      # $5: brush_light_type
                    "${6=0.07}>=0 && $6<=1 &&"\       # $6: brush_light_strength
                    "isval(${7=0.75}) &&"\            # $7: brush_opacity
                    "${8=40%}>=0 && $8>=0 &&"\        # $8: painting_density[%]
                    "${9=0.7}>=0 && $9<=1 &&"\        # $9: painting_contours_coherence
                    "${10=1}>=0 && $10<=1 &&"\        # $10: painting_orientation_coherence
                    "${11=1}>=0 && ${12=0.5%}>=0 &&"\ # $11 and $12: painting_coherence_alpha and painting_coherence_sigma
                    "isval(${13=45}) &&"\             # $13: painting_primary_angle
                    "${14=0.2}>=0 && $14<=1"          # $14: painting_angle_dispersion
  e[^-1] "Brushify image$?, with brush $1."
  v -

  # Precompute the set of oriented/resized brushes.
  pass$1 0 l.
    slices 0 norm n 0,1 threshold 0.1,1 autocrop.
    repeat $4 +rotate[0] {360*$>/$4} done
    rm[0] n 0,1 threshold 0.1,1 autocrop r ${-max_wh},1,1,0,0,0.5,0.5
    a z nm brush
    wb={w} hb={h} whb={wh} ls={255*$6}
    if {$5==0} +f. 0
    elif {$5==1} +n. -$ls,0
    elif {$5==2} +g xy +[-2,-1] min. 0 n. -$ls,0
    elif {$5==3} +g xy +[-2,-1] max. 0 n. 0,$ls
    else +g xy +[-2,-1] n. -$ls,$ls
    fi
    nm. brushlight

    repeat {$2-1}
      ratio={v=(1+$>)/max(1,$2-1);100*((1-v)+$3*v)}%
      +r[brush,brushlight] $ratio,$ratio,100%,1,2
      r[-2,-1] [brush],0,0,0.5,0.5
    done
    a[^:2] z a[^0] z
  endl

  # Generate images with brushes.
  repeat {$!-2} l[$>,brush,brushlight]
    s={0,s} nm={0,n} to_rgb[0] nm[0] img

    # Generate set of random points with orientations.
    +diffusiontensors[img] $9,$10,$11,$12 nm. geometry
    +channels[geometry] 0 sh[geometry] 2 +[-2,-1] ^. 0.3 quantize. $2,0 *. -1 +. $2 -. 1 nm. contours
    1,{img,max(1,${"is_percent $8"}?wh*$8:$8)} rand. 0,{img,w-1} +rand. 0,{img,h-1} a[-2,-1] c nm. pts
    +to_rgba[img] nm. res

    # Render filter.
    f[pts] "*
      begin(
        S2 = round(0.5*["$wb","$hb"]);
        brush_r = brush_g = brush_b = brush_a = vector"$whb"(255);
        ang = $13*pi/180;
        cu = [ cos(ang),sin(ang) ];
        cv = [ -cu[1],cu[0] ];
        T = mul(cu,cu,2) + $14*mul(cv,cv,2);
      );
      P = I;
      G = I(#"$geometry",P);
      ang = u(pi);
      V = [ G[0],G[1],G[1],G[2] ]*(T*[ cos(ang),sin(ang) ]);
      amp = i(#"$contours",P); #cut($2-round(5*$2*sqrt(G[0] + G[2])),0,$2-1);
      ang = round(((atan2(V[1],V[0])%(2*pi))*$4/(2*pi)))%$4;
      col = I(#"$img",P);
      ind = amp*$4 + ang;
      brush = crop(#"$brush",0,0,ind,0,"$wb","$hb",1,1);
      brushlight = crop(#"$brushlight",0,0,ind,0,"$wb","$hb",1,1);
      brush_r = cut(col[0] + brushlight,0,255);
      brush_g = cut(col[1] + brushlight,0,255);
      brush_b = cut(col[2] + brushlight,0,255);
      draw(#"$res",[brush_r,brush_g,brush_b,brush_a],P - S2,"$wb","$hb",1,4,$7,brush,1);
      P"
    k[res,brush,brushlight] mv[res] 0 nm[0] $nm to_colormode[0] {$s+($s%2)}
  endl done rm[brush,brushlight] v +

#@cli cartoon : _smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0
#@cli : Apply cartoon effect on selected images.
#@cli : Default values: 'smoothness=3', 'sharpening=150', 'threshold=20', 'thickness=0.25', 'color=1.5' and 'quantization=8'.
#@cli : $ image.jpg cartoon 3,80,15
cartoon : skip ${1=3},${2=150},${3=20},${4=0.25},${5=1.5},${6=8}
  e[^-1] "Apply cartoon effect on image$?, with smoothness $1, sharpening $2, threshold $3, thickness $4, color $5 and quantization $6."
  v - repeat $! l[$>] split_opacity l[0] to_rgb
    b $1 sharpen $2,1 c 0,255 n 0,255
    if $4 +edges $3 b. $4 >=. 0.9 else 100%,100%,1,1,1 fi
    rgb2lab.. s.. c *[-3,-2] $5 a[-4--2] c lab2rgb.. quantize.. $6,1,0 n.. 0,255 *
  endl a c endl done v +

#@cli color_ellipses : _count>0,_radius>=0,_opacity>=0
#@cli : Add random color ellipses to selected images.
#@cli : Default values: 'count=400', 'radius=5' and 'opacity=0.1'.
#@cli : $ image.jpg +color_ellipses ,,0.15
color_ellipses : skip ${1=1400},${2=5},${3=0.1}
  e[^-1] "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
  v - repeat $1 ellipse {u(0,100)}%,{u(0,100)}%,{u(0,$2)}%,{u(0,$2)}%,{u(0,360)},$3,{u(60,255)},{u(60,255)},{u(60,255)},255 done v +

#@cli cubism : _density>=0,0<=_thickness<=50,_max_angle,_opacity,_smoothness>=0
#@cli : Apply cubism effect on selected images.
#@cli : Default values: 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'.
#@cli : $ image.jpg cubism ,
cubism : check "${1=50}>=0 && ${2=10}>=0 && $2<=50 && ${5=0}>=0" skip ${3=75},${4=0.7}
  e[^-1] "Apply cubism effect on image$?, with density $1, thickness $2, maximum angle $3 deg., opacity $4 and smoothness $5."
  if {"!$1 || !$2 || !$3 || !$4"} return fi
  v - repeat $! l[$>]
    w={w} h={h} s={s}
    P={round($2*max(w,h)/200)}
    N={round(1.5*$1*w*h/(4*$P)/100)}

    # Define Header + nb vertices / primitives.
    ({'CImg3d'}) +. 0.5 ({4*$N};$N)

    # Generate list of random points.
    1,$N rand. $P,{$w-1-$P} +rand. $P,{$h-1-$P} a[-2,-1] x round.

    # Generate list of primitives.
    ++. '-$P,-$P' ++.. '$P,-$P' ++... '$P,$P' ++[-4] '-$P,$P'
    a[-4--1] x i.. (12,0,1,2,3;12,{4*($N-1)},{4*($N-1)+1},{4*($N-1)+2},{4*($N-1)+3})
    r.. 5,$N,1,1,3 round.. 1 a[-2,-1] x

    # Generate list of vertices.
    1,$N rand. {225-$3},{225+$3} *. {pi/180}
    +sin. cos.. +*. -1 ... a[-4--3] x a[-2,-1] x z[-4,-2,-1] 0,2 +*[-2,-1] -1 a[-4--1] x *. {sqrt(2)*$P}
    r... 400%,100%,1,1,0,2 +[-3,-1]

    # Generate materials.
    (-128;$w;$h;$s) +b[0] $5
    if {$N>1} 4,{$N-1},1,1,-128,0,0,0 fi
    1,$N,1,1,1

    # Apply effect on current image.
    y[1--1] a[1--1] y rv3d.
    if {$4>=1} j3d[0] [1],0,0,0,1,2,0,0 rm[1]
    else +j3d[0] [1],0,0,0,1,2,0,0 rm[1] blend alpha,$4
    fi

  endl done v +

#@cli draw_whirl : _amplitude>=0
#@cli : Apply whirl drawing effect on selected images.
#@cli : Default value: 'amplitude=100'.
#@cli : $ image.jpg draw_whirl ,
draw_whirl : skip ${1=100}
  e[^-1] "Apply whirl drawing effect on image$? with amplitude $1."
  v - repeat $! l[$>]
    100%,100% noise. 70,2 ==. 1 *. 255 r. .. &[-1,-2] smooth. $1,0,1,2,2
    sqrt. n. 0,255 equalize.
  endl done v +

#@cli drawing : _amplitude>=0
#@cli : Apply drawing effect on selected images.
#@cli : Default value: 'amplitude=200'.
#@cli : $ image.jpg +drawing ,
drawing : skip ${1=200}
  e[^-1] "Apply drawing effect on image$? with amplitude $1."
  v - repeat $! l[$>] split_opacity l[0] to_rgb
    smooth $1,0.2,1,3,3 b 2 sharpen 1000 [0]
    r[0] 20,20,1,3,2 equalize[0] index[1] [0],1,1
    nm[1] {0,n},1 rm[0]
  endl a c endl done v +

#@cli drop_shadow : _offset_x[%],_offset_y[%],_smoothness[%]>=0,0<=_curvature<=1,_expand_size={ 0 | 1 }
#@cli : Drop shadow behind selected images.
#@cli : Default values: 'offset_x=20', 'offset_y=offset_x', 'smoothness=5', 'curvature=0' and 'expand_size=1'.
#@cli : $ image.jpg drop_shadow 10,20,5,0.5 expand_xy 20,0 display_rgba
drop_shadow : check "${3=5}>=0 && ${4=0}>=0 && $4<=1" skip ${1=20},${2=$1},${5=1}
  e[^-1] "Drop shadow behind image$?, with offsets ($1,$2), smoothness $3 and curvature $4."
  v - to_a repeat $! l[$>]
    nm={0,n}
    dx={if(${is_percent\ $1},w*$1,$1)}
    dy={if(${is_percent\ $2},h*$2,$2)}
    sigma={if(${is_percent\ $3},max(w,h)*$3,$3)}
    w={w} h={h} s={s} +channels 100% coords=${autocrop_coords.\ 0} rm. z $coords  # Crop part with opaque pixels.
    r {w+abs($dx)},{h+abs($dy)},1,100%,0,0,{if($dx>0,0,1)},{if($dy>0,0,1)} r. {w+4*$sigma},{h+4*$sigma},1,100%,0,0,0.5,0.5
    +channels. 100%
    if {!$4} shift. $dx,$dy # Flat shadow.
    else # Curved shadow.
      (0;{pi}) r. ..,3 sin. *. -$4 +. 1 *. $dx
      (0,{pi}) r. ..,3 sin. *. -$4 +. 1 *. $dy
      a[-2,-1] c warp.. .,1,0,0 rm.
    fi
    b. $sigma,0
    r. 100%,100%,1,2,0,0,0,0,0,1 mv. 0 blend alpha
    +channels. 100% >=. 1 * autocrop 0
    if {!$5} $w,$h,1,$s j. ..,{arg(1,$coords)},{arg(2,$coords)} rm.. fi
    nm $nm
  endl done v +

#@cli ellipsionism : _R>0[%],_r>0[%],_smoothness>=0[%],_opacity,_outline>0,_density>0
#@cli : Apply ellipsionism filter to selected images.
#@cli : Default values: 'R=10', 'r=3', 'smoothness=1%', 'opacity=0.7', 'outlise=8' and 'density=0.6'.
#@cli : $ image.jpg +ellipsionism ,
ellipsionism : check "${1=10}>0 && ${2=3}>0 && ${5=8}>0 && ${6=0.6}>0" skip ${3=1%},${4=0.7}
  e[^-1] "Apply ellipsionism filter to image$?, with radii ($1,$2), smoothness $3, opacity $4 and outline $5."
  v - to_rgba repeat $! l[$>]

    # Compute contour angle.
    +luminance g. xy a[-2,-1] c b. $3 orientation.
    sh. 0 sh.. 1 atan2. .. *. {180/pi} +. 90 rm[-2,-1] channels. 1,1

    # Render ellipses.
    ..,..,1,..
    repeat {$6*w*h/max($1,$2)}
      xy={u(w)},{u(h)}
      ellipse. $xy,$1,$2,{-2,i($xy)},$4,\
                {-3,i($xy,0,0)},{-3,i($xy,0,1)},{-3,i($xy,0,2)},{-3,i($xy,0,3)}
      ellipse. $xy,$1,$2,{-2,i($xy)},$4,0x1,\
                {-3,i($xy,0,0)/$5},{-3,i($xy,0,1)/$5},{-3,i($xy,0,2)/$5},{-3,i($xy,0,3)/$5}
    done rm..

    # Renormalize and prepare next image.
    n. .. blend alpha
  endl done v +

#@cli fire_edges : _edges>=0,0<=_attenuation<=1,_smoothness>=0,_threshold>=0,_nb_frames>0,_starting_frame>=0,frame_skip>=0
#@cli : Generate fire effect from edges of selected images.
#@cli : Default values: 'edges=0.7', 'attenuation=0.25', 'smoothness=0.5', 'threshold=25', 'nb_frames=1', 'starting_frame=20' and 'frame_skip=0'.
#@cli : $ image.jpg fire_edges ,
fire_edges : check "${1=0.7}>=0 && ${2=0.25}>=0 && $2<=1 && ${3=0.5}>=0 && ${4=25}>=0 && ${5=1}>0 && ${6=20}>=0 && ${7=0}>=0"
  e[^-1] "Generate fire effect from edges of image$?, with edges $1, attenuation $2, smoothness $3, threshold $4, "\
          "$5 frames, starting frame $6 and frame skip $7."
  v - repeat $! l[$>] nm={0,n}
    norm +gradient_norm n. 0,1 roundify. $1 f[0] 0
    (0,0,0;0,0,0;1,1,1;0,1,0) *. {(1-$2^4)/4}
    repeat {$5*(1+$7)+$6}
      {0,w},{0,h} rand. 0,255 *. [1]
      b. $3
      if $4 >=. $4% else equalize. fi
      n. 0,255
      j[0] .,0,0,0,0,1,[1],1 rm.
      correlate[0] [2]
      if {$>>=$6" && "($>-$6)%($7+1)==0} [0] fi
    done rm[0-2]
  nm $nm endl done
  (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) r. 256,1,1,3,3
  map[^-1] . rm. v +

#@cli fractalize : 0<=detail_level<=1
#@cli : Randomly fractalize selected images.
#@cli : Default value: 'detail_level=0.8'
#@cli : $ image.jpg fractalize ,
fractalize : check "${1=0.8}>=0 && $1<=1"
  e[^-1] "Randomly fractalize image$?, with detail level $1."
  v -
  xc=0.4433
  yc=0.2645
  delta=0.1
  c0r=0.317
  c0i=0.03
  repeat $! l[$>] nm={0,n}
    luminance equalize 256 b 0.25% n 0,255
    100%,100%
    dx={$delta*w/max(w,h)}
    dy={$delta*h/max(w,h)}
    x0={$xc-$dx/2}
    y0={$yc-$dy/2}
    x1={$xc+$dx/2}
    y1={$yc+$dy/2}
    mandelbrot. $x0,$y0,$x1,$y1,256,1,$c0r,$c0i
    +==. 0 inpaint.. . rm.
    n. 0,256
    16,1,1,3 rand. 0,255 r. 256,1,1,3,3 map.. . rm.
    s. c
    i[2,3] [0]
    s={0.1*(1-$1)}
    parallel "register_nonrigid[1] [0],"$s",5","register_nonrigid[3] [2],"$s",5","register_nonrigid[5] [4],"$s",5"
    rm[0,2,4] a c nm $nm
  endl done v +

#@cli glow : _amplitude>=0
#@cli : Add soft glow on selected images.
#@cli : Default value: 'amplitude=1%'.
#@cli : $ image.jpg glow ,
glow : skip ${1=1%}
  e[^-1] "Add soft glow on image$?, with amplitude $1."
  v - repeat $! l[$>] split_opacity +b[0] $1 n. [0] blend_edges[0,-1] 1 a c endl done v +

#@cli halftone : nb_levels>=2,_size_dark>=2,_size_bright>=2,_shape={ 0=square | 1=diamond | 2=circle | 3=inv-square | 4=inv-diamond | 5=inv-circle },_smoothness[%]>=0
#@cli : Apply halftone dithering to selected images.
#@cli : Default values: 'nb_levels=5', 'size_dark=8', 'size_bright=8', 'shape=5' and 'smoothnesss=0'.
#@cli : $ image.jpg halftone ,
halftone : check "${1=5}>=2 && ${2=8}>=2 && ${3=8}>=2 && ${5=0}>=0" skip ${4=5}
  v - s0="square" s1="diamond" s2="circle" s3="inv-square" s4="inv-diamond" s5="inv-circle" v +
  e[^-1] "Apply halftone dithering to image$?, with $1 levels, dark size $3, bright size $4, "${s$4}" shape and smoothness $5."
  v - repeat $! l[$>] s c repeat $! l[$>]
    (0,255) a y quantize $1,0 rows 0,{h-2}
    repeat $1
      s={round(($2*$<+$3*$>)/($1-1))}
      $s,$s =. 1,50%,50% distance. 1,{$4%3} +shift. {round(w/2)},{round(h/2)},0,0,2 min[-2,-1]
      if {$4>=3} <. {100*$</($1-1.1)}% *. {-255} +. {255-$>}
      else <. {100*$>/($1-1.1)}% *. 255 -. $>
      fi
      r. ..,0,2 b. $5 +==.. $> *[-2,-1] +[-2,-1]
    done endl done a c
  endl done v +

#@cli hardsketchbw : _amplitude>=0,_density>=0,_opacity,0<=_edge_threshold<=100,_is_fast={ 0 | 1 }
#@cli : Apply hard B&W sketch effect on selected images.
#@cli : Default values: 'amplitude=1000', 'sampling=3', 'opacity=0.1', 'edge_threshold=20' and 'is_fast=0'.
#@cli : $ image.jpg +hardsketchbw 200,70,0.1,10 median[-1] 2 +local reverse blur[-1] 3 blend[-2,-1] overlay endlocal
hardsketchbw : skip ${1=300},${2=50},${3=0.1},${4=20},${5=0}
  e[^-1] "Apply hard B&W sketch effect on image$?, with amplitude $1, density $2, opacity $3 and edge threshold $4."
  if {!$2} channels 0 f 255 return fi
  v - luminance n 0,1

  if $5 # Fast version.
    repeat $! l[$>] nm={0,n}
      g xy rv *.. -1 a c
      if $4 +norm >=. $4% * fi
      100%,100%,1,1,255 quiver. ..,{max(1,10-$2/6)},$1,0,$3 rm..
    nm $nm endl done

  else # Slower version.
    repeat $! l[$>] nm={0,n}

      # Isolate starting points and tangents.
      w={w} h={h} g xy rv *.. -1 a c * $1
      +norm >=. $4% 100%,100% noise. $2,2 ==. 1 *[-2,-1]

      # Retrieve points coordinates and corresponding tangents.
      pointcloud3d. s3d. rm[-6--5,-3--1] r. 3,{h/3},1,1,-1 s. x rm. a[-2,-1] c
      warp.. .,0,0 +-. .. +[-3,-2] s[-2,-1] c

      # Convert as a 3d object and render on white background.
      i... 1,{h} 1,{h} a[-6--1] x
      i.. ({'CImg3d'}) i.. ({2*h},{h})
      1,{h},1,1,2 1,{h},1,1,2*y ++. 1 a[-3--1] x
      3,{h} 1,{h},1,1,$3 y[-6--1] a[-6--1] y
      $w,$h,1,1,255 j3d. ..,0,0,0,1,1,0,0 rm..
    nm $nm endl done
  fi v +

#@cli hearts : _density>=0
#@cli : Apply heart effect on selected images.
#@cli : Default value: 'density=10'.
#@cli : $ image.jpg +hearts ,
hearts : skip ${1=10}
  e[^-1] "Apply heart filter on image$?, with density $1."
  v - repeat $! l[$>]
    100%,100%,1 noise. $1,2 ==. 1 r. .. n. 0,1 *[-1,-2] _heart9x7
    dilate.. . rm.
  endl done v +

_heart9x7 :
  (9,7,1,1,0,1,-1,2,-3,2,-1,4,-1,13,-1,7,-3,5,-5,3,-7,1,-4)
  decompress_rle.

#@cli houghsketchbw : _density>=0,_radius>0,0<=_threshold<=100,0<=_opacity<=1,_votesize[%]>0
#@cli : Apply hough B&W sketch effect on selected images.
#@cli : Default values: 'density=8', 'radius=5', 'threshold=80', 'opacity=0.1' and 'votesize=100%'.
#@cli : $ image.jpg +houghsketchbw ,
houghsketchbw : check "${1=8}>=0 && ${2=5}>=0 && ${3=80}>=0 && $3<=100 && ${4=0.1}>=0 && $4<=1 && ${5=100%}>0"
  e[^-1] "Apply hough B&W sketch effect on image$?, with density $1, radius $2, threshold $3, opacity $4 and votesize $5."
  v - luminance repeat $! l[$>] nm={0,n}

    # Compute normalized Hough transform.
    res={round(if(${is_percent\ $5},$5*max(w,h),$5))} w={w} h={h} rhomax={sqrt(w^2+h^2)/2}
    hough $res,$res n 0,255

    # Retrieve coordinates of maximas in hough space.
    normalize_local. $1,$2 >=. $3% pointcloud3d.
    s3d. rm[-6--5,-3--1] r. 3,{h/3},1,1,-1 columns. 0,1

    # Convert to (x0,y0)-(x1,y1) line coordinates.
    s. x,2
    *.. {2*pi/$res}                 # theta
    *. {$rhomax/$res}               # rho
    +cos.. *. .. +. {$w/2}          # x
    +sin... *. ... +. {$h/2}        # y
    rm...                           # Remove rho
    i... ...
    cos[-4] sin... *[-4,-3] 10000   # cos(t) sin(t)
    ++.. ...                        # x + sin(t)
    +-.. [-5]                       # y - cos(t)
    -[-4] [-5]                      # x - sin(t)
    +... [-6]                       # y + cos(t)
    rm[-6,-5]

    # Transform as a 3D object.
    i... 1,{h} 1,{h} a[-6--1] x                 # Vertices
    i.. ({'CImg3d'}) i.. ({2*h},{h})            # Header and size.
    1,{h},1,1,2 1,{h},1,1,2*y ++. 1 a[-3--1] x  # Primitives.
    3,{h},1,1,0 1,{h},1,1,$4                    # Colors and opacities
    y[-6--1] a[-6--1] y

    # Render on a white image.
    $w,$h,1,1,255 j3d. ..,0,0,0,1,1,0,0 rm..
  nm $nm endl done v +

#@cli lightrays : 100<=_density<=0,_center_x[%],_center_y[%],_ray_length>=0,_ray_attenuation>=0
#@cli : Generate ray lights from the edges of selected images.
#@cli : Defaults values : 'density=50%', 'center_x=50%', 'center_y=50%', 'ray_length=0.9' and 'ray_attenuation=0.5'.
#@cli : $ image.jpg +lightrays , + cut 0,255
lightrays : check "${1=50}>=0 && $1<=100 && ${4=1}>=0 && ${5=1}>=0" skip ${2=50%},${3=50%}
  e[^-1] "Generate ray lights from image$?, with density $1, center point ($2,$3), ray length $4 and attenuation $5."
  v - repeat $! l[$>]
    gradient_norm >= $1% euclidean2polar $2,$3
    repeat {log2(w)} +shift. {2^$>} +[-2,-1] done
    function1d 0.5,0,1,{$4*w},1,{1+($4+1-$5)*w},0 r. {-2,w},1,1,1,0
    (1,{w}) r. {-2,w},1,1,1,3 /[-2,-1]
    r. .. *[-2,-1] polar2euclidean $2,$3 n 0,255
  endl done v +

#@cli light_relief : _ambient_light,_specular_lightness,_specular_size,_light_smoothness,_darkness,_xl,_yl,_zl,_zscale,_opacity_is_heightmap={ 0 | 1 }
#@cli : Apply relief light to selected images.
#@cli : Default values(s) : 'ambient_light=0.3', 'specular_lightness=0.5', 'specular_size=0.2', 'darkness=0', 'xl=0.2', 'yl=zl=0.5',
#@cli : 'zscale=1', 'opacity=1' and 'opacity_is_heightmap=0'.
#@cli : $ image.jpg blur 2 light_relief 0.3,4,0.1,0
light_relief : skip ${1=0.3},${2=0.5},${3=0.2},${4=0},${5=0.2},${6=0.5},${7=0.5},${8=1},${9=1},${10=0}
  e[^-1] "Apply relief light to image$?."
  v - repeat $! l[$>]
    ({-$6},{1-$6};{-$6},{1-$6}^{-$7},{-$7};{1-$7},{1-$7}^$8,$8;$8,$8) r. ..,..,1,3,3  # Create light vector field.
    if $10 +channels.. 3 to_rgb... else +to_rgb.. norm. fi
    b. $5% g. xy 100%,100%,1,1,$9 a[-3--1] c                                          # Create normal vector field.
    orientation[-2,-1] *[-2,-1] s. c +[-3--1]                                         # Normalized scalar product.
    100%,100% =. 1,{$6*100}%,{$7*100}% distance. 1 sqr. *. -1                         # Compute specular attenuation.
    /. {($3*max(w,h))^2} exp. *. $2 +. $1
    *[-2,-1] -. $4 *. {-2,iM}
    split_opacity[0] +[0,-1] a c c 0,255
  endl done v +

#@cli linify : 0<=_density<=100,_spreading>=0,_resolution[%]>0,_line_opacity>=0,_line_precision>0,_mode={ 0=subtractive | 1=additive }
#@cli : Apply linify effect on selected images.
#@cli : The algorithm is inspired from the one described on the webpage 'http://linify.me/about'.
#@cli : Default values: 'density=50', 'spreading=2', 'resolution=40%', 'line_opacity=10', 'line_precision=24' and 'mode=0'.
#@cli : $ image.jpg linify 40
linify : check "${1=40}>=0 && $1<=100 && ${2=2}>=0 && ${3=40%}>0 && ${4=10}>=0 && isint(${5=24}) && $5>0 && isbool(${6=0})"
  e[^-1] "Apply linify effect on image$?, with density $1, spreading $2, resolution $3, line opacity $4, line precision $5 and "${"-arg 1+$6,subtractive,additive"}" mode."
  v - repeat $! l[$>] remove_opacity nm={n}
    100%,100%,1,{s},$6?0:255
    if {0,w>h} r2dx[0] {${"-is_percent $3"}?max(1,$3*w):min(w,$3)}
    else r2dy[0] {${"-is_percent $3"}?max(1,$3*h):min(h,$3)}
    fi
    n[0] 0,100
    if {narg($_debug)" && "!{*,w}} w[] ${-fitscreen[]\ {1,[w,h]}} fi
    eval "
      is_in(ind,P) = (P[0]>=0 && P[0]<w#ind && P[1]>=0 && P[1]<h#ind);
      const add = $6;
      const density = add?100 - $1:$1;
      const spreading = max(0.1,$2);
      const opacity = $4;
      const precision = $5;
      const om2add = 1 - 2*add;

      fact = [ w/w#0, h/h#0,1,1 ];
      nb_lines = 0;
      ref0 = add?iM#0:im#0;
      do (
        S = stats(#0);
        P0 = add?[ S[8],S[9],0,S[11] ]:[ S[4],S[5],0,S[7] ]; # coords of min or max intensity
        ref = S[add];
        best_ang = best_avg = add?0:inf;
        for (k = 0, k<precision, ++k,
          ang = u(360)*pi/180;
          dP = [ cos(ang), sin(ang),0,0 ];
          dP/=max(abs(dP));
          N = avg = 0;
          P = P0; while (is_in(#0,P), avg+=i(#0,P); ++N; P+=dP);
          P = P0; while (is_in(#0,P), avg+=i(#0,P); ++N; P-=dP);
          avg/=N;
          if (add?(avg>best_avg):(avg<best_avg), best_avg = avg; best_ang = ang);
        );
        dP = [ cos(best_ang), sin(best_ang),0,0 ];
        dP/=max(abs(dP));
        P = P0; while (is_in(#0,P), i(#0,P)+=om2add*spreading; P+=dP);
        P = P0; while (is_in(#0,P), i(#0,P)+=om2add*spreading; P-=dP);
        P = P0*fact; while (is_in(#1,P), i(#1,P)-=om2add*opacity*spreading; P+=dP);
        P = P0*fact; while (is_in(#1,P), i(#1,P)-=om2add*opacity*spreading; P-=dP);
        if (!(nb_lines%250),
          progress = density==ref0?100:round(100*(ref - ref0)/(density - ref0));
          ext('progress ',vtos(progress));
          if (narg("$_debug"),ext('+c[1] 0,255 r. {*,w},{*,h},1,3,2 to. ',vtos(progress),'%,1%,1%,5%,1 w. -1,-1,0 rm.'));
        );
        ++nb_lines;
        breakpoint();
      _(while), add?(ref>density):(ref<density))"
    k. c 0,255 nm $nm
  endl done v +

#@cli mosaic : 0<=_density<=100
#@cli : Create random mosaic from selected images.
#@cli : Default values: 'density=30'.
#@cli : $ image.jpg mosaic ,
mosaic : check "${1=30}>=0"
  e[^-1] "Apply mosaic effect on image$?, with density $1."
  v - repeat $! l[$>]
    100%,100%,1,2,'u<0.25*($1%)^4?[u,1]' s. c
    distance. 1 *. -1 watershed.. . rm.
    blend shapeaverage
  endl done v +

#@cli old_photo
#@cli : Apply old photo effect on selected images.
#@cli : $ image.jpg old_photo
old_photo :
  e[^-1] "Apply old photo effect on image$?."
  v - noise 20 bilateral 30,60 b 2 sharpen 100 frame_fuzzy 8%,8%,6,3 to_rgb shadow_patch 0.75 n 0,255 sepia v +

#@cli pencilbw : _size>=0,_amplitude>=0
#@cli : Apply B&W pencil effect on selected images.
#@cli : Default values: 'size=0.3' and 'amplitude=60'.
#@cli : $ image.jpg pencilbw ,
pencilbw : skip ${1=0.3},${2=60}
  e[^-1] "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
  v - repeat $! l[$>] split_opacity l[0] norm b $1 sharpen 4000 smooth $2,0,1 equalize sqrt n 0,255 endl a c endl done v +

#@cli pixelsort : _ordering={ + | - },_axis={ x | y | z | xy | yx },_[sorting_criterion],_[mask]
#@cli : Apply a 'pixel sorting' algorithm on selected images, as described in the page :
#@cli : http://satyarth.me/articles/pixel-sorting/
#@cli : Default values: 'ordering=+', 'axis=x' and 'sorting_criterion=mask=(undefined)'.
#@cli : $ image.jpg +norm +ge[-1] 30% +pixelsort[0] +,y,[1],[2]
pixelsort : check "(str1='${1=+}'; str1=='+' || str1=='-') && "\
                   "(str2='${2=x}'; str2=='x' || str2=='y' || str2=='z' || str2=='xy' || str2=='yx') && "\
                   "('${3=}'==0 || "${"is_image_arg $3"}") && "\
                   "('${4=}'==0 || "${"is_image_arg $4"}")"
  v - s0="descending" s1="ascending" v +
  if {'$3'!=0" && "'$4'!=0}
    e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with sorting criterion $3 and mask $4."
  elif {'$3'!=0" && "'$4'==0}
    e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with sorting criterion $3."
  elif {'$3'==0" && "'$4'!=0}
    e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with mask $4."
  else
    e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2."
  fi
  v - repeat $!
    if {'$3'!=0} pass$3 0 else +compose_channels[$>] + fi
    if {'$4'!=0} pass$4 0 else [$>],[$>],[$>],1,1 fi
    l[$>,-2,-1]
      nm={0,n} >=. 50% mv.. 0 a c
      order={`";'$1'=='+'?'<':'>'"`}
      if {'$2'=='x';}
        _pixelsort $order channels 1,{s-2}
      elif {'$2'=='y';}
        permute yxzc _pixelsort $order channels 1,{s-2} permute yxzc
      elif {'$2'=='z';}
        permute zxyc _pixelsort $order channels 1,{s-2} permute yzxc
      elif {'$2'=='xy';}
        _pixelsort $order permute yxzc _pixelsort $order channels 1,{s-2} permute yxzc
      elif {'$2'=='yx';}
        permute yxzc _pixelsort $order permute yxzc _pixelsort $order channels 1,{s-2}
      fi
      nm $nm
    endl
  done v +

_pixelsort :
  1,{h},{d}
  f. ":
    quicksort(x0,x1,y,z) = (
      stack = vector"{0,2*w}"();
      stacksize = 0;
      push(elt0,elt1) = (stack[stacksize++] = elt0; stack[stacksize++] = elt1);
      pop() = (_s1 = stack[--stacksize]; _s0 = stack[--stacksize]; [_s0,_s1]);
      push(x0,x1);
      while (stacksize>0,
        range = pop();
        lo = range[0];
        hi = range[1];
        pivot = i(#0,int((lo + hi)/2),y,z,0);
        while (lo<=hi,
           while (i(#0,lo,y,z,0)$1pivot, ++lo);
           while (pivot$1i(#0,hi,y,z,0), --hi);
           if (lo<=hi, _tmp = I(#0,lo,y,z); I(#0,lo++,y,z) = I(#0,hi,y,z); I(#0,hi--,y,z) = _tmp);
        );
        if (range[0]<hi,push(range[0],hi));
        if (lo<range[1],push(lo,range[1]));
      )
    );
    s1 = s#0 - 1;
    for (x0 = 0, x0<w#0, ++x0,
      if (i(#0,x0,y,z,s1),
        for (x1 = x0, x1<w#0 && i(#0,x1,y,z,s1)==1, ++x1);
        quicksort(x0,min(x1,w#0-1),y,z);
        x0 = ++x1;
      )
    )"
  rm.

#@cli polaroid : _size1>=0,_size2>=0
#@cli : Create polaroid effect in selected images.
#@cli : Default values: 'size1=10' and 'size2=20'.
#@cli : $ image.jpg to_rgba polaroid 5,30 rotate 20 drop_shadow ,
polaroid : check "${1=10}>=0 && ${2=20}>=0"
  e[^-1] "Create polaroid effect in image$?, with borders sizes $1 and $2."
  v - - 255 r {100+$1}%,{100+$1}%,1,100%,0,0,0.5,0.5 r 100%,{100+$2}%,1,100%,0,0,0 + 255 v +

#@cli polygonize : _warp_amplitude>=0,_smoothness[%]>=0,_min_area[%]>=0,_resolution_x[%]>0,_resolution_y[%]>0
#@cli : Apply polygon effect on selected images.
#@cli : Default values: 'warp_amplitude=300', 'smoothness=2%', 'min_area=0.1%', 'resolution_x=resolution_y=10%'.
#@cli : $ image.jpg polygonize 300,1%,0.1%,3%,3%
polygonize : check "${1=300}>=0 && ${2=2%}>=0 && ${3=0.1%}>=0 && ${4=10%}>0 && ${5=$4}>0"
  e[^-1] "Polygonize image$? with warp amplitude $1, smoothness $2, minimal area $3 and resolutions ($4,$5)."
  v -  repeat $! l[$>]
    +b $2 gradient_norm. g. a[-2,-1] c channels. 0,2 *. {1/0.1+max(abs(im),abs(iM))}
    resx={max(1,round(if(${is_percent\ $4},w*$4,w/$4)-1))}
    resy={max(1,round(if(${is_percent\ $5},h*$5,h/$5)-1))}
    plane3d 1,1,$resx,$resy *3d. {0,w-1},{0,h-1},1
    s3d. rm.. i.. (0;{h-1}) r.. 3,{h},1,1,3 round.. y..
    [-4] a[-7--2] y r. 3,{h/3},1,1,-1 z. 0,1 permute. yzcx
    repeat $1 +warp[1] .,0,0 +[-2,-1] done
    permute. cxyz z. 0,2 y. j[2] .,0,8 rm[-3,-1]
    [0],[0] j3d. [1],0,0,0,1,2 rm[1]
    if {$3>0}
      min_area={0,if(${is_percent\ $3},$3*w*h,$3)}
      +area. 0,1 >=. $min_area +.. 1 *.. . distance. 1 *. -1 watershed.. . rm.
    fi
    blend shapeaverage
  endl done v +

#@cli poster_edges : 0<=_edge_threshold<=100,0<=_edge_shade<=100,_edge_thickness>=0,_edge_antialiasing>=0,0<=_posterization_level<=15,_posterization_antialiasing>=0
#@cli : Apply poster edges effect on selected images.
#@cli : Default values: 'edge_threshold=40', 'edge_shade=5', 'edge_thickness=0.5', 'edge_antialiasing=10', 'posterization_level=12' and 'posterization_antialiasing=0'.
#@cli : $ image.jpg +poster_edges ,
poster_edges : check "${1=40}>=0 && $1<=100 && ${2=5}>=0 && $2<=100 && ${3=0.5}>=0 && ${4=10}>=0 && ${5=12}>=0 && $5<=15 && ${6=0}>=0"
  e[^-1] "Apply poster edge on image$?, with edge threshold $1, edge shade $2, edge thickness $3, edge antialiasing $4, $5 level of posterization and posterization antialiasing $6."
  v - repeat $! l[$>] split_opacity l[0]
    +g xy,1 a[-2,-1] c norm. b. $3 n. 0,255
    apply_curve. 1,0,1,{max(0,(100-($1%)^0.1*100)*255%)},0.99,{min(255,(101-($1%)^0.1*100+$2)*255%)},0.01,255,0 c. 0,1
    if $4 smooth. {min(50,$4)},0,1,{$4/40},{$4/40},0.8,90 fi
    if $5 autoindex[0] {round((4-sqrt($5+1))*32+2)} fi
    if $6 smooth[0] {min(50,$6)},0,1,{$6/40},{$6/40},0.8,90 fi
    *
  endl a c endl done v +

#@cli poster_hope : _smoothness>=0
#@cli : Apply Hope stencil poster effect on selected images.
#@cli : Default value: 'smoothness=3'.
#@cli : $ image.jpg poster_hope ,
poster_hope : check "${1=3}>=0"
  e[^-1] "Apply Hope stencil poster effect on image$?, with smoothness $1."
  v - repeat $! l[$>] to_rgb
    apc "smooth 200,0,1,$1,1"
    quantize 7,0 f 'if(i!=5,i,i+1-2*(y%2))'
    (0,32,47;0,32,47;209,1,23;209,1,23;90,141,145;-1,-1,-1;253,221,138) permute. yzcx
    map[0] [1] rm[1]
  endl done v +

#@cli rodilius : 0<=_amplitude<=100,_0<=thickness<=100,_sharpness>=0,_nb_orientations>0,_offset,_color_mode={ 0=darker | 1=brighter }
#@cli : Apply rodilius (fractalius-like) filter on selected images.
#@cli : Default values: 'amplitude=10', 'thickness=10', 'sharpness=400', 'nb_orientations=7', 'offset=0' and 'color_mode=1'.
#@cli : $ image.jpg rodilius 12,10,300,10 normalize_local 10,6
#@cli : $ image.jpg normalize_local 10,16 rodilius 10,4,400,16 smooth 60,0,1,1,4 normalize_local 10,16
rodilius : check "${1=10}>=0 && $1<=200 && ${2=10}>=0 && $2<=100 && ${3=400}>=0 && ${4=7}>0" skip ${5=0},${6=1}
  e[^-1] "Apply rodilius filter on image$? with amplitude $1, thickness $2, sharpness $3, $4 orientations, offset $5 and "\
    ${arg\ 1+!$6,brighter,darker}" color mode."
  v - repeat $! l[$>] split_opacity rv
    if {!$6} negate. fi
    +f. 0 nm. {-2,n}
    repeat {round($4)}
      angle={$5+$>*180/round($4)}
      +blur_linear.. $1%,{$1*$2/100}%,$angle,1 b. 0.7 sharpen. $3 max[-2,-1]
    done rm..
    if {!$6} negate. fi
  rv a c endl done v +

#@cli stained_glass : _edges[%]>=0, shading>=0, is_thin_separators={ 0 | 1 }
#@cli : Generate stained glass from selected images.
#@cli : Default values: 'edges=40%', 'shading=0.2' and 'is_precise=0'.
#@cli : $ image.jpg stained_glass 20%,0.1
stained_glass : check "${1=40%}>=0 && ${2=0.2}>=0" skip ${3=0}
  e[^-1] "Apply stained glass effect on image$?, with edges $1, shading $2 and thin-separators "${arg\ 1+!$3,enabled,disabled}"."
  v - repeat $! l[$>]
    im={im-1} - $im  # Ensure strict positiveness of image labels.
    +gradient_norm >=. $1 *.. .
    distance. 1 sharpen. 1e10 !=. 0
    if $3 skeleton. 0 fi
    distance. 1 watershed.. . +.. $im
    n. 0,1  ^. $2 *
  endl done v +

#@cli stars : _density[%]>=0,_depth>=0,_size>0,_nb_branches>=1,0<=_thickness<=1,_smoothness[%]>=0,_R,_G,_B,_opacity
#@cli : Add random stars to selected images.
#@cli : Default values: 'density=10%', 'depth=1', 'size=32', 'nb_branches=5', 'thickness=0.38', 'smoothness=0.5', 'R=G=B=200' and 'opacity=1'.
#@cli : $ image.jpg stars ,
stars : check "${1=10%}>=0 && ${2=1}>=0 && ${3=32}>0 && ${4=5}>=1 && ${5=0.38}>=0 && $5<=1 && ${6=0.5}>=0" skip ${7=200},${8=$7},${9=$8},${10=1}
  e[^-1] "Add $1 random stars to image$?, with depth $2, size $3, $4 branches, thickness $5, smoothness $6, color ($7,$8,$9) and opacity $10."
  if {!$1} return fi
  v -

  # Generate star sprites.
  star3d $4,$5 col3d. 255 *3d. $3
  l. repeat 4 {round(2*$3)},{round(2*$3)} j3d. [0],50%,50%,0,1,2,0,0 r3d[0] 0,0,1,-90 done rm[0] endl
  autocrop[-4--1] 0 r2dy[-4--1] $3 b[-4--1] $6,0 r[-4--1] 100%,100%,1,4
  repeat 4 sh[{-1-$>}] 0,2 fc. $7,$8,$9 rm. done

  # Draw stars on selected images.
  repeat {$!-1} [-4--1] l[$>,-4--1]
    N={round(if(${is_percent\ $1},w*h*$1,$1)/4,1,1)}
    repeat 4
      2,$N rand. -1,1 1,$N rand. 0,1 a[-2,-1] x
      i.. ({'CImg3d'}) +.. 0.5 i.. ($N;$N)
      (1,0;1,{$N-1}) r. 2,$N,1,1,3 round. 4,$N,1,1,1 y[-5,-3--1] a[-5--1] y
      rv[-2,-1] sprites3d.. .,1 rm. *3d. {0.75*{0,w}},{0.75*{0,h}},{1000*$2}
      j3d[0] .,50%,50%,0,$10,0,0,0 rm.
    done
  endl done
  rm[-4--1] v +

#@cli sketchbw : _nb_angles>0,_start_angle,_angle_range>=0,_length>=0,_threshold>=0,_opacity,_bgfactor>=0,_density>0,_sharpness>=0,_anisotropy>=0,_smoothness>=0,_coherence>=0,_is_boost={ 0 | 1 },_is_curved={ 0 | 1 }
#@cli : Apply sketch effect to selected images.
#@cli : Default values: 'nb_angles=2', 'start_angle=45', 'angle_range=180', 'length=30', 'threshold=3', 'opacity=0.03',
#@cli : 'bgfactor=0', 'density=0.6', 'sharpness=0.1', 'anisotropy=0.6', 'smoothness=0.25', 'coherence=1', 'is_boost=0' and 'is_curved=1'.
#@cli : $ image.jpg +sketchbw 1 reverse blur[-1] 3 blend[-2,-1] overlay
sketchbw :
  check "${1=2}>0 && ${3=180}>=0 && ${4=30}>=0 && ${5=3}>=0 && ${7=0}>=0 && ${8=0.6}>0 && ${9=0.1}>=0 && ${10=0.6}>=0 && ${11=0.25}>=0 && ${12=1}>=0"
  skip ${2=45},${6=0.03},${13=0},${14=0}
  e[^-1] "Apply B&W sketch effect on image$?."
  nb_angles,start_angle,angle_range,length,threshold,opacity,bgfactor,density,sharpness,anisotropy,smoothness,coherence,is_boost,is_curved=${1-14}
  length={max($length,1)}
  v - repeat $! l[$>]
    {0,[w,h,1,1,0]}                                                       # [1] = canvas to draw onto
    +gradient_norm[0] sqrt.
    diffusiontensors[0] $sharpness,$anisotropy,$smoothness,$coherence
    a[0,-1] c                                                             # [0] = field of stroke tensors + gradient norm
    1,{$density*wh/sqrt($length)},1,2,round(u([w#0,h#0]-1))               # [2] = set of random points

    repeat $nb_angles

      # Compute vector field for considered orientation.
      [0],[0],1,2,"
        const angle = ("$start_angle" + "$>"*"$angle_range"/"$nb_angles")*pi/180;
        const ca = cos(angle);
        const sa = sin(angle);
        T = I(#0);
        U = [ T[0]*ca + T[1]*sa, T[1]*ca + T[2]*sa ];
        if ("$is_boost",U/=(1e-8 + norm(U)));
        U"

      # Draw curved or straight strokes.
      if $is_curved
        f[2] "*
          oub = ovb = ouf = ovf = 0;
          oixb = xb = xf = i0;
          oiyb = yb = yf = i1;
          oixf = oiyf = -1;
          op = "$opacity" * (i(#0,xf,yf,0,3)<"$threshold"?"$bgfactor":1);
          omop = 1 - op;

          if (op>0, for (dl = 0, dl<"$length", ++dl,

            # Forward
            ixf = round(xf);
            iyf = round(yf);
            if (ixf!=oixf || iyf!=oiyf, (i(#1,ixf,iyf)*=omop)+=op; oixf = ixf; oiyf = iyf);
            uf = i(#-1,xf,yf,0,0,1,1);
            vf = i(#-1,xf,yf,0,1,1,1);
            if (ouf*uf + ovf*vf<0, uf*=-1; vf*=-1);
            xf+=uf;
            yf+=vf;
            ouf = uf;
            ovf = vf;

            # Backward
            ub = i(#-1,xb,yb,0,0,1,1);
            vb = i(#-1,xb,yb,0,1,1,1);
            if (oub*ub + ovb*vb<0, ub*=-1; vb*=-1);
            xb-=ub;
            yb-=vb;
            oub = ub;
            ovb = vb;
            ixb = round(xb);
            iyb = round(yb);
            if (ixb!=oixb || iyb!=oiyb, (i(#1,ixb,iyb)*=omop)+=op; oixb = ixb; oiyb = iyb);
          ));
          I"
      else
        f[2] "*
          const l = "$length";
          x = i0;
          y = i1;
          u = i(#-1,x,y,0,0);
          v = i(#-1,x,y,0,1);
          op = "$opacity" * (i(#0,x,y,0,3)<"$threshold"?"$bgfactor":1);
          omop = 1 - op;
          polygon(#1,2,x - l*u,y - l*v,x + l*u,y + l*v,op,1);
          I"
      fi
      rm.
    done
    k.. * -1 n 0,255
  endl done v +

#@cli sponge : _size>0
#@cli : Apply sponge effect on selected images.
#@cli : Default value: 'size=13'.
#@cli : $ image.jpg +sponge ,
sponge : skip ${1=13}
  e[^-1] "Apply sponge filter on image$?, with brush size $1."
  v - repeat $! l[$>]
    100%,100%,1,1 noise. 20,2 ==. 1 r. .. n. 0,1 *[-1,-2]
    _circle $1 dilate.. . rm.
  endl done v +

_circle :
  if {$1%2==0} 2,2 else 1 fi
  +. 1 r. $1,$1,1,1,0,0,0.5,0.5 distance. 1 n. 0,1 sqrt. c. 0.85,0.86 *. -1 n. 0,1

#@cli stencil : _radius[%]>=0,_smoothness>=0,_iterations>=0
#@cli : Apply stencil filter on selected images.
#@cli : Default values: 'radius=3', 'smoothness=1' and 'iterations=8'.
#@cli : $ image.jpg stencil 1,10,3
stencil : check "${1=3}>=0 && ${2=1}>=0 && ${3=8}>=0"
  e[^-1] "Apply stencil filter on image$?, with radius $1, smoothness $2 and $3 iterations."
  v - n 0,1 repeat $3 b $1 unsharp {$1+$2},1000 c 0,255 done v +

#@cli stencilbw : _edges>=0,_smoothness>=0
#@cli : Apply B&W stencil effect on selected images.
#@cli : Default values: 'edges=15' and 'smoothness=10'.
#@cli : $ image.jpg +stencilbw 40,4
stencilbw : skip ${1=15},${2=10}
  e[^-1] "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
  v - repeat $! l[$>] split_opacity luminance[0] n[0] 0,255
    +edges[0] $1 quantize[0] 3,0,1 b[0] $2
    sharpen[0] 1000000 n[0] 0,1 *[0,-1] n[0] 0,255
  a c endl done v +

#@cli tetris : _scale>0
#@cli : Apply tetris effect on selected images.
#@cli : Default value: 'scale=10'.
#@cli : $ image.jpg +tetris 10
tetris : skip ${1=10}
  e[^-1] "Apply tetris effect on image$?, with scale $1."
  v - repeat $! l[$>]
    wh={w},{h},1,{s} r $1%,$1%,$1%,100%,2 n 0,255 quantize 10,1,0 r $wh b 2 sharpen 300,1
  endl done v +

#@cli warhol : _M>0,_N>0,_smoothness>=0,_color>=0
#@cli : Create MxN Andy Warhol-like artwork from selected images.
#@cli : Default values: 'M=3', 'N=M', 'smoothness=2' and 'color=20'.
#@cli : $ image.jpg warhol 3,3,3,40
warhol : skip ${1=3},${2=$1},${3=2},${4=20}
  e[^-1] "Create $1x$2 Andy Warhol-like artwork from image$?."
  v - r0={100/max($1,$2)}
  repeat $! l[$>]
    norm b $3 r $r0%,$r0%,1,100%,2 quantize 6 n 0,5 round 1
    repeat $1 repeat $2
      (0,1,2,3,4,5) n. 32,224 6,1,1,2,128 noise. $4,0 c. 0,255 a[-2,-1] c ycbcr2rgb. +map[0] . rm..
    done done append_tiles[^0] $1,$2 nm[1] {0,n} rm[0]
  endl done v +

#@cli weave : _density>=0,0<=_thickness<=100,0<=_shadow<=100,_shading>=0,_fibers_amplitude>=0,_fibers_smoothness>=0,_angle,-1<=_x_curvature<=1,-1<=_y_curvature<=1
#@cli : Apply weave effect to the selected images.
#@cli : 'angle' can be { 0=0 deg. | 1=22.5 deg. | 2=45 deg. | 3=67.5 deg. }.
#@cli : Default values: 'density=6', 'thickness=65', 'shadow=40', 'shading=0.5', 'fibers_amplitude=0', 'fibers_smoothness=0', 'angle=0' and 'curvature_x=curvature_y=0'
#@cli : $ image.jpg weave ,
weave : check "${1=6}>=0 && ${2=65}>=0 && $2<=100 && ${3=40}>=0 && $3<=100 && ${4=0.5}>=0"
        check "${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && $7<=3 && ${8=0}>=-1 && $8<=1 && ${9=0}>=-1 && $9<=1"
  e[^-1] "Apply weave effect to image$?, with $1 strips, thickness $2, shadow $3, shading $4, "\
          "fibers amplitude $5 and fibers smoothness $6, angle "{$7*22.5}" deg. and curvatures ($8,$9)."
  v - repeat $! l[$>] split_opacity l[0]
    w={round(max(w,h)/$1,1,1)} h=$w s={(100-$3)*255%} p={max(0.01,$4)}

    # Create patterns.
    1,$h =. 1,0,50% distance. 1 ^. $p c. 50%,100% r. {max(1,round($2*$w%))},100%
    $w,1 =. 1,50% distance. 1 ^. $p c. 50%,100% *. -1 r. 100%,{max(1,round($2*$h%))}
    +*. -1 +*... -1 n[-4,-2] 0,$s n[-3,-1] $s,255
    {w},1 1,... rand[-2,-1] 0,1 b[-2,-1] $6% n[-2,-1] -$5,$5 r. [-4] +[-5] . +[-4,-1] +[-5] . +[-2,-1]
    +f... 255 a[-4,-1] c +f. 255 a[-2,-1] c

    amp_x={$8*($w-w)/2} amp_y={$9*($w-w)/2}
    r[-4--1] $w,$h,1,100%,0,0,0.5,0.5
    f[-4] 'i(x+$amp_x*sin(y/h*pi),y,0,c,1,2)' f. 'i(x-$amp_x*sin(y/h*pi),y,0,c,1,2)'
    f... 'i(x,y+$amp_y*sin(x/w*pi),0,c,1,2)' f.. 'i(x,y-$amp_y*sin(x/w*pi),0,c,1,2)'
    blend[-4,-3] alpha blend[-2,-1] alpha c[-2,-1] 0,255

    # Render full pattern and merge.
    /[-2,-1] 255 . ... a[-4,-2] x a[-2,-1] x a[-2,-1] y rotate_tileable. {$7*22.5}
    r. ..,..,1,1,0,2 *[-2,-1]
  endl a c endl done v +

#@cli whirls : _texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0
#@cli : Add random whirl texture to selected images.
#@cli : Default values: 'texture=3', 'smoothness=6', 'darkness=0.5' and 'lightness=1.8'.
#@cli : $ image.jpg +whirls ,
whirls : skip ${1=3},${2=6},${3=0.5},${4=1.8}
  e[^-1] "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
  v - repeat $! l[$>]
    100%,100% noise. 0.3,2 ==. 1 repeat $1 b. $2 +. 0.1 gradient_norm. ^. 0.2 done
    n. $3,$4 r. .. * c 0,255
  endl done v +

#------------------------------------
#
#@cli :: Warpings
#
#------------------------------------

#@cli deform : _amplitude>=0,_interpolation
#@cli : Apply random smooth deformation on selected images.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
deform : skip ${1=10},${2=1}
  e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
  v - repeat $! l[$>]
    2%,2%,1,2 noise. $1 r. ..,..,1,2,5 warp.. .,1,$2,1 rm.
  endl done v +

#@cli euclidean2polar : _center_x[%],_center_y[%],_stretch_factor>0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply euclidean to polar transform on selected images.
#@cli : Default values: 'center_x=center_y=50%', 'stretch_factor=1' and 'boundary_conditions=1'.
#@cli : $ image.jpg +euclidean2polar ,
euclidean2polar : skip ${1=50%},${2=50%} check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=3"
  e[^-1] "Apply euclidean to polar transform on image$?, with center point ($1,$2), stretch factor $3 and "${"arg 1+$4,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! l[$>]
    cx={if(${is_percent\ $1},$1*(w-1),$1)}
    cy={if(${is_percent\ $2},$2*(h-1),$2)}
    R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
    f 'r=$R*(x/(w-1))^$3;a=y*2*pi/(h-1);i($cx+r*cos(a),$cy+r*sin(a),z,c,1,$4)'
  endl done v +

#@cli equirectangular2nadirzenith
#@cli : Transform selected equirectangular images to nadir/zenith rectilinear projections.
equirectangular2nadirzenith :
  e[^-1] "Transform equirectangular image$? to nadir/zenith rectilinear projections."
  v - repeat $! l[$>]
    100%,100%,1,2
    sh. 100%
    f. "
      X = 2*x/(w-1) - 1;
      Y = y/(h-1) - 0.5;
      if (X<0,
        sinphi1 = 1; X+=0.5,
        sinphi1 = -1; X-=0.5
      );
      rr = sqrt(X*X + Y*Y);
      cc = atan(2*rr);
      phi = rr==0?0:asin(cos(cc)*sinphi1);
      X = atan2(X,-Y*sinphi1)/pi;
      Y = phi/pi;
      (++X)*=0.5*w;
      (Y+=0.5)*=h;
      i(#-2) = X; Y;"
    warp[0] [1],0,0,1 k...
  endl done v +

#@cli fisheye : _center_x,_center_y,0<=_radius<=100,_amplitude>=0
#@cli : Apply fish-eye deformation on selected images.
#@cli : Default values: 'x=y=50', 'radius=50' and 'amplitude=1.2'.
#@cli : $ image.jpg +fisheye ,
fisheye : skip ${1=50},${2=50},${3=50},${4=1.2}
  e[^-1] "Apply Fish-eye effect on image$?, centered at ($1%,$2%) with radius $3% and amplitude $4."
  if {$4==0} return fi
  v - repeat $! l[$>]
    100%,100%,1,1 =. 1,$1%,$2% distance. 1 c. 0,$3% *. -1 n. 0,1 ^. {1/$4}
    i.. ({-$1/100},{1-$1/100};{-$1/100},{1-$1/100}^{-$2/100},{-$2/100};{1-$2/100},{1-$2/100}) r.. .,.,1,2,3
    n. 0,{max(w,h)} *[-2,-1]
    warp.. .,1,1,1 rm.
  endl done v +

#@cli flower : _amplitude,_frequency,_offset_r[%],_angle,_center_x[%],_center_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror}
#@cli : Apply flower deformation on selected images.
#@cli : Default values: 'amplitude=30', 'frequency=6', 'offset_r=0', 'angle=0', 'center_x=center_y=50%' and 'boundary_conditions=3'.
#@cli : $ image.jpg flower ,
flower : skip ${1=30},${2=6},${3=0},${4=0},${5=50%},${6=50%},${7=3}
  e[^-1] "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 deg. and center point ($1,$2)."
  v - if ${"is_percent $3"}
    transform_polar "r + (R*$3) + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
  else
    transform_polar "r + $3 + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
  fi v +

#@cli kaleidoscope : _center_x[%],_center_y[%],_radius,_angle,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Create kaleidoscope effect from selected images.
#@cli : Default values: 'center_x=center_y=50%', 'radius=100', 'angle=30' and 'boundary_conditions=3'.
#@cli : $ image.jpg +kaleidoscope ,
kaleidoscope : skip ${1=50%},${2=50%},${3=100},${4=30},${5=3}
  e[^-1] "Create kaleidoscope effect from image$?, with center point ($1,$2), radius $3, angle $4 deg."
  v - euclidean2polar $1,$2,1,$5 repeat $! l[$>]
    +columns 0,$3% rows. 0,$4% r. ..,0,2 nm[1] {0,n} rm[0]
  endl done polar2euclidean $1,$2,1,$5 v +

#@cli map_sphere : _width>0,_height>0,_radius,_dilation>0,_fading>=0,_fading_power>=0
#@cli : Map selected images on a sphere.
#@cli : Default values: 'width=height=512', 'radius=100', 'dilation=0.5', 'fading=0' and 'fading_power=0.5'.
#@cli : $ image.jpg map_sphere ,
map_sphere : check "${1=512}>0 && ${2=512}>0 && ${5=0}>=0 && ${6=0.5}>=0" skip ${3=100},${4=0.5}
   e[^-1] "Map image$? on spheres in $1x$2 images, with radius $3, dilation $4 and fading $5."
   v - r2={($3*min($1,$2)/200)^2} # Compute squared radius.
   repeat $! l[$>]
     i.. 100%,1,1,100%,0 nm[0] {1,n} a y # Add one border line to have a sphere exterior.
     ({-$1/2},{$1/2}) ({-$2/2};{$2/2}) r[-2,-1] $1,$2,1,1,3 atan2. .. rm.. # Compute theta angle.
     $1,$2 =. 1,50%,50% distance. 1,3 /. $r2 sqrt. c. 0,1
     asin. # Compute phi angle.
     +.. {pi} *.. {({-3,w}-1)/(2*pi)} # Normalize theta to X-coordinates
     *. {2/pi} ^. $4 *. {{-3,h}-1} *. -1 +. {{-3,h}-1} # Normalize phi to Y-coordinates
     if $5 +>=. 1 distance. 1 c. 0,$5% n. 0,1 ^. $6 c.. 1,100% -[-2,-1] fi
     r[-1,-2] 100%,100%,{-3,d}
     +f. z a[-3--1] c
     warp.. .,0,1,1 rm. # Apply image warping
   endl done v +

#@cli nadirzenith2equirectangular
#@cli : Transform selected nadir/zenith rectilinear projections to equirectangular images.
nadirzenith2equirectangular :
  e[^-1] "Transform nadir/zenith rectilinear projection$? to equirectangular images."
  v - repeat $! l[$>]
    100%,100%,1,2
    sh. 100%
    f. "
      X = 2*x/(w-1) - 1;
      Y = y/(h-1) - 0.5;
      output = 1;
      if (Y>0.125,
        sinphi1 = 1; xc = -0.5,
      if (Y<-0.125,
        sinphi1 = -1; xc = 0.5,
        output = 0
      ));
      cosc = sinphi1*sin(Y*pi);
      xx = cos(Y*pi)*sin(X*pi)/cosc;
      yy = -sinphi1*cos(Y*pi)*cos(X*pi)/cosc;
      if (abs(xx)>1, output=0);
      (xx*=0.5)+=xc;
      yy*=0.5;
      if (!output, xx = yy = -1);
      (++xx)*=0.5*w;
      (yy+=0.5)*=h;
      i(#-2) = xx; yy;"
    to_a[0] warp[0] [1],0,0,0 k...
  endl done v +

#@cli polar2euclidean : _center_x[%],_center_y[%],_stretch_factor>0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply euclidean to polar transform on selected images.
#@cli : Default values: 'center_x=center_y=50%', 'stretch_factor=1' and 'boundary_conditions=1'.
#@cli : $ image.jpg +euclidean2polar ,
polar2euclidean : skip ${1=50%},${2=50%} check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=3"
  e[^-1] "Apply polar to euclidean transform on image$?, with center point ($1,$2), stretch factor $3 and "${"arg 1+$4,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  v - repeat $! l[$>]
    cx={if(${is_percent\ $1},$1*(w-1),$1)}
    cy={if(${is_percent\ $2},$2*(h-1),$2)}
    R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
    f 'X=sqrt((x-$cx)^2+(y-$cy)^2);tmp=atan2((y-$cy),(x-$cx));Y=if(tmp<0,tmp+2*pi,tmp);i((X/$R)^(1/$3)*(w-1),Y*(h-1)/(2*pi),z,c,1,$4)'
  endl done v +

#@cli raindrops : _amplitude,_density>=0,_wavelength>=0,_merging_steps>=0
#@cli : Apply raindrops deformation on selected images.
#@cli : Default values: 'amplitude=80','density=0.1', 'wavelength=1' and 'merging_steps=0'.
#@cli : $ image.jpg +raindrops ,
raindrops : check "${2=0.1}>=0 && ${3=1}>=0 && isint(${4=0}) && $4>=0" skip ${1=80}
  e[^-1] "Apply raindrops deformation on image$?, with amplitude $1, density $2, wavelength $3 and $4 merging steps."
  v - repeat $! l[$>]
    100%,100% noise. $2,2 ==. 1 distance. 1 f. 'cos(i)/(1+i/(1e-8+$3))'
    if $4
      i.. (0,1,0;1,0,1;0,1,0) /.. 2 .
      repeat $4 +convolve. ...,1 -. ... rm... done rm[-3,-2]
    fi
    g. a[-2,-1] c *. {$1/(1e-5+max(abs(im),abs(iM)))}
    warp.. .,1 rm.
  endl done v +

#@cli ripple : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@cli : Apply ripple deformation on selected images.
#@cli : Default values: 'amplitude=10', 'bandwidth=10', 'shape=2', 'angle=0' and 'offset=0'.
#@cli : $ image.jpg +ripple ,
ripple : skip ${1=10},${2=20},${3=2},${4=0},${5=0}
  e[^-1] "Apply ripple deformation on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
  v -
  theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
  repeat $! l[$>]
    100%,100%,1,1,"x" -. {w/2} 100%,100%,1,1,'y'
    -. {h/2-$5} *.. $S *. $C +[-2,-1]      # Generate rotated Y.
    _ripple$3. $1,$2                          # Generate warp field.
    +*. {-$S} *.. $C a[-2,-1] c             # Rotate warp field.
    warp.. .,1 rm.
  endl done v +

_ripple0 : f {$1/2}*"(1-2*(i%"{2*$2}"<$2))"
_ripple1 : f "I=(i%$2)/$2;$1*(2*if(I<0.5,I,1-I)-0.5)"
_ripple2 : f {-$1/2}*"cos(i*"{2*pi/$2}")"
_ripple3 : f {-$1/2}*"abs(cos(i*"{2*pi/$2}"))"
_ripple4 : skip $* n 0,{h-1} 1,{h} rand. {-$1/2},{$1/2} m={im} M={iM} b. {$2/10} n. $m,$M map.. . rm.

#@cli rotoidoscope : _center_x[%],_center_y[%],_tiles>0,_smoothness[%]>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Create rotational kaleidoscope effect from selected images.
#@cli : Default values: 'center_x=center_y=50%', 'tiles=10', 'smoothness=1' and 'boundary_conditions=3'.
#@cli : $ image.jpg +rotoidoscope ,
rotoidoscope : skip ${1=50%},${2=50%},${5=1} check "${3=10}>0 && ${4=3}>=0"
  e[^-1] "Create rotational kaleidoscope effect from image$?, with center point ($1,$2), $3 tiles and smoothness $4."
  v - repeat $! l[$>]
    repeat $3 +rotate[0] {360/$3},1,$5,$1,$2 blend_edges $4 done
  endl done v +

#@cli spherize : _radius[%]>=0,_strength,_smoothness[%]>=0,_center_x[%],_center_y[%],_ratio_x/y>0,_angle,_interpolation
#@cli : Apply spherize effect on selected images.
#@cli : Default values: 'radius=50%', 'strength=1', 'smoothness=0', 'center_x=center_y=50%', 'ratio_x/y=1', 'angle=0' and 'interpolation=1'.
#@cli : $ image.jpg grid 5%,5%,0,0,0.6,255 spherize ,
spherize : check "${1=50%}>=0 && ${3=0}>=0 && ${6=1}>0 && isint(${8=1}) && $8>=0 && $8<=2" skip "${2=1},${4=50%},${5=50%},${7=0}"
  e[^-1] "Apply spherize effect on image$?, with radius $1, strength $2, smoothness $3, center ($4,$5), x/y-ratio $6, angle $7 and "${"arg 1+$8,nearest-neighbor,linear,cubic"}" interpolation."
  if {!$1||!$2} return fi
  v - repeat $! l[$>]
    rmax={${"is_percent $1"}?0.5*sqrt((w-1)^2+(h-1)^2)*$1:$1}
    centerx={${"is_percent $4"}?(w-1)*$4:$4}
    centery={${"is_percent $5"}?(h-1)*$5:$5}
    strength={$2>0?$2:1-exp($2/5)}
    100%,100%,1,2,"
      begin(
        center = [ "$centerx","$centery" ];
        wh1 = [ w,h ] - 1;
        m2wh1 = 0.5*max(wh1);
        rmax = "$rmax"/m2wh1;
        const f = 1/"$strength";
        const ratio = $6;
        rotf = rot($7);
        rotb = rot(-$7);
      );
      xy = ([x,y] - center)/m2wh1;
      xy = rotf*xy;
      ratio>=1?(xy[1]*=ratio):(xy[0]/=ratio);
      r = norm2(xy);
      z = r<rmax?sign($2)*sqrt(rmax^2 - r^2):0;
      ratio>=1?(xy[1]/=ratio):(xy[0]*=ratio);
      xy = rotb*xy;
      xy = center + f*xy/(f + z)*m2wh1"
    b. $3
    warp.. .,0,$8,1 rm.
  endl done v +

#@cli symmetrize : _x[%],_y[%],_angle,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror },_is_antisymmetry={ 0 | 1 },_swap_sides={ 0 | 1 }
#@cli : Symmetrize selected images regarding specified axis.
#@cli : Default values: 'x=y=50%', 'angle=90', 'boundary_conditions=3', 'is_antisymmetry=0' and 'swap_sides=0'.
#@cli : $ image.jpg +symmetrize 50%,50%,45 +symmetrize[-1] 50%,50%,-45
symmetrize : skip ${1=50%},${2=50%},${3=90},${4=3},${5=0},${6=0}
  e[^-1] "Symmetrize image$?, regarding axis ($1,$2,$3 deg.)."
  v -
  theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
  if $6 symmetry_cond=A<0 else symmetry_cond=A>0 fi
  repeat $! l[$>]
    x0={if(${is_percent\ $1},w*$1,$1)}
    y0={if(${is_percent\ $2},h*$2,$2)}
    if $5 f 'A=($y0-y)*$u-($x0-x)*$v;X=x+2*($x0-x);Y=y+2*($y0-y);if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
    else f 'A=($y0-y)*$u-($x0-x)*$v;X=x-2*$v*A;Y=y+2*$u*A;if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
    fi
  endl done
  v +

#@cli transform_polar : "expr_radius",_"expr_angle",_center_x[%],_center_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann }
#@cli : Apply user-defined transform on polar representation of selected images.
#@cli : Default values: 'expr_radius=R-r', 'expr_rangle=a', 'center_x=center_y=50%' and 'boundary_conditions=1'.
#@cli : $ image.jpg +transform_polar[0] R*(r/R)^2,a +transform_polar[0] r,2*a
transform_polar : skip "${1=R-r}","${2=a}",${3=50%},${4=50%},${5=1}
  e[^-1] "Apply custom polar transform with 'new_r = $1', 'new_a = $2', center point ($3%,$4%)."
  v - repeat $! l[$>]
    cx={if(${is_percent\ $3},$3*(w-1),$3)}
    cy={if(${is_percent\ $4},$4*(h-1),$4)}
    R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
    f "R ="$R";
       r = sqrt((x-"$cx")^2 + (y-"$cy")^2);
       a = atan2(y-"$cy",x-"$cx");
       nr = ($1);
       na = ($2);
       i("$cx" + nr*cos(na), "$cy" + nr*sin(na), z, c,1,$5)"
  endl done v +

#@cli twirl : _amplitude,_center_x[%],_center_y[%],_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply twirl deformation on selected images.
#@cli : Default values: 'amplitude=1', 'center_x=center_y=50%' and 'boundary_conditions=3'.
#@cli : $ image.jpg twirl 0.6
twirl : skip ${1=1},${2=50%},${3=50%},${4=3}
  e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center point at ($2%,$3%)."
  v - euclidean2polar $2,$3,1,$4 repeat $!
    [$>],[$>],1,1,$1*x channels. -1,0 warp[$>] .,1,1,2 rm.
  done polar2euclidean $2,$3,1,1 v +

#@cli warp_perspective : _x-angle,_y-angle,_zoom>0,_x-center,_y-center,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Warp selected images with perspective deformation.
#@cli : Default values: 'x-angle=1.5', 'y-angle=0', 'zoom=1', 'x-center=y-center=50' and 'boundary_conditions=2'.
#@cli : $ image.jpg warp_perspective ,
warp_perspective : skip ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
  e[^-1] "Apply perspective warp on image$?, with angles ($1 deg.,$2 deg.), zoom $3 and offsets ($4,$5)."
  v - repeat $! l[$>]
    (0,100) -. $4 /. 100 (0;100) -. $5 /. 100 r[-2,-1] ...,...,...,1,3
    +*.. $2 +*.. $1 +[-2,-1] +. $3 /... . /[-2,-1]
    *.. 100 +.. $4 /.. 100 *.. {-3,w}
    *. 100 +. $5 /. 100 *. {-3,h}
    a[-2,-1] c warp.. .,0,1,$6 rm.
  endl done v +

#@cli water : _amplitude,_smoothness>=0,_angle
#@cli : Apply water deformation on selected images.
#@cli : Default values: 'amplitude=30', 'smoothness=1.5' and 'angle=45'.
#@cli : $ image.jpg water ,
water : check ${2=1.5}>=0 skip ${1=30},${3=1},${4=45}
  e[^-1] "Apply water deformation on image$?, with amplitude $1, smoothness $2 and angle $3."
  v - repeat $! l[$>]
    25%,25%,25%,1 noise. $1 g. xy *.. {-sin($3*pi/180)} *. {cos($3*pi/180)} +[-2,-1] b. $2 *. 2 r. ..,..,1,2,3 warp.. .,1 rm.
  endl done v +

#@cli wave : _amplitude>=0,_frequency>=0,_center_x,_center_y
#@cli : Apply wave deformation on selected images.
#@cli : Default values: 'amplitude=4', 'frequency=0.4' and 'center_x=center_y=50'.
#@cli : $ image.jpg wave ,
wave : skip ${1=4},${2=0.4},${3=50},${4=50}
  e[^-1] "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center point at ($3%,$4%)."
  v - repeat $! l[$>]
    100%,100% =. 1,$3%,$4% distance. 1
    *. $2 +sin. cos.. a[-2,-1] c *. $1
    warp.. .,1 rm.
  endl done v +

#@cli wind : _amplitude>=0,_angle,0<=_attenuation<=1,_threshold
#@cli : Apply wind effect on selected images.
#@cli : Default values: 'amplitude=20', 'angle=0', 'attenuation=0.7' and 'threshold=20'.
#@cli : $ image.jpg +wind ,
wind : check "isint(${1=20}) && $1>=0 && ${3=0.7}>=0 && $3<=1" skip "${2=0},${4=20}"
  e[^-1] "Apply wind effect on image$?, with amplitude $1, angle "{round($2/45)*45}" deg., attenuation $3 and threshold $4."
  if {!$1} return fi
  v -
  dxdy=${-_wind{round($2/45)%8}}
  fact={(1-$3)^(1/$1)}
  repeat $! l[$>]
    +gradient_norm >=. $4%
    r. 100%,100%,1,.. *. ..
    repeat $1
      shift. $dxdy,0,0,0 max.. . *. $fact
      remove_pixels. {100/$1}%
    done rm.
  endl done v +

_wind0 : u 1,0
_wind1 : u 1,1
_wind2 : u 0,1
_wind3 : u -1,1
_wind4 : u -1,0
_wind5 : u -1,-1
_wind6 : u 0,-1
_wind7 : u 1,-1

#@cli zoom : _factor,_cx,_cy,_cz,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Apply zoom factor to selected images.
#@cli : Default values: 'factor=1', 'cx=cy=cz=0.5' and 'boundary_conditions=0'.
#@cli : $ image.jpg +zoom[0] 0.6 +zoom[0] 1.5
zoom : skip ${1=2},${2=0.5},${3=0.5},${4=0.5},${5=0}
  e[^-1] "Apply zoom effect on image$?, with factor $1 and center ($2,$3)."
  v - repeat $! l[$>]
    if {d==1} # 2D image.
       ({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
       ({({-2,h}-1)*$3*(1-1/$1)};{({-2,h}-1)*($3+(1-$3)/$1)})
       r[-2--1] ...,...,1,1,3 a[-2--1] c warp.. .,0,1,$5
    else # 3D image.
       ({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
       ({({-2,h}-1)*$3*(1-1/$1)};{({-2,h}-1)*($3+(1-$3)/$1)})
       ({({-3,d}-1)*$4*(1-1/$1)}/{({-3,d}-1)*($4+(1-$4)/$1)})
       r[-3--1] [-4],[-4],[-4],1,3 a[-3--1] c warp.. .,0,1,$5
    fi
    rm.
  endl done v +

#-----------------------------
#
#@cli :: Degradations
#
#-----------------------------

#@cli cracks : 0<=_density<=100,_is_relief={ 0 | 1 },_opacity,_color1,...
#@cli : Draw random cracks on selected images with specified color.
#@cli : Default values: 'density=25', 'is_relief=0', 'opacity=1' and 'color1=0'.
#@cli : $ image.jpg +cracks ,
cracks : check "${1=25}>=0" skip ${2=0},${3=1},${4=0}
  e[^-1] "Add random cracks to image$?, with density $1, opacity $3 and color (${4--1})."
  v - repeat $! l[$>] cut={[im,iM]}
    100%,100%,1,2,'u<0.25*($1%)^4?[u,1]:[0,0]'
    s. c distance. 1 *. -1 watershed.. . rm.
    +dilate. 3 -[-2,-1] !=. 0 thinning. 1
    if $2
      f. "i?i:j(1)?2:j(-1)?0.5:i" n. 0,1
      +fc.. ${4--1} *. .. !=.. 0 j... .,0,0,0,0,$3,..
    else
      +fc.. ${4--1} j... .,0,0,0,0,$3,..
    fi
    k[0]
  endl done v +

#@cli light_patch : _density>0,_darkness>=0,_lightness>=0
#@cli : Add light patches to selected images.
#@cli : Default values: 'density=10', 'darkness=0.9' and 'lightness=1.7'.
#@cli : $ image.jpg +light_patch 20,0.9,4
light_patch : skip ${1=10},${2=0.9},${3=1.7}
  e[^-1] "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
  v - repeat $! l[$>]
    n 0,255 $1,$1 noise. 40 r. ..,5 c. 0,255
    n. $2,$3 * c 0,255
  endl done v +

#@cli noise_hurl : _amplitude>=0
#@cli : Add hurl noise to selected images.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +noise_hurl ,
noise_hurl : skip ${1=10}
  e[^-1] "Add hurl noise to image$?, with amplitude $1%."
  v - repeat $! l[$>]
    +f 0 noise. 10 n. {-2,[im,iM]} 100%,100%
    noise. $1,2 >. 0 r. ..
    *.. . *. -1 +. 1 *[-3,-1] +
  endl done v +

#@cli pixelize : _scale_x>0,_scale_y>0,_scale_z>0
#@cli : Pixelize selected images with specified scales.
#@cli : Default values: 'scale_x=20' and 'scale_y=scale_z=scale_x'.
#@cli : $ image.jpg +pixelize ,
pixelize : skip ${1=20},${2=$1},${3=$1}
  e[^-1] "Pixelize image$? with scales ($1%,$2%,$3%)."
  v - repeat $! l[$>] whd={w},{h},{d} r $1%,$2%,$3%,100%,2 r $whd endl done v +

#@cli scanlines : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@cli : Apply ripple deformation on selected images.
#@cli : Default values: 'amplitude=60', 'bandwidth=2', 'shape=0', 'angle=0' and 'offset=0'.
#@cli : $ image.jpg +scanlines ,
scanlines : skip ${1=60},${2=2},${3=0},${4=0},${5=0}
  e[^-1] "Apply scanlines effect on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
  v -
  theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
  repeat $! l[$>]
    100%,100%,1,1,"x" -. {w/2} 100%,100%,1,1,'y'
    -. {h/2-$5} *.. $S *. $C +[-2,-1]      # Generate rotated Y.
    _ripple$3. $1,$2                            # Generate warp field.
    n. {-$1},$1
    + cut 0,255
  endl done v +

#@cli shade_stripes : _frequency>=0,_direction={ 0=horizontal | 1=vertical },_darkness>=0,_lightness>=0
#@cli : Add shade stripes to selected images.
#@cli : Default values: 'frequency=5', 'direction=1', 'darkness=0.8' and 'lightness=2'.
#@cli : $ image.jpg +shade_stripes 30
shade_stripes : skip ${1=5},${2=1},${3=0.8},${4=2}
  e[^-1] "Add "${arg\ 1+!$2,vertical,horizontal}" shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4."
  v - n 0,255 repeat $! l[$>]
    {max(1,w*($2!=0))},{max(1,h*($2==0))} noise. $1,2 ==. 1 distance. 1 r. .. n. $3,$4 * c 0,255
  endl done v +

#@cli shadow_patch : _opacity>=0
#@cli : Add shadow patches to selected images.
#@cli : Default value: 'opacity=0.7'.
#@cli : $ image.jpg +shadow_patch 0.4
shadow_patch : skip ${1=0.7}
  e[^-1] "Apply shadow patches to image$?, with opacity $1."
  v - repeat $! l[$>]
    100%,100%,1,1 shift. -2,-2 shift. 1,1
    plasma. 3,0.3,8 abs. b. 1 c. 3%,15% r. ..
    n. $1,1 *
  endl done v +

#@cli spread : _dx>=0,_dy>=0,_dz>=0
#@cli : Spread pixel values of selected images randomly along x,y and z.
#@cli : Default values: 'dx=3', 'dy=dx' and 'dz=0'.
#@cli : $ image.jpg +spread 3
spread : skip ${1=3},${2=$1},${3=0}
  e[^-1] "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
  v - repeat $! l[$>]
    100%,100%,100%,3
    sh. 0 rand. {-$1},$1 rm.
    sh. 1 rand. {-$2},$2 rm.
    sh. 2 rand. {-$3},$3 rm.
    warp.. .,1 rm.
  endl done v +

#@cli stripes_y : _frequency>=0
#@cli : Add vertical stripes to selected images.
#@cli : Default value: 'frequency=10'.
#@cli : $ image.jpg +stripes_y ,
stripes_y : skip ${1=10}
  e[^-1] "Add vertical stripes to image$?, with frequency $1."
  v - repeat $! l[$>]
    100% noise. $1,2 ==. 1 *. 255 r. ..
    *. 0.15 + c 0,255
  endl done v +

#@cli texturize_canvas : _amplitude>=0,_fibrousness>=0,_emboss_level>=0
#@cli : Add paint canvas texture to selected images.
#@cli : Default values: 'amplitude=20', 'fibrousness=3' and 'emboss_level=0.6'.
#@cli : $ image.jpg +texturize_canvas ,
texturize_canvas : check "${1=20}>=0 && ${2=3}>=0 && ${3=0.6}>=0 && ${4=80}"
  e[^-1] "Add canvas texture to image$?, with amplitude $1, fibrousness $2 and emboss level $3."
  v -
  repeat $! l[$>]
    {w},{h} rand. 0,255 +blur_x. $2 blur_y.. $2 +[-2,-1] g. a[-2,-1] c
    +compose_channels. + orientation.. compose_channels.. + n.. $3,1 n. 0,255
    sharpen. 80 *[-2,-1] n. -$1,$1 + c 0,255
  endl done v +

#@cli texturize_paper
#@cli : Add paper texture to selected images.
#@cli : $ image.jpg +texturize_paper
texturize_paper :
  e[^-1] "Add paper texture to image$?."
  v - repeat $! l[$>]
    . 30%,30% noise. 1,2 ==. 1 r. ..,..,..,1,0 ifft.
    rm. shift. {round(w/2)},{round(h/2)},{round(d/2)},0,2 sharpen. 1 n. 1,1.2 r. ..
    *[-2,-1] c. ..,.. rm..
  endl done v +

#@cli vignette : _strength>=0,0<=_radius_min<=100,0<=_radius_max<=100
#@cli : Add vignette effect to selected images.
#@cli : Default values: 'strength=100', 'radius_min=70' and 'radius_max=90'.
#@cli : $ image.jpg vignette ,
vignette : check "${1=100}>=0 && ${2=70}>=0 && $2<=100 && ${3=90}>=0 && $3<=100"
  e[^-1] "Add vignette effect to image$?, with strength $1 and size $2."
  v - repeat $! l[$>]
    mM={[im,iM]} d={max(w,h)}
    $d,$d =. 1,50%,50% distance. 1 r. ..,2
    c. $2%,$3% n. 0,$1 - c $mM
  endl done v +

#@cli watermark_visible : _text,0<_opacity<1,_size>0,_angle,_mode={ 0=remove | 1=add },_smoothness>=0
#@cli : Add or remove a visible watermark on selected images (value range must be [0,255]).
#@cli : Default values: 'text=(c) G'MIC', 'opacity=0.3', 'size=53', 'angle=25', 'mode=1' and 'smoothness=0'.
#@cli : $ image.jpg watermark_visible ,0.7
watermark_visible : skip "${1=\251\ G\47MIC}" check "${2=0.3}>0 && $2<1 && ${3=53}>0 && ${6=0.5}>=0" skip ${4=25},${5=1}
  e[^-1] ${arg\ 1+!$5,Add,Remove}" visible watermark '$1' on image$?, with opacity $2, size $3, angle $4 deg."
  v - repeat $! l[$>]
    0 t. "$1",0,0,$3,1,255 rotate. $4,0,0 b. $6 n. 0,255
    r. ..,0,2 +. .. c. 0,255   # Generate opaque watermark image
    if $5 *. $2 *.. {1-$2} +  # Add watermark
    else *. $2 - / {1-$2}     # Remove watermark
    fi
    c 0,255
  endl done v +

#--------------------------------------
#
#@cli :: Blending and Fading
#
#--------------------------------------

#@cli blend : [layer],blending_mode,_opacity[%],_selection_is={ 0=base-layers | 1=top-layers } : blending_mode,_opacity[%]
#@cli : Blend selected G,GA,RGB or RGBA images by specified layer or blend all selected images together, using specified blending mode.
#@cli : 'blending_mode' can be { add | alpha | and | average | blue | burn | darken | difference |
#@cli : divide | dodge | edges | exclusion | freeze | grainextract | grainmerge | green | hardlight |
#@cli : hardmix | hue | interpolation | lighten | lightness | linearburn | linearlight | luminance |
#@cli : multiply | negation | or | overlay | pinlight | red | reflect | saturation | seamless | seamless_mixed | screen |
#@cli : shapeareamax | shapeareamax0 | shapeareamin | shapeareamin0 | shapeaverage | shapeaverage0 | shapemedian | shapemedian0 |
#@cli : shapemin | shapemin0 | shapemax | shapemax0 | softburn | softdodge | softlight | stamp | subtract | value | vividlight | xor }.
#@cli : 'opacity' should be in '[0,1]', or '[0,100]' if expressed with a '%'.
#@cli : Default values: 'blending_mode=alpha', 'opacity=1' and 'selection_is=0'.
#@cli : $ image.jpg +drop_shadow , resize2dy[-1] 200 rotate[-1] 20 +blend alpha display_rgba[-2]
#@cli : $ image.jpg testimage2d {w},{h} blend overlay
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex add,alpha,and,average,blue,burn,darken
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex difference,divide,dodge,exclusion,freeze,grainextract,grainmerge
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex green,hardlight,hardmix,hue,interpolation,lighten,lightness
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex linearburn,linearlight,luminance,multiply,negation,or,overlay
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex pinlight,red,reflect,saturation,screen,shapeaverage,softburn
#@cli : $ command "ex : $""=arg repeat $""# +blend[0,1] ${arg{$>+1}} text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 done" image.jpg testimage2d {w},{h} ex softdodge,softlight,stamp,subtract,value,vividlight,xor
blend : skip ${1=alpha},${2=1},${3=1},${4=0}
  v -
  if ${"is_image_arg $1"}
    n={narg($*)} mode=${arg\ 1+($n>=2),alpha,$2}
    v + e[^-1] "Blend image$? with "${arg\ 1+$4,base,top}" layer $1, using '"$mode"' mode and opacity $3." v -
    repeat $! pass$1 l[$>,-1] if $4 rv fi blend $mode,$3 endl done v + return
  fi
  v + e[^-1] "Blend all image$? together, using '$1' mode and opacity $2." v -
  repeat {$!-1} l[0,1]
    r[1] [0],[0],[0],100%,0,0,0.5,0.5
    s={"s0 = s#0<3?1:3; s1 = s<3?1:3; max(s0,s1)"} # Target color format (G or RGB).
    to_colormode[0] {$s+1-(s#0%2)}                 # Target format (G,GA,RGB or RGBA).
    to_colormode[1] {$s+1-(s%2)}                   # Mask format (G,GA,RGB or RGBA).
    if {0,"s==2 || s==4"} # Target has alpha.
      if {"s==2 || s==4"} # Mask has alpha.
        sh[0,1] 0,{s-2} _blend_$1[2,3] rm[2,3]
        if {['"$1"']=='alpha'} # Special blending code for alpha-mode.
          sh[0,1] 0,{{0,s}-2} sh[0,1] 100% *[2,4] *[3,4] rm[2,3]
          +channels[1] 100% sh[1] 100% f[3] 255 rm[3]
          j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 rm[1,2]
          sh[0] 0,{s-2} sh[0] 100% +[2] 1e-10 /[1,2] rm[1] c 0,255
        else
          sh[1] 0,{s-2} sh[1] 100% j[0] [2],0,0,0,0,{max(0,min(1,$2))},[3],255 rm[^0]
        fi
      else # Mask has no alpha.
        sh[0] 0,{{0,s}-2} rv[1,2] _blend_$1[1,2] j[1] [2],0,0,0,0,{max(0,min(1,$2))} rm[^0]
      fi
    else # Target has no alpha.
      if {"s==2 || s==4"} # Mask has alpha.
        sh[1] 0,{s-2} _blend_$1[0,2] rm[2]
        sh[1] 100% j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 rm[^0]
      else # Mask has no alpha.
        _blend_$1 j[0] [1],0,0,0,0,{max(0,min(1,$2))} rm[1]
      fi
    fi
  endl done v +

_blend_alpha :
_blend_normal :
_blend_and :
  &[1] [0]
_blend_add :
  +[1] [0] c[1] 0,255
_blend_average :
  +[1] [0] /[1] 2
_blend_blue :
  sh[0] 0,1 j[1] [2] rm[2]
_blend_burn :
  +-[0] 255 +[1] 0.1 /[2] [1] rm[1] +[1] 1 *[1] 255 c[1] 0,255
_blend_darken :
  min[1] [0]
_blend_difference :
  -[1] [0] abs[1]
_blend_divide :
  +[1] 0.1 ^[1] -1 *[1] [0] *[1] 255 c[1] 0,255
_blend_dodge :
  -[1] 255.1 ^[1] -1 *[1] [0] *[1] -255 c[1] 0,255
_blend_edges :
  +blend_edges 0.5 rm[1]
_blend_exclusion :
  +*[0,1] /[2] -127.5 +[1,2] +[1] [0]
_blend_freeze :
  *[1] -255 -[1] 0.1 +-[0] 255 sqr[2] /[2] [1] rm[1] +[1] 1 *[1] 255 c[1] 0,255
_blend_grainextract :
  -[1] [0] *[1] -1 +[1] 128 c[1] 0,255
_blend_grainmerge :
  +[1] [0] -[1] 128 c[1] 0,255
_blend_green :
  sh[0] 0 sh[0] 2 j[1] [2] j[1] [3],0,0,0,2 rm[2,3]
_blend_hardlight :
  +*[0,1] /[2] 127.5 ++[0,1] *[3] 2 -[3] 255 -[3] [2] >[1] 128
  j[2] [3],0,0,0,0,1,[1] rm[1,3] c[1] 0,255
_blend_hardmix :
  +[1] [0] >=[1] 255 *[1] 255
_blend_hue :
  to_color sh 0,2 rgb2hsv[2,3] sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] hsv2rgb[2,3] rm[2,3]
_blend_interpolation :
  +*[0] {pi/255} *[1] {pi/255} cos[1,2] +[1,2] -[1] 2 *[1] -63.75 c[1] 0,255
_blend_lighten :
  max[1] [0]
_blend_lightness :
  to_color sh 0,2 rgb2lab[2,3] sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] lab2rgb[2,3] rm[2,3]
_blend_luminance :
  to_color sh 0,2 rgb2ycbcr[2,3] sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] ycbcr2rgb[2,3] rm[2,3]
_blend_linearburn :
  +[1] [0] -[1] 255 c. 0,255
_blend_linearlight :
  *[1] 2 +[1] [0] -[1] 255 c[1] 0,255
_blend_multiply :
  *[1] [0] /[1] 255
_blend_negation :
  +[1] [0] -[1] 255 abs[1] *[1] -1 +[1] 255
_blend_or :
  -|[1] [0]
_blend_overlay :
  +*[0,1] /[2] 127.5 +[1] [0] *[1] 2 -[1] 255 -[1] [2] +<[0] 128 j[1] [2],0,0,0,0,1,[3] rm[2,3] c[1] 0,255
_blend_pinlight :
  *[1] 2 +blend darken -[1] 256 +blend[0,1] lighten >=[1] 0
  j[2] [3],0,0,0,0,1,[1] rm[1,3]
_blend_reflect :
  -[1] 255.1 *[1] -1 +sqr[0] /[2] [1] rm[1] c[1] 0,255
_blend_red :
  sh[0] 1,100% j[1] [2],0,0,0,1 rm[2]
_blend_seamless :
  +blend_seamless 0 rm[1]
_blend_seamless_mixed :
  +blend_seamless 1 rm[1]
_blend_saturation :
  to_color sh 0,2 rgb2hsv[2,3] shift[2,3] 0,0,0,-1,2 sh[2] 1,2 j[1] [4],0,0,0,1 rm[4] shift[2,3] 0,0,0,1,2 hsv2rgb[2,3] rm[2,3]
_blend_screen :
  +-[0] 255 -[1] 255 *[1,2] /[1] 255 *[1] -1 +[1] 255
_blend_shapeareamax :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0
  +f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
  {1,iM+1},1,1,{0,s+1}
  f[1] ">area = i(#2); best = I[#3,i]; if (area>best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
  rm[2] channels[2] 0,{s-2} map[1] [2] rm[2]
_blend_shapeareamax0 :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0
  +f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
  {1,iM+1},1,1,{0,s+1}
  f[1] ">area = i(#2); best = I[#3,i]; if (area>best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
  rm[2] channels[2] 0,{s-2} point[2] 0,0,0,1,0 map[1] [2] rm[2]
_blend_shapeareamin :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0
  +f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
  {1,iM+1},1,1,{0,s+1},inf
  f[1] ">area = i(#2); best = I[#3,i]; if (area<best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
  rm[2] channels[2] 0,{s-2} map[1] [2] rm[2]
_blend_shapeareamin0 :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0
  +f[0] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[2] round[2] 0.01 area[2] 0,0
  {1,iM+1},1,1,{0,s+1},inf
  f[1] ">area = i(#2); best = I[#3,i]; if (area<best[size(best) - 1], I[#3,i] = [ I(#0),area ]);i"
  rm[2] channels[2] 0,{s-2} point[2] 0,0,0,1,0 map[1] [2] rm[2]
_blend_shapeaverage :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0 {iM+1},1,1,{0,s}
  f[0] ">i(#2,i(#1,x,y,z,0),0,0,c)+=i;i"
  +histogram[1] {w},0,{w-1} /[-2,-1] map[1] . rm.
_blend_shapeaverage0 :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0 {iM+1},1,1,{0,s}
  f[0] ">i(#2,i(#1,x,y,z,0),0,0,c)+=i;i"
  +histogram[1] {w},0,{w-1} /[-2,-1] point. 0,0,0,1,0 map[1] . rm.
_blend_shapemedian :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0
  N={iM+1} $N,1,1,{s#0} $N,8,1,{s#0} s. x
  f[1] ">
    begin(siz = vector"$N"());
    k = i;
    k3 = k + 3;
    hk3 = h(#k3);
    copy(i[#k3,siz[k]++],I(#0),s#0,hk3,whd#0);
    if (siz[k]>=hk3,resize(#k3,1,round(1.5*hk3+1),1,s#0,0,0));
    end(for (k = 0, k<size(siz), ++k, resize(#k+3,1,siz[k],1,s#0,0,0)));
    i"
  repeat {s#0} sh[3--1] $> $N,1,1,1,"ic(#"$N"+3+x)" j[2] .,0,0,0,$> rm[-{$N+1}--1] done
  map[1] [2] k[0,1]
_blend_shapemedian0 :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0
  N={iM} {$N+1},1,1,{s#0} $N,8,1,{s#0} s. x
  f[1] ">
    begin(siz = vector"$N"());
    k = i;
    if (k,
      k1 = k - 1;
      k2 = k + 2;
      hk2 = h(#k2);
      copy(i[#k2,siz[k1]++],I(#0),s#0,hk2,whd#0);
      if (siz[k1]>=hk2,resize(#k2,1,round(1.5*hk2+1),1,s#0,0,0));
    );
    end(for (k = 0, k<size(siz), ++k, resize(#k+3,1,siz[k],1,s#0,0,0)));
    i"
  repeat {s#0} sh[3--1] $> $N,1,1,1,"ic(#"$N"+3+x)" j[2] .,1,0,0,$> rm[-{$N+1}--1] done
  map[1] [2] k[0,1]
_blend_shapemin :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0 {iM+1},1,1,{0,s},inf
  f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = min(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
  map[1] [2] rm.
_blend_shapemin0 :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0 {iM+1},1,1,{0,s},inf
  f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = min(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
  point. 0,0,0,1,0 map[1] [2] rm.
_blend_shapemax :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm[1] round[1] 0.01 label[1] 0 {iM+1},1,1,{0,s},-inf
  f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = max(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
  map[1] [2] rm.
_blend_shapemax0 :
  f[1] "begin(A = resize([ 0,(s-1)/s ],s,3));I!=0?I+A:I" norm[1] round[1] 0.01 label_fg[1] 0 {iM+1},1,1,{0,s},-inf
  f[0] ">i(#2,i(#1,x,y,z,0),0,0,c) = max(i(#2,i(#1,x,y,z,0),0,0,c),i);i"
  point. 0,0,0,1,0 map[1] [2] rm.
_blend_softburn :
  +-[0] 255.1 ^[2] -1 *[2] [1] *[2] -127.5 +-[0] 255 ++[1] 0.1 /[3,4] *[3] 127.5 +[3] 255 +[1] [0] >[1] 255
  j[2] [3],0,0,0,0,1,[1] rm[1,3] c[1] 0,255
_blend_softdodge :
  +-[1] 255.1 ^[2] -1 *[2] [0] *[2] -127.5 +-[1] 255 ++[0] 0.1 /[3,4] *[3] 127.5 +[3] 255 +[1] [0] >[1] 255
  j[2] [3],0,0,0,0,1,[1] rm[1,3] c[1] 0,255
_blend_softlight :
  +/[0] 255 /[1] 255 +sqr. *[2] [1] *[1] [3] *[1] -2 *[2] 2 +[1-3] *[1] 255 c[1] 0,255
_blend_stamp :
  *[1] 2 +[1] [0] -[1] 255 c[1] 0,255
_blend_subtract :
  -[1] [0] *[1] -1 c[1] 0,255
_blend_value :
  to_color sh 0,2 rgb2hsv[2,3] sh[2] 0,1 j[1] [4] rm[4] hsv2rgb[2,3] rm[2,3]
_blend_vividlight :
  *[1] 2 +blend burn -[1] 256 +blend[0,1] dodge >=[1] 0
  j[2] [3],0,0,0,0,1,[1] rm[1,3]
_blend_xor :
  xor[1] [0]

#@cli blend_edges : smoothness[%]>=0
#@cli : Blend selected images togethers using 'edges' mode.
#@cli : $ image.jpg testimage2d {w},{h} +blend_edges 0.8
blend_edges : check {$1>=0}
  e[^-1] "Blend image$? using 'edges' mode, with smoothness $1."
  if {$!>1} v - to_rgb r[^0] [0],0,0,0.5,0.5 repeat $! l[$>]
    +gradient_norm +. 1 b. $1 n. 1,10 sqr. s.. c *[-4--2] . a[-4--1] c
  endl done r[^0] [0],0,0,0.5,0.5 + s. c /[-4--2] . rm. a[-3--1] c v + fi

#@cli blend_fade : [fading_shape]
#@cli : Blend selected images together using specified fading shape.
#@cli : $ image.jpg testimage2d {w},{h} 100%,100%,1,1,'cos(y/10)' normalize[-1] 0,1 +blend_fade[0,1] [2]
blend_fade :
  e[^-1] "Blend image$? together using fading pattern $1."
  v - r ${-max_whds},0
  pass$1 0 r. [0],[0],[0],100%,1 max. 0 min. {$!-2}
  repeat {$!-1} +-. $> abs. -. 1 *. -1 max. 0 *[$>,-1] done rm.
  + v +

_fade :
  r.. ...,5 r. ..,3 c. $1%,$2% n. 0,1 j... ..,0,0,0,0,1,. rm[-2,-1]

#@cli blend_median
#@cli : Blend selected images together using 'median' mode.
#@cli : $ image.jpg testimage2d {w},{h} +mirror[0] y +blend_median
blend_median :
  e[^-1] "Blend image$? using 'median' mode."
  if {$!<2} return fi
  v - to_colormode 0 r ${-max_whd},100%,0,0,0.5,0.5,0.5
  if {$!==2} + / 2
  else
    whds={w},{h},{d},{s} r 100%,100%,{d*s},1,-1 a c
    100%,100%,100%,1,"med(I(#0))" k. r $whds,-1
  fi
  v +

#@cli blend_seamless : _is_mixed_mode={ 0 | 1 },_inner_fading[%]>=0,_outer_fading[%]>=0
#@cli : Blend selected images using a seamless blending mode (Poisson-based).
#@cli : Default values: 'is_mixed=0', 'inner_fading=0' and 'outer_fading=100%'.
blend_seamless : check "${2=0}>=0 && ${3=100%}>=0" skip ${1=0}
  v - s0="non-mixed" s1="mixed"
  v + e[^-1] "Blend image$? using seamless mode (Poisson-based), in "${s{$1!=0}}" mode with inner fading $2 and outer fading $3." v -
  to_a[^0] r {0,w+32},{0,h+32},1,100%,0,0,0.5,0.5 # Avoid periodic boundaries problems.

  if {['$3']!='100%'} # With outer fading.
    repeat {$!-1} l[0,1]
      +blend_seamless $1,$2,100% channels.. 100% !=.. 0 distance.. 1
      iM={-2,iM} ic={if(${is_percent\ $3},2*$3*$iM,1+$3)}
      if {$ic<=$iM} c.. 0,{max(1,$ic)} n.. 0,1
      else n.. 0,{max(0,2-$ic/$iM)}
      fi
      *.. -1 +.. 1
      j[0] [2],0,0,0,0,1,[1] rm[1,2]
    endl done
  else # Without outer fading.

    repeat {$!-1} l[0,1]

      # Get background average color.
      +r[0] 1,1,1,100%,2 avg={^} rm.

      # Compute mixed gradients of background and top layer.
      split_opacity. !=. 0 *.. . erode. 3
      g[0,1] xy,1
      *[-3,-2] .

      # Modify mask if 'mixed' mode selected.
      if $1
        +a[0,1] c +a[2,3] c norm[-2,-1]
        <[-2,-1] *[-2,-1]
      fi

      # Compute the desired gradient map.
      if {$2}
        distance. 0
        iM={iM} ic={if(${is_percent\ $2},2*$2*$iM,1+$2)}
        if {$ic<=$iM} c. 0,{max(1,$ic)} n. 0,1
        else n. 0,{max(0,2-$ic/$iM)}
        fi
      fi

      j[-5] ...,0,0,0,0,1,.
      j[-4] ..,0,0,0,0,1,.
      rm[-3--1]

      # Compute divergence (right-hand term of Poisson eq.)
      g[0] x,-1 g[1] y,-1 +

      # Inverse Laplacian and renormalize
      ilaplacian 0
      +fc. $avg
      +[-2,-1]
      c 0,255

    endl done
  fi
  z 16,16,{w-17},{h-17} v +

#@cli fade_diamond : 0<=_start<=100,0<=_end<=100
#@cli : Create diamond fading from selected images.
#@cli : Default values: 'start=80' and 'end=90'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_diamond 80,85
fade_diamond : skip ${1=70},${2=90}
  e[^-1] "Create ($1%,$2%) diamond-shaped fading from image$?."
  v - repeat {int($!/2)} l[$>,{$>+1}]
    (0,1,0;1,1,1;0,1,0) _fade $1,$2
  endl done v +

#@cli fade_linear : _angle,0<=_start<=100,0<=_end<=100
#@cli : Create linear fading from selected images.
#@cli : Default values: 'angle=45', 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_linear 45,48,52
fade_linear : skip ${1=45},${2=30},${3=70}
  e[^-1] "Create ($2%,$3%) linear fading from image$?, with angle $1 deg."
  v - repeat {int($!/2)} l[$>,{$>+1}]
     64,64,1,1,"x*cos($1*pi/180) + y*sin($1*pi/180)" _fade $2,$3
  endl done v +

#@cli fade_radial : 0<=_start<=100,0<=_end<=100
#@cli : Create radial fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_radial 30,70
fade_radial : skip ${1=30},${2=70}
  e[^-1] "Create ($1%,$2%) radial fading from image$?."
  v - repeat {int($!/2)} l[$>,{$>+1}]
    100%,100% =. 1,50%,50% distance. 1 _fade $1,$2
  endl done v +

#@cli fade_x : 0<=_start<=100,0<=_end<=100
#@cli : Create horizontal fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_x 30,70
fade_x : skip ${1=30},${2=70}
  e[^-1] "Create ($1%,$2%) horizontal fading from image$?."
  v - repeat {int($!/2)} l[$>,{$>+1}] (0,1) _fade $1,$2 endl done v +

#@cli fade_y : 0<=_start<=100,0<=_end<=100
#@cli : Create vertical fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
#@cli : $ image.jpg testimage2d {w},{h} +fade_y 30,70
fade_y : skip ${1=30},${2=70}
  e[^-1] "Create ($1%,$2%) vertical fading from image$?."
  v - repeat {int($!/2)} l[$>,{$>+1}] (0;1) _fade $1,$2 endl done v +

#@cli fade_z : 0<=_start<=100,0<=_end<=100
#@cli : Create transversal fading from selected images.
#@cli : Default values: 'start=30' and 'end=70'.
fade_z : skip ${1=30},${2=70}
  e[^-1] "Create ($1%,$2%) transversal fading from image$?."
  v - repeat {int($!/2)} l[$>,{$>+1}] (0/1) _fade $1,$2 endl done v +

#@cli sub_alpha : [base_image],_opacity_gain>=1
#@cli : Compute the minimal alpha-channel difference (opposite of alpha blending) between the selected images and the specified base image.
#@cli : The alpha difference A-B is defined as the image having minimal opacity, such that alpha_blend(B,A-B) = A.
#@cli : Default value: 'opacity_gain=1'.
#@cli : $ image.jpg testimage2d {w},{h} +sub_alpha[0] [1] display_rgba
sub_alpha : check "${2=1}>=1 && "${"is_image_arg $1"}
  e[^-1] "Compute minimal alpha-channel difference between image$? and base image $1, with opacity gain $2."
  v - remove_opacity repeat $! pass$1 0 l[$>,-1]
    to_colormode 0 r ${-max_whd},100%,0,0,0.5,0.5  # Normalize image dimensions.

    # Estimate minimal alpha-channel.
    +>[0,1] *[2] 255
    -[0,2] [1] replace[2] 0,1
    i[2] [0] /[2,3]
    compose_channels[2] max
    *[2] $2 c[2] 0,1

    # Synthetize alpha-difference image.
    +replace[2] 0,1 /[0,3] +[0,1] *[1] 255 a c

  endl done v +

#---------------------------------------------
#
#@cli :: Image Sequences and Videos
#
#---------------------------------------------

#@cli animate : filter_name,"param1_start,...,paramN_start","param1_end,...,paramN_end",nb_frames>=0,_output_frames={ 0 | 1 },_output_filename : delay>0,_back and forth={ 0 | 1 }
#@cli : Animate filter from starting parameters to ending parameters or animate selected images
#@cli : in a display window.
#@cli : Default value: 'delay=30'.
#@cli : $ image.jpg animate flower,"0,3","20,8",9
animate : skip ${1=30},${2=0},${3=""},${4=10},${5=1},"${6=}"
  if {"isval($1)"}
    e[0--3] "Animate image$?, with a delay of $1 ms"${"v - if $2 u \", in back-and-forth mode\" else u \"\" fi v +"}.
    if {!$!} return fi
    v -
    speed,pause,direction,scale,frame=$1,-1,1,1,0
    is_same_size={"res = 1; s = [ w#0,h#0 ]; for (k = 1, k<l && res, ++k, res = (s==[ w#k,h#k ]))"}

    w[0] ${fitscreen[]\ {0,[w,h]}},1,0,-1,-1,{0,b}.{0,x}
    do
      if $is_same_size
        w[$frame] -1,-1,1,0,-1,-1,{$frame,b}.{$frame,x}
      else
        w[$frame] {$scale*[${fitscreen[]\ {$frame,[w,h]}}]},1,0,-1,-1,{$frame,b}.{$frame,x}
      fi
      frame+=$direction
      if $2
        if {$frame==-1} frame=0 direction=1
        elif {$frame==$!} frame={$!-1} direction=-1
        fi
      else frame%=$!
      fi
      wait $speed
      if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} scale*=1.5 wait -1 fi # Increase window size.
      if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} scale/=1.5 wait -1 fi # Decrease window size.
      if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} scale=1 wait -1 fi             # Reset window size.
      if {*,o} speed={min(500,max(10,$speed-10*{*,o}))} wait -1 fi
      if {*,SPACE}
        if {$pause>=0} direction=$pause pause=-1
        else pause=$direction direction=0 fi
        wait -1
      fi

    while {{*}" && "!{*,Q}" && "!{*,ESC}} w 0 v +
  else
    e[0--3] "Compute animated version of filter '$1', from parameters $2 to $3 with $4 frames."
    if {!($5||narg("$6"))} return fi
    v - ($2) ($3) y[-2,-1] x a[-2,-1] y r. 100%,$4,1,1,3 mv. 0 rprogress 0
    repeat {$!-1},u
      v + e[] " > Animate image ["$>"]" v -
      repeat $4 +l[0,1]
        -$1. {0,@{$>*{0,w}}-{($>+1)*{0,w}-1}} rm[0]
        if {narg("$6")} o ${filename\ "$6",$u,$>} fi
        if {!$5} rm fi
        rprogress {100*($>+1)/$4}
        v + e[] "\r > Animate image ["$u"] : Frame "{$>+1}"/$4    " v -
      endl done
    rm[1] done rm[0] v +
  fi

#@cli apply_camera : _"command",_camera_index>=0,_skip_frames>=0,_output_filename
#@cli : Apply specified command on live camera stream, and display it on display window [0].
#@cli : Default values: 'command=""', 'camera_index=0' (default camera), 'skip_frames=0' and 'output_filename=""'.
apply_camera : skip "${1=},${4=}" check "${2=0}>=0 && ${3=0}>=0"
  e[^-1] "Apply command '$1' on camera stream ""#$2, with $3 frames skip and output filename '$4'."
  v - is_ext "$4",avi is_outavi=${}
  l[] i=0 do
    camera $2,1,$3 $1 w. -1,-1,"[G'MIC] Camera ""#$2 ("{w}x{h}")"
    if {narg("$4")} if $is_outavi z. 0,{w-(w%8)-1} o. "$4",25,mp4v,1 else o. ${filename\ "$4",$i} i+=1 fi fi
    if {*,S} o. gmic_camera.png fi
    if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi # Increase window size.
    if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi # Decrease window size.
    if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi             # Reset window size.
    rm.
  while {{*}" && "!{*,ESC}" && "!{*,Q}} camera $2,0 endl v +

#@cli apply_files : "filename_pattern",_"command",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Apply a G'MIC command on specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'command=(undefined)', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
apply_files : check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${2=},${6=}"
  e[^-1] "Apply command '$2' on input image files '$1', with first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
  v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _apply_stream[] "${_file{$frame+1}}","$2",${3-5},"$6" v +

#@cli apply_video : video_filename,_"command",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Apply a G'MIC command on all frames of the specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
apply_video : check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${2=},${6=}"
  e[^-1] "Apply command '$2' on input video file '$1', with first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
  v - _N= _apply_stream[] "\"$1\",$frame","$2",${3-5},"$6" v +

_apply_stream : skip "${2=},${6=}"
  is_ext "$6",avi is_outavi=${}
  frame=$3 i=0 go_on=1
  do
    l[] $1 onfail go_on=0 endl
    if $go_on
      v + e[] "\r  > Frame ""#"$frame$_N"        " v -
      frame+=$5
      l $2 onfail error[0--5] "Command 'apply_stream': Specified command errored: "${} endl
      if {!$!} continue fi
      if {narg("$6")}
        if $is_outavi z. 0,{w-(w%8)-1} o. "$6",25,mp4v,1 else o. ${filename\ "$6",$i} i+=1 fi
      fi
      if {*}
        title="[G'MIC] Frame ""#"$frame
        if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,0,$title
        else w. -1,-1,0,$title
        fi
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi # Increase window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi # Decrease window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi             # Reset window size.
      fi
      rm.
    fi
  while {$go_on" && "($4==-1" || "$frame<=$4)}
  if $is_outavi o[] "$6",25,mp4v,0 fi

#@cli average_files : "filename_pattern",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Average specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
average_files : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1" skip "${5=}"
  e[^-1] "Average input image files '$1', with first frame $2, last frame $3, frame step $4 and output filename '$5'.\n"
  v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _average_stream[] "${_file{$frame+1}}",${2-4},"$5" v +

#@cli average_video : video_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Average frames of specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
average_video : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1" skip "${5=}"
  e[^-1] "Average frames of input video file '$1', with first frame $2, last frame $3, frame step $4 and output filename '$5'.\n"
  v - _N= _average_stream[] "\"$1\",$frame",${2-4},"$5" v +

_average_stream : skip "${5=}"
  is_ext "$5",avi is_outavi=${}
  frame=$2 i=0 go_on=1 N=0
  imM=inf,-inf
  do
    l[] $1 onfail go_on=0 endl
    if $go_on
      v + e[] "\r  > Frame ""#"$frame$_N"        " v -
      imM={v=[$imM];[min(im,v[0]),max(iM,v[1])]}
      N+=1
      if {$!>1} + fi
      if {narg("$5")}
        +/. $N c. $imM
        if $is_outavi z. 0,{w-(w%8)-1} o. "$5",25,mp4v,1 else o. ${filename\ "$5",$i} i+=1 fi
        rm.
      fi
      if {*}
        title="[G'MIC] Frame ""#"$frame
        +n 0,255
        if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,0,$title
        else w. -1,-1,0,$title
        fi
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi # Increase window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi # Decrease window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi             # Reset window size.
        rm.
      fi
      frame+=$4
    fi
  while {$go_on" && "($3==-1" || "$frame<=$3)}
  / $N c $imM
  if $is_outavi o[] "$5",25,mp4v,0 fi

#@cli fade_files : "filename_pattern",_nb_inner_frames>0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Generate a temporal fading from specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension 'avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'nb_inner_frames=10', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
fade_files : check "isint(${2=10}) && $2>0 && isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${6=}"
  e[^-1] "Fade input image files '$1', with $2 inner frames, first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
  v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _fade_stream[] "${_file{$frame+1}}",${2-5},"$6" v +

#@cli fade_video : video_filename,_nb_inner_frames>0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Create a temporal fading sequence from specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : Default values: 'nb_inner_frames=10', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
fade_video : check "isint(${2=10}) && $2>0 && isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && ${5=1}>=1" skip "${6=}"
  e[^-1] "Fade frames of input video file '$1', with $2 inner frames, first frame $3, last frame $4, frame step $5 and output filename '$6'.\n"
  v - _N= _fade_stream[] "\"$1\",$frame",${2-5},"$6" v +

_fade_stream : skip "${6=}"
  is_ext "$6",avi is_outavi=${}
  frame=$3 i=0 go_on=1

  l $1 onfail go_on=0 endl # Load first image.
  if {!$go_on} return fi
  w={w} h={h} s={s}
  if {*} w. ${fitscreen\ $w,$h},0,"[G'MIC]" fi
  pframe=$frame frame+=$5
  do
    l[] $1 onfail go_on=0 endl
    if {!$go_on} break fi
    to_colormode. $s r. $w,$h
    repeat {$2+2} if {$<}
      title="[G'MIC] Frame ""#"$pframe" -> ""#"$frame$_N" ("{1+$>}/$2")"
      v + e[] "\r  - "$title v -
      +j[0] [1],0,0,0,0,{$>/($2+1)}
      if {narg("$6")}
        if $is_outavi z. 0,{w-(w%8)-1} o. "$6",25,mp4v,1 else filename "$6",$i i+=1 o. ${} fi
      fi
      if {*}
        w. -1,-1,0,$title
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi # Increase window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi # Decrease window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi             # Reset window size.
      fi
      rm.
    fi done
    rm[0] pframe=$frame frame+=$5
  while {$go_on" && "($4==-1" || "$frame<=$4)}

  # Output last frame.
  if {narg("$6")}
    if $is_outavi z. 0,{w-(w%8)-1} o[] "$6",25,mp4v,0 else filename "$6",$i o. ${} fi
  fi
  rm

#@cli files2video : "filename_pattern",_output_filename,_fps>0,_codec
#@cli : Convert several files into a single video file.
#@cli : Default values: 'output_filename=output.avi', 'fps=25' and 'codec=mp4v'.
files2video : check "isint(${3=25}) && $3>0" skip "${2=output.avi}",${4=mp4v}
  v -
  files=${"files \"$1\""} arg2var _file,$files nb_files=${}
  ({'$files'}) if {w>128} z. 0,127 s_files={t}... else s_files=$files fi rm.
  v + e[^-1] "Convert image files '"$s_files"' into frames of output video '$2', with $3 fps and $4 codec.\n" v -
  repeat $nb_files l[]
    file=${_file{$>+1}}
    _file=${basename\ $file}
    v + e[] "\r - Image "{1+$>}/$nb_files" ["$_file"] -> [$2]                    " v -
    i $file o "$2",$3,$4,1
    rm
  onfail v + e[] "\n - Error occurred on input file '"$file"'.\n" v -
  endl done
  o $"$2",0,0,0 v +

#@cli median_files : "filename_pattern",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_frame_rows[%]>=1,_is_fast_approximation={ 0 | 1 }
#@cli : Compute the median frame of specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frame is displayed in it during processing.
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1', 'frame_rows=20%' and 'is_fast_approximation=0'.
median_files : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1 && ${5=20%}>0 && isval(${6=0})"
  v - s0="fast" s1="precise"
  v + e[^-1] "Compute median of input image files '$1', with first frame $2, last frame $3, frame step $4, frame rows $5, using "${s{!$6}}" algorithm." v -
  files 3,"$1" _N=/{narg(${})-1} arg2var _file,${}
  l[]
    i[res] ${_file{$frame+1}} f. 0
    _median_stream "${_file{$frame+1}}",${2-6}
  endl v +

#@cli median_video : video_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_frame_rows[%]>=1,_is_fast_approximation={ 0 | 1 }
#@cli : Compute the median of all frames of an input video file, in a streamed way.
#@cli : If a display window is opened, rendered frame is displayed in it during processing.
#@cli : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1', 'frame_rows=100%' and 'is_fast_approximation=1'.
median_video : check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1 && ${5=100%}>0 && isval(${6=1})"
  v - s0="fast" s1="precise"
  v + e[^-1] "Compute median frame of input video file '$1', with first frame $2, last frame $3, frame step $4, frame rows $5, using "${s{!$6}}" algorithm." v -
  _N=
  l[]
    i[res] "$1",0 f. 0
    _median_stream "\"$1\",$frame",${2-6}
  endl v +

_median_stream :

  # Retrieve min/max values of all frames when fast method is used.
  if $6
    v + e[] "- Retrieve min/max values of all frames.\n" v -
    frame=$2 go_on=1
    imM=inf,-inf
    do
      l[] $1 onfail go_on=0 endl
      if $go_on
        v + e[] "\r    > Frame ""#"$frame$_N"        " v -
        imM={v=[$imM];[min(im,v[0]),max(iM,v[1])]}
        if {*}
          title="[G'MIC] Frame ""#"$frame
          if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,1,$title
          else w. -1,-1,1,$title
          fi
        fi
        rm.
        frame+=$4
      fi
    while {$go_on" && "($3==-1" || "$frame<=$3)}
    _N=/{$frame-$4}
    fact={v=[$imM];dv=v[1]-v[0];dv<=0?0:255/dv}
  fi

  # Start median computation.
  h1={h-1} drows={round(${is_percent\ $5}?$5*h:$5)}
  nb_iter={round(h/$drows,1,1)}
  repeat $nb_iter
    row0={$drows*$>} row1={0,min(h,$row0+$drows-1)}
    v + e[] "- Iteration \#"{$>+1}/$nb_iter": Load rows "$row0-$row1/$h1".\n" v -
    frame=$2 go_on=1

    if $6
      # Fast method : compute median frame using streamed histogram computation.
      N=0
      i[hist] {w},$drows,256,{s}
      do
        l[] $1 nm. img onfail go_on=0 endl
        if $img
          v + e[] "\r    > Frame ""#"$frame$_N"        " v -
          if {{*}" && "!$>}
            title="[G'MIC] Frame ""#"$frame
            if {!narg($wh)} wh=${fitscreen[]\ {img,w},{img,h}} w[img] $wh,1,$title
            else w[img] -1,-1,1,$title
            fi
          fi
          rows[img] $row0,$row1 f[img] ":++i(#-2,x,y,round(i*"$fact"),c)"
          rm[img]
          frame+=$4 N+=1
        fi
      while {$go_on" && "($3==-1" || "$frame<=$3)}
      cumulate[hist] z
      N2={int($N/2)}
      [hist],[hist],1,[hist]
      if {$N%2} # Odd number of frames.
        f. ":go_on = 1; for (z = 0, i(#"$hist",x,y,z,c)<"$N2" && z<256, ++z); z"
      else # Even number of frames.
        f. ":begin(N2p = "$N2"; N2n = N2p + 1);
             go_on = 1;
             for (zp = 0, i(#"$hist",x,y,zp,c)<N2p && zp<256, ++zp);
             for (zn = zp, i(#"$hist",x,y,zn,c)<N2n && zn<256, ++zn);
             0.5*(zn + zp);"
      fi
      rm..
      /. $fact c. $imM

    else
      # Slow method : compute median frame using temporal quicksort.
      l[]
        do
          l[] $1 nm. img onfail go_on=0 endl
          if $go_on
            v + e[] "\r    > Frame ""#"$frame$_N"        " v -
            if {{*}" && "!$>}
              title="[G'MIC] Frame ""#"$frame
              if {!narg($wh)} wh=${fitscreen[]\ {w},{h}} w. $wh,1,$title
              else w. -1,-1,1,$title
              fi
            fi
            rows. $row0,$row1
            frame+=$4
          fi
        while {$go_on" && "($3==-1" || "$frame<=$3)}
        v + e[] "\r    > Compute median blending of "$!" frames." v -
        __median_stream
      endl
    fi

    _N=/{$frame-$4}
    j[res] .,0,$row0
    if {*} w[res] -1,-1,1,"[G'MIC] Iteration ""#"$> fi
    rm.

  done
  v + e[] "- Done!" v -

# Median blending optimized to deal with a lot of input frames.
__median_stream :
  if {$!<2} return
  elif {$!==2} + / 2
  else
    f. ":
      stack = vector"{0,2*$!}"();
      stacksize = 0;
      push(elt0,elt1) = (stack[stacksize++] = elt0; stack[stacksize++] = elt1);
      pop() = (_s1 = stack[--stacksize]; _s0 = stack[--stacksize]; [_s0,_s1]);
      push(0,"$!" - 1);
      while (stacksize>0,
        range = pop();
        lo = range[0];
        hi = range[1];
        pivot = i(#int((lo + hi)/2));
        while (lo<=hi,
           while (i(#lo)<pivot, ++lo);
           while (pivot<i(#hi), --hi);
           if (lo<=hi, _tmp = i(#lo); i(#lo++) = i(#hi); i(#hi--) = _tmp);
        );
        if (range[0]<hi,push(range[0],hi));
        if (lo<range[1],push(lo,range[1]));
      )"
    if {$!%2} k[{int($!/2)}]
    else k[{int($!/2-1)},{$!/2}] + / 2
    fi
  fi

#@cli morph : nb_inner_frames>=1,_smoothness>=0,_precision>=0
#@cli : Create morphing sequence between selected images.
#@cli : Default values: 'smoothness=0.1' and 'precision=4'.
#@cli : $ image.jpg +rotate 20,1,1,50%,50% morph 9
morph : check "$1>=0 && ${2=0.1}>=0 && ${3=4}>=0"
  e[^-1] "Create morphing sequence between image$?, with $1 inner frames, smoothness $2 and precision $3.\n"
  if {!$1} return fi
  v - r[^0] [0],3 repeat {$!-1} nm={$>,n} l[$<,{$<+1}]
    v + e[] "\r > Morph image "$>" to image "{$>+1}".    " v -
    +equalize[0,1] n[-2,-1] 0,255
    +displacement[3] [2],$2,$3 +displacement[2] [3],$2,$3 rm[-4,-3]
    repeat {$1+2} if {$>&&$<}
      t={$>/($1+1)} omt={1-$t}
      +*[2] $t +warp[0] .,1,1,1 rm.. *. $omt
      +*[3] {1-$t} +warp[1] .,1,1,1 rm.. *. $t
      +[-2,-1]
    fi done
    rm[2,3] mv[2--1] 1 nm $nm
  endl done v +

#@cli morph_files : "filename_pattern",_nb_inner_frames>0,_smoothness>=0,_precision>=0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Generate a temporal morphing from specified input image files, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'nb_inner_frames=10', 'smoothness=0.1', 'precision=4', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
morph_files : check "isint(${2=10}) && $2>0 && ${3=0.1}>=0 && ${4=4}>=0 && isint(${5=0}) && $5>=0 && isint(${6=-1}) && ($6>=0 || $6==-1) && ${7=1}>=1" skip "${8=}"
  e[^-1] "Morph input image files '$1', with $2 inner frames, smoothness $3, precision $4, first frame $5, last frame $6, frame step $7 and output filename '$8'.\n"
  v - files 3,"$1" _N=/{narg(${})-1} arg2var _file,${} _morph_stream[] "${_file{$frame+1}}",${2-7},"$8" v +

#@cli morph_video : video_filename,_nb_inner_frames>0,_smoothness>=0,_precision>=0,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@cli : Generate a temporal morphing from specified input video file, in a streamed way.
#@cli : If a display window is opened, rendered frames are displayed in it during processing.
#@cli : The output filename may have extension '.avi' (saved as a video), or any other usual image file extension (saved as a sequence of images).
#@cli : Default values: 'nb_inner_frames=10', 'smoothness=0.1', 'precision=4', 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
morph_video : check "isint(${2=10}) && $2>0 && ${3=0.1}>=0 && ${4=4}>=0 && isint(${5=0}) && $5>=0 && isint(${6=-1}) && ($6>=0 || $6==-1) && ${7=1}>=1" skip "${8=}"
  e[^-1] "Morph frames of input video file '$1', with $2 fading frames, smoothness $3, precision $4, first frame $5, last frame $6, frame step $7 and output filename '$8'.\n"
  v - _N= _morph_stream[] "\"$1\",$frame",${2-7},"$8" v +

_morph_stream : skip "${8=}"
  is_ext "$8",avi is_outavi=${}
  frame=$5 i=0 go_on=1

  l $1 onfail go_on=0 endl # Load first image.
  if {!$go_on} return fi
  w={w} h={h} s={s}
  if {*} w. ${fitscreen\ $w,$h},0,"[G'MIC]" fi
  pframe=$frame frame+=$7
  do
    l[] $1 onfail go_on=0 endl
    if {!$go_on} break fi
    to_colormode. $s r. $w,$h
    cutvals={[min(im#0,im#1),max(iM#0,iM#1)]}
    v + e[] "\r  - Frame ""#"$pframe" -> ""#"$frame"            " v -
    +equalize[0,1] n[-2,-1] 0,255
    +displacement[3] [2],$3,$4 +displacement[2] [3],$3,$4 rm[-4,-3]
    repeat {$2+2} if {$<}
      title="Frame ""#"$pframe" -> ""#"$frame" ("$>/$2")        "
      v + e[] "\r  - "$title v -
      t={$>/($2+1)} omt={1-$t}
      +*[2] $t +warp[0] .,1,1,1 rm.. *. $omt
      +*[3] {1-$t} +warp[1] .,1,1,1 rm.. *. $t
      +[-2,-1] c. $cutvals
      if {narg("$8")}
        if $is_outavi z. 0,{w-(w%8)-1} o. "$8",25,mp4v,1 else filename "$8",$i i+=1 o. ${} fi
      fi
      if {*}
        w. -1,-1,0,$title
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} wait -1 fi # Increase window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} wait -1 fi # Decrease window size.
        if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} wait -1 fi             # Reset window size.
      fi
      rm.
    fi done
    rm[0,-2,-1] pframe=$frame frame+=$7
  while {$go_on" && "($6==-1" || "$frame<=$6)}

  # Output last frame.
  if {narg("$8")}
    if $is_outavi z. 0,{w-(w%8)-1} o[] "$8",25,mp4v,0 else filename "$8",$i o. ${} fi
  fi
  rm

#@cli register_nonrigid : [destination],_smoothness>=0,_precision>0,_nb_scale>=0
#@cli : Register selected source images with specified destination image, using non-rigid warp.
#@cli : Default values: 'smoothness=0.2', 'precision=6' and 'nb_scale=0(auto)'.
#@cli : $ image.jpg +rotate 20,1,1,50%,50% +register_nonrigid[0] [1]
register_nonrigid : check ${is_image_arg\ $1}" && ${2=0.2}>=0 && ${3=5}>0 && ${4=0}>=0"
  e[^-1] "Register source image$? with destination image $1, using non-rigid warp with smoothness $1, precision $2 and $3 scale(s)."
  v - pass$1 0 equalize. n. 0,255
  repeat {$!-1}
    +equalize[$>] n. 0,255 +displacement.. .,$2,$3,$4 rm..
    warp[$>] .,1,1,1 rm.
  done rm. v +

#@cli register_rigid : [destination],_smoothness>=0,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }
#@cli : Register selected source images with specified destination image, using rigid warp (shift).
#@cli : Default values: 'smoothness=1' and 'boundary_conditions=0'.
#@cli : $ image.jpg +shift 30,20 +register_rigid[0] [1]
register_rigid : check ${is_image_arg\ $1}" && ${2=1}>=0 && isint(${3=0}) && $3>=0 && $3<=3"
  e[^-1] "Register source image$? with destination image $1, using rigid warp with smoothness $2."
  v - pass$1 0 equalize. b. $2 n. 0,255
  repeat {$!-1}
    +equalize[$>] b. $2 n. 0,255
    +phase_correlation. .. rm..
    shift[$>] {^},0,$3 rm.
  done rm. v +

#@cli transition : [transition_shape],nb_added_frames>=0,100>=shading>=0,_single_frame_only={ -1=disabled | >=0 }
#@cli : Generate a transition sequence between selected images.
#@cli : Default values: 'shading=0' and 'single_frame_only=-1'.
#@cli : $ image.jpg +mirror c 100%,100% plasma[-1] 1,1,6 transition[0,1] [2],5
transition : check ${is_image_arg\ $1}" && $2>=0 && ${3=0}>=0 && $3<=100" skip ${4=-1}
  v - frame={round($4)} s0=" and shading $3" s1=", shading $3 and single-frame-only "$frame v +
  e[^-1] "Create transition sequence between image$? with $2 added frames, transition shape $1"${s{$4>0}}"."
  if {$!<2" || "!$2} return fi
  v - to_colormode 0 r ${-max_whd},100%,0,0,0.5,0.5
  pass$1 0 norm. r. [0],[0],[0],1,3 n. 0,1 mv. 0
  repeat {$!-2} l[0,{$<+1},{$<+2}]
    nm0={1,n}
    if $3 repeat $2 if {$4<0" || "$>==$frame}
      val0={($>+0.5)/$2-$3%}
      val1={($>+0.5)/$2+$3%}
      +f[0] '(i-$val0)/($val1-$val0)' c. 0,1
      +j[2] [1],0,0,0,0,1,. rm..
      nm. $nm0\ ""#{1+$>}
    fi done else repeat $2 if {$4<0" || "$>==$frame}
      +>=[0] {($>+0.5)/$2}
      +j[2] [1],0,0,0,0,1,. rm..
      nm. $nm0\ ""#{1+$>}
    fi done fi
    mv[2] $!
  endl done rm[0] v +

#@cli transition3d : _nb_frames>=2,_nb_xtiles>0,_nb_ytiles>0,_axis_x,_axis_y,_axis_z,_is_antialias={ 0 | 1 }
#@cli : Create 3D transition sequence between selected consecutive images.
#@cli : 'axis_x', 'axis_y' and 'axis_z' can be set as mathematical expressions, depending on 'x' and 'y'.
#@cli : Default values: 'nb_frames=10', 'nb_xtiles=nb_ytiles=3', 'axis_x=1', 'axis_y=1', 'axis_z=0' and 'is_antialias=1'.
#@cli : $ image.jpg +blur 5 transition3d 9 display_rgba
transition3d : check "isint(${1=10}) && $1>=2 && isint(${2=3}) && $2>0 && isint(${3=$2}) && $3>0" skip ${4=1},${5=1},${6=0},${7=1}
  e[^-1] "Create 3D transition sequence between image$?, with $1 frames, $2x$3 tiles and rotation axis ($4,$5,$6).\n"
  if {$!<2} return fi
  v -
  slices 0 to_rgb r ${-max_whds},3
  off=0 repeat {$!-1} l[{$>+$off},{$>+$off+1}]
    v + e[] "\r > Generate transition from image "$>" to image "{$>+1}".    " v -

    # Create 3D rotation vectors.
    $2,$3,1,1,'$4'
    $2,$3,1,1,'$5'
    $2,$3,1,1,'$6'
    a[-3--1] z
    permute. zxyc r. 3,{$2*$3},1,1,-1
    repeat {h} rot$>={@0-2} shift. 0,-1,0,0 done
    rm.

    # Create 3D tiles.
    +split_tiles[-2,-1] $2,$3 mv[0,1] $!
    N={$2*$3} i=0 y=0
    repeat $3
      x=0
      repeat $2
        lw={$i,w} lh={$i,h}
        imageplane3d[$i] imageplane3d[$N] r3d[$N] ${rot$i},180 c3d[$i,$N] +3d[$i,$N]
        x$i=$x y$i=$y x+=$lw i+=1
      done
      y+=$lh
    done

    # Generate intermediate animation frames.
    repeat {$1-2}
      repeat $N r3d[$>] ${rot$>},{180/(1-$1)} ++3d[$>] ${x$>},${y$>},0 done
      +3d[-$N--1] c3d.

      if $7 # Antialiased rendering.
        i... {-2,2*[w,h]},1,3,-1
        *3d. 2 j3d... .,50%,50%,0,1,2,0,0 rm.
        to_rgba.. replace_color.. 0,0,-1,-1,-1,255,0,0,0,0
        downsize_aliased.. 50
      else # Standard rendering.
        i... {-2,w},{-2,h},1,3,-1 j3d... .,50%,50%,0,1,2,0,0 rm.
        to_rgba.. replace_color.. 0,0,-1,-1,-1,255,0,0,0,0
      fi

    done
    rm[0-{$N-1}]
    nm[1--2] {0,n}
    off+={$1-2}
  endl done
  v +

#@cli video2files : input_filename,_output_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1
#@cli : Split specified input video file into image files, one for each frame.
#@cli : First and last frames as well as step between frames can be specified.
#@cli : Default values: 'output_filename=frame.png', 'first_frame=0', 'last_frame=-1' and 'frame_step=1'.
video2files : check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && isint(${5=1}) && $5>=1" skip ${2="frame.png"}
  e[^-1] "Split input video file '$1' into image frames '$2', with first frame $3, last frame $4, and frame step $5.\n"
  v -
  frame=$3 stopflag=0
  do l[]
    i "$1",$frame
    if $!
      o ${"filename \"$2\","$frame} rm
      v + e[] "\r  > Frame ""#"$frame v -
      frame+=$5
    else stopflag=1
    fi
  onfail stopflag=1
  endl while {!$stopflag" && "($frame<=$4" || "$4==-1)}
  v +


#------------------------------
#
#@cli :: Convenience Functions
#
#------------------------------

#@cli alert : _title,_message,_label_button1,_label_button2,...
#@cli : Display an alert box and wait for user's choice.
#@cli : If a single image is in the selection, it is used as an icon for the alert box.
#@cli : Default values: 'title=[G'MIC Alert]' and 'message=This is an alert box.'.
alert : skip "${1=[G"{`39`}"MIC Alert]},${2=This is an alert box.},${3=OK}"
  if {$!==1}
    e[0--3] "Display alert box, with image$?, title '$1', message '$2' and buttons '${3--1}'."
  else
    e[0--3] "Display alert box, with title '$1', message '$2' and buttons '${3--1}'."
  fi
  v -

  if {$!==1} logo= else logo=[] fi
  +l$logo

    # Manage alert icon.
    if {$!==1} to_rgb
    else # No logo provided, generate default logo (alert).
      64,64 polygon 3,50%,10%,10%,90%,90%,90%,1,1 b 3 >= 50%
      +erode. 5 -. .. ==. 0
      polygon. 4,47%,43%,53%,43%,53%,66%,47%,66%,1,0 circle. 50%,76%,2,1,0
      +*[0] 255 . 100%,100% a[-3--1] c -. '3*(y-h/2)'
      *. .. rm.. *[0] 255 rv a c
      drop_shadow 3,3,1 i[0] 100%,100%,1,3,200 blend alpha
    fi
    channels -1,2

    # Create buttons graphics.
    $=arg
    repeat {$#-2} label=${arg{$>+3}} 0 t. $label,0,0,16,1,-200 done
    r[^0] {min(128,max(64,${max_w[^0]}+12))},{min(48,max(24,${max_h[^0]}+12))},1,1,0,0,0.5,0.5
    +[^0] 200 to_rgb[^0]
    mv[0] $!
    [0],[0],1,1,'(y-h/2)' *. -2 c. -30,30 +[0--3] . rm. c[^-1] 0,255  # Add shading to buttons.

    repeat {$!-1} l[$<]

      # Create selected buttons.
      +rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
      rectangle. 1,1,{w-2},{h-2},1,0xFFFFFFFF,0
      line. 2,{h-3},{w-3},{h-3},1,150 line. {w-3},{h-3},{w-3},2,1,150
      line. 1,1,{w-3},1,1,255 line. 1,1,1,{h-3},1,255
      rectangle. 4,4,{w-5},{h-5},1,0xAAAAAAAA,0

      # Create clicked buttons.
      +shift.. 1,1,0,0,2
      rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
      rectangle. 1,1,{w-2},{h-2},1,0xFFFFFFFF,150
      rectangle. 4,4,{w-5},{h-5},1,0xAAAAAAAA,0

      # Create default aspect.
      rectangle... 0,0,100%,100%,1,0xFFFFFFFF,0
      line... 1,{h-2},{w-2},{h-2},1,150 line... {w-2},{h-2},{w-2},1,1,150
      line... 0,0,{w-2},0,1,255 line... 0,0,0,{h-2},1,255

      # Create coordinates image.
      i[0] 100%,100% =[0] 1,0,0

    a c endl done

    # Render alert box graphics.
    +l
      channels 0,3 sh 1,100% -[50%--1] 200 rm[50%--1] frame 8,8,0
      if {$!<6} a[^-1] x else append_tiles[^-1] , fi
      0 t. "$2",0,0,16,1,0,-200,-200,-200 r. {w+16},{h+8},1,4,0
      a[-2,-1] x,0.5 rv a y,0.5
      sh 1,100% +. 200 rm.
      rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
      line 0,0,{w-2},0,1,0,255,255,255 line 0,0,0,{h-2},1,0,255,255,255
    endl
    rm..
    +channels. 0

    # Retrieve (x,y) coordinates of the buttons and fill active area.
    (0,{w-1}) (0;{-2,h-1}) r[-2,-1] ...,3 a[-2,-1] c round. rv[-2,-1] *[-2,-1]
    discard. 0 r. {h/2},2,1,1,-1
    channels.. 1,3 rv[-2,-1]
    100%,100% repeat {-3,w} x0={-3,i($>,0)} y0={-3,i($>,1)} rectangle. $x0,$y0,{$x0+{0,w}-1},{$y0+{0,h}-1},1,{1+$>} done
    a[-2,-1] c

    # Enter event loop.
    repeat 9 if {!{*$>}} disp=$> break fi done   # Find available display window.
    if {!narg($disp)} v + error[0--4] "Command '$0': Cannot open display window for alert box." fi

    selected={if($#==3,0,-1)} clicked=-1
    do

      # Render current view.
      +channels. 0,2
      if {$clicked>=0}
        x0={-3,i($clicked,0)} y0={-3,i($clicked,1)}
        sh[$clicked] 7,9
        j.. .,$x0,$y0 rm.
      elif {$selected>=0}
        x0={-3,i($selected,0)} y0={-3,i($selected,1)}
        sh[$selected] 4,6
        j.. .,$x0,$y0 rm.
      fi
      w$disp. 100%,100%,0,"$1" rm. wait

      # Handle user interactions.
      xm={*$disp,x} ym={*$disp,y} bm={{*$disp,b}&1} val={i($xm,$ym,0,3)}
      if {$bm" && "$val} clicked={$val-1}
      elif {$bm" && "!$val" && "$clicked>=0} selected=$clicked clicked=-1
      elif {!$bm" && "$clicked>=0" && "$clicked==$val-1} break
      fi
      if {*$disp,ARROWRIGHT} selected={($selected+1)%{-2,w}} wait -1
      elif {*$disp,ARROWLEFT} selected={($selected-1)%{-2,w}+($selected==-1)} wait -1
      elif {$selected>=0" && "{*$disp,ENTER}} clicked=$selected break
      fi

    while {{*$disp}" && "!{*$disp,ESC}}

    # Return result (index of clicked button or '-1').
    w$disp 0 rm u $clicked
  endl
  v +

#@cli arg : n>=1,_arg1,...,_argN
#@cli : Return the n-th argument of the specified argument list.
arg : check "isint($1) && ($1)>0"
  v - $=arg u ${arg{1+($1)}} v +

#@cli arg2var : variable_name,argument_1,...,argument_N
#@cli : For each i in [1...N], set 'variable_name$i=argument_i'.
#@cli : The variable name should be global to make this command useful (i.e. starts by an underscore).
arg2var :
  v - $=arg u {$#-1} repeat ${} $1{1+$>}=${arg{2+$>}} done v +

#@cli autocrop_coords : value1,value2,... | auto
#@cli : Return coordinates (x0,y0,z0,x1,y1,z1) of the autocrop that could be performed on the latest of the selected images.
#@cli : Default value: 'auto'
autocrop_coords : skip ${1=auto}
  v -
  is_auto={['"$1"']=='auto'}
  w={w} h={h} d={d}
  value={i(w-1,h-1,d-1)} +=. {1+$value},100%,100%,100% _autocrop$is_auto. ${1--1} =. $value,100%,100%,100%
  x0={$w-w} y0={$h-h} z0={$d-d} rm.
  +_autocrop$is_auto. ${1--1}
  x1={$x0+w-1} y1={$y0+h-1} z1={$z0+d-1} rm.
  u $x0,$y0,$z0,$x1,$y1,$z1
  v +

_autocrop0 : autocrop $*
_autocrop1 : skip $* autocrop

#@cli base642img : "base64_string"
#@cli : Decode given base64-encoded string as a newly inserted image at the end of the list.
#@cli : The argument string must have been generated using command 'img2base64'.
base642img :
  v - base642uchar "$1" unserialize. v +

#@cli base642uchar : "base64_string"
#@cli : Decode given base64-encoded string as a newly inserted 1-column image at the end of the list.
#@cli : The argument string must have been generated using command 'uchar2base64'.
base642uchar :
  v - 0
  eval "
    hash = vector256();
    for (k = _'A', k<=_'Z', ++k, hash[k] = k - _'A');
    for (k = _'a', k<=_'z', ++k, hash[k] = k - _'a' + 26);
    for (k = _'0', k<=_'9', ++k, hash[k] = k - _'0' + 52);
    hash[_'+'] = hash[_'-'] = 62;
    hash[_'/'] = hash[_'_'] = 63;
    s = ['$1'];
    const ss = size(s);
    ss>=2?(
      resize(#-1,1,ss*3/4 - (s[ss-1]==_'=') - (s[ss-2]==_'='),1,1);
      od = 0;
      for (os = 0, os<size(s),
        c1 = hash[s[os++]];
        c2 = hash[s[os++]];
        c3 = hash[s[os++]];
        c4 = hash[s[os++]];
        i[#-1,od++] = (c1<<2) | (c2>>4);
        i[#-1,od++] = ((c2&15)<<4) | (c3>>2);
        i[#-1,od++] = ((c3&3)<<6) | c4;
      )
    )"
  nm. "[unnamed]"
  v +

#@cli basename : file_path,_variable_name_for_folder
#@cli : Return the basename of a file path, and opt. its folder location.
#@cli : When specified 'variable_name_for_folder' must starts by an underscore
#@cli : (global variable accessible from calling function).
basename : skip ${2=unused}
  v -
  l[] ({"'$1'"}) replace 92,47 s +,47
  if {i==47} a y $2={t} u ""
  elif {$!==1} u {t} $2=""
  else a[^-1] y u {t} $2={-2,t}
  fi
  rm endl
  v +

#@cli bin : binary_int1,...
#@cli : Print specified binary integers into their octal, decimal, hexadecimal and string representations.
bin :
  v - dec=${bin2dec\ ${^0}} v +
  e[^-1] "Convert binary integer"${arg\ 1+($#>1),"",s}" '${^0}' to octal '"${dec2oct\ $dec}"',
          decimal '"$dec"', hexadecimal '"${dec2hex\ $dec}"' and string '"${dec2str\ $dec}"'."

#@cli bin2dec : binary_int1,...
#@cli : Convert specified binary integers into their decimal representations.
bin2dec :
  v - $=arg res,sep= repeat $# res=$res$sep${_$0\ ${arg{$>+1}}} sep=, done u $res v +

_bin2dec :
  u {"str = vtos(abs($1));
      for (k = val = 0, str[k], ++k,
        c = str[k];
        (val<<=1)+=(c==_'0'?0:c==_'1'?1:nan);
        isnan(val)?break()
      ); sign($1)*val"}

# compress_gmic
# Compress .gmic custom command files for compressing update files a little bit,
# by removing empty lines, and useless comments.
compress_gmic :
  v -
  s -,10 N=$!
  ap _compress_gmic
  s -,10 i[1--2] (10) a y
  v +

_compress_gmic :
  if {i==_'#'}
    if {h<5" || "(!same([{^}],'#@gui',5)" && "!same([{^}],'#@cli',5)" && "!same([{^}],'#@web',5))} rm. (10) fi
  else
    l. s +,32,35 if {$!>2} k[0] fi a y endl
    autocrop. 32 if {!w} rm. (10) fi
  fi

# compress_gmic_cli
# Compress .gmic custom command files for the 'gmic' command line tool,
# by removing empty lines, and useless comments (non starting with '#@cli').
compress_gmic_cli :
  v -
  s -,10 N=$!
  ap _compress_gmic_cli
  s -,10 i[1--2] (10) a y
  v +

_compress_gmic_cli :
  if {i==_'#'}
    if {!same([{^}],'#@cli',5)" || (i[5]!=_' ' && i[5]!=_':')"} rm. (10) fi
  else
    l. s +,32,35 if {$!>2} k[0] fi a y endl
    autocrop. 32 if {!w} rm. (10) fi
  fi

# compress_gmic_gui
# Compress .gmic custom command files for the plug-in,
# by removing empty lines, and useless comments (non starting with '#@gui').
compress_gmic_gui :
  v -
  s -,10 N=$!
  ap _compress_gmic_gui
  s -,10 i[1--2] (10) a y
  v +

_compress_gmic_gui :
  if {i==_'#'}
    if {!same([{^}],'#@gui',5)} rm. (10) fi
  else
    l. s +,32,35 if {$!>2} k[0] fi a y endl
    autocrop. 32 if {!w} rm. (10) fi
  fi

#@cli dec : decimal_int1,...
#@cli : Print specified decimal integers into their binary, octal, hexadecimal and string representations.
dec :
  e[^-1] "Convert decimal integer"${arg\ 1+($#>1),"",s}" '${^0}' to binary '"${dec2bin\ ${^0}}"',"\
          " octal '"${dec2oct\ ${^0}}"', hexadecimal '"${dec2hex\ ${^0}}"' and string '"${dec2str\ ${^0}}"'."

#@cli dec2str : decimal_int1,...
#@cli : Convert specifial decimal integers into its string representation.
dec2str :
  v - u {`[${^0}]`} v +

#@cli dec2bin : decimal_int1,...
#@cli : Convert specified decimal integers into their binary representations.
dec2bin :
  v - $=arg res,sep= repeat $# res=$res$sep${_$0\ ${arg{$>+1}}} sep=, done u $res v +

_dec2bin :
  u {`"const sgn = sign($1);
       const N = (isinf($1) || isnan($1)?1:1 + floor(log2(max(1,abs($1))))) + (sgn>=0?0:1);
       res = vectorN();
       sgn>=0?0:(res[0] = _'-');
       for (val = abs($1); k = size(res) - 1, k>=(sgn<0?1:0), --k, res[k] = _'0' + (val&1); val>>=1); res"`}

#@cli dec2hex : decimal_int1,...
#@cli : Convert specified decimal integers into their hexadecimal representations.
dec2hex :
  v - $=arg res,sep= repeat $# res=$res$sep${_$0\ ${arg{$>+1}}} sep=, done u $res v +

_dec2hex :
  u {`"begin(tab = [ _'0',_'1',_'2',_'3',_'4',_'5',_'6',_'7',_'8',_'9',_'a',_'b',_'c',_'d',_'e',_'f' ]);
       const sgn = sign($1);
       const N = (isinf($1) || isnan($1)?1:1 + floor(log2(max(1,abs($1)))/4)) + (sgn>=0?0:1);
       res = vectorN();
       sgn>=0?0:(res[0] = _'-');
       for (val = abs($1); k = size(res) - 1, k>=(sgn<0?1:0), --k, res[k] = tab[val&15]; val>>=4); res"`}

#@cli dec2oct : decimal_int1,...
#@cli : Convert specified decimal integers into their octal representations.
dec2oct :
  v - $=arg res,sep= repeat $# res=$res$sep${_$0\ ${arg{$>+1}}} sep=, done u $res v +

_dec2oct :
  u {`"const sgn = sign($1);
       const N = (isinf($1) || isnan($1)?1:1 + floor(log2(max(1,abs($1)))/3)) + (sgn>=0?0:1);
       res = vectorN();
       sgn>=0?0:(res[0] = _'-');
       for (val = abs($1); k = size(res) - 1, k>=(sgn<0?1:0), --k, res[k] = _'0' + (val&7); val>>=3); res"`}

#@cli fact : value
#@cli : Return the factorial of the specified value.
fact : check isint($1)
  v - res=1 repeat $1 res*={($>+1)} done u $res v +

#@cli fibonacci : N>=0
#@cli : Return the Nth number of the Fibonacci sequence.
fibonacci : check "$1>=0"
  u {N=$1;if(N<2,N,for(n=N;F0=0;F1=1,n=n-1,F2=F0+F1;F0=F1;F1=F2))}

#@cli file_mv : filename_src,filename_dest
#@cli : Rename or move a file from a location $1 to another location $2.
file_mv :
  e[^-1] "Move file '$1' to location '$2'."
  v - if ${-is_windows} x "move "$1" "$2 else x "mv "$1" "$2 fi v +

#@cli file_rand
#@cli : Return a random filename for storing temporary data.
file_rand :
  v -
  do filename=${-path_tmp}gmic$_pid{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}
  while $filename
  u $filename
  v +

#@cli file_rm : filename
#@cli : Delete a file.
file_rm :
  e[^-1] "Remove file '$1'."
  v -
  if ${-is_windows}
    1 nm. "$1" dir={/{f}} base={/{b}} ext={/{x}} rm. com=""
    if {narg($dir)} com="cd \""$dir"\\\" && " fi
    if {narg($ext)} com=${com}"del \""$base.$ext"\"" else com=${com}"del \""$base"\"" fi
    x $com
  else
    x "rm -f \"$1\""
  fi
  v +

#@cli filename : filename,_number1,_number2,...,_numberN
#@cli : Return a filename numbered with specified indices.
filename : skip "${1=default}"
  v -
  if {$#==1} u "$1"
  else
  (${2--1}) nm. "$1" u {f}{b}
  repeat {w}
    u ${}_{int(i/100000)%10}{int(i/10000)%10}{int(i/1000)%10}{int(i/100)%10}{int(i/10)%10}{i%10}
    shift. -1
  done
  if {narg({'{x}'})} u ${}.{x} fi
  rm.
  fi
  v +

#@cli files : _mode,path : (+)
#@cli : Return the list of files and/or subfolders from specified path.
#@cli : 'path' can be eventually a matching pattern.
#@cli : 'mode' can be { 0=files only | 1=folders only | 2=files + folders }.
#@cli : Add '3' to 'mode' to return full paths instead of filenames only.
#@cli : Default value: 'mode=5'.

#@cli fitratio_wh : min_width,min_height,ratio_wh
#@cli : Return a 2D size 'width,height' which is bigger than 'min_width,min_height' and has the specified w/h ratio.
fitratio_wh :
  v - if {$3*$2>$1} u {int($3*$2)},$2 else u $1,{int($1/$3)} fi v +

#@cli fitscreen : width,height,_depth,_minimal_size[%],_maximal_size[%]
#@cli : Return the 'ideal' size WxH for a window intended to display an image of specified size on screen.
#@cli : Default values: 'depth=1', 'minimal_size=128' and 'maximal_size=85%'.
fitscreen : check "$1>=1 && $2>=1 && ${3=1}>=1 && ${4=128}>0 && ${5=85%}>0"
  v -
  eval "
    is_percent(str) = (unref(_is_pct); _is_pct=['#str']; _is_pct[size(_is_pct) - 1]==_'%');
    const u = "{*,u}";
    const v = "{*,v}";
    ms = round(is_percent($4)?[ u,v ]*$4:[ $4,$4 ]);
    Ms = round(is_percent($5)?[ u,v ]*$5:[ $5,$5 ]);
    s = [ $1,$2 ];
    $3>1?(s+=$3);
    s[0]<ms[0]?(s = [ ms[0],s[1]*ms[0]/s[0] ]);
    s[1]<ms[1]?(s = [ s[0]*ms[1]/s[1],ms[1] ]);
    s[0]>Ms[0]?(s = [ Ms[0],s[1]*Ms[0]/s[0] ]);
    s[1]>Ms[1]?(s = [ s[0]*Ms[1]/s[1],Ms[1] ]);
    s[0] = max(1,s[0],ms[0]);
    s[1] = max(1,s[1],ms[1]);
    round(s)"
  v +

#@cli fontchart
#@cli : Insert G'MIC font chart at the end of the image list.
#@cli : $ fontchart
fontchart :
  e[^-1] "Generate G'MIC font chart."
  v - l[]
    repeat 256
      if {$>==92} char=\\ else char={`max(1,(c=$>;c>=23&&c<=28?32:c))`} fi
      0 t. {``$char},0,0,50,1,255
    done
    a z,0.5
    s z
    repeat $!
      t[$>] $>,1,-1,13,1,200
      0 t. \\${dec2oct\ $>},1,-1,13,1,1
      100%,100%,1,1,200 j[$>] .,{$>,[w,h]-[w#-1,h#-1]},0,0,1,.. rm[-2,-1]
    done
    frame 1,1,128 append_tiles ,
  endl v +

# font2cimgh
# Encode a font image as a C-style string for CImg.h.
font2cimgh :
  e[^-1] "Encode font image$? as a C-style string for CImg.h."
  v - repeat $! l[$>] bnm={0,b}
    v + e[] "  > Encode font '"$bnm"'." v -
    W,H={[w/256,h]}
    if {!isint($W)} error[0--4] "Font image '"$bnm"' has wrong dimensions ("{[w,h,d,s]}")." fi
    +f "i==im || i==iM" is_binary={im==1} rm.

    # Find best parameters for RLE compression.
    Mm=0 MM=100
    do
      M={floor(($Mm+$MM)/2)}
      +compress_rle $is_binary,$M rows. 6,100% +. {32-im} iM={iM}
      if {iM<126} Mm=$M rm. elif {iM>126} MM=$M rm. fi
    while {$iM!=126}
    k. nb_chunks={1+int(h/65536)}

    v + e[] "\r  > Encode font '"$bnm"' -> W = "$W", H = "$H", M = "$M", is_binary = "$is_binary", nb_chunks = "$nb_chunks"." v -

    # Generate C-style string for storing font data.
    replace_str "\\","\\\\"
    replace_str "\"","\\\""
    s y,-111
    repeat $!
      if {$>,i[h-1]==_'\\'&&i[h-2]!=_'\\'} rows[$>] 0,{$>,h-2} rows[{$>+1}] -1,100% =[{$>+1}] {'\\'} fi
      l[$>]
        i[0] ({'"      \""'}) ({'\"'})
        if {!$<} ({'" };"'}) fi
        ({'\n'})
        y a y
      endl
    done
    repeat {$nb_chunks-1} ind={int($!*($>+1)/$nb_chunks)} l[$ind] = {','},0,100% ({'\n'}) y a y endl done
    i[0] ({'"    static const char *const data_font"${W}x${H}"[] = {"\n'})
    y a y o raw:$bnm.h,uchar

  endl done v +

#@cli fps
#@cli : Return the number of time this function is called per second, or -1 if this info is not yet available.
#@cli : Useful to display the framerate when displaying animations.
fps :
  v -
  if {narg($_fps_fps)}
    dt={$|-$_fps_time}
    if {$dt>1} _fps_fps={round($_fps_nbframes/$dt)} _fps_time=$| _fps_nbframes=0 fi
    u $_fps_fps
    _fps_nbframes+=1
  else _fps_nbframes=0 _fps_time=$| _fps_fps=-1 u -1
  fi
  v +

#@cli gcd : a,b
#@cli : Return the GCD (greatest common divisor) between a and b.
gcd : check "isint($1) && isint($2) && $1*$2!=0"
  v - _gcd {max(abs($1),abs($2))},{min(abs($1),abs($2))} v +

_gcd :
  r={$1%$2} if $r u ${_gcd\ $2,$r} else u $2 fi

#@cli hex : hexadecimal_int1,...
#@cli : Print specified hexadecimal integers into their binary, octal, decimal and string representations.
hex :
  v - dec=${hex2dec\ ${^0}} v +
  e[^-1] "Convert hexadecimal integer"${arg\ 1+($#>1),s,""}" '${^0}' to binary '"${dec2bin\ $dec}"',
           octal '"${dec2oct\ $dec}"', decimal '"$dec"' and string '"${dec2str\ $dec}"'."

#@cli hex2dec : hexadecimal_int1,...
#@cli : Convert specified hexadecimal integers into their decimal representations.
hex2dec :
  v - $=arg res,sep= repeat $# res=$res$sep${_$0\ ${arg{$>+1}}} sep=, done u $res v +

_hex2dec :
  u {"str = ['$1']; str[0]==_'-'?-stov([['0x'],str[1,size(str)-1]]):stov([['0x'],str])"}

#@cli hex2img : "hexadecimal_string"
#@cli : Insert new image 1xN at the end of the list with values specified by the given hexadecimal-encoded string.
hex2img :
  v - ({'"$1"'}) 1,{w/2}
  f. "*
    from_char(x) = x>=48 && x<=57?x - 48:x-87;
    off = 2*y;
    from_char(i[#-2,off])*16 + from_char(i[#-2,off+1])"
  rm.. v +

#@cli hex2str : hexadecimal_string
#@cli : Convert specified hexadecimal string into a string.
hex2str : skip ${1=""}
  v -
  if {!narg("$1")} u "" v + return fi
  ({'$*'}) if {w<2} rm. u "" v + return fi
  f. 'v=i-if(i>=97,87,48);if(x%2,v,v*16)' r. 2,{int(w/2)},1,1,-1 cumulate. x z. 1,1
  u {t} rm. v +

#@cli img2hex
#@cli : Return representation of last image as an hexadecimal-encoded string.
#@cli : Input image must have values that are integers in [0,255].
img2hex :
  v - whds={w},{h},{d},{s} y. 2,{h}
  f.. "*
    to_char(x) = x>=0 && x<=9?48 + x:87 + x;
    i(#-1,0,y) = to_char(int(i/16));
    i(#-1,1,y) = to_char(i%16);
    i"
  u {t} rm. r. $whds,-1 v +

#@cli img2str
#@cli : Return the content of the latest of the selected images as a special G'MIC input string.
img2str :
  v - i[-2] 256
  eval. ">begin(off = 0);
    sep = x==w - 1?(y==h - 1?(z==d - 1?(c==s - 1?0:_'^'):_'/'):_';'):_',';
    it = vtos(i);
    off + size(it) + 1>=w(#-2)?resize(#-2,round(1.5*w(#-2)),1,1,1,0);
    for (k = 0, k<size(it) && it[k], ++k, i[#-2,off++] = it[k]);
    i[#-2,off++] = sep"
  u {-2,t} rm.. v +

#@cli img2text : _line_separator
#@cli : Return text contained in a multi-line image.
#@cli : Default value: 'line_separator= '.
img2text : skip "${1= }"
  v - +l s y s -,0 y x if {$!>1} i[1--2] ({'"$1"'}) fi a x u {0,t} rm endl v +

#@cli img82hex
#@cli : Convert selected 8bits-valued vectors into their hexadecimal representations (ascii-encoded).
img82hex :
  e[^-1] "Convert 8bits-valued vector$? into hexadecimal representations (ascii-encoded)."
  v - % 256 y
  repeat $!
    +f[$>] 'v=int(i)&15;v+if(v<10,48,87)' # Lower digit
    f[$>] 'v=int(i)>>4;v+if(v<10,48,87)'  # Higher digit
    a[$>,-1] x
  done v +

#@cli hex2img8
#@cli : Convert selected hexadecimal representations (ascii-encoded) into 8bits-valued vectors.
hex2img8 :
  e[^-1] "Convert hexadecimal representation$? (ascii-encoded) into 8bits-valued vectors."
  v - repeat $!
    s. x,2 f[-2,-1] 'if(i>=97,i-87,i-48)' *.. 16 +[-2,-1]
  mv. 0 done v +

#@cli is_3d
#@cli : Return 1 if all of the selected images are 3D objects, 0 otherwise.
is_3d :
  v - u 1 l check3d 1 onfail u 0 endl v +

# Faster version.
_is_3d :
  v - u {"h>6 && int(i[0])==67 && int(i[1])==73 && int(i[2])==109 && int(i[3])==103 && int(i[4])==51 && int(i[5])==100"} v +

#@cli is_ext : filename,_extension
#@cli : Return 1 if specified filename has a given extensioin.
is_ext : skip "${1=}"
  v - 0 nm. "_$1" u {"lowercase(['"{x}"'])==lowercase(['$2'])"} rm. v +

#@cli is_image_arg : string
#@cli : Return 1 if specified string looks like '[ind]'.
is_image_arg : skip "${1=;}"
  v -
  u {"str = ['$1'];
      s1 = size(str) - 1;
      (str[0]==_'[' && str[s1]==_']') || (str[0]=='.' && str[s1]=='.') && min(str)>=45 && max(str)<=122"}
  v +

#@cli is_pattern : string
#@cli : Return 1 if specified string looks like a drawing pattern '0x......'.
is_pattern : skip "${1=;}"
  v - u {"str = ['$1']; size(str)>2 && same(str,'0x',2)"} v +

#@cli is_percent : string
#@cli : Return 1 if specified string ends with a '%', 0 otherwise.
is_percent :
  v - u {"s=['$1'];s[size(s)-1]==_'%'"} v +

#@cli is_videofilename
#@cli : Return 1 if extension of specified filename is typical from video files.
is_videofilename : skip "${1=}"
  v - 0 nm. "_$1" u {"
    ext = lowercase(['"{x}"']);
    ext=='avi' || ext=='mov' || ext=='asf' || ext=='divx' || ext=='flv' || ext=='mpg' ||
    ext=='m1v' || ext=='m2v' || ext=='m4v' || ext=='mjp' || ext=='mp4' || ext=='mkv' ||
    ext=='mpe' || ext=='movie' || ext=='ogm' || ext=='ogg' || ext=='ogv' || ext=='qt' || ext=='rm' ||
    ext=='vob' || ext=='wmv' || ext=='xvid' || ext=='mpeg'"}
  rm. v +

#@cli is_windows
#@cli : Return 1 if current computer OS is Windows, 0 otherwise.
is_windows :
  v - u {narg($OS)==1" && "narg($WINDIR)==1} v +

#@cli math_lib
#@cli : Return string that defines a set of several useful macros for the embedded math evaluator.
math_lib :
  v -
  u "

  dar_size(ind) = i[#ind,whd(#ind)-1];  # Return number of elements in dynamic array #ind.

  dar_insert(ind,elt,pos) = ( # Inserts new element 'elt' into dynamic array #ind, at index [pos] ('pos' must be in [0,dar_size(#ind)]).
    _dar_pos = pos;
    _dar_siz = dar_size(#ind);
    if (_dar_pos<=_dar_siz,
      _dar_siz>=h(#ind) - 1?resize(#ind,1,_dar_siz*2 + 2,1,s#ind,0);
      for (_dar_c = 0, _dar_c<s#ind, ++_dar_c, copy(i(#ind,_dar_pos + 1,0,0,_dar_c),i(#ind,_dar_pos,0,0,_dar_c),_dar_siz - _dar_pos));
      unref(_dar_elt); _dar_elt = elt;
      copy(i[#ind,_dar_pos],_dar_elt,max(1,size(_dar_elt)),h(#ind),1);
      (dar_size(ind#)) = ++_dar_siz;
    );
  );

  dar_insert(ind,elt) = ( # Inserts new element 'elt' at the end of dynamic array #ind.
    _dar_siz = dar_size(#ind);
    _dar_siz>=h(#ind) - 1?resize(#ind,1,_dar_siz*2 + 2,1,s#ind,0);
    unref(_dar_elt); _dar_elt = elt;
    copy(i[#ind,_dar_siz],_dar_elt,max(1,size(_dar_elt)),h(#ind),1);
    (dar_size(ind#)) = ++_dar_siz;
  );

  dar_remove(ind,pos) = ( # Remove element from dynamic array #ind, at index [pos] ('pos' must be in [0,dar_size(#ind) - 1]).
    _dar_pos = pos;
    _dar_siz = dar_size(#ind);
    if (_dar_pos<_dar_siz,
      _dar_siz = --dar_size(#ind);
      for (_dar_c = 0, _dar_c<s#ind, ++_dar_c, copy(i(#ind,_dar_pos,0,0,_dar_c),i(#ind,_dar_pos + 1,0,0,_dar_c),_dar_siz - _dar_pos));
#      _dar_siz<=h(#ind)/3 - 1?(resize(#ind,1,max(2,h(#ind)/2),1,s#ind,0); (dar_size(#ind)) = _dar_siz);
    )
  );

  dar_remove(ind) = ( # Remove last element from dynamic array #ind.
    _dar_siz = dar_size(#ind);
    _dar_size>0?dar_size(#ind) = --_dar_size;
  );

  dist(A,B) = ( # Distance from point A to point B
    norm(B - A);
  );

  dist(X,A,B) = ( # Distance from point X to segment [A,B]
    AB = B - A;
    P = A + dot(X - A,B - A)/max(1e-8,dot(AB,AB))*AB;
    dot(P - A,P - B)<=0?norm(P - X):min(norm(A - X),norm(B - X));
  );

  dist(A,B,C,D) = ( # Distance from segment [A,B] to segment [C,D]
    min(dist(A,C,D),dist(B,C,D),dist(C,A,B),dist(D,A,B));
  );

  search_dichotomic(fn_x,target,epsilon,xmin,xmax) = ( # Dichotomic search : Find x in [xmin,xmax] s.a f(x) = target, with a epsilon-precision
    # fn_x must be a strictly monotonic function !
    # if 'xmin = xmax = nan', range of 'x' is auto-detected.
    _dicho_fn(x) = _dicho_sgn*(fn_x);
    _dicho_epsilon = epsilon;
    _dicho_m = xmin;
    _dicho_M = xmax;
    _dicho_sgn = 1;

    _dicho_autom = isnan(_dicho_m);
    _dicho_autoM = isnan(_dicho_M);
    if (_dicho_autom, _dicho_m = -1);
    if (_dicho_autoM, _dicho_M = 1);
    _dicho_sgn = _dicho_fn(_dicho_m)>_dicho_fn(_dicho_M)?-1:1;
    _dicho_res = nan;
    _dicho_target = _dicho_sgn*target;
    _dicho_nb_attempts = 30;
    _dicho_autom?do (_dicho_fm = _dicho_fn(_dicho_m); _dicho_fm<_dicho_target?break(); _dicho_m*=2; _(while), --_dicho_nb_attempts);
    _dicho_nb_attempts?(
      _dicho_autoM?do (_dicho_fM = _dicho_fn(_dicho_M); _dicho_fM>_dicho_target?break(); _dicho_M*=2; _(while), --_dicho_nb_attempts);
      _dicho_nb_attempts?(
        _dicho_nb_attempts = 100;
        do (
          _dicho_c = (_dicho_m + _dicho_M)/2;
          _dicho_fc = _dicho_fn(_dicho_c);
          abs(_dicho_fc - _dicho_target)<_dicho_epsilon?(_dicho_res = _dicho_c; break()):
          _dicho_fc<_dicho_target?(_dicho_m = _dicho_c):
          (_dicho_M = _dicho_c);
          _(while), --_dicho_nb_attempts
        );
      );
    );
    _dicho_res;
  );
  search_dichotomic(fn_x,target,epsilon) = search_dichotomic(fn_x,target,1e-3,nan,nan);
  search_dichotomic(fn_x,target) = search_dichotomic(fn_x,target,1e-3);
  search_dichotomic(fn_x) = search_dichotomic(fn_x,0);

  arrow(ind,P0,P1,angle,length,opacity,color) = ( # Draw an arrow from P0 to P1 on image #ind
    unref(_da_color);
    _opacity = opacity;
    _da_color = color;
    _P0 = P0;
    _P1 = P1;
    _P0P1 = _P1;
    _P0P1-=_P0;
    if (length<0, _P0P1*=-length/100, _P0P1*=length/norm2(_P0P1));
    coords = [ _P0,_P1,_P1,_P1 - rot(angle)*_P0P1,_P1,_P1 - rot(-angle)*_P0P1 ];
    for (_k = 0, _k<3, ++_k,
      polygon(#ind,2,coords[4*_k,2],coords[4*_k+2,2],_opacity,_da_color);
   );
  );

  spline(ind,P0,T0,P1,T1,opacity,color) = ( # Draw spline P0-P1 with tangents T0,T1 on image #ind
    unref(_ds_color);
    _P0 = P0;
    _P1 = P1;
    _opacity = opacity;
    _ds_color = resize(color,s#ind)*=abs(_opacity);
    _omopacity = 1 - max(_opacity,0);
    _C = mul([ 2,-2,1,1,-3,3,-2,-1,0,0,1,0,1,0,0,0 ],[ _P0,P1,T0,T1 ],2);
    _dt = _dtmin = 1/max(abs(_P1 - _P0));
    _P0 = inf;
    for (_t = 0, _t<=1, _t+=_dt,
      _P = round(mul([_t^3,_t^2,_t,1],_C,2));
      _dP = abs(mul([3*_t^2,2*_t,1,0],_C,2));
      _dt = min(_dtmin,0.75/max(_dP));
      if (_P0!=_P, I(#ind,_P) = _ds_color + _omopacity*I(#ind,_P));
      _P0 = _P;
    );
    nan;
  );

  triangle(ind,P0,P1,P2,opacity,color0,color1,color2) = ( # Draw a shaded triangle P0-P1-P2 on image #ind
    unref(_dt_color);
    unref(_dt_color0);
    unref(_dt_color1);
    unref(_dt_color2);
    _opacity = opacity;
    _dt_color0 = resize(color0,s#ind);
    _dt_color1 = resize(color1,s#ind);
    _dt_color2 = resize(color2,s#ind);
    _A = round(P0);
    _B = round(P1);
    _C = round(P2);
    _xmin = max(0,min(_A[0],_B[0],_C[0]));
    _xmax = min(w#ind-1,max(_A[0],_B[0],_C[0]));
    _ymin = max(0,min(_A[1],_B[1],_C[1]));
    _ymax = min(h#ind-1,max(_A[1],_B[1],_C[1]));
    _M = transp([_A,1,_B,1,_C,1],3);
    for (_y = _ymin, _y<_ymax, ++_y,
      for (_x = _xmin, _x<_xmax, ++_x,
        _L = round(solve(_M,[_x,_y,1]),1e-5);
        if (min(_L)>=0,
          _dt_color = _L[0]*_dt_color0 + _L[1]*_dt_color1 + _L[2]*_dt_color2;
          copy(i(#ind,_x,_y,0,0),_dt_color,size(_dt_color),whd#ind,1,_opacity);
        );
      );
    );
    nan;
  );

  hsv2rgb(I) = ( # Convert HSV vector to RGB
    _I = I;
    _I[0]%=360;
    _I[1] = cut(_I[1],0,1);
    _I[2] = cut(_I[2],0,1);
    _c = _I[2]*_I[1];
    _x = _c*(1-abs((_I[0]/60)%2-1));
    (arg(1 + int(_I[0]/60),[_c,_x,0],[_x,_c,0],[0,_c,_x],[0,_x,_c],[_x,0,_c],[_c,0,_x])+=_I[2] - _c)*=255;
  );

  is_intriangle(P,A,B,C) = ( # Test if a point is inside a triangle
    _v0 = C - A;
    _v1 = B - A;
    _v2 = P - A;
    _dot00 = dot(_v0,_v0);
    _dot01 = dot(_v0,_v1);
    _dot02 = dot(_v0,_v2);
    _dot11 = dot(_v1,_v1);
    _dot12 = dot(_v1,_v2);
    _invDenom = 1/(_dot00*_dot11 - _dot01*_dot01);
    _u = (_dot11*_dot02 - _dot01*_dot12)*_invDenom;
    _v = (_dot00*_dot12 - _dot01*_dot02)*_invDenom;
    _u>=0 && _v>=0 && _u + _v<1);

  is_inquadrilateral(P,A,B,C,D) = ( # Test if a point is inside a quadrilateral
    is_intriangle(P,A,B,D) || is_intriangle(P,B,C,D);
  );

  is_percent(str) = (unref(_is_pct); _is_pct=['#str']; _is_pct[size(_is_pct) - 1]==_'%');

  length_spline(P0,T0,P1,T1) = ( # Compute the length of a spline P0-P1 with tangents T0,T1
    _P0 = P0;
    _P1 = P1;
    _C = mul([ 2,-2,1,1,-3,3,-2,-1,0,0,1,0,1,0,0,0 ],[ _P0,_P1,T0,T1 ],2);
    _l = norm(_P1 - _P0);
    if (_l,
      _nl = _l + 1;
      _dt = 1/_l;
      while (_nl - _l>=0.01,
        _l = _nl;
        _nl = 0;
        __P0 = _P0;
        for (_t = 0, _t<=1, _t+=_dt,
          __P = mul([_t^3,_t^2,_t,1],_C,2);
          _nl+=norm(__P - __P0);
          __P0 = __P;
        );
        _dt = 1/max(1,_nl);
      );
    );
    _l
  );

  map(V,x,fnx) = ( # Apply a function x->fnx on a vector variable V
    unref(x#,_#x);
    for (_#x = 0, _#x<size(V#), ++_#x, x# = V#[_#x]; V#[_#x] = fnx#);
    V#;
  );

  pexp(x) = ( # Good polynomial approximation of 'exp(-x^2)' for |x|<2
    _pexp_x = abs(x);
    _pexp_x<2?-0.110353*_pexp_x^4 + 0.683221*_pexp_x^3 -1.17282*_pexp_x^2 + 1:0
  );

  proj(X,A,B) = ( # Projection of point X onto line (A,B)
    _AB = B - A;
    P = A + dot(X - A,_AB)/max(1e-8,dot(_AB,_AB))*_AB;
  );
  "
  v +

#@cli mad
#@cli : Return the MAD (Maximum Absolute Deviation) of the last selected image.
#@cli : The MAD is defined as MAD = med_i|x_i-med_j(x_j)|
mad :
  v - if $! +-. {ic} abs. u {1.4826*ic} rm. else u 0 fi v +

#@cli max_w
#@cli : Return the maximal width between selected images.
max_w :
  v - u {arg(1,${_max_whds\ 4})} v +

#@cli max_h
#@cli : Return the maximal height between selected images.
max_h :
  v - u {arg(2,${_max_whds\ 4})} v +

#@cli max_d
#@cli : Return the maximal depth between selected images.
max_d :
  v - u {arg(3,${_max_whds\ 4})} v +

#@cli max_s
#@cli : Return the maximal spectrum between selected images.
max_s :
  v - u {arg(4,${_max_whds\ 4})} v +

#@cli max_wh
#@cli : Return the maximal wxh size of selected images.
max_wh :
  v - _max_whds 2 v +

#@cli max_whd
#@cli : Return the maximal wxhxd size of selected images.
max_whd :
  v - _max_whds 3 v +

#@cli max_whds
#@cli : Return the maximal wxhxdxs size of selected images.
max_whds :
  v - _max_whds 4 v +

_max_whds :
  w=0 h=0 d=0 s=0
  repeat $!
    w={max($w,w)}
    h={max($h,h)}
    d={max($d,d)}
    s={max($s,s)}
  mv. 0 done
  if {$1>=4} u $w,$h,$d,$s
  elif {$1==3} u $w,$h,$d
  elif {$1==2} u $w,$h
  else u $w
  fi

#@cli med
#@cli : Return the median value of the last selected image.
med :
  v - u {ic} v +

#@cli median_color
#@cli : Return the median color value of the last selected image.
median_color :
  v - u "" s="" repeat {s} +channels. $> u ${}$s${med.} s=, rm. done v +

#@cli min_w
#@cli : Return the minimal width between selected images.
min_w :
  v - u {arg(1,${_min_whds\ 4})} v +

#@cli min_h
#@cli : Return the minimal height between selected images.
min_h :
  v - u {arg(2,${_min_whds\ 4})} v +

#@cli min_d
#@cli : Return the minimal depth between selected images.
min_d :
  v - u {arg(3,${_min_whds\ 4})} v +

#@cli min_s
#@cli : Return the minimal s size of selected images.
min_s :
  v - _min_s ${_min_whds\ 4} v +

_min_s :
  u $4

#@cli min_wh
#@cli : Return the minimal wxh size of selected images.
min_wh :
  v - _min_whds 2 v +

#@cli min_whd
#@cli : Return the minimal wxhxd size of selected images.
min_whd :
  v - _min_whds 3 v +

#@cli min_whds
#@cli : Return the minimal wxhxdxs size of selected images.
min_whds :
  v - _min_whds 4 v +

_min_whds :
  w={w} h={h} d={d} s={s}
  repeat $!
    w={min($w,w)}
    h={min($h,h)}
    d={min($d,d)}
    s={min($s,s)}
  mv. 0 done
  if {$1>=4} u $w,$h,$d,$s
  elif {$1==3} u $w,$h,$d
  elif {$1==2} u $w,$h
  else u $w
  fi

#@cli normalize_filename : filename
#@cli : Return a "normalized" version of the specified filename, without spaces and capital letters.
normalize_filename :
  v - ({'"$1"'}) f. 'if(i>=65&&i<=90,i+32,if(i==32,95,i))' u {t} rm. v +

#@cli oct : octal_int1,...
#@cli : Print specified octal integers into their binary, decimal, hexadecimal and string representations.
oct :
  v - dec=${oct2dec\ ${^0}} v +
  e[^-1] "Convert octal integer"${arg\ 1+($#>1),"",s}" '${^0}' to binary '"${dec2bin\ $dec}"', decimal '"$dec"',
           hexadecimal '"${dec2hex\ $dec}"' and string '"${dec2str\ $dec}"'."

#@cli oct2dec : octal_int1,...
#@cli : Convert specified octal integers into their decimal representations.
oct2dec :
  v - $=arg res,sep= repeat $# res=$res$sep${_$0\ ${arg{$>+1}}} sep=, done u $res v +

_oct2dec :
  u {"str = vtos(abs($1));
      for (k = val = 0, str[k], ++k,
        c = str[k];
        (val<<=3)+=(c>=_'0' && c<=_'7'?c - _'0':nan);
        isnan(val)?break()
      ); sign($1)*val"}

#@cli padint : number,_size>0
#@cli : Return a integer with 'size' digits (eventually left-padded with '0').
padint : check "isint($1)" skip ${2=4}
  v - u "" repeat $2 u ${}{int($1/10^$<)%10} done v +

#@cli path_gimp
#@cli : Return a path to store GIMP configuration files for one user (whose value is OS-dependent).
path_gimp :
  v -
  if {!narg({'$_path_gimp'})}
    if {narg({'${GIMP2_DIRECTORY}'})} _path_gimp=${GIMP2_DIRECTORY}
    elif {narg({'${USERPROFILE}'})} _path_gimp=${USERPROFILE}
    elif {narg({'${HOME}'})} _path_gimp=${HOME}
    fi
    if ${-is_windows} sep=\\ else sep=/ fi
    if $_path_gimp${sep}AppData${sep}Roaming${sep}GIMP${sep}2.10${sep}pluginrc
      _path_gimp=$_path_gimp${sep}AppData${sep}Roaming${sep}GIMP${sep}2.10${sep}
    elif $_path_gimp${sep}.gimp-2.8${sep}pluginrc
      _path_gimp=$_path_gimp${sep}.gimp-2.8${sep}
    elif $_path_gimp${sep}.gimp-2.6${sep}pluginrc
      _path_gimp=$_path_gimp${sep}.gimp-2.6${sep}
    else
      _path_gimp=${-path_tmp}
    fi
  fi
  u $_path_gimp
  v +

#@cli path_tmp
#@cli : Return a path to store temporary files (whose value is OS-dependent).
path_tmp :
  v -
  if {!narg({'$_path_tmp'})}
    if {narg({'${TMP}'})} _path_tmp=${TMP}
    elif {narg({'${TEMP}'})} _path_tmp=${TEMP}
    elif {narg({'${TMPDIR}'})} _path_tmp=${TMPDIR}
    elif {narg({'${HOME}'})} _path_tmp="/tmp"
    fi
    if ${-is_windows} _path_tmp=$_path_tmp{`92`} else _path_tmp=$_path_tmp/ fi
  fi
  u $_path_tmp
  v +

#@cli reset
#@cli : Reset global parameters of the interpreter environment.
reset :
  e[^-1] "Reset global parameters of the interpreter environment."
  v -1 db3d m3d md3d f3d l3d sl3d ss3d v +

#@cli RGB
#@cli : Return a random int-valued RGB color.
RGB :
  v - u {round(u(255))},{round(u(255))},{round(u(255))} v +

#@cli RGBA
#@cli : Return a random int-valued RGBA color.
RGBA :
  v - u {round(u(255))},{round(u(255))},{round(u(255))},{round(u(255))} v +

#@cli std_noise
#@cli : Return the estimated noise standard deviation of the last selected image.
std_noise :
  v - if $! +laplacian. -. {ic} abs. u {1.4826*ic/sqrt(d==1?20:42)} rm. else u 0 fi v +

#@cli str : string
#@cli : Print specified string into its binary, octal, decimal and hexadecimal representations.
str : skip $1
  v - dec={'$*'} v +
  e[^-1] "Convert string '$*' to binary '"${dec2bin\ $dec}"', octal '"${dec2oct\ $dec}"', decimal '"$dec"' and
           hexadecimal '"${dec2hex\ $dec}"'."

#@cli str2hex : string
#@cli : Convert specified string into a sequence of hexadecimal values.
str2hex :
  v - ({'"$*"'}) y. r. 2,100% f. 'v=if(x,i%16,int(i/16));if(v<=9,48+v,87+v)' u {t} rm. v +

#@cli strcontains : string1,string2
#@cli : Return 1 if the first string contains the second one.
strcontains :
  v - l[] ({'"$1"'}) s +,{'"$2"'} u {$!>1} rm endl v +

#@cli strlen : string1
#@cli : Return the length of specified string argument.
strlen : skip "${1=}"
  v - u {narg({'"$1"'})} v +

#@cli strreplace : string,search,replace
#@cli : Search and replace substrings in an input string.
strreplace : skip "${3=}"
  v -
  if {narg("$3")}
    ls=${strlen\ "$2"}
    lr={${strlen\ "$3"}-1}
    l[] ({'"$1"'}) s +,{'"$2"'} s y,-$ls
    repeat $! if {[{$>,^}]==['"$2"']} rows[$>] 0,$lr f[$>] {'"$3"'} fi done
    a y u {t} rm endl
  else
    l[] ({'"$1"'}) s -,{'"$2"'} a y u {t} rm endl
  fi
  v +

#@cli strlowercase : string
#@cli : Return a lower-case version of the specified string.
strlowercase :
  v - ({'"$*"'}) +. 'if(i>=65&&i<=90,32,0)' u {t} rm. v +

#@cli strvar : string
#@cli : Return a simplified version of the specified string, that can be used as a variable name.
strvar :
  v - ({'"$*"'}) f. "
   (i>=_'0' && i<=_'9') || (i>=_'a' && i<=_'z') || i==_'_'?i:
   (i>=_'A' && i<=_'Z')?i - _'A' + _'a':
   _'_'"
   if {"i>=_'0' && i<=_'9'"} r. {w+1},1,1,1,0,0,1 =. {_'_'} fi
   y. do h={h} replace_str. "__","_" while {h!=$h}
   u {t} rm. v +

#@cli strver : _version
#@cli : Return the specified version number of the G'MIC interpreter, as a string.
#@cli : Default value: 'version=$_version'.
strver : check ${1=$_version}>0
  v - ({'$1'}) r. {2*w-1} f. 'if(x%2,_'.',i)' u {t} rm. v +

#@cli tic
#@cli : Initialize tic-toc timer.
#@cli : Use it in conjunction with 'toc'.
tic :
  e[^-1] "Initialize timer."
  v - if {!narg($_ticpos)} _ticpos=0 fi _tic$_ticpos=$| _ticpos={$_ticpos+1} v +

#@cli toc
#@cli : Display elapsed time of the tic-toc timer since the last call to 'tic'.
#@cli : This command returns the elapsed time in the status value.
#@cli : Use it in conjunction with 'tic'.
toc :
  v - _ticpos={$_ticpos-1} u {_$|-${_tic$_ticpos}} v +
  e[^-1] "Elapsed time: "${}" s".

#@cli to_clutname : "string"
#@cli : Return simplified name that can be used as a CLUT name, from specified input string.
to_clutname :
  v - 0 nm. "$1" nm={b} rm.
  u {`"ss = lowercase([['"$nm"'],0]);
       const N = 2*size(ss);
       sd = vectorN();
       for (ps = pd = 0, ss[ps], ++ps,
         ss[ps]<=_' '?(sd[pd++] = _'_'):
         (ss[ps]==_'(' || ss[ps]==_')' ||
          ss[ps]==_'{' || ss[ps]==_'}' ||
          ss[ps]==_'[' || ss[ps]==_']' ||
          ss[ps]==_'\'' || ss[ps]==_'\"')?0:
         (ps && ss[ps]>=_'0' && ss[ps]<=_'9' && ss[ps-1]>=_'a' && ss[ps-1]<=_'z')?(sd[pd++] = _'_'; sd[pd++] = ss[ps]):
         (sd[pd++] = ss[ps]);
       ); sd[pd] = 0; sd"`} v +

#@cli uchar2base64 : _encoding={ 0=base64 | 1=base64url }
#@cli : Encode the values of the latest of the selected images as a base64-encoded string.
#@cli : The string can be decoded using command 'base642uchar'.
#@cli : Selected images must have values that are integers in [0,255].
#@cli : Default values: 'encoding=0'.
uchar2base64 : skip "${1=0}"
  v -
  if {isval("$1")} encoding=$1 else encoding=0 noarg fi
  {ceil(whds*4/3)+([0,2,1])[whds%3]}
  eval "
    hash = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    "$encoding"?(hash[62] = _'-'; hash[63] = _'_');
    od = ov = n = 0;
    for (os = 0, os<whds#-2,
      v = i[#-2,os++]&255;
      n==0?(i[#-1,od++] = hash[v>>2]; ov = v; n = 1):
      n==1?(i[#-1,od++] = hash[((ov&3)<<4) | (v>>4)]; ov = v; n = 2):
      (i[#-1,od++] = hash[((ov&15)<<2) | (v>>6)]; i[#-1,od++] = hash[v&63]; n = 0);
    );
    n==1?(i[#-1,od++] = hash[((ov&3)<<4)]; copy(i[#-1,od],_'=',2,1,0); od+=2):
    n==2?(i[#-1,od++] = hash[((ov&15)<<2)]; i[#-1,od++] = _'=');
  "
  u {t} rm. v +

#@cli img2base64 : _encoding={ 0=base64 | 1=base64url }
#@cli : Encode selected images as a base64-encoded string.
#@cli : The images can be then decoded using command 'base642img'.
#@cli : Default values: 'encoding=0'.
img2base64 : skip "${1=0}"
  v -
  if {isval("$1")} encoding=$1 else encoding=0 noarg fi
  +serialize u ${uchar2base64\ $encoding} rm.
  v +

#@cli average_colors
#@cli : Return the average vector-value of the latest of the selected images.
average_colors :
  v -
  res=""
  repeat {s-1} sh. {1+$>} res=$res,{ia} rm. done
  sh. 0 u {ia}$res rm.
  v +

#@cli covariance_colors : _avg_outvarname
#@cli : Return the covariance matrix of the vector-valued colors in the latest of the selected images (for arbitrary number of channels).
#@cli : Parameter 'avg_outvarname' is used as a variable name that takes the value of the average vector-value.
covariance_colors : skip "${1=avg}"
  v -
  $1=${-average_colors}
  f ">begin(avg = [ "$""$1" ]; const S2 = s^2; C = vectorS2(0); ); mI = I - avg; C+=mul(mI,mI,s); end(C/=whd - 1; ext('u ',vtos(C))); I"
  v +

#-------------------------------------
#
#@cli :: Other Interactive Commands
#
#-------------------------------------

#@cli demo : _run_in_parallel={ 0=no | 1=yes | 2=auto }
#@cli : Show a menu to select and view all G'MIC interactive demos.
demo : check "isint(${1=2}) && $1>=0 && $1<=2"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v -
  use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r
  strver=${-strver}
  if {narg($_prerelease)} strver=${strver}_pre#$_prerelease fi
  v +
  e[] "\n
------ "${g}"G\47MIC demos"$n" ------------------\n
----\n
---- "${c}"Mouse button"$n" to select a demo.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------"
  v - l[]
  entries="2048 game","Blobs Editor","Bouncing Balls","Connect Four","Fire Effect","Fireworks","Fish-Eye Effect",\
          "Fourier Filtering","Tower of Hano\357","Histogram Demo","Hough Transform","Jawbreaker","Virtual Landscape","The Game of Life",\
          "Light Effect","Mandelbrot Explorer","3D Metaballs","Minesweeper","Minimal Path","Pacman","Paint",\
          "Plasma Effect","RGB Quantization","3D Reflection","3D Rubber Object","Shade Bobs","Spline Editor","3D Starfield",\
          "Tetris","Tic-Tac-Toe","Image Waves","Fractal Whirls","Color Curves"
  commands=x_2048,x_blobs,x_bouncing,x_connect4,x_fire,x_fireworks,x_fisheye,\
           x_fourier,x_hanoi,x_histogram,x_hough,x_jawbreaker,x_landscape,x_life,\
           x_light,x_mandelbrot,x_metaballs3d,x_minesweeper,x_minimal_path,x_pacman,x_paint,\
           x_plasma,x_quantize_rgb,x_reflection3d,x_rubber3d,x_shadebobs,x_spline,x_starfield3d,\
           x_tetris,x_tictactoe,x_waves,x_whirl,_demo_color_curves
  nb_entries={narg($entries)}
  parallel_mode={1-if($1!=2,$1,$_cpus>=2)}
  strver=${-strver}
  if {narg($_prerelease)} strver.=_pre#$_prerelease fi

  # Generate menu graphics.
  l[]
    repeat $nb_entries
      arg 1+$>,$entries entry=${}
      0 t. $entry,0,0,24,1,1
    done
    r ${-max_wh},1,1,0,0,0.5,0.5
    frame 12,6,0 a z
    +n[0] 0,255
    +shift[0] 1,3,0,0 max[0,-1]
    +f[0] z+1
    1,1,100%,3,u(128,255) r. 1,[0],[0],3 *. 'y/(h-1)' r. [0],[0],[0],3,3

    100%,100%,1,1,"x = min(x,w-1-x); y = min(y,h-1-y); (x*y/wh)^0.7>0.01"
    +dilate. 3 xor.. .
    +[0] ..
    *.. 100 +[1,-2]
    *[2,3] .
    rm.
    frame 4,4,0
    a c s z
    append_tiles 3 s c
    to_rgb[1] a[3-5] c

    0 t. "G\'MIC demos",2,2,32,1,1,1,1
    if $_prerelease 0 t. "Version:\n"$strver,40,1,18,1,1,1,1 rows. 2,100%
    else 0 t. "Version: "$strver,40,1,18,1,1,1,1 rows. -2,100%
    fi
    a[-2,-1] x,0.5
    b. 0.5 n. 0,1
    (32;255^255;255^0;0) r. ..,..,1,3,3 *[-2,-1] round. 1,-1 +!=. 0 channels. 1

    s=8
    r[^-2,-1] 100%,{h+h#0+2*$s+6},1,100%,0,0,0,1
    rectangle[0] 0,$s,100%,{$s+6+h-1},1,0.6
    rectangle[1] 0,$s,100%,{$s+6+h-1},1,120,120,32
    j[0] .,{(w#0-w)/2},{$s+3},0,0,-1
    j[1] ..,{(w#0-w)/2},{$s+3},0,0,1,. rm[-2,-1]
    c[0] 0,1
    nm menu_opac,menu_fgcol,menu_ind,menu_bgcol
  endl

  # Generate 3D cursors.
  arrow3d 20,20,0,0,0,0,20%,40%,40% col3d. 255,128,0 nm. cursor3d

  # Generate 3D background object.
  l[]
    n=16
    chromeball64x64[] 200,100,64 n. 0,230 s. c,-3
    rgb2hsv.. r.. 100%,100%,$n,3 f.. "[z*360/d,G,B]" hsv2rgb..
    N={6*$n} P={2*$N-1}
    i[0] ({'CImg3d'}) i[1] ($N,$P) i[2] 3,$N # Header, points
    i[3] 2,$N,1,1,"x?y:1" i[4] 3,{$N-1},1,1,"x==0?2:x==1?y:y+1" y[3,4] a[3,4] y # Primitives
    l[4] # Colors
      s z i[0--2] (-128,{w},{h},3) 4,{$N-$n},1,1,'x==0?-128:x==1?y%$n:0' # Colors
      3,{$P-$N},1,1,200 y a y
    endl
    l[5] # Opacities
      n 0,0.5 i[0] (-128,{w},{h},1) 4,{$N-1},1,1,-128,0,0,0
      1,{$P-$N},1,1,0.25 y a y
    endl
    y a y
    nm background3d
  endl

  # Generate background.
  {menu_fgcol,[w,h]},1,3 +plasma. 1,1,5 n. 0,230 water. 100
  (0.1;0.03^0;0.1^0.2;0.1) r. ..,3 *[-2,-1]
  (0;1) r. ..,..,1,1,3 pow. 1.5 n. 0.2,1.15 *[-2,-1] n. 0,128
  nm. background
  w. -1,-1,0,"[G'MIC - "$strver"]" cursor 0

  # Enter event loop.
  omb,ind_clicked,cfx,cfy,cfz,alpha=0
  nfx,nfy,nfz={[g,g,g]} time0={$|-4}
  do
    mx,my,mb={menu_fgcol,x={*,x};y={*,y};[x<0?-1:x*(w-1)/({*,w}-1),y<0?-1:y*(h-1)/({*,h}-1),{*,b}]}
    ind={menu_ind,i($mx,$my)}
    if {$mb" && "!$ind_clicked} ind_clicked=$ind fi

    # Render current view.
    [background]

    3,$N,1,1,"const t = 0.8*"$|"; const a = "$alpha"; const oma = 1 - a;
              x==0?oma*cos("$cfx"*y + t) + a*cos("$nfx"*y + t):
              x==1?oma*sin("$cfy"*y + t) + a*sin("$nfy"*y + t):
                   oma*sin("$cfz"*y + t) + a*sin("$nfz"*y + t)"
    y.
    j[background3d] .,0,8 rm.
    +r3d[background3d] 1,2,3,{20*$|} *3d. {menu_fgcol,[w,h]/2-30},300 +3d. 0,0,300
    j3d.. .,50%,50%,0,1,1,0,0,200 rm.
    if {$|-$time0>5} alpha+=0.02 fi
    if {$alpha>1} alpha-=1 cfx,cfy,cfz=$nfx,$nfy,$nfz nfx,nfy,nfz={[g,g,g]} time0={$|-u*3} fi

    if {$ind>0} +==[menu_ind] $ind j.. [menu_bgcol],0,0,0,0,{$mb" && "$ind_clicked==$ind?0.6:1},. rm. fi # Draw selection background
    j. [menu_fgcol],0,0,0,0,1,[menu_opac]

    if {$mx>0}
      +r3d[cursor3d] 1,1.3,0.6,{50*cos($|)}
      j3d.. .,$mx,$my,0,1,4,0,0,800,{-2,[w,h]/2},-1000,0.7 rm.
    fi

    w. -1,-1,0
    if {{*,CTRLLEFT}&&{*,D}} w. 150%,150% elif {{*,CTRLLEFT}&&{*,C}} w. 100%,100% fi
    rm.

    # Manage user selection.
    if {!$mb" && "$omb" && "$ind_clicked" && "$ind_clicked==$ind}
      m "com : v 0 "${arg\ $ind,$commands} parallel $parallel_mode,"l[] com v -1 rm endl" uncommand com
    elif {!$mb} ind_clicked=0
    fi
    omb=$mb

    wait 20
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 endl v 0 e[] ""

_demo_color_curves :
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  if {!narg($__demo_color_curve)}
    e[] "\n
------ "${g}"Color curves"$n" ----------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" on a curve creates a new control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" on a control point deletes it.\n
---- "${c}"Left mouse button"$n" on the main image window shows the initial image until button is released.\n
---- "${c}"Right mouse button"$n" on the main image window adds a keypoint to all curves from picked color.\n
---- Key '"${c}"R"$n"' on a curve resets it.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' close the current window.\n
----\n
------------------------------------------------------------------------------------------------"
    v - __demo_color_curve=1 l[] do rm sp ? while {s!=3} endl x_color_curves rgb __demo_color_curve= v +
  else
    e[] "\n
------ "${g}"Color curves"$n" ----------------------------------------------------------------------------\n
----\n
---- Only "${c}"one session"$n" allowed at the same time !\n
----\n
------------------------------------------------------------------------------------------------"
  fi

#@cli x_2048
#@cli : Launch the 2048 game.
x_2048 :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"2048"$n" -----------------------------------------------\n
----\n
---- Join the numbers and get to the "${g}"2048"$n" tile!\n
----\n
---- Use your "${c}"arrow keys"$n" to move the tiles. When two tiles\n
---- with the same number touch, they merge into one!\n
---- This command is a port of the '"${c}"2048"$n"' game originally\n
---- designed by "${c}"Gabriele Cirulli"$n", and available at:\n
---- "${g}"http://gabrielecirulli.github.io/2048/"$n"\n
----\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
  v - l[]
  score=0 f3d 50 m3d 0
  m "_x_2048_setrandom : +==[0] 0 f. 'if(i,4*y+x,-1)' discard. -1
     off={i[round(u(h-1))]} rm. x={$off&3} y={$off>>2} n={if(u<0.75,1,2)}
     =[0] $n,$x,$y [{2+$n}] c3d.
     repeat 6 j3d[1] .,{78+$x*121},{190+$y*121},{10*$<},{(1+$>)/6} w[1] wait 20 done
     rm."
  m "_x_2048_object3d : +f[0] 'if(i,i*16+4*y+x,-1)' discard. -1
     N={h} repeat {h} v={-{1+$>},@$>} ++3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} done
     +3d[-$N--1] rm.."
  i[0] 4,4

  # Pre-render game canvas and numbered titles.
  b0=204,192,179 b1=238,228,218 b2=237,224,200 b3=242,177,121
  b4=245,149,99 b5=246,124,95 b6=246,94,59 b7=237,207,114
  c0=119,110,101 c1=249,246,242 s0=" "
  520,630,1,3 fc. 250,248,239
  t. "2048",20,10,86,1,$c0
  t. "Join the numbers and get to the 2048 tile!",20,90,20,1,$c0
  rectangle. 422,20,501,75,1,187,173,160 t. "SCORE",439,25,15,1,238,228,218
  repeat 12
    107,107,1,3 fc. ${b{min($>,7)}} +fc. ${c{$>>2}}
    s1={2^$>} 0 t. ${s{$>>0}},0,0,52,1,1
    r. ..,..,1,1,0,0,0.5,0.5 dilate_circ. 3 b. 0.5
    j... ..,0,0,0,0,1,.,1 rm[-2,-1]
  done
  frame_round[2--1] 10,5,1,0.5,187,173,160 frame[2--1] 7,7,187,173,160 to_rgb[2--1]
  r[2] 400%,400%,1,3,0,2 j[1] [2],18,130
  sprite3d[3--1]

  # Run game.
  w[1] 100%,100%,0,"[G"{`39`}"MIC] 2048" insert_new=1
  repeat 2 _x_2048_setrandom done
  do

    # Render game graphics at current iteration.
    if $insert_new
      _x_2048_object3d *3d. 121 j[1] [2],18,130 j3d[1] .,78,190 rm.
      80,25,1,3 fc. $c1 0 t. $score,0,0,25,1,1,1,1 r. ..,0,0,0.5,0.8
      rectangle[1] 422,45,501,69,1,187,173,160 j[1] ..,422,45,0,0,1,. rm[-2,-1]
      w[1] insert_new=0
    fi

    # Check for the end of the game.
    ++[0] 1 f. 'j(-1)==i||j(1)==i||j(0,-1)==i||j(1,0)==i||i==1'
    if {0,iM==11} # Game won.
      alert "Game Over","\nCongratulations! You got the 2048 title!\n\n   Your score: "$score,"OK"
      break
    elif {!iM} # Game lost.
      alert "Game Over","\nBad luck! You lost the game!\n\n   Your score: "$score,"OK"
      break
    fi
    rm.

    # Manage user events.
    wait
    is_shift=0 uncommand shift2048,ishift2048,vshift2048
    if {*,ARROWLEFT}
      m "shift2048:" m "ishift2048:" m "vshift2048:"
      is_shift=1
    elif {*,ARROWRIGHT}
      m "shift2048: rotate 180" m "ishift2048: rotate 180"
      m "vshift2048: s3d l[2] r 3,{h/3},1,1,-1 s x -[0,1] 3 *[0,1] -1 a x y endl a y"
      is_shift=1
    elif {*,ARROWUP}
      m "shift2048: rotate -90" m "ishift2048: rotate 90"
      m "vshift2048: s3d l[2] r 3,{h/3},1,1,-1 s x rv[0,1] -[0] 3 *[0] -1  a x y endl a y"
      is_shift=1
    elif {*,ARROWDOWN}
      m "shift2048: rotate 90" m "ishift2048: rotate -90"
      m "vshift2048: s3d l[2] r 3,{h/3},1,1,-1 s x rv[0,1] -[1] 3 *[1] -1  a x y endl a y"
      is_shift=1
    fi
    if {*,r} w[1] 100%,100% fi

    # Manage tile shifts and fusions.
    if $is_shift
      wait -1
      shift2048[0]
      repeat 2

        # Tile shifts.
        _x_2048_object3d
        +s[0] y discard[-4--1] 0 y[-4--1] x r[-4--1] 4,1,1,1,0,0 a[-4--1] y
        +==[0,-1] insert_new={$insert_new||!im} rm.
        +f[0,-1] 'if(i,x,-1)' discard[-2,-1] -1 rv[-2,-1] -[-2,-1] rv[0,-2] rm..

        if {(im||iM)&&!{*,k}} # Render animation for shift.
          /. 5 z. 0,2 y.
          repeat 5
            j.. .,0,8,0,0,-1
            j[1] [2],18,130 +vshift2048.. *3d. 121 j3d[1] .,78,190 rm.
            w[1] wait 20
          done
        fi
        rm[-2,-1]

        # Tile fusions.
        if {!$>} dscore=0
          [0] +f[0] 'if(i,i*16+4*y+x,-1)' discard. -1
          repeat {h}
            x={i[$>]&3} y={(i[$>]>>2)&3} n={i[$>]>>4}
            if {$x>0" && "{0,i($x-1,$y)}==$n}
              =[0] 0,$x,$y =[0] {$n+1},{$x-1},$y =.. 0,$x,$y insert_new=1 dscore+={2^($n+1)}
            else =. -1,0,$>
            fi
          done
          score+=$dscore

          if {iM<0} rm[-2,-1]
          else # At least one tile fusions.
            discard. -1
            rv[0,-2] _x_2048_object3d rv[0,-3] vshift2048. *3d. 121 # Only tiles that do not move in this step.
            j[1] [2],18,130 j3d[1] .,78,190 rm[-3,-1]
            N={h} repeat {h} v={-{1+$>},@$>} ++3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} done # Only tiles that move.
            +3d[-$N--1] rm..
            0 t. +$dscore,0,0,33,1,1 100%,100%,1,3 fc. $c0
            repeat 6  # Render animation for fusion.
              +vshift2048... *3d. 121 +j3d[1] .,78,190
              j. ...,430,{80-$>},0,0,{min(1,$</6)},[-4]
              w. rm[-2,-1] -3d... {1/6},0,0 wait 20
            done
            rm[-3--1]
          fi

        fi
      done
      ishift2048[0]

      # Insert new tile.
      if $insert_new _x_2048_setrandom fi
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 endl uncommand _x_2048_setrandom,_x_2048_object3d v +

#@cli x_blobs
#@cli : Launch the blobs editor.
x_blobs :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Blobs editor"$n" --------------------------\n
----\n
---- "${c}"Mouse"$n" to insert/move/delete blobs.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
  v -

  # Create background image [0].
  l[] (0;0^0;128^0;255) r. 450,450,1,3,3 flower. 30,8,0,0,50%,50%,1 water. 20
  w {f=h<0.5*{*,v}?1.5:1;[w,h]*=f},0,0,"[G"{`39`}"MIC] Blobs Editor"

  # Start event loop.
  moving=-1
  do
    x={{*,x}*{0,w}/{*,w}}
    y={{*,y}*{0,h}/{*,h}}
    b={*,b} nearest=-1
    fps=${-fps}

    # Render image of blobs and find nearest blob to mouse pointer.
    if {$!>1}
      {0,[w,h]},1,2
      repeat {1,h}
        r={1,i[2]*(1+i[3]*cos(i[4]+i[5]*$|*1000))}
        ellipse. {1,@0,1},$r,$r,0,1,{1,@6-7}
        d={sqrt(($x-{1,@0})^2+($y-{1,@1})^2)}
        if {$d<$r} nearest=$> fi
      shift[1] 0,-1,0,0,2 done
      b. 15
      +norm. +>=. 50 <=.. 40 *[-3,-1]
      +*[0,-1] rm.. rv[-2,-1] *. 1.6 c. 0,255 +[-2,-1]
      if {$fps>0} to. $fps" fps",5,{h-29},24,2,0.2 fi
      w.
      if {{*,CTRLLEFT}&&{*,D}} w[] {2*[w,h]} elif {{*,CTRLLEFT}&&{*,C}} w[] {[w,h]} fi
      rm.
    else
      +to[0] "G\47MIC Blobs Editor",75,100,35,3,1,200,128,255
      to. "* Left mouse button : Create and move blobs.\n\n\
           * Right mouse button : Remove blob.\n\n\
           * Middle mouse button : Remove all blobs.\n\n\
           * Key 'ESC' or 'Q' : Quit.\n\n\
           * Colors and sizes of appearing blobs are\n   chosen randomly",\
           50,180,18,1,1,255
      w.
      if {{*,CTRLLEFT}&&{*,D}} w[] {1.5*[w,h]} elif {{*,CTRLLEFT}&&{*,C}} w[] {[w,h]} fi
      rm.
    fi
    wait 20

    # Manage blob insertion, removal or move.
    if {$x<0||$y<0} continue fi
    if {$b&1}
      if {$nearest>=0" || "$moving>=0} # Move existing blob.
        if {$moving<0} moving=$nearest fi
        =[1] $x,0,$moving =[1] $y,1,$moving
        else # Insert new blob.
          ($x,$y,{u(20,50)},{u(-0.3,0.3)},{u(0,pi/2)},{u(0,0.009)},{u(64,255)},{u(64,255)}) a[^0] y
          moving={h-1}
        fi
    elif {$b&2} # Remove existing blob.
      if {$nearest>=0} l[1] s y rm[$nearest] a y endl nearest=-1 fi
    elif {$b&4} # Remove all blobs.
      k[0]
    else
      moving=-1
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 endl v +

#@cli x_bouncing
#@cli : Launch the bouncing balls demo.
x_bouncing :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Bouncing balls"$n" ------------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
  v - l[]
  520,320,1,3 plasma 1,1,9 n 0,220
  N=12
  repeat $N
    ball[] {round(u(32,80))},${-RGB}
    t$>={u(200)} x$>={0,u(10,w-10)} h$>={u(150,300)} vx$>={if(u<0.5,1,-1)*u(1,8)}
  done
  mv[0] $!
  w. {f=w<0.5*{*,u}?1.5:1;[w,h]*=f},0,"[G"{`39`}"MIC] Bouncing Balls"
  (0;0.7;1) r. {-2,w},70,1,1,3

  do
    [$N]
    repeat $N
      bw={$>,w} bh={$>,h}
      y={${h$>}*abs(cos(${t$>}*pi/60))-$bh/2}
      dt=1
      if {$y<0} d={-$y} y=0 bh-=$d bw+=$d dt={max(0.2,1-($d/$bh)^2)} else dt=1 fi
      if {${x$>}+$bw/2>w}
        d={${x$>}+$bw/2-w} bw-=$d bh+={0.5*$d}
        if {${x$>}+$bw/4>w} vx$>={-${vx$>}} fi
      fi
      if {${x$>}-$bw/2<0}
        d={$bw/2-${x$>}} bw-=$d bh+={0.5*$d}
        if {${x$>}-$bw/4<0} vx$>={-${vx$>}} fi
      fi
      +r[$>] $bw,$bh,1,4,3 s. c,-3
      j... ..,{max(0,min({$N,w-$bw},${x$>}-$bw/2))},{{$N,h}-{h}-$y-70},0,0,1,.,255 rm[-2,-1]
      t$>+=$dt
      x$>+={$dt*${vx$>}}
    done

    +rows. {h-2*70},{h-1-70} mirror. y *. [{$N+1}]
    j.. .,0,{-2,h-71},0,0,0.5 rm.
    fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-29},24,2,0.2 fi
    w.

    if {{*,CTRLLEFT}&&{*,D}} w[] {1.5*w},{1.5*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
    rm. wait 20
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w 0 rm endl v +

#@cli x_color_curves : _colorspace={ rgb | cmy | cmyk | hsi | hsl | hsv | lab | lch | ycbcr | last }
#@cli : Apply color curves on selected RGB[A] images, using an interactive window.
#@cli : Set 'colorspace' to 'last' to apply last defined color curves without opening interactive windows.
#@cli : Default value: 'colorspace=rgb'.
x_color_curves : skip ${1=rgb}
  if {['"$1"']!='last'&&!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[^-1] "Apply color curves of image$?, in the '$1' colorspace."
  if {['"$1"']=='last'} v -
    if {!narg($_xcc_colorbase)} v + return fi
    __x_color_curves[] $_xcc_colorbase
  else
    e[] "\n
------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" on a curve creates a new control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" on a control point deletes it.\n
---- "${c}"Left mouse button"$n" on the main image window shows the initial image until button is released.\n
---- "${c}"Right mouse button"$n" on the main image window adds a keypoint to all curves from picked color.\n
---- Key '"${c}"R"$n"' on a curve resets it.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' close the current window.\n
----\n
------------------------------------------------------------------------------------------------"
    v -
    __x_color_curves[] $1 _xcc_colorbase=$1
  fi

  to_color repeat $! l[$>]

    if {['"$1"']!='last'} # Open interactive windows to set color curves.
      +r[0] ${fitscreen[]\ {0,w},{0,h},1,128,70%},1,100%,3
      +l. xcc_goto s c histogram 256,0,255 xcc_info endl # Compute additional info for each image channel (histogram and color axis).
      __C0= __C1= __C2= __C3= __C4=
      if {narg($__xcc_C0)} __C0=$__xcc_C0 fi
      if {narg($__xcc_C1)} __C1=$__xcc_C1 fi
      if {narg($__xcc_C2)} __C2=$__xcc_C2 fi
      if {narg($__xcc_C3)} __C3=$__xcc_C3 fi
      if {narg($__xcc_C4)} __C4=$__xcc_C4 fi

      x={1,({*,u}-560-w)/2} y={1,({*,v}-h)/2}
      if {$!==5} # 3 channels.
        parallel "w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" x_select_function1d... __C0,"$_color0"",\
                 "w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" x_select_function1d.. __C1,"$_color1"",\
                 "w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" x_select_function1d. __C2,"$_color2"",\
                 "w. 100%,100%,0,0,"{$x+560}","$y" _x_color_curves[-4]"
      elif {$!==6} # 4 channels.
        parallel "w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" x_select_function1d[-4] __C0,"$_color0"",\
                 "w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" x_select_function1d... __C1,"$_color1"",\
                 "w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" x_select_function1d.. __C2,"$_color2"",\
                 "w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" x_select_function1d. __C3,"$_color3"",\
                 "w. 100%,100%,0,0,"{$x+560}","$y" _x_color_curves[-5]"
      elif {$!==7} # 5 channels.
        parallel "w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" x_select_function1d[-5] __C0,"$_color0"",\
                 "w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" x_select_function1d[-4] __C1,"$_color1"",\
                 "w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" x_select_function1d... __C2,"$_color2"",\
                 "w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" x_select_function1d.. __C3,"$_color3"",\
                 "w[] 256,256,0,0,"{$x+280}","{$y+600}",\"Curve: "$_title4"\" x_select_function1d. __C4,"$_color4"",\
                 "w. 100%,100%,0,0,"{$x+560}","$y" _x_color_curves[-6]"
      fi
      k[0]
    fi

    # Apply color curves on fullres image.
    xcc_goto
    repeat {s} function1d[] 1,${__xcc_C$>} *. {255%} r. 256,1,1,1,5 c. 0,255 sh[0] $> map. .. rm[-2,-1] done
    xcc_backto

  endl done
  uncommand xcc_goto,xcc_backto,xcc_info v +

_x_color_curves :
  title={0,b} if {narg({'{0,x}'})} title=$title.{0,x} fi ({'$title'}) discard. {'~'} title={t} rm.
  +drgba. w. 100%,100%,0,"[G"{`39`}"MIC] Image: "$title rm.
  xcc_goto. .

  oC0= oC1= oC2= oC3= oC4= viewmode=0
  do
    wait 100 need_refresh=0

    # Manage user events.
    oviewmode=$viewmode is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}} x={*,x} y={*,y}
    if {*,r} need_refresh=1 # Window resize.
    elif {$is_ctrl" && "{*,-D}} w[] {{*,w}*125%},{{*,h}*125%} need_refresh=1 # Increase window size.
    elif {$is_ctrl" && "{*,-C}} w[] {{*,w}*80%},{{*,h}*80%} need_refresh=1 # Decrease window size.
    elif {$is_ctrl" && "{*,-R}} w[] {w},{h} need_refresh=1 # Reset window size.
    elif {{*,b}&1} viewmode={x={*,x};if(x<w/3,1,if(x<2*w/3,2,3))} # Change viewmode.
    elif {{*,b}&2" && "$x>=0" && "$y>=0} # Add control point from picked color.
      xc={$x*w/{*,w}} yc={$y*h/{*,h}} +z[0] $xc,$yc,$xc,$yc
      repeat {s} (${__C$>},{i[$>]/255%},{i[$>]/255%}) r. 2,{w/2},1,1,-1 sort. +,y __C$>={^} rm. done
      rm. wait -1
    else viewmode=0
    fi
    need_refresh={$need_refresh||$oviewmode!=$viewmode}

    # Update result.
    repeat {s} if {['_${oC$>}']!=['_${__C$>}']} # Channel must be updated.
      function1d[] 1,${__C$>} *. {255%} r. 256,1,1,1,5 c. 0,255
      +channels[0] $> map. .. j[1] .,0,0,0,$> rm[-2,-1]
      need_refresh=1 oC$>=${__C$>}
    fi done

    # Display view.
    if $need_refresh
      if {$viewmode==0} # Modified view.
        +xcc_backto[1]
      elif {$viewmode%2} # Split view.
        w2={0,int(w/2)} b={$viewmode==1} +z[{!$b}] 0,{$w2-1} +z[$b] $w2,100%
        xcc_backto.. xcc_backto. a[-2,-1] x line. 50%,0,50%,100%,1,0
      else # Original view.
        +xcc_backto[0]
      fi
      if {s>3} drgba. fi w. rm. refresh=0
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,SPACE}" && "!{*,ENTER}}
  w 0
  repeat 5 if {narg(${__C$>})} __xcc_C$>=${__C$>} __C$>=-1 fi done  # Transfer curves to output variable and request curve widgets to close;

# Define colorspace conversion functions.
__x_color_curves :
  if {['"$1"']=='rgb'}
    _color0="255,180,180" _color1="180,255,180" _color2="180,180,255" _color3="220,220,220" _title0=Red _title1=Green _title2=Blue _title3=Alpha
    m "xcc_goto:" m "xcc_backto:"
    m "xcc_info: (0,255;0,0;0,0) (0,0;0,255;0,0) (0,0;0,0;0,255) r[-3--1] 256,3,1,1,3 "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  elif {['"$1"']=='cmy'}
    _color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Alpha
    m "xcc_goto: s c,-3 rgb2cmy[0] a c" m "xcc_backto: s c,-3 cmy2rgb[0] a c"
    m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) r[-3--1] 256,3,1,1,3 "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  elif {['"$1"']=='cmyk'}
    _color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="180,180,180" _color4="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Key _title4=Alpha
    m "xcc_goto: s c,-3 rgb2cmyk[0] a c" m "xcc_backto: s c,-4 cmyk2rgb[0] a c"
    m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) (255,0) r[-4--1] 256,3,1,1,3 "\
      "a[0,-4] y a[1,-3] y a[2,-2] y a[3,-1] y"
  elif {['"$1"']=='hsi'}
    _color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Intensity _title3=Alpha
    m "xcc_goto: s c,-3 rgb2hsi8[0] a c" m "xcc_backto: s c,-3 hsi82rgb[0] a c"
    m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) hsi82rgb[-3--1] permute[-3--1] xcyz "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  elif {['"$1"']=='hsl'}
    _color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Lightness _title3=Alpha
    m "xcc_goto: s c,-3 rgb2hsl8[0] a c" m "xcc_backto: s c,-3 hsl82rgb[0] a c"
    m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) hsl82rgb[-3--1] permute[-3--1] xcyz "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  elif {['"$1"']=='hsv'}
    _color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Value _title3=Alpha
    m "xcc_goto: s c,-3 rgb2hsv8[0] a c" m "xcc_backto: s c,-3 hsv82rgb[0] a c"
    m "xcc_info: 256,1,1,3,if(!c,x,255) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) hsv82rgb[-3--1] permute[-3--1] xcyz "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  elif {['"$1"']=='lab'}
    _color0="180,180,180" _color1="220,180,220" _color2="220,220,180" _color3="220,220,220" _title0=Lightness _title1=Chroma-A _title2=Chroma-B _title3=Alpha
    m "xcc_goto: s c,-3 srgb2rgb[0] apo[0] rgb2lab8,0,4 a c" m "xcc_backto: s c,-3 apo[0] lab82rgb,0,4 rgb2srgb[0] a c"
    m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,240,if(c==1,x,128)) 256,1,1,3,if(!c,240,if(c==1,128,x)) lab82rgb[-3--1] permute[-3--1] xcyz "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  elif {['"$1"']=='lch'}
    _color0="180,180,180" _color1="220,180,220" _color2="255,220,220" _color3="220,220,220" _title0=Lightness _title1=Chroma _title2=Hue _title3=Alpha
    m "xcc_goto: s c,-3 srgb2rgb[0] apo[0] rgb2lch8[0],0,4 a c" m "xcc_backto: s c,-3 apo[0] lch82rgb[0],0,4 rgb2srgb[0] a c"
    m "xcc_info: 256,1,1,3,if(!c,x,0) 256,1,1,3,if(!c,255,if(c==1,x,128)) 256,1,1,3,if(!c,220,if(c==1,128,x)) lch82rgb[-3--1] permute[-3--1] xcyz "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  elif {['"$1"']=='ycbcr'}
    _color0="180,180,180" _color1="220,220,255" _color2="255,220,220" _color3="220,220,220" _title0=Luma _title1=Blue\ chroma _title2=Red\ chroma _title3=Alpha
    m "xcc_goto: s c,-3 rgb2ycbcr[0] a c" m "xcc_backto: s c,-3 ycbcr2rgb[0] a c"
    m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,128,if(c==1,x,128)) 256,1,1,3,if(!c,128,if(c==1,128,x)) ycbcr2rgb[-3--1] permute[-3--1] xcyz "\
      "a[0,-3] y a[1,-2] y a[2,-1] y"
  else v + error[0--3] "Command 'x_color_curves': Unknown specified color space '$1'."
  fi

#@cli x_colorize : _is_lineart={ 0 | 1 },_max_resolution={ 0 | >=128 },_multichannels_output={ 0 | 1 },_[palette1],_[palette2],_[grabber1]
#@cli : Colorized selected B&W images, using an interactive window.
#@cli : When >0, argument 'max_resolution' defines the maximal image resolution used in the interactive window.
#@cli : Default values: 'is_lineart=1', 'max_resolution=1024' and 'multichannels_output=0'.
x_colorize : skip ${1=0},${3=0},${4=0},${5=0},${6=0} check "${2=1024}==0 || $2>=128"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - s0="image" s1="lineart" s2="multichannel" s3="merged" use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[^-1] "Colorize selected B&W "${s{!$1}}"$? interactively, with maximum resolution $2 and "${s{2+!$3}}" output."
  e[] "\n
--------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" creates a new colored control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" or key '"${c}"X"$n"' over a control point deletes it.\n
---- "${c}"Right mouse button"$n" or key '"${c}"P"$n"' anywhere else picks a color from the image.\n
---- "${c}"Mouse wheel"$n", or keys '"${c}"CTRL+arrows UP/DOWN"$n"' zoom view in/out.\n
---- '"${c}"CTRL+mouse wheel"$n"', '"${c}"SHIFT+mouse wheel"$n"' or "${c}"arrow keys"$n" move image in zoomed view.\n
---- Key '"${c}"SPACE"$n"' updates the extrapolated color field.\n
---- Key '"${c}"TAB"$n"' toggles between markers view modes.\n
---- Key '"${c}"BACKSPACE"$n"' deletes the last control point added.\n
---- Key '"${c}"PAGE UP"$n"' increases image contrast.\n
---- Key '"${c}"PAGE DOWN"$n"' decreases image contrast.\n
---- Key '"${c}"R"$n"' toggles color replace mode.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
--------------------------------------------------------------------------------------"
  v -
  N=$!
  thread_main="_x_colorize[0] ${1--1}"
  thread_color="w[] 400,320,0,\"Palette: main\" x_select_color[] __color,255,255,255"

  is_palette1=${"is_image_arg[] $4"}
  if $is_palette1
    pass$4 1 ({'{b}'}) discard. {'~'} palette_title1={t} rm.
    thread_palette1="w[] 400,400,0,\"Palette: "$palette_title1"\" x_select_palette["{$!-1}"] __color"
  fi

  is_palette2=${"is_image_arg[] $5"}
  if $is_palette2
    pass$5 1 ({'{b}'}) discard. {'~'} palette_title2={t} rm.
    thread_palette2="w[] 400,400,0,\"Palette: "$palette_title2"\" x_select_palette["{$!-1}"] __color"
  fi

  is_grabber=${"is_image_arg[] $6"}
  if $is_grabber
    pass$6 1 ({'{b}'}) discard. {'~'} palette_grabber={t} rm.
    thread_grabber="w[] ${\"fitscreen[] {w},{h},1,128,50%\"},0,\"Grabber: "$palette_grabber"\" x_grab_color["{$!-1}"] __color"
  fi

  __color=255,255,255

  if {!$is_palette1" && "!$is_palette2" && "!$is_grabber}
    repeat $N l[$>]
      parallel $thread_main,$thread_color
    endl done
  else
    repeat $N l[$>,$N--1]
      parallel $thread_main,$thread_color,$thread_palette1,$thread_palette2,$thread_grabber
    endl done
  fi
  k[0-{$N-1}]
  v +

_x_colorize :

  # Init variables and images.
  name={n} title={b} if {narg({x})} title=$title.{x} fi
  w={w} h={h}

  if $1 # Line-art.
    if {s==4} sh. 3 if {abs(im-iM)>64} +*. -1 rm.. +. 255 else rm. sh. 0 fi
    else sh. 0
    fi
    n 0,255
    else # Regular image.
    if {s==1} sh. 0
    else +luminance.
    fi
  fi

  nm. img

  fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
  selection=-1 view_markers=2 contrast=9 xpan=-1 ypan=-1 replace_color= current_replace_color=

  if {narg($_gui_control_points)>=6}  ($_gui_control_points) r. {w/6},6,1,1,-1 # Import list of control points from plug-in GUI.
  else 0 # Empty list of control points.
  fi
  nm. points

  # Compute potential map.
  if {$2>0} if {$w>$h} +r2dx[img] {min($2,$w)},2 else +r2dy[img] {min($2,$h)},2 fi else [img] fi
  __x_colorize. $1
  pw={potential,w} ph={potential,h}

  # Start event loop.
  do

    # Handle user events for zoom/navigation/resizing.
    if {narg($replace_color)" && "{*,x}<0" && "{*,y}<0} wait 200 else wait fi
    x={*,x} y={*,y} b={*,b} o={*,-o}
    is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
    is_shift={{*,SHIFTLEFT}" || "{*,SHIFTRIGHT}}
    is_mouseout={$x<0" || "$y<0}
    x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
    oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1

    if {*,r} # When window resized.
      nww={*,d} nwh={*,e} m={min($nww,$nwh)}
      cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
      x0={$cx-$dx/2} x1={$cx+$dx/2}
      y0={$cy-$dy/2} y1={$cy+$dy/2}
      ww=$nww wh=$nwh
    elif {$is_ctrl" && "{*,-D}} # Increase window size.
      nww={min({*,u},$ww*1.25)} nwh={min({*,v},$wh*1.25)} m={min($nww,$nwh)}
      if {$m==$nww} ww=$m wh={$h*$m/$w} else ww={$w*$m/$h} wh=$m fi
    elif {$is_ctrl" && "{*,-C}} # Decrease window size.
      nww={$ww/1.25} nwh={$wh/1.25}
      if {min($nww,$nwh)>=64} ww=$nww wh=$nwh fi
    elif {$is_ctrl" && "{*,R}} # Reset window size.
      fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
      x0=0 y0=0 x1={$w-1} y1={$h-1}
    elif {($is_shift" && "$o<0)" || "{*,ARROWLEFT}} # Go left.
      dx={($x1-$x0)/6} x0-=$dx x1-=$dx
    elif {($is_shift" && "$o>0)" || "{*,ARROWRIGHT}} # Go right.
      dx={($x1-$x0)/6} x0+=$dx x1+=$dx
    elif {($is_ctrl" && "$o>0)" || "({*,ARROWUP}" && "!$is_ctrl)} # Go up.
      dy={($y1-$y0)/6} y0-=$dy y1-=$dy
    elif {($is_ctrl" && "$o<0)" || "({*,ARROWDOWN}" && "!$is_ctrl)} # Go down.
      dy={($y1-$y0)/6} y0+=$dy y1+=$dy
    elif {$o>0" || "($is_ctrl" && "{*,ARROWUP})} # Zoom in.
      if {$x1-$x0>16" && "$y1-$y0>16}
        cx={if($x>=0" && "!{*,ARROWUP},$x,($x0+$x1)/2)}
        cy={if($y>=0" && "!{*,ARROWUP},$y,($y0+$y1)/2)}
        x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
        x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
      fi
    elif {$o<0" || "($is_ctrl" && "{*,ARROWDOWN})} # Zoom out.
      zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
      if {$zfactor<1.3}
        cx={if($x>=0" && "!{*,ARROWDOWN},$x,($x0+$x1)/2)}
        cy={if($y>=0" && "!{*,ARROWDOWN},$y,($y0+$y1)/2)}
        x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
        x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
        dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
        x0+=$dx x1+=$dx y0+=$dy y1+=$dy
      else
        dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
        x0+=$dx x1+=$dx y0+=$dy y1+=$dy
      fi
    elif {$b&4" && "!$is_mouseout} # Pan.
      if {$panx<0" && "$pany<0} panx=$x pany=$y
      else dx={round($panx-$x)} dy={round($pany-$y)} x0+=$dx y0+=$dy x1+=$dx y1+=$dy
      fi
    else panx=-1 pany=-1
    fi
    if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} rm[baseview] fi

    # Handle events related to control points management.
    N={points,w}
    if {narg($baseview)" && "($b&3" || "{*,X}" || "{*,P})" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
      if {$selection==-1" && "$N} # Check for selection of an existing point.
        ($x;$y) r. $N,2 -. [points] *. {max($ww,$wh)/max($x1-$x0,$y1-$y0)} sqr. s. y +[-2,-1]
        dmin={im} selection={if($dmin>25,-1,xm)} rm.
      fi
      if {narg($replace_color)} # Go back from 'Replace color' mode.
        replace_color= wait -1
      elif {$selection>=0}
        if {$b&1" && "$view_markers} # Move existing point.
          +columns[points] $selection ox={i[0]} oy={i[1]} =. $x =. $y,0,1 j[points] .,$selection rm.
          rm[view]
        elif {($b&2" || "{*,X})" && "$view_markers} # Remove existing point.
          if {$N>1} +z[points] {$selection+1},100% j[points] .,$selection rm. r[points] {$N-1},100%,1,1,0
          else rm[points] i[points] 0 fi
          wait -1 rm[view]
        fi
      elif {$b&1} # Add new point
       ($x;$y;0) ($__color) y. y +. 1 a[-2,-1] y a[points,-1] x selection=$N if {!$view_markers} view_markers=2 fi rm[view]
      elif {$b&2" || "{*,P}} # Pick color from image.
        __color={colors,I($x*$pw/$w,$y*$ph/$h)}
      fi
    else selection=-1
      if {{*,-SPACE}" && "narg($colors)} replace_color= rm[colors] # Update color map.
      elif {*,-TAB} view_markers={($view_markers-1)%3} rm[view] wait -1 # Toggle markers.
      elif {!$is_ctrl" && "{*,-R}}  # Switch color replace mode.
        if {narg($replace_color)} replace_color= else replace_color=$__color fi
        rm[baseview] wait -1
      elif {*,PAGEDOWN} contrast={max(0,$contrast-1)} rm[view] wait -1 # Decrease contrast.
      elif {*,PAGEUP} contrast={min(9,$contrast+1)} rm[view] wait -1 # Increase contrast.
      elif {{*,BACKSPACE}" && "$N} if {$N>1} z[points] 0,{$N-2} else i=$points rm[points] i[$i] 0 nm[$i] points fi rm[view] wait -1 # Remove last point.
      fi
    fi

    # Manage zoomed view bounds.
    w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
    if {$x0<-$w2} x1-={$x0+$w2} x0=-$w2 fi
    if {$y0<-$h2} y1-={$y0+$h2} y0=-$h2 fi
    if {$x1>=$w+$w2} x0+={$w-1+$w2-$x1} x1={$w-1+$w2} fi
    if {$y1>=$h+$h2} y0+={$h-1+$h2-$y1} y1={$h-1+$h2} fi

    # Render color map.
    if {!narg($colors)}
      N={points,w}
      if {narg($view)} to[view] "Processing...",5,5,20,2 w[view] fi
      if $N
        [points]
        sh. 0,0,0,0 *. {$pw/$w} rm.
        sh. 1,1,0,0 *. {$ph/$h} rm.
        pointcloud. -1,$pw,$ph
        +compose_channels. max !=. 0 distance. 1 *. 0.02 +. 1 ^. -1 +. [potential] # Additional term that depends on marker's positions.
        if {!$1} dilate.. 3 fi
        watershed.. . rm. -. 1
      else [potential],[potential],1,3,255
      fi
      nm. colors
      if {narg($baseview)} rm[baseview] fi
    fi

    # Manage replace color mode.
    if {!narg($replace_color)" && "narg($points_replaced)}
      rm[points,colors,view] nm[colors_replaced] colors nm[points_replaced] points current_replace_color=
    elif {narg($replace_color)" && "['$__color']!=['$current_replace_color']}
      if {narg($colors_replaced)} rm[colors_replaced,points_replaced] fi
      current_replace_color=$__color
      if {points,w}
        +replace_color[colors] 0,0,$replace_color,$current_replace_color
        +rows[points] 3,5 permute. xzcy -. 1
        replace_color. 0,0,$replace_color,$current_replace_color
        +. 1 permute. xcyz +j[points] .,0,3 rm..
      else 0 0
      fi
      nm.. colors_replaced
      nm. points_replaced
      if {narg($baseview)} rm[baseview] fi
    fi

    # Render base image.
    if {!narg($baseview)}
      nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
      nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
      +z[img] $x0,$y0,$x1,$y1
      r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
      if {narg($replace_color)" && "{points,w}} icolors=$colors_replaced else icolors=$colors fi
      +z[$icolors] $nx0,$ny0,$nx1,$ny1
      r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
      if $1 *.. -1 +.. 255 channels.. -3,0 blend. ..,alpha rm..
      else rgb2ycbcr. j. ..,0,0,0,0 rm.. ycbcr2rgb.
      fi
      nm. baseview
      if {narg($view)} rm[view] fi
    fi

    # Render view.
    if {!narg($view)}
      [baseview] r. 100%,100%,1,3
      if {$contrast<9} /. {10-$contrast} +. {128*(1-1/(10-$contrast))} fi
      if $view_markers
        if {$view_markers==2} rad1=5 rad2=3 else rad1=3 rad2=2 fi
        if {narg($replace_color)" && "{points,w}} ipoints=$points_replaced else ipoints=$points fi
        repeat {$ipoints,w}
          +columns[$ipoints] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} col={i[3]-1},{i[4]-1},{i[5]-1} rm.
          circle. $x,$y,$rad1,1,0 circle. $x,$y,$rad2,1,$col
        done
      fi

      if {narg($replace_color)}
        to. "Replace      by",5,5,20,2
        rectangle. 80,8,111,25,1,0 rectangle. 82,10,109,23,1,$replace_color
        rectangle. 150,8,181,25,1,0 rectangle. 152,10,179,23,1,$current_replace_color
      fi

      nm. view
      w[view] $ww,$wh,0,$title
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}

  # Recompute colors at full resolution.
  if {narg($view)} to[view] "Processing fullres...",5,5,20,2 w[view] fi
  k[0,img,points]
  N={points,w} status=
  if $N
    status={points,^}
    [img] __x_colorize. $1
    pointcloud[points] -1,$w,$h
    +compose_channels[points] max !=. 0 distance. 1 *. 0.02 +. 1 ^. -1 +[potential,-1]
    if {!$1} zfact={{img,max(w,h)}/{potential,max(w,h)}} dilate[points] {int(3*$zfact)} fi
    watershed[points] [potential] -[points] 1 nm[points] colors
  else [img],[img],1,3,255 nm. colors
  fi

  if $3 # Multichannels output.
    k[0,colors] a c
  else # Merge for single layer output.
    k[0,img,colors]
    if $1 +*[img] -1 +. 255 channels. -3,0 blend[colors,-1] alpha rm[0,img]
    else rgb2ycbcr[colors] j[colors] [img],0,0,0,0 rm[0,img] ycbcr2rgb[colors]
    fi
  fi
  a c nm $name

  __color=-1 # Force color selectors to close.
  u $status  # Return control points.
  w 0

# Compute potential function.
__x_colorize :
  if $1 # Potential for lineart.
    n. 0,1 ^. 5 repeat 4 +b. 0.5% min done
  else  # Potential for generic grayscale image.
    gradient_norm. n. 0,255 normalize_local. 3,3 *. -1 n. 0,255
    b. 0.05% n. 0,1 sqr. +b. 0.5% n[-2,-1] 0,1 min[-2,-1]
  fi
  nm. potential

#@cli x_connect4
#@cli : Launch the Connect Four game.
x_connect4 :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Connect Four"$n" --------------------------------------------\n
----\n
---- Connect four tokens in a row, column or diagonally\n
---- to win the game.\n
----\n
---- "${c}"Left mouse button"$n" on a column inserts a new token.\n
---- Keys '"${c}"SPACE"$n"' or '"${c}"ENTER"$n"' lets the computer play the turn\n
---- (or restart game when it's over).\n
---- Key '"${c}"ENTER"$n"' also enables autoplay for the current player.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' close the window.\n
----\n
----------------------------------------------------------------"
  v - l[]

  # Create sprite graphics.
  7,6 nm. board
  R={board,u={*,u};v={*,v};int(0.5*min(u/w,v/h))}

  {2*$R},{2*$R} circle. 50%,50%,32%,1,1 b. 2% g. xy +[-2,-1] n. 0,1
  +n. -1,0.5 abs. negate. +f. 200 rv[-3--1] a[-3--1] c hsv2rgb.
  to_rgba. circle. 50%,50%,27%,1,0

  {4*$R},{4*$R} circle. 50%,50%,20%,1,1 b. 1% g. xy +[-2,-1] n. 0,1 negate.
  pow. 0.5 +n. -1,0.8 abs. negate. +f. 10 rv[-3--1] a[-3--1] c
  . sh. 0 f. 60 rm. hsv2rgb[-2,-1]
  100%,100% circle. 50%,50%,30%,1,255 a[-3,-2] .,c rm.

  r2dx[-3--1] $R s[-3--1] c,-3 rm...
  n[^0] 0,255 round[^0] nm[^0] cache,cachem,token0,token1,tokenm
  +b[cachem] 2% shift. 1%,1%,0,0,2 max[cachem,-1]
  r[cache,cachem] 100%,{board,h*100}%,1,100%,0,2

  # Define board evaluation function.
  evalf="const op = 3 - p;
         case(dx,dy) = (
           pgood = pbad = 0;
           for (k = -2, k<2, ++k,
             X = x + k*dx;
             Y = y + k*dy;
             if (X>=0 && X<w && Y>=0 && Y<h,
               val = i(X,Y);
               if (pgood>=0 && val==op, pgood = -1, pgood+=!!val);
               if (pbad>=0 && val==p,  pbad = -1, pbad+=!!val);
             );
           );
           pgood = arg(2+pgood,0,1,2,4,100,1e8);
           pbad = arg(2+pbad,0,1,2,4,10000,1e8);
           pgood - pbad;
         );
         case(1,0) + case(0,1) + case(1,1) + case(1,-1)"

  # Start game.
  do

    # Initialize game.
    if {!narg($visu)}
      {board,[w,h]*$R},1,3,64
      repeat {board,h},y repeat {board,w},x
        val={board,i($x,$y)} if $val j. [token{$val-1}],{$x*$R},{$y*$R},0,0,1,[tokenm],255 fi
      done done
      +r[cache,cachem] {board,[w,h]*$R},1,100%,0,2 a[-2,-1] c blend[-2,-1] alpha
      nm. visu w[visu] 100%,100%,0,"[G'MIC] Connect Four"
      turn=0 is_falling=0 x=-1 yv=0 dyv=0 winner=
      autoplayer0=0 autoplayer1=0
    fi

    # Estimate ymax for each column.
    if {!narg($ymax)}
      i[ymax] {board,w},1,1,1,"y=-1; for (k = 0, k<h#"$board", ++k, if(!i(#"$board",x,k),y = k)); y"
      if {iM<0} winner=-1,-1,-1 fi # Draw game
    fi

    if {narg($winner)} # End of game animation
      i[tmpvisu] [visu]
      x={arg(1,$winner)} y={arg(2,$winner)} c={arg(3,$winner)}
      if {$x<0} # Draw game
        if {!narg($text)}
          0 t. "Draw game",0,0,57,1,1 r2dx. {tmpvisu,w/2} expand_xy. 3,0 +dilate. 5 n.. 0,255 to_rgb..
          nm[-2,-1] text,textm
        fi
        j[tmpvisu] [text],{tmpvisu,([w,h]-[w#$text,h#$text])/2},0,0,{0.7+0.3*sin(5*$|)},[textm]
      else
        repeat 4
          [token$turn]
          rgb2hsv. sh. 1,2 +. {0.4*sin(5*$|)} c. 0,1 rm. hsv2rgb.
          j. [cache],0,0,0,0,1,[cachem],255
          j[tmpvisu] .,{$R*[$x,$y]},0,0,1 rm.
          x+={$c!=2?1:0} y+={$c==1?0:$c==4?-1:1}
        done
      fi
      w[tmpvisu] 100%,100% rm[tmpvisu] wait 20

      if {{*,-SPACE}" || "{*,-ENTER}} # Restart new game
        rm[visu,ymax] f[board] 0 winner=
      fi

    elif {!$is_falling} # Manage column selection

      if {!${autoplayer$turn}}
        x={visu,X={*,x};X<0?X:int(X*w#$board/w)}
        yM={i("#"$ymax,$x)}
        if {board,$x<0" || "$x>=w} w[visu] 100%,100%
        else
          [visu] $R,100%,1,3,($yM>=0?1:0)*($turn?[255,255,0]:[255,0,0])
          j.. .,{$x*$R},0,0,0,{$yM>=0?0.15:0.3} rm.
          w. 100%,100% rm.
        fi
        wait
      fi

      if {{*,-b}&1" && "$yM>=0" && "$x>=0} is_falling=1 yv=0 dyv=1 # Manual play
      elif {${autoplayer$turn}" || "{*,-SPACE}" || "{*,ENTER}} # Computer play
        if {*,-ENTER} autoplayer$turn=1 fi
        max_score=-inf max_col=
        repeat {board,w},move1
          yM1={i("#"$ymax,$move1)}
          if {$yM1>=0}
            +=[board] {1+$turn},$move1,$yM1 nm. board1
            i[ymax1] {board,w},1,1,1,"y=-1; for (k = 0, k<h#"$board1", ++k, if(!i(#"$board1",x,k),y = k)); y"
            opp_max_score=-inf opp_max_board={board,^}
            opp_turn={($turn+1)%2}
            repeat {board,w},move2
              yM2={i("#"$ymax1,$move2)}
              if {$yM2>=0}
                +=[board1] {1+$opp_turn},$move2,$yM2
                +f. "const p = 1 + "$opp_turn"; "$evalf score={is+u} rm.
                if {$score>$opp_max_score} opp_max_score=$score opp_max_board={^} fi
                rm.
              fi
            done
            rm[board1,ymax1]

            {board,[w,h,1,1]},$opp_max_board
            f. "const p = 1 + "$turn"; "$evalf score={is+u} rm.
            if {$score>$max_score} max_score=$score max_col=$move1 fi
          fi
        done
        x=$max_col is_falling=1 yv=0 dyv=1
      fi

    else # Manage token falling animation
      if {!narg($column)}
        $R,{board,h*$R},1,3,64
        repeat {board,h} v={board,i($x,$>)} if $v j. [token{$v-1}],0,{$>*$R},0,0,1,[tokenm],255 fi done
        nm. column
      fi

      yM={i("#"$ymax,$x)}
      [column]
      j. [token$turn],0,$yv,0,0,1,[tokenm],255
      j. [cache],0,0,0,0,1,[cachem],255
      i[tmpvisu] [visu]
      j[tmpvisu] ..,{$R*$x},0,0,0 rm.. w[tmpvisu] 100%,100%
      if {$yv>=$yM*$R}
        j[visu] [tmpvisu] is_falling=0
        =[board] {$turn+1},$x,$yM
        rm[ymax,column]

        # Check end of game.
        +f[board] "if (!i,0,
                      case_h = i==j(1) && i==j(2) && i==j(3);
                      case_v = i==j(0,1) && i==j(0,2) && i==j(0,3);
                      case_d1 = i==j(1,1) && i==j(2,2) && i==j(3,3);
                      case_d2 = i==j(1,-1) && i==j(2,-2) && i==j(3,-3);
                      case_h?1:case_v?2:case_d1?3:case_d2?4)"
        if {iM} winner={[xM,yM,i(xM,yM)]} # Player won !
        else turn={($turn+1)%2}
        fi
        rm.
      fi
      rm[tmpvisu]
      yv={min($yM*$R,$yv+$dyv)} dyv+={visu,h/100}
      wait 20
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 endl v +

#@cli x_fire
#@cli : Launch the fire effect demo.
x_fire : skip "${1=G\47MIC}"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Fire effect"$n" ------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
  v -

  # Init image data.
  i[0] 100,32 w[0] {[4.5*w,6.75*h]},0,"[G"{`39`}"MIC] Fire Effect"
  if {{*,w}<0.5*{*,u}} w[] {[{*,w},{*,h}]*1.5} fi
  i[1] (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) r[1] 256,1,1,3,3
  i[2] (0,0,0;0,0,0;1,1,1;0,1,0) *[2] 0.21
  text3d "$1",33,3,1
  mv. 3 c3d[3] n3d[3] *3d[3] 320 col3d[3] 255,205,130 db3d 0 f3d 300
  100,100 rand. 0,255 ellipse. 50%,50%,5,5,0,1,300 b. 10
  sharpen. 1000 shrink_xy. 1 n. 0,255 to_rgb. light3d . rm.

  # Start animation loop.
  angle=0
  do
    correlate[0] [2]                                 # Apply fire effect.
    {0,w},1 rand. 128,256 j[0] .,0,{{0,h}-1} rm.     # Add new random values at the bottom line.
    +r[0] 400,200,1,1,3 map. [1]                     # Map fire palette
    +r3d[3] 0,1,0,$angle j3d.. .,50%,50%,0,1,5,0,0   # Draw 3D object.
    *3d. 0.25,0.16,1 j3d[0] .,50%,50%,0,1,3,0,0
    rm.
    angle+=3                                         # Update 3D angle.
    fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-22},16,1,0.2 fi
    w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {1.5*[w,h]} elif {{*,CTRLLEFT}&&{*,C}} w[] {[w,h]} fi
    rm. wait 40
  while {{*}" && "!{*,ESC}" && "!{*,Q}}

  # Exit properly.
  rm[0-3] w 0
  v +

#@cli x_fireworks
#@cli : Launch the fireworks demo.
x_fireworks :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Fireworks"$n" --------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------"
  v - l[]
  (16;64^64;32^128;32) r 320,160,1,3,3             # [-2] = Background (color gradient).
  .                                                 # [-1] = Rendered image.
  w. {1.5*w},{1.5*h},0,"[G"{`39`}"MIC] Fireworks"  # Display window.
  time=0
  do                                               # Start animation loop.
    time-=1
    if {$!==2\ ||\ $time<0} # Insert new rocket.
      i[0] ({u(w)},\        # X-position
            {h},\           # Y-position
            {u(-3,3)},\     # X-velocity
            {u(2)-5},\      # Y-velocity
            {30+u(20)},\    # Time of explosion
            1.5,\           # Radius
            255,255,255)    # Color
      time={u(20)}           # Elapsed time until next rocket.
    fi
    *. 0.99                 # Create fading effect with previous frames.
    j. ..,0,0,0,0,0.2       # Add background.
    i=0
    repeat {$!-2}
      to_be_removed=0
      radius={if({$i,@4}>0,{$i,@5}/3,{$i,@5}*(1+2*({$i,@4}+2)/120))}
      ellipse. {$i,@0},{$i,@1},{$i,@5},{max(0.5,$radius)},{atan2({$i,@3},{$i,@2})*180/pi},0.6,{$i,@6-8}  # Draw rocket.
      ({$i,@2},{$i,@3},0,0.09,-1,0,0,0,0) +[$i,-1] # Compute new position of the rocket.
      if {{$i,@0}<0\ ||\ {$i,@0}>=w\ ||\ {$i,@1}>=h\ ||\ $radius<0} to_be_removed=1 fi # Discard if rocket disappear.
      if {{$i,@4}<0\ &&\ {$i,@4}>=-1} # In case of explosion -> Split current rocket into several colorful rockets.
        color={min(255,80+u(200))},{min(255,80+u(200))},{min(255,80+u(200))}
        radius={u(10)}
        N={5+u(10)}
        repeat $N
          angle={$>*2*pi/$N}
          i... ({$i,@0,1},{2*cos($angle)+{$i,@2}/1.5},{2*sin($angle)+{$i,@3}/1.5},-2,$radius,$color)
        done
        to_be_removed=1
      fi
      if $to_be_removed rm[$i] else i+=1 fi  # If processed rocket has to be removed.
    done
    fps=${-fps} if {$fps>0} to. $fps" fps",3,{h-20},14,1,0.2 fi
    w. wait 20  # Display rendered frame.
    if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 endl v +

#@cli x_fisheye
#@cli : Launch the fish-eye effect demo.
x_fisheye :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Fish-eye effect"$n" --------------------\n
----\n
---- "${c}"Mouse pointer"$n" moves fish-eye center.\n
---- "${c}"Mouse buttons"$n" set fish-eye size.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
  v -
  if {$!>0} a x n 0,255 r2dy 220 else
  120,90,1,3 rand. 0,255 plasma. 0.3,3 n 0,255
  t "  G\47MIC\nFISH-EYE\n EFFECT",20,13,23,1,255 scale3x b 5 sharpen 1000
  f i+150-3*abs(y-h/2) c. 0,255 frame_fuzzy. 15,10,15,1.5,0 to_rgb.
  fi
  torus3d 20,6 col3d. {u(30,255)},{u(30,255)},{u(30,255)} +r3d. 1,0,0,90
  col3d. {u(30,255)},{u(30,255)},{u(30,255)} +3d. 15 +3d[-2,-1] *3d. 4 db3d 0 c3d.
  R=30
  w.. {1.25*{-2,w}},{1.25*{-2,h}},0,"[G"{`39`}"MIC] Fish-Eye Effect"
  do
    wait 40
    if {{*,b}==1} R={min(80,$R+8)} fi
    if {{*,b}==2} R={max(3,$R-8)} fi
    +j3d.. .,{50+30*cos($|*2.5)}%,{50+30*sin($|*1.6)}%,{80+230*sin($|*2.6)},0.7,3,0,0 r3d.. 1,0.2,0.6,3
    if {{*,x}>=0}
    fisheye. {{*,x}*100/{*,w}},{{*,y}*100/{*,h}},$R
    fi
    w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
    rm.
    if {{*}==0" || "{*,ESC}" || "{*,Q}} rm[-2,-1] w 0 v + return fi
  while 1

#@cli x_fourier
#@cli : Launch the fourier filtering demo.
x_fourier :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Fourier-filtering"$n" ----------------------------------------\n
----\n
---- "${c}"Mouse buttons"$n" on the right image to set min/max frequencies.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------------"
  v -
  if {!$!} sp ? r2dx 400 fi

  repeat $! l[$>]

    # Init variables.
    need_update=1  # need_update (boolean)
    freqmin=0      # min freq. (in %)
    freqmax=100    # max freq. (in %)

    if {w>3*{*,u}/5} r2dx. {3*{*,u}/10} fi  # Reduce image size if necessary.
    if {h>3*{*,v}/5} r2dy. {3*{*,v}/5} fi

    # Compute fourier transform.
    +fft. nm.. real nm. imag

    # Generate log-magnitude image.
    +sqr[real,imag] +[-2,-1] sqrt. +. 1 log.
    n. 0,255 shift. {round(w/2)},{round(h/2)},0,0,2 to_colormode. {-2,s}
    nm. logmag

    +r2dy. 128 frame. 1,1,0 nm. thumb
    w[0,-2] -1,-1,0,"[G"{`39`}"MIC] Fourier Filtering"

    l
    if {!narg($first_time)}
      parallel 0,"alert[thumb] \"[G"{`39`}"MIC Fourier Filtering]\",\
            \"The G\47MIC Fourier filtering demo illustrates the effect\n\
            of bandpass frequency filtering on an image. Use your mouse\n\
            buttons to select low and high bounds for the frequencies\n\
            displayed on the Fourier representation of the image\n\
            (right image).\",\
            \"OK\""
      first_time=0
    fi

    # Enter user event-loop.
    do

      if $need_update # If image must be updated.

        # Generated filtering mask.
        i[mask] [logmag],[logmag]
        r={sqrt(w^2+h^2)*$freqmax/200} ellipse[mask] 50%,50%,$r,$r,0,1,1
        r={max(0,sqrt(w^2+h^2)*$freqmin/200-1)} if $r ellipse[mask] 50%,50%,$r,$r,0,1,0 fi

        # Compute filtered log-magnitude.
        +*[logmag] [mask] +. [mask] /. 2 n. 0,255

        # Compute filtered fourier representation.
        shift[mask] -{mask,round(w/2)},-{mask,round(h/2)},0,0,2
        +*[real,imag] [mask]
        rm[mask]

        # Compute filtered image by inverse fourier.
        ifft[-2,-1] rm. n. 0,255

        # Display filtered image.
        rv[-2,-1]
        if {*} r[-2,-1] {{*,w}/2},{*,h} fi
        t. "Freq. Min/Max = "{int($freqmin)}"% / "{int($freqmax)}"%",5,5,13,1,255
        w[-2,-1] rm[-2,-1]
        need_update=0

      fi

      wait

      if {{*,b}" && "{*,x}>={*,w}/2}  # If mouse button pressed on the right pane.
        r={200*sqrt(({*,x}-3*{*,w}/4)^2+({*,y}-{*,h}/2)^2)/\ # Compute selected radius (in %).
           sqrt(({*,w}/2)^2+{*,h}^2)}
        if {{*,b}&1} freqmax=$r        # Update max freq. if left button.
        else freqmin={max(0,$r-3)}      # Update min freq. if other button.
        fi
        if {$freqmin>=$freqmax} freqmin=$freqmax fi   # Check that the min/max freq. are ordered.
        need_update=1                                      # Tell that the image must be updated.
      fi

      if {*,r} need_update=1 fi
      if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} need_update=1 fi # Increase window size.
      if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} need_update=1 fi # Decrease window size.
      if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {2*{0,w}},{0,h} need_update=1 fi         # Reset window size.

    while {{*}" && "!{*,ESC}" && "!{*,Q}}
    w 0
    endl
    rm[^0] # Clean images and window.
  endl done rm v +

#@cli x_grab_color : _variable_name
#@cli : Open a color grabber widget from the first selected image.
#@cli : Argument 'variable_name' specifies the variable that contains the selected color values at any time.
#@cli : Assigning '-1' to it forces the interactive window to close.
#@cli : Default values: 'variable_name=xgc_variable'.
x_grab_color : skip ${1=xgc_variable}
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  if {!$!} error[0--3] "Command '$0': Missing specified input image." fi
  v - l[0] nm={n} nm. img v +
  e[^-1] "Open "${arg\ {0,s},GRAY,GRAYA,RGB,RGBA}" color grabber widget for image$?, with variable name '$1'."
  v -

  if {!{*}} w[] ${fitscreen[]\ {w},{h},1,128,50%},0,0,-1,-1,"Grab a color" fi
  _x_grab_color +dilate. 3 nm. icon_mask *.. 255 to_rgb.. nm.. icon_sprite

  xc=5 yc=5 o$1=$$1

  cursor[0] 0
  do
    if {!narg($visu0)}
      +r[img] {*,w},{*,h},1,100%,2 drgba. w. nm. visu0
    fi

    x={*,x} y={*,y} b={*,b} mouse_over={$x>=0" && "$y>=0}
    hc={narg($$1)?40:24}
    yc={visu0,nhc=h-$hc-8;!$mouse_over?$yc:$y<$hc||$yc+$hc>=h?nhc:$y>=nhc?5:$yc}

    if {[0$ox,0$oy,0$ob,0$ohc,0$oyc,0$ocolor,0${o$1}]!=[$x,$y,$b,$hc,$yc,0$color,0$$1]}
      i[visu] [visu0]
      if {narg($color)}
        24,$hc,1,[img] fc. $color
        if {narg($$1)} rectangle. 0,24,100%,100%,1,$$1 line. 0,24,100%,24,1,0 fi
        drgba. frame. 1,1,0 frame. 1,1,255 j[visu] .,$xc,$yc rm.
        0
        if {narg($$1)}
          t. "Position ("$X","$Y")\nColor    ("{``$color}")\nSelected ("{``$$1}")",1,0,15,1,255
        else
          t. "Position ("$X","$Y")\nColor ("{``$color}")",1,0,15,1,255
        fi
        +dilate. 5 r.. 100%,100%,1,3
        j[visu] ..,{30+$xc},$yc,0,0,0.85,.,255 rm[-2,-1]
      fi

      if $mouse_over
        X={img,round($x*(w-1)/({*,w}-1))}
        Y={img,round($y*(h-1)/({*,h}-1))}
        color={img,round(I($X,$Y))}
        j[visu] [icon_sprite],$x,{icon_sprite,$y-h+1},0,0,1,[icon_mask]
        if {$b&1} $1=$color fi
      fi
      w[visu] rm[visu]

      ox=$x oy=$y ob=$b ohc=$hc oyc=$yc ocolor=$color o$1=$$1
    fi

    if {arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} wait 50 else wait fi
    if {*,r} w[] -1 rm[visu0] yc=5 v - fi
    if {['$$1']=='-1'} break fi # Close request

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w 0 k[img] nm $nm endl
  u $color
  v +

# Define color grabber icon.
_x_grab_color :
  base642img \
"MSB1bnNpZ25lZF9jaGFyIGxpdHRsZV9lbmRpYW4KMSAzMzcgMSAxICMyNzcKeJyNiNlOwlAYBi9IDDcaY+LGpiJbj7tBKEbglTQE7dcbkZS1gfNXFCxlK6"\
"WE83w+gDaaeG0mmWTm67NSea5s1Pz6Ot80tnrb/d3BnhkYBq3QKDyOTA5nmfqDnW2W5nK77Mj60yLXgZvrqm6Oq47MYWc4ZhnCJE2wrgjmBWFwRmr/hNQ3"\
"ZqivKQIlCN0YQZdeQGgxzXOD1T3XWEMhVWMtz1Wmw4h1QHEOShogqQc67YPOBwpdmgpdWzDSY9DNFJS1wWUH/NZF926FTl4oel48tgui3C6KUrMo7rWCYC"\
"vJg4k/fvp/5/dJq9QyuUy48UXMOZ5H7ah9ND2YRMbhUXgUsoLDgOnxsf++0/TX1zRf1fcNa0iPgw=="
  -. 127 decompress_rle.
  frame. 10,10,0
  r2dx. 24

#@cli x_hanoi
#@cli : Launch the Tower of Hanoi game.
x_hanoi :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Tower of Hanoï"$n" ---------------------\n
----\n
---- "${c}"Left button"$n" and "${c}"mouse"$n" to move a disk.\n
---- "${c}"Right button"$n" to rotate 3D view.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
  v - l[]
  l[] # Create 3D rods
    cylinder3d 1,10 r3d 1,0,0,90
    ++3d 10,0,0  +-3d.. 10,0,0
    box3d 30,1,10 -3d. 15,0,5
    +3d nm rods3d
    400,400 noise. 1 fftpolar. f.. 'r=sqrt((x-w/2)^2+.01*(y-h/2)^2);i/(1+r)' ifftpolar[-2,-1] n. 0,31
    (86,50,50;132,36,12;218,109,66;231,207,180;255,193,140) permute. yzcx r. 32,1,1,3,3
    map.. . rm. b. 2% b. x,1% sharpen. 100 c. 0,255
    r3d.. 1,0,0,-90 texturize3d.. . r3d.. 1,0,0,90 rm.
  endl

  l[] # Create 3D disks
    6,1,1,3,'[360*x/w,0.9*(1-(x/w)^0.5),0.9]' hsi2rgb.
    ytop0=0
    repeat {0,w}
      R,r={3-0.3*$>},{1.6-0.22*$>}
      torus3d $R,$r,36,10
      300,300 plasma. 1,1,3 b. 20 sharpen. 300 n. 150,255 1,1,1,3,{0,I[$>]} r. ..,..,1,3 rv[-2,-1] blend[-2,-1] luminance,0.75 # Marble texture
      texturize3d.. . rm.
      /3d. 1,1,{0.3+$r} r3d. 1,0,0,90 -3d. 0,0.8,0
      a$>,x$>,y$>,h$>=0,0,$ytop0,{1.8*$r/(0.3+$r)}
      ytop0+=${h$>}
      nm. disk3d$>
    done
    rm[0]
  endl

  w[] 640,400,0,"[G"{`39`}"MIC] Tower of Hano\357"
  1,3,1,3,'y==0?[32,128,100]:y==1?[64,16,0]:[0,0,0]' r. {*,w},{*,h},1,3,3 nm. background
  nb_moves,buttons,motion3d_x,motion3d_y=0
  x,rod,rod_source,rod_target,selected=-1
  fading=$| error=0
  do

    # Display 3D view for current game state.
    repeat 6 +r3d[disk3d$>] 1,1,1,${a$>} +3d. {10*(${x$>}-1)},-${y$>},0 done +3d[-6--1] +3d. [rods3d]
    r3d. 1,0,0,20
    if {!($buttons&2)} r3d. 0,1,0.3,{5*cos(1.5*$|)} r3d. 0.3,0,1,{3*sin(0.8*$|)} fi
    r3d. 1,0,0,$motion3d_y r3d. 0,-1,0,$motion3d_x *3d. 20
    [background] j3d. ..,50%,70%,10,1,5,0,1,800,200,0,-3000,0.15,0.2
    t. "#Moves: "$nb_moves,2%,92%,20,1,255

    if $error (255^0^0) r. .. j.. .,0,0,0,0,$error error={max(0,$error-0.2)} rm. fi
    if {$|-$fading<1}  *. {$|-$fading} fi
    w. wait 40
    if {{*,CTRLLEFT}&&{*,D}} w[] {w*1.5},{h*1.5} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
    rm[-2,-1]

    # Get index of top disk for each rod.
    top0,top1,top2,ytop0,ytop1,ytop2=-1
    repeat 6
      rod={round(${x$>})}
      if {$selected!=$>" && "${y$>}+${h$>}>${ytop$rod}} ytop$rod={${y$>}+${h$>}} top$rod=$> fi
    done

    # Manage user events.
    prev_buttons=$buttons
    mouse_x,mouse_y,buttons={*,x},{*,y},{*,b}
    if {$mouse_x>=0} x={2.6*($mouse_x/{*,w}-0.5)+1} rod={round($x)} fi

    if {$mouse_x>=0" && "$buttons&2} # Right mouse button
      motion3d_x,motion3d_y={([$mouse_x,$mouse_y]/[{*,w},{*,h}]-0.5)*90}

    elif {$mouse_x>=0" && "$buttons&1} # Left mouse button
      if {$selected<0} # Select a disk
        selected=${top$rod}
        rod_source={$selected<0?-1:$rod}
      fi
      if {$selected>=0" && "$rod>=0} # Move a selected disk
        if {${y$selected}<11} y$selected={min(11,${y$selected}+3)}
        else
          x$selected+={d=$rod-${x$selected};sign(d)*min(0.3,abs(d))}
          y$selected={x=${x$selected};11+1.5*sin(pi*abs(x-round(x)))}
          a$selected={x=${x$selected};45*sin(pi*abs(x-round(x)))}
        fi
      fi

    elif {!$buttons} # No mouse button
      if {$rod>=0" && "$selected>=0}
        if {$rod_target<0}
          if {${top$rod}<$selected} rod_target=$rod nb_moves+={$rod_target!=$rod_source} # Allowed move
          else rod_target=$rod_source error=0.8 # Forbidden move
          fi
        fi
        x$selected=$rod_target
        a$selected=0
        ytop={max(0,${ytop$rod_target})}
        if {${y$selected}>$ytop} y$selected={max($ytop,${y$selected}-3)}
        else x,rod,rod_source,rod_target,selected=-1
        fi
      fi
    fi

    if {!($buttons&2)} # Slowly go back to initial 3D view
      motion3d_x-={sign($motion3d_x)*min(1,abs($motion3d_x))}
      motion3d_y-={sign($motion3d_y)*min(1,abs($motion3d_y))}
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w[] 0 rm endl v +

#@cli x_histogram
#@cli : Launch the histogram demo.
x_histogram :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Histogram demo"$n" -------------------------------\n
----\n
---- "${c}"Mouse"$n" to set parameters.\n
---- "${c}"Right button"$n" or key '"${c}"SPACE"$n"' to reset.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
  v -
  if {!$!} sp ? to_rgb
  else k[0] to_rgb r2dy 300,2 if {w>800} r 800,100%,1,3,2 fi n 0,255
  fi

  # Prepare image layout.
  +frame. 1,1,0
  300,{h},1,3,220

  t. "Gamma :",5,0,16,1,0
  t. "Contrast :",5,50,16,1,0
  t. "Brightness :",5,100,16,1,0
  t. "Smoothness :",5,150,16,1,0
  t. "Sharpness :",5,200,16,1,0
  t. "Clusters :",5,250,16,1,0
  a[-2,-1] x
  {w},200,1,3,255
  grid. 10%,10%,0,0,0.3,0xCCCCCCCC,0
  rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
  axes. 0,255,1,0,13,1,0
  frame[-2,-1] 5,5,220
  a[-2,-1] y

  # Initialize variables.
  clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1

  # Start event loop.
  do

    # Render corrected image and insert it in canvas.
    [0]
    ia={ia}
    if $gamma /. 255 ^. {1/$gamma} *. 255 fi
    -. $ia *. $contrast +. $brightness +. $ia
    b. $smoothness
    sharpen. $sharpness
    c. 0,255
    +j.. .,6,6

    # Render parameter sliders.
    sx={{0,w}+12}
    _x_histogram. {$gamma*100/4} j.. .,$sx,25 rm.
    _x_histogram. {$contrast*100/4} j.. .,$sx,75 rm.
    _x_histogram. {($brightness+128)*100/256} j.. .,$sx,125 rm.
    _x_histogram. {$smoothness*100/10} j.. .,$sx,175 rm.
    _x_histogram. {$sharpness*100/2000} j.. .,$sx,225 rm.
    _x_histogram. {$clusters*100/256} j.. .,$sx,275 rm.

    # Render corresponding histogram.
    +s.. c histogram[-3--1] $clusters,0,255 /[-3--1] {6*{0,wh}/$clusters} rm[-5]
    +z[-4] 5,{0,h+16},{{-4,w}-5},{{-4,h}-6}
    graph. [-4],3,0,1,0,0.2,255,0,0
    graph. ...,3,0,1,0,0.2,0,255,0
    graph. ..,3,0,1,0,0.2,0,0,255
    rm[-4--2]
    j.. .,5,{0,h+16} rm.

    if {{*,b}&1\ &&\ {*,x}<{0,w}\ &&\ {*,y}<{0,h}}
      j. [0],6,6 to. Original,10,10,16
    fi

    # Display rendering.
    w. {w},{h},0,"[G"{`39`}"MIC] Histogram Demo" rm.
    wait

    # Manage user interactions.
    if {{*,b}&1\ &&\ {*,x}>={0,w}-10}
      if {{*,y}>=25\ &&\ {*,y}<=42}
        gamma={max(0,min(4,({*,x}-$sx)*4/280))}
      elif {{*,y}>=75\ &&\ {*,y}<=92}
        contrast={max(0,min(4,({*,x}-$sx)*4/280))}
      elif {{*,y}>=125\ &&\ {*,y}<=142}
        brightness={max(-128,min(128,({*,x}-$sx)*256/280-128))}
      elif {{*,y}>=175\ &&\ {*,y}<=192}
        smoothness={max(0,min(10,({*,x}-$sx)*10/280))}
      elif {{*,y}>=225\ &&\ {*,y}<=242}
        sharpness={max(0,min(2000,({*,x}-$sx)*2000/280))}
      elif {{*,y}>=275\ &&\ {*,y}<=292}
        clusters={max(2,min(256,({*,x}-$sx)*256/280))}
      fi
    fi
    if {{*,b}&2\ ||\ {*,SPACE}} clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1 fi
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w 0 rm v +

_x_histogram :
  val={max(0,min(100,$1))}
  280,2,1,3,255 line. 0,0,$val%,0,1,0,255,0 line. 0,1,$val%,1,1,240,255,62 r. 100%,16,1,3,3
  0 t. {round($val)}%,0,0,14,1,1 +*. -255 +. 255 r. 100%,100%,1,3
  j... .,{(280-w)/2},{(16-h)/2},0,0,1,.. rm[-2,-1]
  r. {w+2},{h+2},1,3,0,0,0.5,0.5

#@cli x_hough
#@cli : Launch the hough transform demo.
x_hough :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Hough-transform"$n" -----------------------------------------\n
----\n
---- "${c}"Mouse buttons"$n" on the vote image to draw corresponding line.\n
---- "${c}"Mouse buttons"$n" on the image to vote for all lines crossing.\n
---- the clicked point.\n
---- Key '"${c}"SPACE"$n"' to reset the hough window.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------------"
  v -
  if {!$!} l[] sp greece onfail testimage2d 400 endl fi
  n 0,255

  repeat $! l[$>]
    r. ${fitscreen\ {w},{h}},1,100%,3  # Resize to fit screen if necessary.
    if {!narg($first_time)}
      parallel 0,"+l[0] r2dy 128 frame 1,1,0 \
        alert \"[G"{`39`}"MIC Hough Transform]\",\
           \"The G\47MIC Hough transform demo illustrates the application\n\
           of the Hough transform to detect lines in an image. Use your\n\
           mouse buttons to explore the transform image and see how\n\
           lines in images are represented by points in the transform.\",\
           \"OK\" \
        rm endl"
      first_time=0
    fi

    rhomax={sqrt(w^2+h^2)/2}
    +b. 1.5 hough. 512,400 b. 0.5 +. 1 log. n. 0,255
    w.. -1,-1,0,"[G"{`39`}"MIC] Image" w1. -1,-1,0,"[G"{`39`}"MIC] Hough Transform"

    do
      wait

      if {*,b} # When clicking on the image.
        x0={{*,x}-{*,w}/2}
        y0={{*,y}-{*,h}/2}
        rho0={sqrt(($x0)^2+($y0)^2)}
        theta0={atan2($y0,$x0)}
        (0,{2*pi}) ($theta0,{$theta0-2*pi})
        r[-2,-1] {-3,w},1,1,1,3
        cos. *. $rho0 +<. 0 abs..
        *. {pi} +[-3,-1] %.. {2*pi}
        *.. {0.5*{-3,w}/pi} *. {{-3,h}/$rhomax}
        a[-2,-1] y
        repeat {w} point.. {i($>,0)},{i($>,1)},0,0.3,255 done
        rm. w1.

      elif {{*1,x}>=0" && "{*1,b}} # When clicking on the vote window.
        theta={{*1,x}*2*pi/{*1,w}}
        rho={{*1,y}*$rhomax/{*1,h}}
        x={{-2,w}/2+$rho*cos($theta)}
        y={{-2,h}/2+$rho*sin($theta)}
        x0={$x+1000*sin($theta)}
        y0={$y-1000*cos($theta)}
        x1={$x-1000*sin($theta)}
        y1={$y+1000*cos($theta)}
        ..
        line. $x0,$y0,$x1,$y1,1,0x0F0F0F0F,255
        line. {$x0+1},$y0,$x1,$y1,1,0x0F0F0F0F,255
        line. $x0,{$y0+1},$x1,$y1,1,0x0F0F0F0F,255
        line. $x0,$y0,$x1,$y1,1,0xF0F0F0F0,0
        line. {$x0+1},$y0,$x1,$y1,1,0xF0F0F0F0,0
        line. $x0,{$y0+1},$x1,$y1,1,0xF0F0F0F0,0
        w. rm.

      elif {{*,SPACE}" || "{*1,SPACE}}
        rm. +b. 1.5 hough. 512,400 b. 0.5 +. 1 log. n. 0,255
        w1. -1,-1,0,"Hough Transform"

      elif {*,r} w..
      elif {*1,r} w1.
      fi

    while {{*}" && "{*1}" && "!{*,ESC}" && "!{*,Q}" && "!{*1,ESC}" && "!{*1,Q}}
    w 0 w1 0
    rm. endl
    if {!{*}" || "!{*1}} break fi
  done rm v +

#@cli x_jawbreaker : 0<_width<20,0<_height<20,0<_balls<=8
#@cli : Launch the Jawbreaker game.
x_jawbreaker : check "${1=12}>0 && $1<20 && ${2=13}>0 && $2<20 && ${3=5}>0 && $3<=8"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Jawbreaker"$n" --------------------------------------------\n
----\n
---- The goal of the game is to "${c}"remove the maximum number of\n
---- balls on the board"$n", simply by clicking on them. But a\n
---- colored ball can disappear only if it is grouped with at\n
---- least one ball of the same color. The score is higher if\n
---- you destroy larger sets of connected colored balls.\n
----\n
---- "${c}"Left mouse button"$n" to select/destroy balls on board.\n
---- Key '"${c}"BACKSPACE"$n"' or '"${c}"SPACE"$n"' to undo the last move.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
  v -

  # Init images and variables.
  i[board] $1,$2 rand[board] 1,$3 round[board] 1
  i[undo] .
  i[balls] 40,40,1,4 _x_jawbreaker_ball.
  autocrop. 0 expand_xy. 1,0 *. 1.5 c. 0,255 r. {{board,w}*w},{{board,h}*h},1,1,0,2 /. 255
  i[back] {w},{h},1,3 l.
    rand 0,255 blur_xy 6,20 equalize 100,0,255 blur_xy 2,4
    sh 0 sh.. 1 sh... 2 /... 4 /.. 8 /. 2 rm[-3--1]
  endl
  i[visu] [back]
  score=0
  undoscore=0
  render_board=1
  shapescorey=0
  shapescore=0

  # Enter user-event loop.
  do

    # Render board graphics.
    if $render_board
      +abs[board] -. 1 *. {360/$3} +>=[board] 0 *. 0.9 +!=[board] 0
      r[-3--1] [balls] [balls] *[-2,-1] a[-3--1] c hsv2rgb.
      +compose_channels. + >. 0 dilate. 3
      j[visu] [back] j[visu] ..,0,0,0,0,1,. rm[-2,-1]
      if {!$shapescorey} w[visu] {back,w},{back,h},0,"[G"{`39`}"MIC] Jawbreaker (Score : "$score")" fi
      render_board=0
    fi

    # Add shape score sprite if necessary.
    if $shapescorey
      +t[visu] "+"$shapescore,{*,x},{{*,y}-64+$shapescorey},32,{($shapescorey-1)/31},255
      shapescorey={max(0,$shapescorey-1)}
      w. {back,w},{back,h},0,"[G"{`39`}"MIC] Jawbreaker (Score : "$score")" rm. wait 25
    else wait fi

    # Check for the end of the game.
    +f[board] "if(i,j(-1)==i || j(1)==i || j(0,1)==i || j(0,-1)==i,0)"
    if {!is} rm. break fi rm.

    # Manage user-events
    if {*,r} render_board=1                   # Will resize window to initial size, if resized.
    elif {*,S} o[visu] gmic_jawbreaker.png   # Save snapshot if requested.
    elif {{*,BACKSPACE}" || "{*,SPACE}}      # Manage undo move.
      abs[undo] j[board] [undo]
      score=$undoscore
      render_board=1

    elif {{*,x}">=0 && "{*,b}}               # Manage button click.

      # Retrieve board coordinates.
      wait -1
      x={"int("{*,x}"*"{board,w}"/"{*,w}")"}
      y={"int("{*,y}"*"{board,h}"/"{*,h}")"}

      # When selecting a ball -> display selection and init new shape score sprite.
      if {{board,i($x,$y)}>0}
        abs[board] flood[board] $x,$y,0,0,0,1,-{board,i($x,$y)}
        +>=[board] 0 -. 1
        shapescore={(is+1)^2} shapescorey={if($shapescore,32,0)} rm.

      # When confirming selection of a ball -> remove set of connected balls.
      elif {board,i($x,$y)}

        +flood[board] $x,$y,0,0,0,1,-1 ==. -1
        if {is>1} # If selected ball is connected to at least one ball.

          # Save undo state.
          j[undo] [board]
          undoscore=$score

          # Manage board shifts (vertical and horizontal).
          flood[board] $x,$y,0,0,0,1,0
          repeat {board,w}
            +columns[board] $> mirror. y
            h={board,h} l. s -,0 a y if $! r 1,$h,1,1,0 mirror y else i 1,$h fi endl
            j[board] .,$> rm.
          done
          rows[board] -1,100% f[board] "if(y==0,if(i(x,h-1),x,w),i)" sort[board] +,x rows[board] 1,100%

          # Update score.
          score+={int((is-1)^2)}

        fi
        rm. # Remove selection mask.

      else abs[board]  # Remove previous selection if clicked outside balls.
      fi

      render_board=1
    fi

  while {{*}" && "!{*,Q}" && "!{*,ESC}}

  # Game over.
  if {{*}" && "!{*,ESC}}
    w[] {visu,w},{visu,h},0,"[G"{`39`}"MIC] Jawbreaker (Final Score : "$score")"
    i[gameover] 260,85 t. "Game Over!",3,0,53,1,1 t. "Score : "$score,23,53,32,1,1
    +dilate. 5 nm. "mgameover" *.. 255 r.. 100%,100%,1,3
    repeat 25
      +r[gameover,mgameover] {400-12*($>+1)}%,{400-12*($>+1)}%
      +j[visu] ..,{({visu,w}-w)/2},{({visu,h}-h)/2},0,0,{$>/25},.
      w. rm[-3--1] wait 25
    done
    do
      wait if {*,r} w[] {*,w},{*,h} wait -1 fi
      while {{*}" && "!{*,Q}" && "!{*,ESC}" && "!{*,b}}
    rm[gameover,mgameover]
  fi

  # End properly.
  rm[board,undo,balls,back,visu]
  w 0 v +

_x_jawbreaker_ball :
  mwh={min(w,h)}
  sh 3 f. 0 rm.
  ellipse {0.5*$mwh},{0.5*$mwh},{0.5*$mwh-4},{0.5*$mwh-4},0,1,240,240,240,1
  sh 0,2 *. '($mwh+y-x)/(2*w)' rm.
  sh 3 *.. . dilate. 5 rm.
  sh 0,2 +. 'if(i&&(!j(-1)||!j(1)||!j(0,-1)||!j(0,1)),240/6,0)' rm.
  ellipse {$mwh*0.7},{$mwh*0.3},{min(30,$mwh*$mwh/512)},{min(30,$mwh*$mwh/512)},0,{min($mwh/64,1)},255,255,255,1

#@cli x_landscape
#@cli : Launch the virtual landscape demo.
x_landscape :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Virtual landscape"$n" -------------------------------------\n
----\n
---- Enjoy the view!\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
  v - l[]
  W=150 H=350

  # Generate global map + colors.
  900,900 plasma. 1,1,6 b. 0.07% n. 0,255 nm. map
  +g. *. 0.5 +[-2,-1] n. 0,1 ^. 2 n. -150,330
  equalize[map] 256 n[map] -400,160 c[map] 0,100% # Add water.
  (0,102,51;149,175,124;102,42,0;255,255,255) permute. yzcx srgb2rgb. r. 256,1,1,3,3 rgb2srgb. +n[map] 0,255 map. .. rm..
  +. .. rm.. c. 0,255 nm. colors # Colors.

  # Pre-compute some images used on each frame.
  $W,$H,1,1,'x' y. x nm. x # Increasing x.
  $W,$H,1,1,'1+x+y*w' y. x nm. offsets # Offsets (+1).
  $W,$H,1,1,'0.5*y' nm. gmap Mgmap={iM} # Z-increment for altitude map.
  $W,$H,1,3 fc. 60,80,135 nm. ccolors # Color for the horizon.
  $W,$H,1,1,'(y/$H)^2' nm. mcolors # Mask for the horizon.
  $W,400,1,1,'b=h-1-$Mgmap;if(y>=b,256+(y-b)*255/(h-1-b),y*255/b)' round. # Background.

  (96^16^128) (0^200^255) a[-2,-1] x r. 256,1,1,3,3
  (0^32^0) (0^64^128) a[-2,-1] x r. 256,1,1,3,3
  a[-2,-1] x map.. . rm.

  nm. background
  quadrangle3d[] -0.45,0,0,0.45,0,0,0.55,1,0,-0.55,1,0 *3d. {$W/2},{$H/2} nm. viewrange3d # View range.
  (64^16^0) r. $W nm. groundcolor # Ground color.

  # Start animation.
  w[] 600,400,0,"[G"{`39`}"MIC] Virtual Landscape"
  do

    # Get part of the map to display.
    t={$|*0.03}
    xm={map,w/2+(w-$H/2)/2*cos(3.1*$t)}
    ym={map,h/2+(h-$H/2)/2*sin(2.8*$t)}
    u={map,(w-$H/2)*cos(2.5*$t)}
    v={map,(h-$H/2)*sin(9.7*$t)}
    a={atan2($v,$u)*180/pi}
    +r3d[viewrange3d] 0,0,1,$a y. x
    ({$xm+i[8]},{$xm+i[11]};{$xm+i[17]},{$xm+i[14]}^{$ym+i[9]},{$ym+i[12]};{$ym+i[18]},{$ym+i[15]}) rm..
    r. $W,$H,1,2,3 +warp[map,colors] .,0,1,0 rm...
    nm.. lmap nm. lcolors

    # Add color shading and altitude to local maps.
    +!=[lmap] 0 nm. ground
    +[lmap] [gmap]
    j[lcolors] [ccolors],0,0,0,0,1,[mcolors]
    j[lcolors] [groundcolor]
    +round[lmap] f. '>m=abs(j(0,-1));i>m?i:-m' nm. y0  # Compute visible top points.
    +shift. 0,1 abs. +. 1 nm. y1 # Compute visible bottom points.
    *[y0,y1] [ground] rm[ground]
    r[lcolors,y0,y1] {$W*$H},1,1,100%,-1

    # Keep only visible primitives.
    +>[y0] 0 *. [offsets] discard. 0
    if {h} # There is something to display (ground).
      -. 1 +warp[x] .,0,0,0 nm. lx
      warp[lcolors,y0,y1] ..,0,0,0 rm..

      # Generate 3D object.
      N={h} ({'CImg3d'},{2*$N},$N)
      +a[lx] [y0],x rm[y0] +a[lx] [y1],x rm[lx,y1] a[-2,-1] y z. 0,2
      1,$N,1,1,2 +f. y ++. $N a[-3--1] x
      mv[lcolors] $! permute. cyzx
      1,$N,1,1,1
      y[-5--1] y a[-5--1] y *3d. -1,-1
      +j3d[background] .,{background,w-1},{background,h},0,1,1,0,0,0 rm[-3,-2]
    else # Case of nothing to display (only water).
      rm[-5--1] [background]
    fi

    r. {*,w},{*,h},1,3
    fps=${-fps} if {$fps>0} to. $fps" fps",5,5,24,2,0.2 fi
    w. -1,-1,0 rm.
    if {{*,CTRLLEFT}&&{*,D}} w[] 900,600 elif {{*,CTRLLEFT}&&{*,C}} w[] 600,400 fi
    wait 20
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 endl v +

#@cli x_life
#@cli : Launch the game of life.
x_life :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"The game of life"$n" --------------------------------------\n
----\n
---- The goal is to create the "${c}"biggest possible biological\n
---- system"$n". You start with a stock of cells which you can\n
---- spread over the board. For each new cells created\n
---- simultaneously and spontaneously by your system, you\n
---- gain more new cells to scatter.\n
----\n
---- "${c}"Left mouse button"$n" to scatter cells in stock.\n
---- "${c}"Right mouse button"$n" to reset game.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
  v -
  i[0] 90,90,1,1,0                                             # Image[0] = game state.
  i[1] [0] f[1] 0                                              # Image[1] = generation counter.
  i[2] 400,400,1,3                                             # Image[2] = visualization.
  i[3] 1                                                       # Image[3] = colormap (to be initialized).
  iteration=0                                                  # Iteration counter.
  score=0                                                      # Current score.
  bestscore=0                                                  # Best score.
  stock=500                                                    # Remaining cells.
  w[0] 400,400,0,"[G"{`39`}"MIC] The Game of Life"             # Initialize display window.
  cursor[0] 0

  # Start user-event loop.
  do
    (1,1,1;1,0,1;1,1,1) +correlate[0] .,0 rm..                # Count numbers of neighboring living cells.
    +ir. 2,2 &. [0] ir.. 3,3 -|[-2,-1]                        # Make the game evolve (kill or create cells).
    rv[0,-1]                                                  # Update game state.
    if {{*,x}>0" && "{*,b}==1" && "$stock>0}                  # Add random cells to the game if user presses mouse button.
      nb={u*7}
      repeat $nb
        x={{*,x}/{*,w}*{0,w}+u(-4,4)}
        y={{*,y}/{*,h}*{0,h}+u(-3,3)}
        =[0] 1,$x,$y
        =[1] $iteration,$x,$y
        point[2] {$x*{2,w}/{0,w}},{$y*{2,h}/{0,h}},0,0.8,255
      done
      stock={round(max(0,$stock-$nb))}
    fi

    -. [0] *. -1                                              # Compute difference between consecutive states.
    stock-={2*(min(0,int(is/16*$score/150)))}                 # Increment available cells if the evolution is fast.
    +[1] [0]                                                  # Increment generation counter for still existing cells.
    min. 0 +. 1 *[1,-1]                                       # Reset generation counter for died cells.

    if {{*,b}==2}                                             # Reset game if right mouse button has been pressed.
      f[0-2] 0 iteration=0 score=0 bestscore=0 stock=500 rm[3] i[3] 1
    fi

    if {{3,w}==1}                                             # Create color palette if necessary.
      rm[3] i[3] {u(3,12)},1,1,3,u(100,255)
      r[3] {u(100,300)}%,1,1,3,4
      point[3] 0,0,0,1,0
      r[3] {u(100,600)}%,1,1,3,5 c[3] 0,255
    fi

    +r[1] {2,w},{2,h} &. 7 b. {1+$score*0.05}                  # Render colored image of the game and display it.
    n. 0,{3,w} map. [3] *. 0.1 +[2,-1] /[2] 1.1
    [2] if {{*,x}>0}                                           # Add a small target icon at the mouse position.
      opac={0.7*min(1,$stock/500)} r={min(500,$stock)*cos($iteration)/100}
      ellipse. {*,x},{*,y},{15+$r},{15+$r},0,$opac,0,196,0
      ellipse. {*,x},{*,y},{10+$r},{10+$r},0,$opac,32,64,16
      ellipse. {*,x},{*,y},{5+$r},{5+$r},0,$opac,255,230,0
    fi
    t. "Living cells : "$score"\n"\                            # Add score description.
       "Stock : "$stock"\n"\
       "Score : "$bestscore,5,3,22,0.7,255
    w. {*,w},{*,h}
    if {*,S} o. gmic_life.png fi                               # Save snapshot if requested.
    rm.

    if {!($iteration%10)} score={0,is} bestscore={max($score,$bestscore)} fi  # Re-compute current and best scores, every 10th iterations.
    wait 60
    iteration+=1
  while {{*}" && "!{*,ESC}" && "!{*,Q}}

  # End game and quit properly.
  rm[0-3] w 0 v +

#@cli x_light
#@cli : Launch the light effect demo.
x_light :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Light effect"$n" ------------------------\n
----\n
---- Move light position with "${c}"mouse"$n".\n
---- "${c}"Mouse buttons"$n" fade light in/out.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
  v -

  # Create warping and color images.
  0 t. "    G\47MIC\nLight effect",0,0,80,1,255 expand_xy. 15,0 b. 3
  . n.. 0,1 r.. 100%,100%,1,3
  sh.. 0 *. 120 rm.
  sh.. 1 *. 70 rm.
  sh.. 0,50%,0,2 *. 120 rm.
  25%,25%,1,1 rand. -20,20 smooth. 10,0,1,1,4 r. ..,3 b. 3 n. -100,100
  +[-2,-1] g. xy a[-2,-1] c n. -150,150
  w[] {1.5*{-2,w}},{1.5*{-2,h}},0,"[G"{`39`}"MIC] Light Effect"  # Init display window.
  cursor[0] 0

  # Create a large light image.
  light=70
  640,640 gaussian. $light n. 0,255
  t=0

  # Start animation.
  do

    # Manage light position and intensity.
    if {{*,x}>=0}
      X={round((w-{*,x})/2)}
      Y={round((h-{*,y})/2)}
    else
      X={round((w-{-2,w}*(1+cos(2*$t)))/2)}
      Y={round((h-{-2,h}*(1+sin(2.5*$t)))/2)}
      t+=0.02
    fi
    if {{*,b}&1} light={min(200,$light+10)} gaussian. $light n. 0,255 fi
    if {{*,b}&2} light={max(10,$light-10)} gaussian. $light n. 0,255 fi

    # Render lightened image.
    +z. $X,$Y,{$X+{-2,w}-1},{$Y+{-2,h}-1}
    warp. ...,1,0,1
    r. 100%,100%,1,3 +. [-4] c. 0,255
    fps=${-fps} if {$fps>0} to. $fps" fps",5,5,16,1,0.2 fi
    w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h}
    elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
    rm. if {{*,x}>=0" && "!{*,b}} wait else wait 20 fi
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w[] 0 rm[-3--1] v +

#@cli x_mandelbrot : _julia={ 0 | 1 },_c0r,_c0i
#@cli : Launch Mandelbrot/Julia explorer.
x_mandelbrot : skip ${1=0},${2=0.317},${3=0.03}
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Mandelbrot/Julia explorer"$n" -----------------\n
----\n
---- Select zooming region with "${c}"mouse"$n".\n
---- "${c}"Click once"$n" to reset zoom factor.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
---- Key '"${c}"C"$n"' to print current fractal coordinates.\n
----\n
--------------------------------------------------"

  # Init variables and display.
  v -
  rm w 512,512,0 _x_mandelbrot_coords $1 _x_mandelbrot_palette

  # Start event loop.
  do
    siz={min({*,w},{*,h})}                                                                     # Desired window dimension.
    $siz,$siz mandelbrot. {0,^},256,$1,{if($1,$2,0)},{if($1,$3,0)} map. [1]                    # Render fractal.
    if $1 w. $siz,$siz,0,"[G"{`39`}"MIC] Julia Set c=("{0,@0-1}")-("{0,@2-3}"), c0=($2,$3)"    # Display on window.
    else w. $siz,$siz,0,"[G"{`39`}"MIC] Mandelbrot Set c=("{0,@0-1}")-("{0,@2-3}")" fi
    w={w} h={h} round. select. 2                                                               # Get the user selection.

    if {i[0]>0}                                                                                # If valid selection found.
      M={max(i[3]-i[0],i[4]-i[1])}                                                             # Compute max dimension of selected rectangle.
      if {$M<5} _x_mandelbrot_coords $1 rm[1] _x_mandelbrot_palette mv. 1                      # If selection too small, reset the view,
      else ({{0,@0}+{@0}*({0,@2}-{0,@0})/$w};\                                                 # Else compute new fractal coordinates.
             {{0,@1}+{@1}*({0,@3}-{0,@1})/$h};\
             {{0,@0}+({@0}+$M)*({0,@2}-{0,@0})/$w};\
             {{0,@1}+({@1}+$M)*({0,@3}-{0,@1})/$h})
      fi
      rm[0] mv. 0                                                           # Validate new coordinates.
    fi
    rm.                                                                     # Delete latest rendering.
    if {{*,C}}                                                              # If 'C' key has been pressed.
      if $1 v + e[0--4] "Julia set, at c = ("{0,@0-1}")-("{0,@2-3}"), with c0 = ($2,$3)." v -
      else v + e[0--4] "Mandelbrot set, at c = ("{0,@0-1}")-("{0,@2-3}")." v -
      fi
    fi
    if {!{*}" || "{*,ESC}" || "{*,Q}} rm w 0 v + return fi
    wait -1
  while 1

_x_mandelbrot_coords :
  if $1 (-2;-2;2;2) else (-2.1;-1.5;1.2;1.5) fi

_x_mandelbrot_palette :
  6,1,1,3 rand. 20,255 r. 32,1,1,3,3 r. 1024,1,1,3,0,2 =. 0,0,0,0,0 =. 0,0,0,0,1 =. 0,0,0,0,2

#@cli x_mask_color : _colorspace={ all | rgb | lrgb | ycbcr | lab | lch | hsv | hsi | hsl | cmy | cmyk | yiq },_spatial_tolerance>=0,_color_tolerance>=0
#@cli : Interactively select a color, and add an alpha channel containing the corresponding color mask.
#@cli : Argument 'colorspace' refers to the color metric used to compute color similarities, and can be basically one of { rgb | lrgb | ycbcr | lab | lch | hsv | hsi | hsl | cmy | cmyk | yiq }.
#@cli : You can also select one one particular channel of this colorspace, by setting 'colorspace' as 'colorspace_channel' (e.g. 'hsv_h' for the hue).
#@cli : Default values: 'colorspace=all', 'spatial_tolerance=5' and 'color_tolerance=5'.
x_mask_color : check "${2=5}>=0 && ${3=5}>=0" skip ${1=all}
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[^-1] "Interactively create color mask for image$?, with color space $1, spatial tolerance $2 and color tolerance $3."
  e[] "\n
----------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" adds a wanted color to the selection.\n
---- "${c}"Right mouse button"$n" adds an unwanted colors to the selection.\n
---- "${c}"Middle mouse button"$n" or key '"${c}"R"$n"' resets color mask.\n
---- Key '"${c}"SPACE"$n"' or '"${c}"TAB"$n"' toggles view modes (masked RGB or mask).\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
----------------------------------------------------------------------------------------------------"
  v - l[] _ac_$1 onfail error[0--3] "Command '$0' : Invalid colorspace '$*'." endl
  m _ac_forward:$_f
  repeat $! l[$>] slices 0 basename {0,n} nm=${}
    wh=${fitscreen\ {[w,h]},1,128,1024}
    +r $wh,1,100%,2
    +_ac_forward. channels. $_s
    if {1,s>3} channels[1] 0,2 fi to_rgb[1]

    w[1] 100%,100%,0,$nm
    colors_add=-1 colors_sub=-1 visumode=0
    is_clicked=0 time=0 delay=0.1
    do

      # Manage user events.
      time={$is_clicked?$time:$|}
      wait
      x={2,round({*,x}*(w-1)/({*,w}-1))}
      y={2,round({*,y}*(h-1)/({*,h}-1))}
      b={*,b}
      c=$x,$y,{2,I($x,$y)}
      is_add={arg(1,$colors_add)>=0}
      is_sub={arg(1,$colors_sub)>=0}
      is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
      is_resized=0
      refresh=0

      if {$x>=0" && "$b&1} # Add a color
        if $is_add colors_add=$colors_add,$c else colors_add=$c fi
        is_clicked=1
        refresh={$|-$time>$delay}
      elif {$x>=0" && "$b&2} # Subtract a color
        if $is_sub colors_sub=$colors_sub,$c else colors_sub=$c fi
        is_clicked=1
        refresh={$|-$time>$delay}
      elif {$b&4" || "{*,R}} # Reset colors
        colors_add=-1 colors_sub=-1 refresh=1 is_clicked=1
      elif {!$b}
        refresh={$is_clicked==1}
        is_clicked=0
      fi
      if {{*,-TAB}||{*,-SPACE}} visumode={($visumode+1)%3} refresh=1 fi # Change visu mode
      if {*,r} is_resized=1
      elif {$is_ctrl" && "{*,-D}} w[] {1,1.25*[w,h]} is_resized=1
      elif {$is_ctrl" && "{*,-C}} w[] {1,0.8*[w,h]} is_resized=1
      elif {$is_ctrl" && "{*,R}} w[] ${fitscreen\ {0,[w,h]},1,128,1024} is_resized=1
      fi
      if $is_resized rm[1,2] +r {*,d},{*,e},1,3,2 +_ac_forward. channels. $_s refresh=1 fi

      # Refresh view.
      if $refresh
        _x_mask_color[2] {$2*w#2/w#0},$3,{``$colors_add},{``$colors_sub} delay=${}
        if {$visumode==0} +. 64 c. 0,255 +a[1,-1] c drgba. w. -1,-1,$nm" [half-masked]" rm.
        elif {$visumode==1} +a[1,-1] c drgba. w. -1,-1,$nm" [masked]" rm.
        else w. -1,-1,$nm" [mask]"
        fi
        rm.
        time=$|
      fi

    while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}

    # Rescale to original image dimensions.
    if {arg(1,$colors_add)>=0} ($colors_add) r. {2+s#2},{w/(2+s#2)},1,1,-1 +z. 0,1 *. '{(w#0-1)/(w#2-1)},{(h#0-1)/(h#2-1)}' j.. . colors_add={-2,^} rm[-2,-1] fi
    if {arg(1,$colors_sub)>=0} ($colors_sub) r. {2+s#2},{w/(2+s#2)},1,1,-1 +z. 0,1 *. '{(w#0-1)/(w#2-1)},{(h#0-1)/(h#2-1)}' j.. . colors_sub={-2,^} rm[-2,-1] fi
    rm[-2,-1] +_ac_forward channels. $_s
    _x_mask_color. $2,$3,{``$colors_add},{``$colors_sub}
    rm.. a c

  endl done
  uncommand _ac_forward
  v +

_x_mask_color : # Estimate color mask image.
  100%,100%
  is_add={arg(1,$3)>=0}
  is_sub={arg(1,$4)>=0}
  t0=$|
  if {$is_add" || "$is_sub}
    if $is_add ($3) r. {2+s#0},{w/(2+s#0)},1,1,-1 N_add={h} M_add={"M = vectorw(); for (k = 0, k<w, ++k, M[k] = med(crop(k,1)));M"} rm. fi
    if $is_sub ($4) r. {2+s#0},{w/(2+s#0)},1,1,-1 N_sub={h} M_sub={"M = vectorw(); for (k = 0, k<w, ++k, M[k] = med(crop(k,1)));M"} rm. fi
    f. "begin(
          const is_add = "$is_add";
          const is_sub = "$is_sub";
          const ss = sqrt(2)*$1;
          const sc = sqrt(2)*$2;
          colors_add = [ $3 ];
          colors_sub = [ $4 ];
          M_add = [ 0"$M_add"];
          M_sub = [ 0"$M_sub"];
          const N_add = 0"$N_add";
          const N_sub = 0"$N_sub";
          const siz = 2 + s#0;
          const siz2 = sqr(siz);
          sigma = vectorsiz(sc);
          sigma[0] = sigma[1] = ss;

          tensor(op) = (
            T = vectorsiz2();
            if (is_#op,
              for (k = 0, k<size(colors_#op), k+=siz, C = colors_#op[k,siz]-=M_#op; C*=sigma; T+=mul(C,C,siz));
              T/=1e-8 + N_#op;
              T+=eye(siz);
              T = inv(T);
            ); T
          );

          T_add = tensor(add);
          T_sub = tensor(sub);
        );
        P = [ x,y,I#0 ];
        pot_add = is_add?(C = P - M_add; exp(-dot(C,T_add*C))):1;
        pot_sub = is_sub?(C = P - M_sub; exp(-dot(C,T_sub*C))):0;
        pot_add - pot_sub"
    c. 0,1 n. 0,512 c. 0,255
  else f. 255
  fi
  u {$|-$t0}

#@cli x_metaballs3d
#@cli : Launch the 3D metaballs demo.
x_metaballs3d :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"3D metaballs"$n" ---------------------------------------\n
----\n
---- "${c}"Mouse button"$n" or '"${c}"SPACE"$n"' key to toggle rendering mode.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------"
  v - l[]
  100,100 noise. 100,1 plasma. 1,0,10 r. 512,320,1,3 n. 0,1 b. 4,0 n. 0,255
  mix_channels. (0.7,0,0;0,0.9,0;0,0,1.2) c. 0,255 l3d
  0
  24,24,24,1,'X=x-w/2;Y=y-h/2;Z=z-d/2;exp(-(X*X+Y*Y+Z*Z)/100)'
  72,72,72 M=8 mode=3
  s0=Dots s1=Wireframe s2=Flat s3=Flat-shaded s4=Gouraud-shaded s5=Phong-shaded
  repeat $M fx$>={2*g} fy$>={2*g} fz$>={2*g} done
  w[0] -1,-1,0,"[G"{`39`}"MIC] 3D Metaballs"
  do
    repeat $M
      x$>={w/2+0.5*(w-{2,w}-4)*cos(${fx$>}*$|)}
      y$>={h/2+0.5*(h-{2,h}-4)*sin(${fy$>}*$|)}
      z$>={d/2+0.5*(d-{2,d}-4)*sin(${fz$>}*$|)}
    done
    f[3] 0 repeat $M j[3] [2],{${x$>}-{2,w/2}},{${y$>}-{2,h/2}},{${z$>}-{2,d/2}},0,-1 done
    +r[3] 28,28,28,1,2 isosurface3d. 0.4 -3d. 12,12,12 *3d. 13 rv3d.
    r3d. 1,2,1,{100*$|}
    N={i[7]} (255,255,150;200,96,164;50,150,230) r. 3,$N,1,1,3 y. j.. .,0,{{-2,h}-4*$N} # Do some color tweaks.
    if {!$mode} circles3d.. 4 fi
    if {!{1,w}}
      0 t. ${s$mode},5,5,23,0.5,255,255,255 b. 0.7 n. 0,255
      +dilate. 3 +j[0] ..,5,3,0,0,1,.,255 mv. 1 rm[2,-2,-1]
    fi
    +j3d[1] ..,50%,50%,0,1,{if(!$mode,3,$mode)},0,0,300,0,0,-500,0.1,1.5
    fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-22},16,2,0.2 fi
    w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
    rm[-3--1] wait 20
    if {{*,b}||{*,SPACE}} mode={($mode+if({*,b}&2,-1,1))%6} wait -1 rm[1] i[1] 0 fi
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 endl v +

#@cli x_minesweeper : 8<=_width=<20,8<=_height<=20
#@cli : Launch the Minesweeper game.
x_minesweeper : check "${1=20}>=8 && $1<=30 && ${2=$1}>=8 && $2<=30"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Minesweeper"$n" -------------------------------------------\n
----\n
---- The goal is to "${c}"clear the minefield"$n" without detonating a\n
---- mine.\n
----\n
---- "${c}"Left mouse button"$n" to try clearing one square.\n
---- "${c}"Right mouse button"$n" to flag or unflag a square.\n
---- "${c}"Middle mouse button"$n" to reset mine field.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------\n"
  v -
  # Generate random mine field and player board.
  # Labels : 0=mine, 1=empty, 2='1-near', 3='2-near', ..., 9='8-near', 10=still unknown.
  $1,$2 noise. 30,2 ==. 1 nb_mines={is} (1,1,1;1,0,1;1,1,1) +convolve.. .,0 rm.. +. 1 ==.. 0 *[-2,-1] nm. field
  do x={round(u(w-1))} y={round(u(h-1))} while {i($x,$y)!=1} # Find a good starting point.
  +f[field] 11 =. 12,$x,$y nm. board

  # Generate sprite graphics.
  24,24,1,3,200 fc. 255,180,130
  ellipse. 12,12,4,4 line. 6,12,18,12 line. 12,6,12,18 line. 13,10,14,10,1,255 line. 13,11,14,11,1,255
  z. 1,1,{w-2},{h-2} frame. 1,1,0
  +fc. 230,250,255
  +t. "1",10,5,13,1,0,196,0 +t.. "2",9,5,13,1,0,128,0 +t... "3",9,5,13,1,0,0,255
  +t[-4] "4",9,5,13,1,255,0,0 +t[-5] "5",9,5,13,1,200,0,0 +t[-6] "6",9,5,13,1,150,0,0
  +t[-7] "7",9,5,13,1,128,0,0 +t[-8] "8",9,5,13,1,64,0,0
  +f. 'if(x<=1||y<=1||x>=w-2||y>=h-2,if(x<y,128,255),160+2*(y+x))'
  +polygon. 4,13,15,11,15,6,18,17,18,1,0 line. 12,15,12,6,1,255,0,0 polygon. 3,12,6,6,9,12,12,1,220,0,0
  rv[-2,-1]
  . 100%,100%,1,3 line. 6,14,10,18,1,0,200,0 line. 10,18,16,6,1,0,200,0 dilate. 2
  +channels. 1 n. 0,0.7 dilate. 3 j... ..,0,0,0,0,1,. rm[-2,-1]
  a[-13--1] x nm. sprites

  # Pre-calculate offsets and canvas for faster board rendering.
  (0,23;0,23^0,0;23,23) r. 24,24,1,2,3 r. {board,w*24},{board,h*24},1,2,0,2 nm. offsets
  .,.,1,3,255 frame. 1,1,0 frame. 23,23,255
  0 t. "Number of mines : "$nb_mines,0,0,18,1,100,200,255 negate. j.. .,{({-2,w}-w)/2},{{-2,h}-h-2} rm.
  nm. canvas

  # Start user interaction loop.
  failed=0 succeeded=0 nb_flags=0 started=0
  do

    # Render board.
    +*[board] 24 r. [offsets],[offsets] channels. 0,1 +. [offsets] +warp[sprites] .,0,0 rm..
    j[canvas] .,24,24 rm.

    # Wait for user's selection.
    wait -1
    if $failed
      0 t. "Game\nOver!",3,3,38,1,255 r. 100%,100%,1,4 sh. 3 dilate. 5 /. 2 rm.
      drop_shadow. 5,5,1 blend[canvas,-1] alpha
      0 t. "Boom! You failed!",0,0,18,1,100,255,255 r. {canvas,w},100%,1,3,0,0,0.5,0.5 negate. j[canvas] .,0,3 rm.
      do w[canvas] {w},{h} wait while {{*}" && "!{*,ESC}" && "!{*,Q}}
    elif $succeeded
      0 t. "Success!",3,3,38,1,255 r. 100%,100%,1,4 sh. 3 dilate. 5 /. 2 rm.
      drop_shadow. 5,5,1 blend[canvas,-1] alpha
      0 t. "Congratulations! ("{round($|-$tic)}" s)",0,0,18,1,255,100,255 r. {canvas,w},100%,1,3,0,0,0.5,0.5
      negate. j[canvas] .,0,3 rm.
      do w[canvas] {w},{h} wait while {{*}" && "!{*,ESC}" && "!{*,Q}}
    else
      +==[board] 10 nb_flags={is} rm.
      do
        if {!$started} tic=$| fi
        0 t. "Elapsed time : "{round($|-$tic)}" s / Flags : "$nb_flags,0,0,18,1,255,200,0 r. {canvas,w},100%,1,3,0,0,0.5,0.5
        negate. j[canvas] .,0,3 rm.
        wait 50
        x={int(({*,x}-24)/24)} y={int(({*,y}-24)/24)} b={*,b}
        w[canvas] {w},{h},0,"[G"{`39`}"MIC] Minesweeper"
      while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!$b}
    fi

    # Manage selected square.
    if {$x>=0\ &&\ $y>=0\ &&\ $x<{board,w}\ &&\ $y<{board,h}}
      if {$b&1}  # Try to clean square.
        started=1 val={field,i($x,$y)}
        if {$val==0} +==[field] 0 j[board] [field],0,0,0,0,1,. rm. failed=1  # Found a mine -> boom!
        elif {$val==1} +flood[field] $x,$y,0,0,1,1,-1 ==. -1 dilate. 3 j[board] [field],0,0,0,0,1,. rm. # Found an empty area.
        else =[board] $val,$x,$y # Close to one or several mines.
        fi
      elif {n={board,i($x,$y)};$b&2" && "n>=10" && "n<=11}
        =[board] {if({board,i($x,$y)}==11,10,11)},$x,$y # Flag or unflag a square.
      elif {$b&4} f[board] 10  # Reset minefield.
      fi
    fi

    if {$nb_mines==$nb_flags\ &&\ {board,iM}!=11} succeeded=1 fi  # Check if board is cleared.
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w 0 v +

#@cli x_minimal_path
#@cli : Launch the minimal path demo.
x_minimal_path :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Minimal path"$n" ------------------------------------------\n
----\n
---- "${c}"Click on two points"$n" to compute and display the minimal\n
---- path between those points. The ending point is then\n
---- chosen as the next starting point for another path.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
  v -
  if {!$!} sp ? fi
  n 0,200 round 1
  repeat $! l[$>]
    w[0] -1,-1,0,"[G"{`39`}"MIC] Select Starting Point P0"

    if {!narg($first_time)}
      parallel 0,"+l[0] r2dy 128 frame 1,1,0 \
        alert \"[G"{`39`}"MIC Minimal Path]\",\
           \"The G\47MIC minimal path demo illustrates how minimal paths\n\
           can be computed in images to detect and track edge points.\n\
           Use your mouse to select desired starting and ending points,\n\
           and see what is the minimal path computed between these points.\",\
           \"OK\" \
        rm endl"
      first_time=0
    fi

    +gradient_norm b. 1 f. exp(-i/10)
    to_rgb[0] +select[0] 0 P0={^}
    ellipse[0] {@0,1},3,3,0,1,255,0,255
    ellipse[0] {@0,1},3,3,0,1,0xFFFFFFFF,255,255,255
    rm.
    if {min($P0)>=0}
      p=1
      do
        w[0] -1,-1,0,"[G"{`39`}"MIC] Select Ending Point P"$p
        +select[0] 0
        if {{*,S}}
          rm.
          +to[0] "Saving snapshot...",5,5,13,1,1,255,255,255 w. rm.
          o[0] gmic_minimal_path.png
          wait -1
        else
          P1={^}
          ellipse[0] {@0,1},3,3,0,1,255,0,255
          ellipse[0] {@0,1},3,3,0,1,0xFFFFFFFF,255,255,255
          rm.
          if {min($P1)>=0}
            +to[0] "Processing...",5,5,13,1,1,255,255,255 w. rm.
            +minimal_path[1] $P0,$P1,1
            pointcloud. 0 *. 255 r. 100%,100%,1,[0],0,0,0,0,0,0.5 r. [0],0 -|[0,-1]
            P0=$P1 p+=1
          fi
        fi
      while {{*}" && "!{*,ESC}" && "!{*,Q}}
    fi
    rm[1] w 0
  endl done v +

#@cli x_pacman
#@cli : Launch pacman game.
x_pacman :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Pacman"$n" -----------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the "${g}"pacman"$n" game.\n
----\n
---- Move the pacman to eat all pacdots on the different levels.\n
---- Eating a pacgum makes pacman invincible for "${c}"10 seconds"$n",\n
---- which mean pacman can eat ghosts during this time.\n
---- Eating a ghost earns "${c}"100 pts"$n".\n
---- Eating a cherry earns "${c}"10 pts"$n".\n
---- Eating a strawberry earns "${c}"100 pts"$n".\n
---- Eating an orange earns "${c}"1000 pts"$n".\n
---- Eating a banana earns "${c}"5000 pts"$n".\n
----\n
---- "${c}"Arrow keys"$n" to control pacman.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
  v - l[]

  # Initialize characters gfx.
  m "_pacman_ghost_base_gfx : 31,19 circle. 15,15,15,1,1 31,12,1,1,'y<4+8*abs(cos(x*0.3+0.25*pi*$""1))' a[-2,-1] y"
  repeat 4
    _pacman_ghost_standard_gfx 255,0,0,$> nm. ghost0_$>
    _pacman_ghost_standard_gfx 0,255,222,$> nm. ghost1_$>
    _pacman_ghost_standard_gfx 255,184,222,$> nm. ghost2_$>
    _pacman_ghost_standard_gfx 255,184,71,$> nm. ghost3_$>
    _pacman_ghost_afraid_gfx $> nm. ghosta_$>
    _pacman_ghost_base_gfx $> r. 16,16,1,1,2 nm. ghostm_$>
    _pacman_ghost_standard_gfx 0,0,0,$> nm. ghostd_$>
    _pacman_pacman_gfx $> nm.. pacman_$> nm. pacmanm_$>
  done
  +channels[ghostd_0] 0 !=. 0 nm. ghostdm
  _pacman_cherry_gfx nm. fruit0 _pacman_strawberry_gfx nm. fruit1
  _pacman_orange_gfx nm. fruit2 _pacman_banana_gfx nm. fruit3
  20,2,1,3,200 nm. gate
  score0,score1,score2,score3,score4=10,100,1000,5000,"Argh!"

  repeat 5
    0 t. ${score$>},0,0,13,1,255,255,255 autocrop. 0 expand_xy. 1,0 +dilate. 3
    nm. scorem$> nm.. score$>
  done
  time4=255,255,255 time3=255,255,32 time2=255,128,32 time1=255,32,32
  repeat 11 0 t. $<" s",0,0,23,1,${time{min(4,round(($<+1)/2))}} nm. time$< done
  0 t. "Get Ready!",0,0,32,1,255 autocrop. 0 expand_xy. 4,0 +dilate. 8 r.. 100%,100%,1,3
  nm.. get_ready nm. get_readym
  0 t. "Game\nOver!",0,0,53,1,255 autocrop. 0 expand_xy. 4,0 +dilate. 8 r.. 100%,100%,1,3
  nm.. game_over nm. game_overm

  # Start game.
  score=0 level=-1 lives=3 is_quit=0
  do

    # Build new level if necessary.
    if {$level<0}
      _rlevel=33 _glevel=33 _blevel=255
      _pacman_map_level{((-$level-1)%6)+1} mw={w} mh={h} mw2={int(w/2)} mh2={int(h/2)}
      if {$level<-6} replace. 3,2 fi
      nm. map0 i[map] .

      # Precompute valid directions on each map point, and shortest path to the ghost's home.
      +shift[map] -1,0 +shift[map] 0,-1 +shift[map] 1,0 +shift[map] 0,1 a[-4--1] z !=. 1 nm. can_go
      +==[map] 1 100%,100% =. 1,$mw2,$mh2 distance. 1,..,3 rm..
      f. 'if(i==2,0,if(i==8,1,if(i==1,2,if(i==4,3,i))))' nm. path
      +==[map] 2 pacdots={is} rm.
      level={-$level}
    fi

    # Render board gfx.
    f[map] 'if(i>=4,0,i)' +==[map] 1 expand_xy. 1,0 r. 1600%,1600% erode. 9 b. 2
    g. xy abs[-2,-1] +[-2,-1] >=. 80% b. 2 n. 0,1 shrink_xy. 16
    +*. $_glevel +*.. $_blevel *... $_rlevel a[-3--1] c
    16,16,1,1,'x' +-[map] 1 max. 0 *. 16 r. 1600%,1600%
    16,16,1,1,'y' r[-3,-1] ..,0,2 +[-2,-1] a[-2,-1] c
    16,16,1,3 _pacman_pacdots_gfx _pacman_pacgum_gfx a[-3--1] y
    warp. ..,0,0 rm.. -|[-2,-1] r. 100%,{h+24},1,3,0,0,0,1
    t. "Lives :",10,0,24,1,255 t. "Score :",{w-140},0,24,1,255
    if $lives +r[pacman_2] 12,12,1,4,2 r. {100*$lives}%,100%,1,4,0,2 j.. .,90,7 rm. fi
    nm. visu
    w[visu] {visu,f=h<0.5*{*,v}?1.5:1;[w,h]*=f},0,"[G"{`39`}"MIC] Pacman" cursor[0] 0
    0 t. "Level "$level,0,0,64,1,1 autocrop. 0 expand_xy. 4,0 (0,255^0,255^0,0) +map.. . rm.. dilate.. 8
    nm. level_N nm.. levelm_N

    repeat 4 xg$>={16*$mw2} yg$>={16*$mh2+4*$>} dg$>=3 mg$>=0 done
    xp={16*10} yp={16*21} dp=-1 pacgum_timer=-1 fruit_timer=$| dying_pacman=0 is_get_ready=1
    xscore=0 yscore=0 nscore=0 oscore=0

    # Start game interaction.
    do

      # Display board graphics.
      t={int(6*$|)%4} left={if($pacgum_timer>=0,10-$|+$pacgum_timer,-1)}
      [visu]
      repeat 4
        mg=${mg$>} xg=${xg$>} yg={${yg$>}+24}
        if {$mg==0} j. [ghost$>_$t],$xg,$yg,0,0,1,[ghostm_$t]
        elif {$mg==1} t2={if($left>7,$t,if($left>3,int(12*$|)%4,int(24*$|)%4))} j. [ghosta_$t2],$xg,$yg,0,0,1,[ghostm_$t]
        elif {$mg==2} j. [ghostd_$t],$xg,$yg,0,0,0.8,[ghostdm]
        else j. [ghost$>_$t],$xg,$yg,0,0,{$mg-2},[ghostm_$t] j. [ghostd_$t],$xg,$yg,0,0,1,[ghostdm]
        fi
      done
      if $dying_pacman
        _pacman_pacman_gfx {$dying_pacman/2} rotate[-2,-1] {90*(abs($dp)-1)} j... ..,$xp,{24+$yp},0,0,1,.,255 rm[-2,-1]
        dying_pacman+=1
        if {$dying_pacman>64}
          if {$lives!=1} rm. break fi
          j. [game_over],{(w-{game_over,w})/2},{12+(h-{game_over,h})/2},0,0,{min(1,($dying_pacman-64)/50)},[game_overm],255
          rectangle. 90,7,101,18,1,0
        fi
      else
        +rotate[pacman_$t,pacmanm_$t] {90*(abs($dp)-1)} j... ..,$xp,{24+$yp},0,0,1,.,255 rm[-2,-1]
        if {$left>=0" && "($left>=5" || "$t<=2)} j. [time{round($left)}],{(w-{time0,w})/2-10},1 fi
      fi
      t. $score,{w-60},3,20,1,255
      if {$is_get_ready}
        j. [level_N],{(w-{level_N,w})/2},{12+(h-1.5*{level_N,h})/2},0,0,1,[levelm_N]
        if {int($|*4)%2} j. [get_ready],{(w-{get_ready,w})/2},{24+(h+{get_ready,h})/2},0,0,1,[get_readym],255 fi
      fi
      if {$oscore>0} j. [score$nscore],$xscore,$yscore,0,0,$oscore,[scorem$nscore],255 oscore-=0.04 yscore-=1 fi
      j. [gate],158,223,0,0,0.6
      w.
      if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h}
      elif {{*,CTRLLEFT}&&{*,C}} w[] {f=h<0.5*{*,v}?1.5:1;[w,h]*=f}
      fi
      rm.

      # Manage ghosts displacements and collisions.
      repeat 4
        xg=${xg$>} yg=${yg$>} dg=${dg$>} mg=${mg$>}

        if {max(abs($xg-$xp),abs($yg-$yp))<=8}            # Test collision between ghost and pacman.
          if {$mg==0" && "!$dying_pacman} dying_pacman=1  # Was in normal mode -> dying pacman.
            xscore=$xp yscore={$yp+12} oscore=1 nscore=4
          elif {$mg==1} mg=2 mg$>=$mg score+=100          # Was in invicibility mode -> dying ghost.
            xscore=$xp yscore={$yp+12} oscore=1 nscore=1
          fi
        fi
        if {$mg>=2" && "($xg>>4)==$mw2" && "($yg>>4)==$mh2} # Check if dying ghost has returned to home.
          mg+=0.01
          if {$mg>=3} mg=0 xg&=-2 yg&=-2 fi
          mg$>=$mg
        fi

        if {!($xg&15)" && "!($yg&15)} # Check if ghost can take a new direction.
          ({u},{u},{u},{u};0,1,2,3)
          if {$mg<2}
            =. {u(0.6,1)},{if($mg==0,dX0=$xp-$xg;dY0=$yp-$yg;if(abs(dX0)>abs(dY0),if(dX0>0,0,2),if(dY0>0,1,3)),\ # Try to chase pacman.
                                     dX1=$xp-$xg;dY1=$yp-$yg;if(abs(dX1)<abs(dY1),if(dX1>0,2,0),if(dY1>0,3,1)))} # Try to escape pacman.
            =. 0,{($dg+2)%4}
            if $is_get_ready =. 0.8,{path,i({$xg>>4},{$yg>>4})} fi
          else =. 1,{path,i({$xg>>4},{$yg>>4})} # If dying ghost, follow the best path to home.
          fi
          sort. -,x repeat 4 d={i($>,1)} if {can_go,i({$xg>>4},{$yg>>4},$d)} dg=$d break fi done rm. # Try directions until it matches.
          dg$>=$d
        fi
        u={D=${dg$>};(D==0)-(D==2)}
        v={D=${dg$>};(D==1)-(D==3)}
        xg$>={($xg+$u*(1+($mg==0)))%(16*$mw)}
        yg$>={($yg+$v*(1+($mg==0)))%(16*$mh)}
      done

      wait 22

      # Manage pacman displacement.
      if {!$dying_pacman}
        d={if({*,ARROWRIGHT},1,if({*,ARROWDOWN},2,if({*,ARROWLEFT},3,if({*,ARROWUP},4,$dp))))}
        if {!($xp&15)" && "!($yp&15)}
          i={map,i({$xp>>4},{$yp>>4})}
          if {$i==2} score+=10 pacdots-=1 # Pacdot eaten.
          elif {$i==3} pacgum_timer=$| repeat 4 if {!${mg$>}} mg$>=1 dg$>={(${dg$>}+2)%4} fi done  # Pacgum eaten.
          elif {$i>=4} score+={${score{$i-4}}} xscore=$xp yscore={$yp+12} oscore=1 nscore={$i-4} # Fruit eaten.
          fi
          =[map] 0,{$xp>>4},{$yp>>4}
          16,16,1,3 j[visu] .,$xp,{24+$yp} rm.
          d={if({can_go,i({$xp>>4},{$yp>>4},{abs($d)-1})},$d,$dp)}
          d={if({can_go,i({$xp>>4},{$yp>>4},{abs($d)-1})},$d,-abs($dp))}
          dp=$d
        else dp={if(abs($d-$dp)==2,$d,$dp)}  # Allow to turn back on non-integer locations.
        fi
        is_get_ready={if($dp>0,0,$is_get_ready)}
        u={($dp==1)-($dp==3)}
        v={($dp==2)-($dp==4)}
        xp={($xp+2*$u)%(16*$mw)}
        yp={($yp+2*$v)%(16*$mh)}

        if {$pacgum_timer>=0" && "$|>$pacgum_timer+10} # Check if pacgum still has some effect.
          repeat 4 xg$>&=-2 yg$>&=-2 mg$>={if(${mg$>}==1,0,${mg$>})} done
          pacgum_timer=-1
        fi

        if {!$is_get_ready" && "($|-$fruit_timer)>=10}
          x={round(u(0,{map0,w}))}
          y={round(u(0,{map0,h}))}
          if {!{map,i($x,$y)}" && "{map0,i($x,$y)}==2}
            n={min(3,int(abs(g*1.7)))} =[map] {4+$n},$x,$y j[visu] [fruit$n],{16*$x},{16*$y+24} fruit_timer=$|
          fi
        fi

      fi
      if {!{*}" || "{*,Q}" || "{*,ESC}} is_quit=1 fi

    while {!$is_quit" && "$pacdots}

    if $is_quit break         # Player asked to quit
    elif $pacdots             # Player lost a life
      lives-=1
    else                      # Player achieved level
      level={-$level-1} wait[0] -1
      rm[map0,map,can_go,path]
    fi
    rm[visu,level_N,levelm_N]
  while $lives
  rm w 0 endl v +

# The functions below create the various sprite gfx.
_pacman_ghost_standard_gfx :
  _pacman_ghost_base_gfx $4 (0,$1^0,$2^0,$3) map.. . rm.
  ellipse. 10,11,3,4,0,1,255 ellipse. 20,11,3,4,0,1,255
  r. 16,16,1,3,2 point. 5,{7-($4>=2)},0,1,1 point. 10,{7-($4>=2)},0,1,1

_pacman_ghost_afraid_gfx :
  _pacman_ghost_base_gfx $1
  if {$1<2} col=255,255,255 (0,0^0,0^0,208) else col=255,0,0 (0,248^0,248^0,248) fi
  map.. . rm. r. 16,16,1,3,2
  line. 4,4,6,6,1,$col,255 line. 4,6,6,4,1,$col,255
  line. 9,4,11,6,1,$col,255 line. 9,6,11,4,1,$col,255
  f. 'if(y>=9&&y<=10&&x>=2&&x<=13&&((int((x+1)/2)+y)%2),arg(c+1,$col),i)'

_pacman_pacman_gfx :
  32,32,1,1,'X=x-15;Y=y-15;A=atan2(Y,X);R=sqrt(X^2+Y^2);R<15.5&&abs(A)>0.8*0.33*$1'
  (0,255^0,255^0,0^0,255) map.. . rm. r. 16,16,1,4,2 s. c,-3

_pacman_pacdots_gfx :
  (255^184^151) r. 4,4,1,3 r. 16,16,1,3,0,0,0.5,0.5

_pacman_pacgum_gfx :
  16,16,1,3 circle. 7,7,7,1,255,128,64

_pacman_cherry_gfx :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNzYgMSAxIDEgIzU5CnicFYpBCgAxDALVXvv/p5ZtmsgmIMoM7k0Cx/ySYYIXrE5qOgTmE1KGloUW1pp1qVUqmkt3H"\
"j9Whx3SMSAyMCAxIDEgIzI2Cnicc/eNYkjPzUyONwACveTM3PQqBgA+VQX2"
  decompress_rle. (0,0,255,255^0,173,0,255^0,0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5

_pacman_strawberry_gfx :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNzIgMSAxIDEgIzYwCnicJYlJDoAwEMOyHOH/H+UANJ0RBaRIlp1tJ4HAd9HFaoUtTNWC1yIPWT5ew5em+lT994guK"\
"HgAoIoa8zEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
  decompress_rle. (0,0,255,255^0,173,0,255^0,0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5

_pacman_orange_gfx :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNDQgMSAxIDEgIzQ2CnicBcHBDQAgDAOxXPjC/gsxU4VKi7DnAukKPU6SYjTVptxhbSv8wpVufUwDEZ4xIDIwIDEgM"\
"SAjMjYKeJxz941iSM/NTI43AAK95Mzc9CoGAD5VBfY="
  decompress_rle. (0,0,255,255^0,173,173,255^0,0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5

_pacman_banana_gfx :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KNzAgMSAxIDEgIzQ4CnicNcqxDQAgDMTANx0S++8aIC9ShObceC6QQoSJ5Ai5vWW2WTI6xr+bvLU/BnUW3jEgMjAgM"\
"SAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
  decompress_rle. (0,255,255^0,173,255^0,0,255) map.. . rm. r2dy. 14 r. 16,16,1,3,0,0,0.5,0.5

_pacman_map_level1 :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjAxIDEgMSAxICM5Nwp4nGWOUQ6AMAhDKX56Be9/QnWJArEM9MdsGa9QYOsGiOy4FaZYHAo1aMezIJ+QJnszLsq2a"\
"Raf9Q9GiaBnGmEZhSe8wLOdVqO+My+cFdJj9OpVQ0vzRm8l/L954AHE9jnsMSAyMCAxIDEgIzI2Cnicc/eNYkjPzUyONwACveTM3PQqBgA+VQX2"
  decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
  _rlevel=33 _glevel=33 _blevel=255

_pacman_map_level2 :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjA4IDEgMSAxICMxMDAKeJxljkEOAzEIAxn32C/0/y+MdlUloAKJemgvjAOG+PkCs8ElHsjRQk0iycwS+/2jcuJln"\
"hhhf3SxPKWw9DaJmYsbmLOqmyaXn92UsVV9Y+sweOvb7YB1vQPPDnV4a/ABHS45BDEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
  decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
  _rlevel=200 _glevel=33 _blevel=33

_pacman_map_level3 :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjA5IDEgMSAxICMxMDEKeJxVTlsOwDAIAve5K+z+N+zStGomeyTdjwIKYT9IoHGAbpOgdQ3n1i1ZinHdnO+20FuKg"\
"3nf4WIO3YolP8QEQ75CEkoKaUIDT3K95w8OZbp4lDcMj1PNUjXyDg+u4LTGC5LiOwAxIDIwIDEgMSAjMjYKeJxz941iSM/NTI43AAK95Mzc9CoGAD5VBfY="
  decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
  _rlevel=33 _glevel=200 _blevel=255

_pacman_map_level4 :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjEwIDEgMSAxICM5MAp4nHVPQQ6AMAhr8egX/P8TN+cGGSy6TBMTQgqlUPaDBDINLBJZbMQHqmwq7e40eahgy8i/j"\
"DKB1QhlRWBzcPH09Rnr9ALTrHSOuN5N+IFF9LIY9uOPDitcQvExIDIwIDEgMSAjMjYKeJxz941iSM/NTI43AAK95Mzc9CoGAD5VBfY="
  decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
  _rlevel=200 _glevel=200 _blevel=33

_pacman_map_level5 :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMjA3IDEgMSAxICMxMDAKeJxdjlEKxCAMRPOmn3uF3v+ELXRrDE2qwrIgzPB8Mn52MDv4ihBbQyjQyuRBz96RF8NmS"\
"YAb98s65j95Wd0bFqxG1MNV/s1ealMujRHdI5wtf9X0WnWmFWO/7JmJXScPVxI1CjEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
  decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
  _rlevel=200 _glevel=255 _blevel=33

_pacman_map_level6 :
  base642img \
"MiBjaGFyIGxpdHRsZV9lbmRpYW4KMTgzIDEgMSAxICM5Mgp4nGVO0QqAQAhz67Ff6P+/sK66TNqJUBCozDHn5gUwW9EIBnhi2nmBPQmHCeMwDbuzBNCH1"\
"oZeDBEiPSWiAoXU8Yfhn4PyiNc1X3i99NwUJPMoVyVs3PAASqEr4jEgMjAgMSAxICMyNgp4nHP3jWJIz81MjjcAAr3kzNz0KgYAPlUF9g=="
  decompress_rle. +mirror. x z. 1,100% a[-2,-1] x
  _rlevel=255 _glevel=130 _blevel=233

#@cli x_paint
#@cli : Launch the interactive painter.
x_paint :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Interactive painter"$n" -----------------------\n
----\n
---- Use "${c}"mouse"$n" to select color and brush.\n
---- "${c}"Left button"$n" draws a colored stroke.\n
---- "${c}"Right button"$n" fills a colored region.\n
---- "${c}"Arrow keys"$n" or '"${c}"SPACE"$n"' and '"${c}"BACKSPACE"$n"' to swap\n
---- between available images.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------"
  v - to_rgb
  if {!$!} i[0] 512,512,1,3,255 nm[0] "[New image]" else k[0] fi
  1 # Brush image [-1]
  parallel "_x_paint[]","w[] 400,320,0,Palette x_select_color[] __color,0,0,0" k[0]
  v +

_x_paint :

  # Init variables.
  pass[-2,-1] 1 ({'{-2,n}'}) discard. {'~'} nm... {t} rm.
  __color={0,if(ia<128,vector3(255),vector3(0))}
  brushsize=1
  brushopacity=0
  brushangle=90
  brushthickness=1
  image=0
  refresh_image=1
  refresh_brush=1
  ox1=-1
  oy1=-1

  # Start user event loop.
  do

    # Open/refresh brush window.
    if $refresh_brush
      rm. (32,64;64,32) r. 16,16,1,3,1 r. {8*48},{4*48},1,3,0,2
      repeat 4,y repeat 8
        ellipse. {48*$>+24},{48*$y+24},{2*$>+1},{(2*$>+1)*$brushthickness},$brushangle,{1-$y/4},255
      done done
      rectangle. {$brushsize*48},{$brushopacity*48},\
                  {$brushsize*48+47},{$brushopacity*48+47},\
                  1,0xFFFFFFFF,255,128,128
      {w},16,1,3 line. 0,50%,100%,50%,1,0x55555555,128,64,128
      bx={$brushangle*w/180}
      rectangle. {$bx-16},20%,{$bx+16},80%,1,128
      line. {$bx-16},20%,{$bx+16},20%,1,255 line. {$bx+16},20%,{$bx+16},80%,1,255
      line. {$bx-16},80%,{$bx+16},80%,1,64 line. {$bx-16},20%,{$bx-16},80%,1,64
      a[-2,-1] y
      16,{h-16},1,3 line. 50%,0,50%,100%,1,0x55555555,128,64,128
      by={$brushthickness*(h-16)}
      rectangle. 20%,{$by-16},80%,{$by+16},1,128
      line. 20%,{$by-16},80%,{$by-16},1,255 line. 80%,{$by-16},80%,{$by+16},1,255
      line. 20%,{$by-16},20%,{$by+16},1,64 line. 20%,{$by+16},80%,{$by+16},1,64
      a[-2,-1] x
      w3. {w},{h},0,"Brush"
      refresh_brush=0
    fi

    # Open/refresh image window.
    if $refresh_image
      w1[$image] {$image,w},{$image,h},0,"Image "#$image" : "{$image,b}.{$image,x}
      refresh_image=0
    fi

    # Manage user events.
    x1={*1,x} y1={*1,y}
    x2={*2,x} y2={*2,y}
    x3={*3,x} y3={*3,y}

    if {$x1>=0}                        # Event in the image window.
      if {{*1,b}&1}                   # Left button -> draw brush stroke.
        ox1={if($ox1<0,$x1,$ox1)}
        oy1={if($oy1<0,$y1,$oy1)}
        delta={max(abs($x1-$ox1),abs($y1-$oy1))}
        r1={2*$brushsize+1}
        r2={$r1*$brushthickness}
        dx={2*($x1-$ox1)/max(1,$delta)}
        dy={2*($y1-$oy1)/max(1,$delta)}
        o={1-($brushopacity/4)^0.04}
        repeat {max(1,($delta+1)/2)}
          ellipse[$image] {$ox1+$>*$dx},{$oy1+$>*$dy},$r1,$r2,$brushangle,$o,$__color
        done
        ox1=$x1 oy1=$y1
        refresh_image=1
      else
        ox1=-1 oy1=-1
        if {{*1,b}&2}               # Right button -> fill region.
          flood[$image] $x1,$y1,0,10,0,1,$__color
          refresh_image=1
        fi
      fi
    fi

    if {{*1,ARROWRIGHT}" || "{*2,ARROWRIGHT}" || "{*3,ARROWRIGHT}" || "\  # Manage image selection.
         {*1,ARROWUP}" || "{*2,ARROWUP}" || "{*3,ARROWUP}" || "\
         {*1,SPACE}" || "{*2,SPACE}" || "{*3,SPACE}}
      image={($image+1)%($!-2)} refresh_image=1
    elif {{*1,ARROWLEFT}" || "{*2,ARROWLEFT}" || "{*3,ARROWLEFT}" || "\
           {*1,ARROWDOWN}" || "{*2,ARROWDOWN}" || "{*3,ARROWDOWN}" || "\
           {*1,BACKSPACE}" || "{*2,BACKSPACE}" || "{*3,BACKSPACE}}
      image={($image-1)%($!-2)} refresh_image=1
    fi

    if {*1,S} o[$image] gmic_paint.png fi  # Save snapshot if requested.

    if {{*3,b}" && "$x3>=0}  # Manage brush selection.
      if {$x3<384" && "$y3>=192} brushangle={$x3*180/(w-16)}   # Bottom slider -> select brush angle.
      elif {$x3>=384" && "$y3<192} brushthickness={$y3/(h-16)} # Right slider -> select brush thickness.
      elif {$x3<384" && "$y3<192} brushsize={int($x3*8/(w-16))} brushopacity={int($y3*4/(h-16))}
      fi
      refresh_brush=1
    fi
    wait
    while {{*1}" && "!{*1,Q}" && "!{*1,ESC}}

  # Exit properly.
  __color=-1 w1[] 0 w2[] 0 w3[] 0 rm[-2,-1]

#@cli x_plasma
#@cli : Launch the plasma effect demo.
x_plasma :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Plasma effect"$n" ----------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
  v - l[]

  # Init plasma backgrounds.
  N=8
  repeat $N
    320,200,1,3 rand. 0,255 plasma. 1,0,7 n. 0,255
    amp={u(-40,40)} freq={round(u(2,6))} dir$>={if(u<0.5,-1,1)*round(u(1,2))}
    100%,100%,1,1,'$amp*cos(y*2*pi*$freq/h)'
  done

  {w+2},100%,1,1,'x' 100%,100%,1,1,'Y=(y-80+15*cos(x/30)+10*sin(x/22));if(Y<0||Y>=50,-1,Y)' a[-2,-1] c
  0 t. "** Welcome to G\47MIC, a powerful image processing framework **",0,0,50,1,255
  b. 0.5 n. 0,255
  M={w}

  # Start animation loop.
  w[] {0,f=1.5*h<0.5*{*,v}?3:1.5;[w,h]*=f},0,"[G"{`39`}"MIC] Plasma Effect"
  t=0 tt={-1.5*{0,w}}

  do
    tic=$|

    # Render interpolated background between two successive plasmas.
    a={int($t)} a2={2*$a} a21={$a2+1}
    b={($a+1)%$N} b2={2*$b} b21={$b2+1}
    +warp[$a2] [$a21],1,0,2
    +warp[$b2] [$b21],1,0,2
    j.. .,0,0,0,0,{$t-$a} rm.

    shift[$a21] 0,${dir$a},0,0,2  # Animate plasma background.
    shift[$b21] 0,${dir$b},0,0,2
    if {int($t+0.005)>int($t)} dir$a={if(u<0.5,-1,1)*round(u(1,3))} fi
    t={($t+max(0.005,($|-$tic)))%$N}

    # Render text scrolling.
    +z.. $tt,{$tt+w-1+2}
    warp. [-4],0,0,0
    r. 100%,100%,1,3
    +*. -1 +. 255
    j... .,0,0,0,0,1,..,255 rm.
    j.. .,-2,-2,0,0,1,.,255 rm.

    tt+={max(2,($|-$tic)*250)} # Animate scrolling.
    if {$tt>=$M} tt={-1.5*{0,w}} fi

    # Display rendered frame.
    fps=${-fps} if {$fps>0} to. $fps" fps",5,5,16,1,0.2 fi
    w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
    rm. wait 20
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm[{-2*$N-2}--1] w[] 0 endl v +

#@cli x_quantize_rgb : _nbcolors>=2
#@cli : Launch the RGB color quantization demo.
x_quantize_rgb : check "isint(${1=16}) && $1>1"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"RGB Quantization"$n" --------------------------------------\n
----\n
---- This demo shows how RGB colors can be quantified using\n
---- the "${c}"k-means algorithm"$n".\n
----\n
---- "${c}"Left mouse button"$n" on 3D view rotates the color cube.\n
---- "${c}"Right mouse button"$n" on 3D view toggles colors/clusters mode.\n
---- "${c}"Left mouse button"$n" on image toggles dithering mode,\n
---- "${c}"Left mouse button"$n" on colormap adds a random color.\n
---- "${c}"Right mouse button"$n" on colormap removes a color.\n
---- Key '"${c}"R"$n"' init colormap with random values.\n
---- Key '"${c}"U"$n"' init colormap with uniform sampling.\n
---- Key '"${c}"M"$n"' init colormap with median-cut algorithm.\n
---- Key '"${c}"SPACE"$n"' does a single iteration of k-means and pauses.\n
---- Key '"${c}"ENTER"$n"' runs k-means algorithm.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
  v -
  if {!$!} sp ? fi
  k[0] to_rgb if {h>300} r2dy 300 round 1 fi nm. img  # Resize input image if necessary.
  +r {w*h},1,1,3,-1 r. {min(w,8192)},1,1,3 nm. colors     # Get reduced set of image colors.
  $1,1,1,3 rand. 0,255 round. 1 nm. centroids          # Initialize random centroids.
  _x_quantize_rgb_3d (1,0,0,0;0,1,0,0;0,0,1,0) nm. pose3d     # Init 3D object.
  _x_quantize_rgb_text "Colors",clustering0
  _x_quantize_rgb_text "Clusters",clustering1
  _x_quantize_rgb_text "Dithering: off",dithering0
  _x_quantize_rgb_text "Dithering: on",dithering1
  if {img,h<300} +r2dy[img] 300,1 else [img] fi             # Generate visualization canvas.
  {w+315},365,1,3,255 rm..
  rectangle. 4,4,305,305,1,0xFFFFFFFF,0
  rectangle. 309,4,{w-5},305,1,0xFFFFFFFF,0
  rectangle. 4,309,{w-5},360,1,0xFFFFFFFF,0
  .,.
  rectangle. 310,5,{w-6},305,1,1
  rectangle. 5,310,{w-6},360,1,2
  300,300,1,1,'(y<<11)+(x<<2)+3' j.. .,5,5 rm.
  a[-2,-1] c nm. visu

  # Start k-means iterations.
  dithering=0 clustering=0 pause=1 s0=off s1=on
  do

    # Create and display visualization.
    if {!narg($visu_3d)} # Update 3D vizualization.
      +-[centroids] 2 ++[centroids] 2 a[-2,-1] x permute. cxyz y. -. 128
      j[obj3d] .,0,8 rm.  # Update centroids position in 3D object.
      [obj3d]
      if $clustering
        if {{colors,iM}<256} +index[colors] [centroids] *. 256 +[colors,-1] fi # Estimate nearest centroids for all colors.
        +channels[colors] 0 >>. 8 map. 2 permute. cxyz y. j.. .,0,{{-2,h}-$_N-h} rm.
      fi

      pose3d. {pose3d,^} 300,300,1,3 j3d. ..,50%,50%,100,1,2,0,0,300 rm..
      j. [clustering$clustering],2,0,0,0,1,[mclustering$clustering],255
      nm. visu_3d j[visu] [visu_3d],5,5
    fi

    if {!narg($visu_img)} # Update indexed image.
      +index[img] [centroids],{0.7*$dithering},1 if {h<300} r2dy. 300,1 fi
      j. [dithering$dithering],2,0,0,0,1,[mdithering$dithering],255
      nm. visu_img j[visu] [visu_img],310,5
    fi

    if {!narg($visu_centroids)} # Update colormap.
      +luminance[centroids] a. [centroids],y sort. +,x rows. 1 r. {visu,w-10},50,1,3
      0 t. "Colors: "{centroids,w},2,0,16,1,255,255,255 +dilate. 3 j... ..,2,2,0,0,1,.,255
      rm[-2,-1] nm. visu_centroids j[visu] [visu_centroids],5,310
    fi
    l[visu]
    w -1,-1,0,"[G"{`39`}"MIC] RGB Quantization"
    if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
    endl

    # Check for user's interactions.
    x={int({*,x}*{visu,w}/{*,w})}
    y={int({*,y}*{visu,h}/{*,h})}
    b={*,b}
    i={visu,i($x,$y,0,3)}
    if {$b&1" && "$i==1} # Toggle dithering.
      dithering={!$dithering} rm[visu_img] wait -1
    elif {$b&1" && "$i==2} # Add new color.
      (${-RGB}) y. c a[centroids,-1] x  _x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait 100
    elif {$b&2" && "$i==2" && "{centroids,w}>2} # Remove color.
      r[centroids] {centroids,w-1} _x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait 100
    elif {$b&2" && "$i>=3} # Toggle clusters/colors mode.
      clustering={!$clustering} rm[visu_3d] wait -1
    elif {*,M} # Init colormap with median-cut.
      +&[colors] 255 colormap. {centroids,w},0,0 rm[centroids] nm. centroids
      _x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait -1
    elif {*,R} # Init colormap with random values.
      rand[centroids] 0,255 round[centroids] 1
      _x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait -1
    elif {*,U} # Init colormap with uniform sampling.
      uniform_distribution {centroids,w},3 *. 255 rm[centroids] nm. centroids
      _x_quantize_rgb_3d rm[visu_3d,visu_img,visu_centroids] &[colors] 255 pause=1 wait -1
    elif {*,ENTER} # Start k-means iterations.
      pause=0
    elif {$b&1" && "$i>=3} # Manage 3D view rotation.
      coords={visu,i($x,$y,0,3)-3} u1={(($coords>>2)&511)-150} v1={($coords>>11)-150}
      if {!narg($u0)} u0=$u1 v0=$v1 fi
      if {$u0!=$u1" || "$v0!=$v1}
        n0={sqrt(($u0)^2+($v0)^2)}
        nu0={if($n0>135,$u0*135/$n0,$u0)} nv0={if($n0>135,$v0*135/$n0,$v0)} nw0={sqrt(max(0,18225-($nu0)^2-($nv0)^2))}
        n1={sqrt(($u1)^2+($v1)^2)}
        nu1={if($n1>135,$u1*135/$n1,$u1)} nv1={if($n1>135,$v1*135/$n1,$v1)} nw1={sqrt(max(0,18225-($nu1)^2-($nv1)^2))}
        u={$nv0*$nw1-$nw0*$nv1} v={$nw0*$nu1-$nu0*$nw1} w={$nv0*$nu1-$nu0*$nv1} n={sqrt(($u)^2+($v)^2+($w)^2)}
        rotation3d[] $u,$v,$w,{-asin($n/18225)*180/pi} mv[pose3d] $! m*[-2,-1] nm. pose3d
        u0=$u1 v0=$v1 rm[visu_3d]
      fi
    elif {!($b&1)} u0=
    fi

    if {!$pause" || "{*,SPACE}}  # Do one iteration of k-means.
      pause={*,-SPACE}

      # Estimate new centroids positions.
      &[colors] 255 +index[colors] [centroids] *. 256 +[colors,-1]      # Estimate nearest centroids for all colors.
      repeat {colors,s}                                                    # Recompute centroid positions.
        sh[colors] $> +histogram. {centroids,w*256},0,{centroids,w*256-1} rm..
        i.. 256,1,1,1,'x' r.. {w},1,1,1,0,2 *.. . r[-2,-1] {centroids,w},1,1,1,2 max. 0.01 /[-2,-1]
      done a[-{colors,s}--1] c
      rm[centroids] nm. centroids

      # Reassign unused centroids.
      +>>[colors] 8 channels. 0 histogram. {centroids,w},0,{centroids,w-1}
      cmax={xM}
      repeat {w} if {!i($>)} point[centroids] $>,0,0,1,{centroids,I($cmax)} point[centroids] $>,0,0,-0.001,${-RGB} fi done
      rm. c[centroids] 0,255

      if $visu_3d rm[visu_3d] fi
      if $visu_img rm[visu_img] fi
      if $visu_centroids rm[visu_centroids] fi
      wait 20

    else if $visu_img wait fi
    fi

  while {{*}" && "!{*,Q}" && "!{*,ESC}}
  rm w 0 v +

 _x_quantize_rgb_3d :
  if $obj3d rm[obj3d] fi
  +distribution3d[centroids] circles3d. 5 col3d. 255      # Pre-compute 3D object.
  colorcube3d p3d. 1
  +&[colors] 255 distribution3d. o3d. 0.8 +3d[-3--1]
  -3d. 128,128,128 nm. obj3d _N={i[7]}

_x_quantize_rgb_text :
  0 t. "$1",0,0,16,1,255 r. {w+2},15,1,1,0,0,0.5,0.5 +dilate. 3 to_rgb..
  nm.. $2 nm. m$2

#@cli x_reflection3d
#@cli : Launch the 3D reflection demo.
x_reflection3d :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"3D reflection"$n" ----------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
  v -

  # Render background.
  128,256,1,3 rand. 0,255 plasma. 1,100 blur_xy. 30,2
  sh. 0 n. 0,90 rm. sh. 1 n. 0,60 rm. sh. 2 n. 0,180 rm.
  +mirror. x [-2,-1] a[-4--1] x
  +luminance. mirror. x b. 2 n. 0,255

  # Create 3D objects.
  torus3d 30,10 col3d. 255,200,0
  spherical3d 47,34,"80+20*abs(cos(2*theta))" s3d. rm.. i.. 3,{h},1,1,150,220,255,200,255,255 y.. a[-6--1] y
  spherical3d 47,34,"100*abs(1+0.6*cos(3*phi)*sin(4*theta))"
  r3d[-2,-1] 0,1,0,90 db3d 0

  # Start animation loop.
  xb,xl,anim=0
  w[] 400,400,0,"[G"{`39`}"MIC] 3D Reflection"
  do

    tic=$|
    # Recreate 3D interpolated background object.
    +rows. 8,{8+3*i[6]-1} +j... .,0,8,0,0,{if($anim<250,0,0.5-0.5*cos(($anim-250)/100))} rm..

    # Render 3D background object (with flat colors).
    +z[-6] $xb,0,{$xb+255},255 j3d. ..,75%,50%,0,1,3,0,0

    # Render light reflection map.
    +z[-6] $xl,0,{$xl+255},255
    xf={min(30,$anim-70)+20*cos(1.8*$|)}
    yf={50+20*sin(2.7*$|)}
    j3d. [-6],{20+$xf}%,$yf%,0,1,4,0,0

    # Add light reflection to 3D background object.
    l3d . rm. +j3d. ..,75%,50%,0,1,5,0,0 j.. .,0,0,0,0,0.6 rm[-3,-1]

    # Add 3D foreground object.
    j3d. [-4],$xf%,$yf%,0,1,4,0,0

    # Display frame and update animation variables.
    fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-19},13,1,0.2 fi
    w. rm.

    if {{*,CTRLLEFT}&&{*,D}} w[] 800,800 elif {{*,CTRLLEFT}&&{*,C}} w[] 400,400 fi
    xb={($xb+6)&255}
    xl={($xl-6)&255}
    anim+=1
    r3d[-2,-1] {sin(0.5*$|)},{cos($|)},1,{max(0.005,$|-$tic)*33}
    r3d... -1,0.3,0.8,{max(0.005,$|-$tic)*100}
    wait 20
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm[-5--1] w[] 0 v +

#@cli x_rubber3d
#@cli : Launch the 3D rubber object demo.
x_rubber3d :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"3D rubber object"$n" -------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
  v - rm
  sphere3d 150,0 torus3d 70,15 cylinder3d 20,40
  col3d... 200,200,200,0.3 col3d.. 128,200,76 col3d. 200,128,76
  c3d[-3--1] r3d. 1,0,0,70 +3d[-3--1] +3d. 10,-8,20 *3d. 1.5
  400,400,64,3
  {w},{h},1,3,'if(c==0,x,if(c==1,y,y*{1,d}/h))'
  {w},{h},1,3
  w[] {w},{h},0,"[G"{`39`}"MIC] 3D Rubber Object"
  frame=0
  do
    fps=${-fps}
    {w},{h},1,3 fc. 16,32,32 j3d. [0],50%,50%,0,1,3,0,0 j[1] .,0,0,$frame rm.
    r3d[0] 0.1,1,0.6,{3*cos($|*1.25)} r3d[0] 1,0.2,0.6,-1
    +warp[1] [2],0,0 *[3] 0.8 *. 0.2 +[3] . rm.
    if {$fps>0} to. $fps" fps",5,{h-29},24,2,0.2 fi
    w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {2*w},{2*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {w},{h} fi
    wait[0] 20
    sh[2] 2 -. 1 &. {{1,d}-1} rm.
    frame={($frame-1)%{1,d}}
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 v +

#@cli x_segment : _max_resolution={ 0 | >=128 }
#@cli : Segment foreground from background in selected opaque RGB images, interactively.
#@cli : Return RGBA images with binary alpha-channels.
#@cli : Default value: 'max_resolution=1024'.
x_segment : check "${1=1024}==0 || $1>=128"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[^-1] "Extract foreground from background in image$? interactively, with maximum resolution $1."
  e[] "\n
----------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" or key '"${c}"F"$n"' create a new foreground control point (or move an existing one).\n
---- "${c}"Right mouse button"$n" or key '"${c}"B"$n"' create a new background control point (or move an existing one).\n
---- "${c}"Mouse wheel"$n", or keys '"${c}"CTRL+arrows UP/DOWN"$n"' zoom view in/out.\n
---- '"${c}"CTRL+mouse wheel"$n"', '"${c}"SHIFT+mouse wheel"$n"' or "${c}"arrow keys"$n" move image in zoomed view.\n
---- Key '"${c}"SPACE"$n"' updates the extraction mask.\n
---- Key '"${c}"TAB"$n"' toggles background view modes.\n
---- Key '"${c}"M"$n"' toggles marker view modes.\n
---- Key '"${c}"BACKSPACE"$n"' deletes the last control point added.\n
---- Key '"${c}"PAGE UP"$n"' increases background opacity.\n
---- Key '"${c}"PAGE DOWN"$n"' decreases background opacity.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
----------------------------------------------------------------------------------------------------"
  v - repeat $! l[$>]

    # Init variables and images.
    name={0,n} title={0,b} if {narg({0,x})} title=$title.{0,x} fi
    w={w} h={h} fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
    selection=-1 marker_mode=2 xpan=-1 ypan=-1 bg_mode=0 opacity=64
    to_rgb nm img

    if {narg($_gui_control_points)>=4}  ($_gui_control_points) r. {w/4},4,1,1,-1 # Import list of control points from plug-in GUI.
    else 0 # Empty list of control points.
    fi
    nm. points

    # Compute potential map.
    if {$1>0} if {$w>$h} +r2dx[img] {min($1,$w)},2 else +r2dy[img] {min($1,$h)},2 fi else [img] fi
    _x_segment.
    pw={potential,w} ph={potential,h}

    # Start event loop.
    do

      # Handle user events for zoom/navigation/resizing.
      wait
      x={*,x} y={*,y} b={*,b} o={*,-o}
      is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
      is_shift={{*,SHIFTLEFT}" || "{*,SHIFTRIGHT}}
      is_mouseout={$x<0" || "$y<0}
      x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
      oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1

      if {*,r} # When window resized.
        nww={*,d} nwh={*,e} m={min($nww,$nwh)}
        cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
        x0={$cx-$dx/2} x1={$cx+$dx/2}
        y0={$cy-$dy/2} y1={$cy+$dy/2}
        ww=$nww wh=$nwh
      elif {$is_ctrl" && "{*,-D}} # Increase window size.
        nww={min({*,u},$ww*1.25)} nwh={min({*,v},$wh*1.25)} m={min($nww,$nwh)}
        if {$m==$nww} ww=$m wh={$h*$m/$w} else ww={$w*$m/$h} wh=$m fi
      elif {$is_ctrl" && "{*,-C}} # Decrease window size.
        nww={$ww/1.25} nwh={$wh/1.25}
        if {min($nww,$nwh)>=64} ww=$nww wh=$nwh fi
      elif {$is_ctrl" && "{*,-R}} # Reset window size.
        fdim=${fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
        x0=0 y0=0 x1={$w-1} y1={$h-1}
      elif {($is_shift" && "$o<0)" || "{*,ARROWLEFT}} # Go left.
        dx={($x1-$x0)/6} x0-=$dx x1-=$dx
      elif {($is_shift" && "$o>0)" || "{*,ARROWRIGHT}} # Go right.
        dx={($x1-$x0)/6} x0+=$dx x1+=$dx
      elif {($is_ctrl" && "$o>0)" || "({*,ARROWUP}" && "!$is_ctrl)} # Go up.
        dy={($y1-$y0)/6} y0-=$dy y1-=$dy
      elif {($is_ctrl" && "$o<0)" || "({*,ARROWDOWN}" && "!$is_ctrl)} # Go down.
        dy={($y1-$y0)/6} y0+=$dy y1+=$dy
      elif {$o>0" || "($is_ctrl" && "{*,ARROWUP})} # Zoom in.
        if {$x1-$x0>16" && "$y1-$y0>16}
          cx={if($x>=0" && "!{*,ARROWUP},$x,($x0+$x1)/2)}
          cy={if($y>=0" && "!{*,ARROWUP},$y,($y0+$y1)/2)}
          x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
          x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
        fi
      elif {$o<0" || "($is_ctrl" && "{*,ARROWDOWN})} # Zoom out.
        zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
        if {$zfactor<1.3}
          cx={if($x>=0" && "!{*,ARROWDOWN},$x,($x0+$x1)/2)}
          cy={if($y>=0" && "!{*,ARROWDOWN},$y,($y0+$y1)/2)}
          x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
          x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
          dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
          x0+=$dx x1+=$dx y0+=$dy y1+=$dy
        else
          dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
          x0+=$dx x1+=$dx y0+=$dy y1+=$dy
        fi
      elif {$b&4" && "!$is_mouseout} # Pan.
        if {$panx<0" && "$pany<0} panx=$x pany=$y
        else dx={round($panx-$x)} dy={round($pany-$y)} x0+=$dx y0+=$dy x1+=$dx y1+=$dy
        fi
      else panx=-1 pany=-1
      fi
      if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} rm[baseview] fi

      # Handle events related to control points management.
      N={points,w}
      is_left_button={$b&1" || "{*,F}} is_right_button={$b&2" || "{*,B}} is_button={$is_left_button" || "$is_right_button}
      if {narg($baseview)" && "$is_button" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
        if {$selection==-1" && "$N} # Check for selection of an existing point.
          ($x;$y) r. $N,2 -. [points] *. {max($ww,$wh)/max($x1-$x0,$y1-$y0)} sqr. s. y +[-2,-1]
          dmin={im} selection={if($dmin>25,-1,xm)} rm.
        fi
        if {$selection>=0}
          if $marker_mode # Move existing point.
            +columns[points] $selection ox={i[0]} oy={i[1]}
            =. $x =. $y,0,1 =. {1+$is_left_button},0,3
            j[points] .,$selection rm. rm[view]
          fi
        else # Add new foreground or background point.
          ($x;$y;0;{1+$is_left_button}) a[points,-1] x selection=$N if {!$marker_mode} marker_mode=2 fi rm[view]
        fi
      else selection=-1
        if {{*,SPACE}" && "narg($labels)} rm[labels] # Update labels.
        elif {{*,TAB}" && "narg($baseview)} bg_mode={($bg_mode+1)%6} rm[baseview] wait -1 # Toggle background view modes.
        elif {{*,M}" && "narg($view)} marker_mode={($marker_mode-1)%3} rm[view] wait -1 # Toggle markers view modes.
        elif {{*,PAGEDOWN}" && "narg($baseview)} opacity={max(0,$opacity-32)} rm[baseview] wait -1 # Decrease background opacity.
        elif {{*,PAGEUP}" && "narg($baseview)} opacity={min(255,$opacity+32)} rm[baseview] wait -1 # Increase background opacity.
        elif {{*,BACKSPACE}" && "$N} if {$N>1} z[points] 0,{$N-2} else i=$points rm[points] i[$i] 0 nm[$i] points fi rm[view] wait -1 # Remove last point.
        fi
      fi

      # Manage zoomed view bounds.
      w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
      if {$x0<-$w2} x1-={$x0+$w2} x0=-$w2 fi
      if {$y0<-$h2} y1-={$y0+$h2} y0=-$h2 fi
      if {$x1>=$w+$w2} x0+={$w-1+$w2-$x1} x1={$w-1+$w2} fi
      if {$y1>=$h+$h2} y0+={$h-1+$h2-$y1} y1={$h-1+$h2} fi

      # Render labels.
      if {!narg($labels)}
        N={points,w}
        if {narg($view)} to[view] "Processing...",5,5,20,2 w[view] fi
        if $N
          [points]
          sh. 0,0,0,0 *. {$pw/$w} rm.
          sh. 1,1,0,0 *. {$ph/$h} rm.
          pointcloud. -1,$pw,$ph dilate. 3
          watershed. [potential] -. 1
        else [potential],[potential],1,1,1
        fi
        nm. labels
        if {narg($baseview)} rm[baseview] fi
      fi

      # Render base image.
      if {!narg($baseview)}
        nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
        nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
        +z[img] $x0,$y0,$x1,$y1
        r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
        +z[labels] $nx0,$ny0,$nx1,$ny1
        r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
        if {$bg_mode>=3} *. -1 +. 1 fi
        *. {255-$opacity} +. $opacity a[-2,-1] c
        if {$bg_mode%3>=1} i.. 100%,100%,1,3,{(($bg_mode-1)%3)*255} blend[-2,-1] alpha
        else drgba.
        fi
        nm. baseview
        if {narg($view)} rm[view] fi
      fi

      # Render view.
      if {!narg($view)}
        [baseview] r. 100%,100%,1,3
        if $marker_mode
          if {$marker_mode==2} rad1=5 rad2=3 opa=1 else rad1=3 rad2=2 opa=0.8 fi
          col0=255,0,0 col1=0,255,0
          repeat {points,w}
            +columns[points] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} l={i[3]-1} rm.
            circle. $x,$y,$rad1,1,0 circle. $x,$y,$rad2,$opa,${col$l}
          done
        fi

        nm. view
        w[view] $ww,$wh,0,$title
      fi

    while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}

    # Recompute labels at full resolution.
    if {narg($view)} to[view] "Processing fullres...",5,5,20,2 w[view] fi
    k[img,points]
    N={points,w} status=
    if $N
      status={points,^}
      [img] _x_segment. pointcloud[points] -1,$w,$h
      zfact={{img,max(w,h)}/{potential,max(w,h)}} dilate[points] {int(3*$zfact)}
      watershed[points] [potential] -[points] 1 k[img,points]
      *. 255
    else k[img] [img],[img],1,1,255
    fi
    a c nm $name

  endl done
  u $status   # Return control points of last image.
  w 0 v +

# Compute potential function.
_x_segment :
  b. 0.2% gradient_norm. f. '1/(1+i^2)'
  nm. potential

#@cli x_select_color : _variable_name
#@cli : Display a RGB or RGBA color selector.
#@cli : Argument 'variable_name' specifies the variable that contains the selected color values (as R,G,B,[A]) at any time.
#@cli : Its value specifies the initial selected color. Assigning '-1' to it forces the interactive window to close.
#@cli : Default value: 'variable_name=xsc_variable'.
x_select_color : skip ${1=xsc_variable}
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - rm
  n={narg($$1)} if {!$n} $1=0,0,0 fi
  rgba_mode={$n>=4} R={arg(1,$$1)} G={arg(2,$$1)} B={arg(3,$$1)} A={if($rgba_mode,arg(4,$$1),255)}
  v + e[^-1] "Open "${arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget, with variable '$1' and starting color "($$1)"." v -
  if {!{*}} w[] {400+24*$rgba_mode},400,0,"Select a color" fi
  update_view=1 is_sv=0 is_h=0 is_a=0 colordb=0 is_thread_variable={arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'}

  # Manage color presets.
  m "add_preset : if {!narg($_xsc_preset$""1)} _xsc_preset$""1=$""2,$""3,$""4 fi"
  add_preset 0,0,0,0,0 add_preset 1,255,255,255 add_preset 2,255,0,0 add_preset 3,0,255,0 add_preset 4,0,0,255 add_preset 5,255,255,0
  add_preset 6,255,0,255 add_preset 7,0,255,255 add_preset 8,50,50,50 add_preset 9,100,100,100 add_preset 10,150,150,150 add_preset 11,200,200,200
  uncommand add_preset
  if {!narg($_xsc_preset)} _xsc_preset=11 fi
  ($R^$G^$B) c. 0,255 rgb2hsv. H={i[0]} S={i[1]} V={i[2]} rm.

  # Start event loop.
  do
    w={*,d} h={*,e} x={*,x} y={*,y} b={*,b}

    # Update base image.
    if {!$!}
      $w,$h,1,3,200
      if $rgba_mode x1={w-89} y1={h-57} x2={w-80} else x1={w-49} y1={h-57} x2={w-40} fi
      x0=8 y0=8 x3={$x2+31} x4={w-40} x5={$x4+31} x6={max($x0+232+32*$rgba_mode,w-152)} y6={$y1+7}
      rectangle {$x0-1},{$y0-1},{$x1+1},{$y1+1},1,0xFFFFFFFF,232 line {$x0-1},{$y0-1},{$x1+1},{$y0-1},1,128 line {$x0-1},{$y0-1},{$x0-1},{$y1+1},1,128
      (1;0) (0,1) r[-2,-1] {$x1-$x0+1},{$y1-$y0+1},1,1,3 i... 100%,100%,1,1,$H a[-3--1] c hsv2rgb. j.. .,$x0,$y0 rm.
      rectangle {$x2-1},{$y0-1},{$x3+1},{$y1+1},1,0xFFFFFFFF,232 line {$x2-1},{$y0-1},{$x3+1},{$y0-1},1,128 line {$x2-1},{$y0-1},{$x2-1},{$y1+1},1,128
      (359;0^1;1^1;1) r. {$x3-$x2+1},{$y1-$y0+1},1,3,3 hsv2rgb. j.. .,$x2,$y0 rm.
      if $rgba_mode
        rectangle {$x4-1},{$y0-1},{$x5+1},{$y1+1},1,0xFFFFFFFF,232 line {$x4-1},{$y0-1},{$x5+1},{$y0-1},1,128 line {$x4-1},{$y0-1},{$x4-1},{$y1+1},1,128
        (1;0) r. {$x5-$x4+1},{$y1-$y0+1},1,4,3 *. 255 drgba. j.. .,$x4,$y0 rm.
      fi
      t. "Current",$x0,{$y1+12},14,1,0
      if {narg($_xsc_old)}
        t. "Old",$x0,{$y1+34},14,1,0
        ($_xsc_old) y. c r. 48,16 drgba. r. {w+2},{h+2},1,3,0,0,0.5,0.5 j.. .,{$x0+55},{$y1+32} rm.
      fi
      repeat 12
        (${_xsc_preset$>}) -. 255 r. 4,1,1,1,0 +. 255
        y. c r. 18,18 drgba. frame. 1,1,{255*($>==$_xsc_preset)}
        j.. .,{$x6+($>%6)*25},{$y6+($>>=6)*25} rm.
      done
      update_view=1
    fi

    # Update view.
    if $update_view
      .
      cx={$x0+$V*($x1-$x0)} cy={$y0+(1-$S)*($y1-$y0)}
      if {$cx>$x0} line. {$cx-1},$y0,{$cx-1},$y1,1,200 fi
      if {$cx<$x1} line. {$cx+1},$y0,{$cx+1},$y1,1,200 fi
      if {$cy>$y0} line. $x0,{$cy-1},$x1,{$cy-1},1,200 fi
      if {$cy<$y1} line. $x0,{$cy+1},$x1,{$cy+1},1,200 fi
      line. $x0,$cy,$x1,$cy,1,0 line. $cx,$y0,$cx,$y1,1,0
      cy={$y0+(359-$H)*($y1-$y0)/359}
      if {$cy>$y0} line. $x2,{$cy-1},$x3,{$cy-1},1,200 fi
      if {$cy<$y1} line. $x2,{$cy+1},$x3,{$cy+1},1,200 fi
      line. $x2,$cy,$x3,$cy,1,0
      if $rgba_mode
        cy={$y0+(255-$A)*($y1-$y0)/255}
        if {$cy>$y0} line. $x4,{$cy-1},$x5,{$cy-1},1,200 fi
        if {$cy<$y1} line. $x4,{$cy+1},$x5,{$cy+1},1,200 fi
        line. $x4,$cy,$x5,$cy,1,0
      fi
      ($H^$S^$V^$A) sh. 0,2 hsv2rgb. rm. round. R={i[0]} G={i[1]} B={i[2]}
      r. 48,16 drgba. r. {w+2},{h+2},1,3,0,0,0.5,0.5 j.. .,{$x0+55},{$y1+10} rm.
      t. "HSV ("{round($H)}","{round($S*255)}","{round($V*255)}")",{$x0+115},{$y1+24},14,1,0
      if $rgba_mode t. "RGBA ("$R","$G","$B","{round($A)}")",{$x0+115},{$y1+8},14,1,0
      else t. "RGB ("$R","$G","$B")",{$x0+115},{$y1+8},14,1,0
      fi
      ({'${dec2hex\ {$R*65536+$G*256+$B}}'}) -. {'0'} r. 6,1,1,1,0,0,1,0 +. {'0'}
      f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
      t.. "HTML ""#"{t},{$x0+115},{$y1+40},14,1,0 rm.
      w. 100%,100%,0 rm.
      if $rgba_mode $1=$R,$G,$B,$A else $1=$R,$G,$B fi
      update_view=0
    fi
    if $is_thread_variable wait 50 else wait fi

    # Manage window size.
    ww={*,w} wh={*,h}
    is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
    if {*,r} ww={*,d} wh={*,e}
    elif {$is_ctrl" && "{*,-D}} ww={1.25*$ww} wh={1.25*$wh}
    elif {$is_ctrl" && "{*,-C}} ww={0.8*$ww} wh={0.8*$wh}
    elif {$is_ctrl" && "{*,R}} ww={400+24*$rgba_mode} wh=400
    fi
    ww={max(200,$ww)} wh={max(200,$wh)}
    if {$ww!={*,w}" || "$wh!={*,h}} w[] $ww,$wh rm fi

    # Manage user events.
    if {$b&1" && "$x>=0" && "$y>=0}
      if {!$is_h" && "!$is_a" && "($is_sv" || "($x>=$x0" && "$x<=$x1" && "$y>=$y0" && "$y<=$y1))} # SV selection.
        S={max(0,min(1,1-($y-$y0)/($y1-$y0)))} V={max(0,min(1,($x-$x0)/($x1-$x0)))}
        update_view=1 colordb=0 is_sv=1 k[0]
      elif {!$is_sv" && "!$is_a" && "($is_h" || "($x>=$x2" && "$x<=$x3" && "$y>=$y0" && "$y<=$y1))} # H selection.
        H={max(0,min(359,359-($y-$y0)*359/($y1-$y0)))}
        colordb=0 is_h=1 rm
      elif {!$is_sv" && "!$is_h" && "($is_a" || "($x>=$x4" && "$x<=$x5" && "$y>=$y0" && "$y<=$y1))} # A selection.
        A={round(max(0,min(255,255-($y-$y0)*255/($y1-$y0))))}
        colordb=0 is_a=1 update_view=1 k[0]
      elif {!$is_sv" && "!$is_h" && "!$is_a" && "{narg($_xsc_old)}" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+32" && "$y<=$y1+47} # Old color.
        ($_xsc_old) y. c sh. 0,2 rgb2hsv. rm. H={i[0]} S={i[1]} V={i[2]} A={i[3]}
        colordb=0 rm
      elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x6" && "$x<=$x5" && "$y>=$y6" && "$y<=$y6+50" && "($x-$x6)%25<=20" && "($y-$y6)%25<=20} # Preset.
        p={int(($x-$x6)/25)+6*int(($y-$y6)/25)} (${_xsc_preset$p}) -. 255 r. 4,1,1,1,0 +. 255 y. c sh. 0,2 rgb2hsv. rm.
        H={i[0]} S={i[1]} V={i[2]} A={i[3]}
        colordb=0 rm
      elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+10" && "$y<=$y1+27} # Add current as old and/or preset.
        _xsc_old=$R,$G,$B,$A colordb={($colordb+1)%2}
        if {!$colordb} _xsc_preset$_xsc_preset=$R,$G,$B,$A _xsc_preset={($_xsc_preset-1)%12} fi # Double-click to add to preset.
        rm wait -1
      else colordb=0
      fi
    elif {!$b} is_sv=0 is_h=0 is_a=0
    fi
    if {*,ARROWUP} colordb=0 S={min(1,$S+1/256)} update_view=1 k[0] wait -1
    elif {*,ARROWDOWN} colordb=0 S={max(0,$S-1/256)} update_view=1 k[0] wait -1
    elif {*,ARROWRIGHT} colordb=0 V={min(1,$V+1/256)} update_view=1 k[0] wait -1
    elif {*,ARROWLEFT} colordb=0 V={max(0,$V-1/256)} update_view=1 k[0] wait -1
    elif {*,PAGEUP} colordb=0 H={min(359,$H+1)} rm wait -1
    elif {*,PAGEDOWN} colordb=0 H={max(0,$H-1)} rm wait -1
    fi

    # Check RGB variable modification from another thread.
    if {['$$1']=='-1'} break fi # Close request
    if {(($rgba_mode" && "['$$1']!='$R,$G,$B,$A')" || "(!$rgba_mode" && "['$$1']!='$R,$G,$B'))" && "$x<0" && "$y<0" && "!$is_sv" && "!$is_h" && "!$is_a}
      ($$1) y. c -. 255 r. 1,1,1,4,0 +. 255 sh. 0,2 rgb2hsv. rm.
      H={i[0]} S={i[1]} V={i[2]} A={i[3]} rm
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0
  if $rgba_mode u $R,$G,$B,$A else u $R,$G,$B fi
  _xsc_old=${}
  v +

#@cli x_select_function1d : _variable_name,_background_curve_R,_background_curve_G,_background_curve_B
#@cli : Open an interactive window, where the user can defined its own 1D function.
#@cli : If an image is selected, it is used to display additional information :
#@cli :   - The first row defines the values of a background curve displayed on the window (e.g. an histogram).
#@cli :   - The 2nd, 3rd and 4th rows define the R,G,B color components displayed beside the X and Y axes.
#@cli : Argument 'variable_name' specifies the variable that contains the selected function keypoints at any time.
#@cli : Assigning '-1' to it forces the interactive window to close.
#@cli : Default values: 'variable_name=xsf_variable', 'background_curve_R=220', 'background_curve_G=background_curve_B=background_curve_T'.
x_select_function1d : skip ${1=xsf_variable},${2=220},${3=$2},${4=$2}
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  e[^-1] "Open 1D function widget, with variable name '$1'."
  v -
  if $! k[0] fi
  is_additional_data=$!
  if {!{*}} w[] 400,400,0,"Create a 1D function" fi
  reset_w={*,w} reset_h={*,h}
  if {!narg($$1)} $1=0,0,100,100 fi
  i[points] ($$1) y. x r. 2,{w/2},1,1,-1
  is_thread_variable={arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} selected=-1 X=-1 Y=-1
  do

    # Update base view.
    if {!narg($baseview)}
      {{*,d}-48},{{*,e}-48},1,3,255
      if $is_additional_data  # Render background graph.
        100%,100% +rows[0] 0 graph.. .,3,0,0,0,1,1 rm. c. 0,1
        +fc.. ${2-4} j... .,0,0,0,0,1,.. rm[-2,-1]
      fi
      grid. {(w-1)/8},{(h-1)/8},0,0,0.2,0xCCCCCCCC,0
      line. 0,100%,100%,0,0.2,0
       frame. 24,24,200
      rectangle. 23,23,{w-24},{h-24},1,0xFFFFFFFF,232 line. 23,23,23,{h-24},1,128 line. 23,23,{w-24},23,1,128
      if {$is_additional_data" && "{0,h}>1} # Render colored X-axis guide.
        if {{0,h}>2} +rows[0] 1,3 else +rows[0] 1 r. 100%,3 fi
        r. {-2,w-48},3,1,1,3 permute. xzcy r. 100%,8 frame. 1,1,0
        j.. .,23,{-2,h-19} rotate. -90 j.. .,{-2,w-19},23 rm.
      fi
      nm. baseview
      l rm[view] onfail endl
    fi

    # Update view.
    if {!narg($view)}
      +z[baseview] 24,24,{baseview,w-25},{baseview,h-25} r. 200%,200%

      # Draw curve.
      function1d[] 1,{points,^}
      l. c 0,100 transpose
        i[0] ({'CImg3d'},{h},{h-1})
        i.. 1,100%,1,1,y 1,100% a[-3--1] x
        1,{h-1},1,1,2 +f. y ++. 1 a[-3--1] x
        4,100%,1,1,1 y a y col3d 0
      endl
      *3d. {-2,(w-1)/100},{-2,(1-h)/100}
      j3d.. .,0,100%,0,1,1,0,0 rm.

      # Draw control points.
      repeat {points,h}
        x={points,i(0,$>)} y={100-{points,i(1,$>)}}
        circle. $x%,$y%,6,1,0xFFFFFFFF,0
      done
      if {$selected>=0}
        x={points,i(0,$selected)} y={100-{points,i(1,$selected)}}
        circle. $x%,$y%,3,1,0
      fi

      r. 50%,50%,1,3,2
      +j[baseview] .,24,24 rm..

      # Draw current coordinates.
      if {$X>=0" && "$Y>=0} t. "X: "{min(255,round(255*$X/100))}" Y: "{min(255,round(255*$Y/100))},24,6,12,1 fi
      nm. view
      w[view]
    fi

    if $is_thread_variable wait 50 else wait fi

    # Manage user events.
    x={*,x} y={*,y} b={*,b} is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
    X={($x-24)*100/({*,w}-49)} Y={100-($y-24)*100/({*,h}-49)}
    oww={*,w} owh={*,h} ww=$oww wh=$owh
    if {*,r} ww={*,d} wh={*,e} # Resize window.
    elif {$is_ctrl" && "{*,-D}} ww={view,w*125%} wh={view,h*125%} # Increase window size.
    elif {$is_ctrl" && "{*,-C}} ww={view,w*75%} wh={view,h*75%} # Decrease window size.
    elif {$is_ctrl" && "{*,R}} ww=$reset_w wh=$reset_h # Reset window size.
    elif {!$is_ctrl" && "{*,R}} rm[points] i[points] (0,0;100,100) $1={points,^} rm[view] # Reset keypoints.
    elif {$b&3} # Add/move/delete point.
      is_inside={$X>=0" && "$Y>=0" && "$X<=100" && "$Y<=100}

      # Check for a point selection.
      if {$selected<0} +f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*{*,w}%' z. 0,0 selected={if(im>8,-1,ym)} rm. fi

      if {$x>=0" && "$b&1" && "$selected>=0} # Move an existing point.
        if {{*,SHIFTLEFT}||{*,SHIFTRIGHT}} X={points,i(0,$selected)} fi
        if {{*,CTRLLEFT}||{*,CTRLRIGHT}} Y={points,i(1,$selected)} fi
        if {points,$selected>0" && "$selected<h-1}
          =[points] {points,max(min($X,i(0,$selected+1)-0.5),i(0,$selected-1)+0.5)},0,$selected
        fi
        =[points] {min(100,max(0,$Y))},1,$selected $1={points,^} rm[view]

      elif {$b&1" && "$is_inside} # Create new point.
        ($X,$Y) a[points,-1] y sort[points] +,y
        +f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*{*,w}%' z. 0,0 selected={if(im>8,-1,ym)} $1={points,^} rm[view,-1]
      elif {$b&2" && "$selected>0" && "$selected<{points,h-1}" && "$is_inside} # Delete an existing point.
        l[points] s y rm[$selected] a y endl wait -1 selected=-1 $1={points,^} rm[view]
      fi
    elif {!($b&1)} selected=-1
    fi

    # Manage window size.
    ww={min(90%*{*,u},max(200,$ww))}
    wh={min(90%*{*,v},max(200,$wh))}
    if {$oww!=$ww" || "$owh!=$wh} w[] $ww,$wh rm[baseview,view] fi

    # Check points variable modification from another thread.
    if {['$$1']=='-1'} break fi # Close request
    if {['$$1']!=['{points,^}']} rm[points] i[points] ($$1) y. x r. 2,{w/2},1,1,-1 l rm[view] onfail endl fi # Keypoints changed.

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w[] 0 u {points,^}
  if $is_additional_data rm[^0] else rm fi
  v +

#@cli x_select_palette : _variable_name,_number_of_columns={ 0=auto | >0 }
#@cli : Open a RGB or RGBA color selector widget from a palette.
#@cli : The palette is given as a selected image.
#@cli : Argument 'variable_name' specifies the variable that contains the selected color values (as R,G,B,[A]) at any time.
#@cli : Assigning '-1' to it forces the interactive window to close.
#@cli : Default values: 'variable_name=xsp_variable' and 'number_of_columns=2'.
x_select_palette : skip ${1=xsp_variable},${2=0}
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  if {!$!} error[0--3] "Command '$0': Missing specified palette image." fi
  v - k[0] +r {w*h*d},1,1,{s},-1 to_color. rgba_mode={s==4} to_rgba. nm. palette v +
  e[^-1] "Open "${arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget for palette$?, with variable name '$1'."
  v -
  if {w>1024} v + error[0--3] "Command '$0': Too much colors ("{w}") in selected palette." fi
  if {!{*}} w[] 400,400,0,0,-1,-1,"Palette: "{0,b} fi

  selected=-1 oselected=-1
  do
    ww={*,w} wh={*,h}
    R={palette,round(i($selected,0,0,0))} G={palette,round(i($selected,0,0,1))}
    B={palette,round(i($selected,0,0,2))} A={palette,round(i($selected,0,0,3))}

    # Update color in specified variable.
    if {$selected>=0" && "$oselected!=$selected}
      if $rgba_mode $1=$R,$G,$B,$A else $1=$R,$G,$B fi
    fi

    # Check close request from external thread.
    if {['$$1']=='-1'} break fi

    # Create base view.
    if {!narg($baseview)} l[palette]
      {w},1,1,1,x +. 1
      s. x append_tiles[^0] $2
      M={w} N={h} 100%,100%,1,1,1
      +r. {$ww-17},100%,1,1,4
      r.. 100%,{$wh-57},1,1,4
      r[-2,-1] .,.. -|[-2,-1]
      line. 100%,0,100%,100%,1,1
      line. 0,100%,100%,100%,1,1
      -. 1 *. -1
      r.. .,.,1,1,1 -.. 1
      +map.. [0],0 drgba.
      rv[-2,-1] *[-2,-1]
      +!=.. -1 dilate. 3
      mv... $! +. 1 a[-3--1] c
      nm. baseview
    endl
    if {narg($view)} rm[view] fi
    fi

    # Create and display view.
    if {!narg($view)}
      $ww,$wh,1,3,200
      if {$selected<0} sh[baseview] 0,2
      else
        +channels[baseview] 0,2 +channels[baseview] 4,4
        !=. {$selected+1} rectangle. 0,0,100%,100%,1,0xFFFFFFFF,1
        +dilate. 5 -[-2,-1] *. -1 +dilate. 5 *.. 255
        r.. 100%,100%,1,3 j... ..,0,0,0,0,1,. rm[-2,-1]
        if $rgba_mode t.. "RGBA ("$R","$G","$B","$A")",8,{$wh-45},14,1,0
        else t.. "RGB ("$R","$G","$B")",8,{$wh-45},14,1,0
        fi
        ($R^$G^$B) rgb2hsv. H={round(i[0])} S={round(i[1]*255)} V={round(i[2]*255)} rm.
        t.. "HSV ("$H","$S","$V")",8,{$wh-31},14,1,0
        ({'${dec2hex\ {$R*65536+$G*256+$B}}'}) -. {'0'} r. 6,1,1,1,0,0,1,0 +. {'0'}
        f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
        t... "HTML ""#"{t},8,{$wh-17},14,1,0 rm.
      fi
      sh[baseview] 3 j... ..,8,8,0,0,1,. rm[-2,-1]
      nm. view w[view]
    fi

    if {arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} wait 50 else wait fi

    # Manage window size.
    is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
    if {*,r} ww={*,d} wh={*,e}
    elif {$is_ctrl" && "{*,-D}} ww={1.25*$ww} wh={1.25*$wh}
    elif {$is_ctrl" && "{*,-C}} ww={0.8*$ww} wh={0.8*$wh}
    elif {$is_ctrl" && "{*,R}} ww=400 wh=400
    fi
    ww={max(200,$ww)} wh={max(200,$wh)}
    if {($ww!={*,w}" || "$wh!={*,h})" && "narg($baseview)} w[] $ww,$wh rm[baseview] fi

    # Handle user events.
    oselected=$selected
    if {narg($baseview)}
      x={*,x} y={*,y} b={*,b}
      if {$b&1" && "$x>=0" && "$y>=0}  # Select color.
        if {baseview,i($x-8,$y-8,0,4)} selected={baseview,i($x-8,$y-8,0,4)-1} else selected=-1 fi
        rm[view] wait -1
      elif {{*,ARROWUP}" && "$selected>=$M} selected-=$M rm[view] wait -1
      elif {{*,ARROWDOWN}" && "$selected<{0,w-$M}} selected+=$M rm[view] wait -1
      elif {{*,ARROWRIGHT}" && "$selected<{0,w-1}} selected+=1 rm[view] wait -1
      elif {{*,ARROWLEFT}" && "$selected>0} selected-=1 rm[view] wait -1
      fi
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  w 0 k[0]
  if {$selected>=0} if $rgba_mode u $R,$G,$B,$A else u $R,$G,$B fi else u -1 fi
  v +

#@cli x_shadebobs
#@cli : Launch the shade bobs demo.
x_shadebobs :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Shade bobs"$n" -------------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------------"
  v - rm t=100 w 512,512,0,"[G"{`39`}"MIC] Shade Bobs"

  # Start animation loop.
  do
    t+=0.015
    if {$t>4*pi" || "{*,b}} # Reset motions variables if necessary.
      rx={u(-1,1)} ry={u(-1,1)} rz={u(-1,1)} rt={u(-1,1)} rcx={u(-0.6*0.6)} t=0
      N={20+round(u(80))} R={(2+round(u(40)))*min({*,w},{*,h})/300}
      if $obj3d rm[colormap,img,obj3d] fi
      {4+round(u(12))},1,1,3 noise[0] 255,2 ==. 1 r[0] 256,1,1,3,3 *[0] 255 shift[0] 1 nm. colormap
      (67.5;73.5;109.5;103.5;51.5;100.5;{2*$N};$N) 3,{2*$N},1,1,0
      1,$N,1,1,5 2,$N,1,1,'y+x*$N' a[-2--1] x z. 0,5
      4,$N,1,1,1 y[-3--1] a[-4--1] y nm. obj3d
      {*,w},{*,h} nm. img
      wait -1
    fi

    # Compute bobs coordinates.
    r={$ry+$rx*cos(6*$rz*$t)+(1-$rx)*sin(6*$rt*$t)}
    (0;{30*$ry*($N-1)}) ($t;{2*pi*($N-1)/$N+$t}) r[-2,-1] 1,$N,1,1,3
    +.. {360*sin($rz*$t)} *.. {pi/180}
    +sin[-2,-1] cos[-4,-3] *[-4,-2] $r *[-3,-1] $rcx +[-4,-3] +[-2,-1]
    *.. {{*,w}/2} *. {{*,h}/2} a[-2,-1] x
    ++. $R -.. $R a[-2,-1] y z. 0,2 y. j[obj3d] .,0,8 rm.

    # Draw bobs, map colors and display.
    j3d[img] [obj3d],50%,50%,0,-1,2,0,0
    &[img] 255 +map[img] [colormap] w. rm. wait 20
    if {{*,CTRLLEFT}&&{*,D}} w[] 1024,1024 elif {{*,CTRLLEFT}&&{*,C}} w[] 512,512 fi
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 v +

#@cli x_spline
#@cli : Launch spline curve editor.
x_spline :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Spline curve editor"$n" --------------------------\n
----\n
---- "${c}"Mouse"$n" to insert/move/delete points.\n
---- Key '"${c}"R"$n"' to reset the curve.\n
---- Key '"${c}"SPACE"$n"' to shows/hide spline curve.\n
---- Key '"${c}"P"$n"' to shows/hide control points.\n
---- Key '"${c}"ENTER"$n"' to shows/hide control polygon.\n
---- Key '"${c}"T"$n"' to shows/hide point tangents.\n
---- Key '"${c}"I"$n"' to shows/hide point indices.\n
---- Key '"${c}"C"$n"' to shows/hide point coordinates.\n
---- Keys '"${c}"+"$n"' and '"${c}"-"$n"' to increase/decrease roundness.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"

  # Init display and variables.
  v -
  if $! a x n 0,255 to_rgb else (0;0^0;128^0;0) r. 512,512,1,3,3 nm. "[G"{`39`}"MIC] Spline Editor" fi
  w[0] {0,w},{0,h},0,0,-1,-1,{n} r[0] {*,w},{*,h},1,3,1
  i[1] 1         # Point coordinates
  roundness=0.5  # Curve roundness
  visuflags=23   # Visualisation flags
  nearest=-1     # Nearest point
  active=-1      # Active point

  # Start event loop.
  do

    # Init coordinates [1] if necessary.
    if {{1,whds}==1}
      rm[1] roundness=0.5 nearest=-1 active=-1
      i[1] ({0.2*w},{0.2*h};\
            {0.2*w},{0.8*h};\
            {0.8*w},{0.8*h};\
            {0.8*w},{0.2*h})
    fi

    # Estimate screen-normalized coordinates [2], curve tangents [3] and tangent orientations [4].
    [1] ({{*,w}/{0,w}},{{*,h}/{0,h}}) *[-2,-1]                       # Normalized coordinates.
    +shift[2] 0,-1,0,0,2 +shift[2] 0,1,0,0,2 -[-2,-1] *. $roundness  # Curve tangents.
    +s. x sqr[-2,-1] +[-2,-1] sqrt. r. 2 +/[-2,-1] rm..              # Tangent orientations.

    # Display curve, control points, polygon and tangents.
    +r[0] {*,w},{*,h},1,3
    if {$visuflags&4} polygon. {2,h},{2,^},0.3,128,200,255 fi
    repeat {1,h}
      line. {2,@0-3},0.3,255,255,0
      if {$visuflags&1} spline. {2,@0-1},{3,@0-1},{2,@2-3},{3,@2-3},1,255 fi
      if {$visuflags&8} line. {{2,@0}-{4,@0}*20},{{2,@1}-{4,@1}*20},{{2,@0}+{4,@0}*20},{{2,@1}+{4,@1}*20},1,0,255,0 fi
      if {$visuflags&16} t. $>,{{2,@0}-3},{{2,@1}-18},13,1,255,255,0 fi
      if {$visuflags&32} t. "("{round({1,@0})}","{round({1,@1})}")",{{2,@0}-16},{{2,@1}+10},13,1,100,200,255 fi
      shift[1-4] 0,-1,0,0,2
    done
    if {$visuflags"&2"} repeat {1,h}
      ellipse. {2,@0-1},4,4,0,1,0,0,0 ellipse. {2,@0-1},2,2,0,1,255,100,155 shift[2] 0,1,0,0,2
    done fi
    w. rm[3,4,-1] wait

    # Handle key events.
    if {*,SPACE} visuflags+={if($visuflags&1,-1,1)} wait -1 fi  # Show/hide spline.
    if {*,P} visuflags+={if($visuflags&2,-2,2)} wait -1 fi      # Show/hide points.
    if {*,ENTER} visuflags+={if($visuflags&4,-4,4)} wait -1 fi  # Show/hide polygon.
    if {*,T} visuflags+={if($visuflags&8,-8,8)} wait -1 fi      # Show/hide tangents.
    if {*,I} visuflags+={if($visuflags&16,-16,16)} wait -1 fi   # Show/hide indices.
    if {{*,C}" && "!{*,CTRLLEFT}" && "!{*,CTRLRIGHT}} visuflags+={if($visuflags&32,-32,32)} wait -1 fi # Show/hide coordinates.
    if {{*,PADADD}" && "$roundness<1} roundness*=1.1 wait -1 fi    # Increase roundness.
    if {{*,PADSUB}" && "$roundness>0.1} roundness*=0.9 wait -1 fi  # Decrease roundness.
    if {{*,R}" && "!{*,CTRLLEFT}" && "!{*,CTRLRIGHT}} rm. i[1] 1 wait -1 fi  # Reset curve.
    if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} w[] {{*,w}*1.5},{{*,h}*1.5} fi # Increase window size.
    if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} w[] {{*,w}/1.5},{{*,h}/1.5} fi # Decrease window size.
    if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} w[] {0,w},{0,h} fi             # Reset window size.
    if {*,r} w[] fi # Resize window if necessary.

    # Set/unset active point.
    if {{*,b}==0} active=-1                          # Unset active point if mouse button is released.
    elif {{*,x}>=0" && "{*,b}" && "$active==-1}      # Find new active point.
      [2] ({*,x},{*,y}) -[-2,-1] sqr. s. x +[-2,-1]  # Compute distance vector to points.
      nearest={ym}                                   # Set nearest point.
      if {im<64} active=$nearest fi               # Set it as active point, if near enough.
      rm.
    fi
    rm[2]

    # Move active point.
    if {{*,b}&1" && "{*,x}>=0" && "$active!=-1}
      =[1] {{*,x}*{0,w}/{*,w}},0,$active
      =[1] {{*,y}*{0,h}/{*,h}},1,$active

    # Delete nearest point.
    elif {{*,b}&2" && "{*,x}>=0" && "{1,h}>3}
      l[1] s y rm[$nearest] a y endl wait -1

    # Insert new active point.
    elif {{*,b}&1" && "{*,x}>=0}
      xy=({{*,x}*{0,w}/{*,w}},{{*,y}*{0,h}/{*,h}})  # Point coordinates in the image basis.
      +shift[1] 0,-1,0,0,2 +. [1] /. 2              # Compute center of segments.
      $xy -[-2,-1] sqr. s. x +[-2,-1]               # Compute distance vector to segments.
      ns={ym} rm.                                   # Get nearest segment.
      l[1] s y i[{$ns+1}] $xy a y endl              # Insert new point at right position.
      active={$ns+1}                                # Set new active point as newly inserted.
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}

  # Render spline as a tertiary mask for output.
  +shift[1] 0,-1,0,0,2 +shift[1] 0,1,0,0,2 -[-2,-1] *. $roundness
  [0],[0],1,1,2 rm[0]
  repeat {1,h} spline. {0,@0-1},{1,@0-1},{0,@2-3},{1,@2-3},1,1 shift[0] 0,-1,0,0,2 shift[1] 0,-1,0,0,2 done
  flood. 0,0,0,0,0,1,0

  # Exit properly.
  rm[0,1] w 0 v +

#@cli x_starfield3d
#@cli : Launch the 3D starfield demo.
x_starfield3d :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"3D starfield"$n" ---------------------------------------\n
----\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------"
  v - l[]
    ({'G\47MIC'}) s x
    x=0 N=$! repeat $N 0 t. {$>,t},0,0,48,1,1 x$>=$x y$>=0 z$>={-3200-150*$>} x={$x+w+8} done k[50%--1]
    expand_xy 6,0 dilate_circ 5 b 0.5 expand_z 1,0 isosurface3d 10% *3d 1,1,5 rv3d
    repeat $N col3d[$>] ${-RGB} done
    0 t. "Version "${-strver},0,0,48,1,1 r2dy. 18 +f. 255 to_rgb.
    random3d 2500 col3d. 255 *3d. 320,200,1000 -3d. 160,100
    l3d 0,0,-600
    w[] 640,400,0,"[G"{`39`}"MIC] 3D Starfield"
    t0=0 t=0

    do
      320,200,1,3

      # Starfield.
      l.. s3d
        r[2] 3,{2,h/3},1,1,-1 s[2] x %[4] 1000
        +/[4] 1000 *. -1 n. 0,2 c. 0,1 sqr. j.. . rm.
        a[2-4] x
        y a y
      endl
      j3d. ..,50%,50%,-600,1,0,0,0,240 -3d.. 0,0,{min(12,$t0/10-4)}

      # Torus.
      torus3d 100,30 col3d. 255,64,255
      +col3d. 64,64,255 r3d. 1,0,0,-90 +3d. 65,0,0
      +3d[-2,-1] c3d.
      r3d. 1,1,0,{-6*$t} r3d. 0,0,1,{2*$t}
      j3d.. .,{($t-200)*2}%,50%,0,0.25,3,0,0 rm.

      # Letters.
      repeat $N
        +r3d[$>] 1,{$>%4},1,{-${z$>}/2}
        j3d.. .,{90+${x$>}},{60+${y$>}},${z$>},1,4,0,0 rm.
        z$>={tl=280+6*$<;if($t<tl,min(0,${z$>}+20),-20*($t-tl))}
      done

      # Presents.
      if {$t<280} op={max(0,min(1,($t-200)/20))}
      else op={max(0,1-($t-280)/20)}
      fi
      j. ...,{(w-{-3,w})/2},120,0,0,$op,[-4]

      w. wait 30 rm.
      t0+=1 t={$t0%350}
      if {!$t} x=0 repeat 5 z$>={-3200-150*$>} done fi

    while {{*}" && "!{*,ESC}" && "!{*,Q}}
    w[] 0 rm endl v +

#@cli x_tetris
#@cli : Launch tetris game.
x_tetris :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Tetris"$n" --------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the "${g}"Tetris"$n" game.\n
----\n
---- "${c}"Arrow keys"$n" to move/rotate the triominos.\n
---- Key '"${c}"SPACE"$n"' to make the current triomino falling.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
----------------------------------------------------------"
  v - rm

  # Init board and triominos shapes.
  i[m0] 4,1,1,1,1,1,1,1
  i[m4] 3,2,1,1,1,0,0,1,1,1
  i[m8] 3,2,1,1,0,0,1,1,1,1
  i[m12] 2,2,1,1,1,1,1,1
  i[m16] 3,2,1,1,0,1,1,1,1,0
  i[m20] 3,2,1,1,0,1,0,1,1,1
  i[m24] 3,2,1,1,1,1,0,0,1,1
  if {u<0.25}  # Enable extended set.
    i[m28] 2,1,1,1,1,1
    i[m32] 2,2,1,1,1,1,0,1
    i[m36] 3,1,1,1,1,1,1
    i[m40] 1,1,1,1,1
    i[m44] 3,2,1,1,1,1,1,1,0,1
    i[m48] 3,3,1,1,1,1,1,1,0,1,1,1,1
  fi
  repeat $! i={4*$>} l[m$i] repeat 3 +rotate[0] {90*($>+1)} nm. m{$i+$>+1} done endl done
  N=$!

  # Render triomino colored sprites.
  i[colors] 3,$N,1,1,'u(16,224)' r. 3,400% i[mask] (0,-1,0;1,0,-1;0,1,0) *. 120
  repeat $N
    +r[m$>] 500%,500%,1,3 +correlate. [mask],0 r. 200%,200%,1,1,3 r.. . *[-2,-1] c. 30%,100%
    +r[m$>] .,.,1,3 +replace_color. 0,0,1,1,1,{colors,@{3*$>}-{3*$>+2}} rv[-3,-1] +[-3,-1] c.. 0,255
    channels. 0 *. 255 a[-2,-1] c nm. s$>
  done
  rm[colors,mask]
  fact={{s0,w}/{m0,w}}

  # Generate board and background.
  W=12 H=20
  i[board] $W,$H i[curr_board] [board]
  i[render] {$fact*$W},{$fact*$H},1,3 i[curr_render] [render] +channels. 0 nm. curr_render_mask
  +rows[render] 0,50% plasma. 1,2 noise. 20 blur_y. 40%,1 +mirror. y a[-2,-1] y r. [render]
  n. 0,64 blur_x. 1 100%,100% noise. 0.5,2 ==. 1 b. 1 *. 300 +[-2,-1] c. 0,255 nm. background

  # Start game.
  time=$| score=0 fall_mode=0 gameover=0 n=-1 nn={round(u(0,$N-1))}
  do
    wait {if($fall_mode,-1,-20)}

    # In case of game over.
    if $gameover
      +j[background] [curr_render],0,0,0,0,0.7,[curr_render_mask],255
      to. "Game\nOver!",22,30%,32,2,1,255 w. rm.
      continue
    fi

    # Check for completed lines and select new random triomino.
    if {$n<0}
      l[board] s y i=-1 repeat $! if {$<,im} i=$<,$i fi done
      0 rm[$i] a y score+={2^(narg($i)-1)-1} r $W,$H,1,1,0,0,0,1 nm board endl
      if {narg($i)>1} l[render] s y,$H 0 rm[$i] a y r {$fact*$W},{$fact*$H},1,3,0,0,0,1 nm render endl fi
      n=$nn nn={round(u(0,$N-1))} x={$W/2} y=0 do_render=1 fall_mode=0
    fi

    # Render board at current time.
    if $do_render
      rm[curr_board,curr_render,curr_render_mask]
      i[curr_board] [board] j[curr_board] [m$n],{$x-int({m$n,w}/2)},$y,0,0,1,[m$n]
      i[curr_render] [render] sh[s$n] 3 j[curr_render] [s$n],{$fact*($x-int({m$n,w}/2))},{$fact*$y},0,0,1,.,255 rm.
      +*[curr_board] 255 r. [curr_render],[curr_render] nm. curr_render_mask
      0 t. "Score : "$score"    Next :",4,0,32,1,164 r. 40%,40%,1,3,2 +!=. 0 *. 255
      j[curr_render] ..,0,0,0,0,1,.,255 j[curr_render_mask] .,0,0,0,0,1,.,255 rm[-2,-1]
      +*[m$nn] 196 r. 300%,300%,1,3 j[curr_render,curr_render_mask] .,{{curr_render,w}-w-4},3,0,0,1,.,196 rm.
      do_render=0
    fi

    +shift[background] 0,{round(-13*$|*1.04^$score)},0,0,2
    j. [curr_render],0,0,0,0,1,[curr_render_mask],255
    w. {2.25*w},{2.25*h},0,"[G"{`39`}"MIC] Tetris" rm. cursor[0] 0

    # Manage user interactions.
    if {*,SPACE} fall_mode=1 fi
    if {{*,ARROWUP}" || "{*,ARROWLEFT}" || "{*,ARROWRIGHT}}
      an={if({*,ARROWUP},n=$n+1;if(n%4,n,n-4),$n)}
      nx={w2=int({m$an,w}/2);max(w2,min($x-{*,ARROWLEFT}+{*,ARROWRIGHT},$W-({m$an,w}%2)-w2))}
      +j[board] [m$an],{$nx-int({m$an,w}/2)},$y,0,0,-1,[m$an]
      if {{iM}==1} x=$nx n=$an fi
      rm.
      do_render=1
    fi

    if {{*,ARROWDOWN}" || "$|-$time>0.9^int($score/2)" || "$fall_mode}   # Piece goes down.
      y+=1
      +j[board] [m$n],{$x-int({m$n,w}/2)},$y,0,0,-1,[m$n]
      if {{iM}>1" || "$y+{m$n,h}>$H}
        if {$y<=1} gameover=1 fi  # Game over!
        j[board] [curr_board] j[render] [curr_render] n=-1
      fi
      rm.
      time=$| do_render=1
    fi

  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 v +

#@cli x_tictactoe
#@cli : Launch tic-tac-toe game.
x_tictactoe :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Tic-Tac-Toe game"$n" -----------------\n
----\n
---- Use "${c}"mouse"$n" to select positions of the\n
---- symbols. Close window to exit game.\n
----\n
-----------------------------------------"
  v -                          # Become quiet.

  # Allocate variables.
  message=0                    # [-7] : State message.
  counter=0                    # [-6] : Turn counter (0 to 8).
  player=0                     # [-5] : Current player (0 or 1).
  state=0                      # [-4] : Board state.
  tmp3=0                       # [-3] : Temporary variable 3.
  tmp2=0                       # [-2] : Temporary variable 2.
  tmp1=0                       # [-1] : Temporary variable 1.
  _x_tictactoe2                # Generate board.
  w. -1,-1,0," "               # Init display window.

  # Start main loop.
  do

    # Set state message depending on the current player.
    if $player message="Tic-Tac-Toe (O to play)"
    else message="Tic-Tac-Toe (X to play)"
    fi

    # Select position by the user.
    do                                                                       # Enter event loop.
      w[] {w},{h},0,"[G"{`39`}"MIC] "$message wait                            # Wait for events and force window size if necessary.
      if {!{*}" || "{*,ESC}" || "{*,Q}} w[] 0 rm v + return fi         # Quit properly if window has been closed.
      if {{*,b}&1" && "{*,x}>20" && "{*,y}>20" && "{*,x}<400" && "{*,y}<400}   # If mouse button has been pressed on the board area.
        tmp3={int(({*,x}-15)/130)}                                              # Get x-coord of the selected position (0,1 or 2).
        tmp2={int(({*,y}-15)/130)}                                              # Get y-coord of the selected position (0,1 or 2).
        tmp1={4^($tmp2*3+$tmp3)}                                                # Get state code of the selected position.
        if {int($state/$tmp1)%4} tmp1=-1 fi                                # Check availability of the selected position.
      else tmp1=-1 fi                                                      # If no mouse button, do nothing but loop.
    while {$tmp1<0}                                                          # Go on until a valid position has been selected.

    # Draw symbol on selected position and update board state.
    _x_tictactoe{$player%2}                                                  # Generate the symbol sprite and his mask.
    j... ..,{"130*"$tmp3" + 15+u(-5,5)"},\                                   # Draw symbol at its position (with some fuzzyness).
               {"130*"$tmp2" + 15+u(-5,5)"},0,0,1,.
    rm[-2--1]                                                                # Delete the sprite and the mask (not needed anymore).
    w.                                                                       # Update display window.
    state+={(1+$player)*$tmp1}                                                # Update the board state.

    # Check for a winning configuration.
    (21,1344,86016,4161,16644,66576,65793,4368;\                              # The list of winning configurations.
     0,0,0,0,1,2,0,0;\                                                        # Corresponding X coords for the stroke.
     0,1,2,0,0,0,0,0;\                                                        # Corresponding Y coords for the stroke.
     3,3,3,4,4,4,5,6)                                                         # Corresponding index of the stroke sprite.
    repeat {w}                                                               # Start to check configurations.
      tmp1={@$>}                                                              # Save the current configuration code (used several times).
      if {($state&$tmp1)==$tmp1||($state&(2*$tmp1))==2*$tmp1}                # If a winner has been found.
        _x_tictactoe{i($>,3)}                                                # Generate the stroke symbol and his mask.
        j[-4] ..,{130*{-3,i($>,1)}+u(-5,5)},\                                # And display it on the board at its position.
                        {130*{-3,i($>,2)}+u(-5,5)},0,0,1,. rm[-2--1]
        if {($state&$tmp1)==$tmp1} w.. -1,-1,0,"Tic-Tac-Toe (X won!)"
        else w.. -1,-1,0,"Tic-Tac-Toe (O won!)"                             # Update display window.
        fi
        do wait
          if {*} w[] {*,w},{*,h} fi
        while {{*}" && "!{*,ESC}" && "!{*,Q}}                                # Wait for the window to be closed.
        rm w[] 0 v + return                                               # And return properly.
      fi
    done                                                                     # Go on until all configurations have been checked.
    rm.                                                                      # Delete winning configuration data.

    player={($player+1)%2}                                                  # Select next player.
    counter+=1                                                              # Increment turn counter.
  while {$counter<9}                                                       # Loop to next move until all positions have been filled.

  # Here, the game has been ended without winners.
  w[] -1,-1,0,0,"Tic-Tac-Toe (Tied game!)"                                 # Change window title.
  do wait
    if {*} w[] {*,w},{*,h} fi
  while {{*}" && "!{*,ESC}" && "!{*,Q}}                                    # Wait for the window to be closed.
  w[] 0 rm v +                                                           # Return properly.

# Generate Tic-Tac-Toe graphics.
_x_tictactoe : # Apply a hand-drawing effect.
  spread. 4 b. 6 sharpen. 0.8 n. 0,1

__x_tictactoe : # Apply color to last image and generate corresponding opacity mask.
  +f. 1-i +n.. $2,255 +n... $3,255 n[-4] $1,255 a[-4,-2,-1] c

_x_tictactoe0 : # Generate a 'X' and his mask.
  128,128,1,1,1 line. 15%,15%,85%,85%,1,0 line. 15%,85%,85%,15%,1,0 erode. 12 _x_tictactoe deform. 4 __x_tictactoe 40,40,160

_x_tictactoe1 : # Generate a 'O' and his mask.
  128,128,1,1,1 ellipse. 50%,50%,22%,22%,0,1,0 ellipse. 50%,50%,15%,15%,0,1,1 _x_tictactoe deform. 4 __x_tictactoe 160,40,160

_x_tictactoe2 : # Generate the board.
  391,391,1,1,"!(x%130) || !(y%130)" r. 421,421,1,1,0,0,0.5,0.5 dilate. 3 _x_tictactoe f. 1-i
  100%,100% noise. 10 b. 8,0 sharpen. 1.5 n. 220,255 *[-2,-1] to_rgb.

_x_tictactoe3 : # Generate an horizontal stroke and his mask.
  421,130,1,1,1 line. 10%,60%,90%,60%,1,0 erode. 6 _x_tictactoe rotate. {u(-6,6)},1,1,50%,50% __x_tictactoe 180,10,10

_x_tictactoe4 : # Generate a vertical stroke and his mask.
  _x_tictactoe3 transpose[-2--1]

_x_tictactoe5 : # Generate a ++ diagonal stroke and his mask.
  421,421,1,1,1 line. 10%,10%,90%,90%,1,0 erode. 6 _x_tictactoe __x_tictactoe 180,10,10

_x_tictactoe6 : # Generate a +- diagonal stroke and his mask.
  421,421,1,1,1 line. 10%,90%,90%,10%,1,0 erode. 6 _x_tictactoe __x_tictactoe 180,10,10

#@cli x_waves
#@cli : Launch the image waves demo.
x_waves :
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Image waves"$n" --------------------------\n
----\n
---- "${c}"Left mouse button"$n" to drop balls.\n
---- "${c}"Right mouse button"$n" to rotate view.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"CTRL+F"$n"' to switch fullscreen mode.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
---------------------------------------------"
  v -
  if {!$!} l[] # Generate fractal image
    200,200 x={-1.06-u*0.1} y={-0.26-u*0.1}
    mandelbrot $x,$y,{$x+0.1},{$y+0.1},256
    16,1,1,3,u r. 256,1,1,3,3 shift. 1
    map[0] . rm. r2dx 100
    +mirror y +mirror x + n 0,128
    shape_fern {2*w},70%,25 r2dx. {-2,3*w/4} to_rgb. r. ..,0,0,0.5,0.5 n. 0,196 +[-2,-1] c. 0,255
  endl else k[0] r[0] 100,100,1,3,2 fi
  i[0] (20;80;0^20;80;0^20;80;0) r[0] 400,300,1,3,3 water[0] 100,2
  w[0] {0,1.25*w},{0,1.25*h},0,"[G"{`39`}"MIC] Image Waves"
  w={w} elevation3d. 0 rv3d.
  sh. 8,{7+3*i[6]},0,0 r. 3,{h/3},1,1,-1
  (0,1,0;1,0,1;0,1,0) /. 2
  ball[] 20,200,255,128,1,0.7,3.5

  0 $w,$w .
  l3d {$w/2},-200,-1000 sl3d 0.4 ss3d 0.8 f3d 500 time0=$|
  do
    +convolve. [3],1 -. ... rm... b. 0.8 -. {ia} # Update height map.
    r. 1,{$w*$w},1,1,-1 j[2] .,2,0 r. $w,$w,1,1,-1 # Set 3D object coordinates.
    [1]
    if {5,h} +l[5] rows 0,2
      nb={w}
      i[0] ({'CImg3d'}) i[1] ($nb,$nb) transpose[2]
      (1,0;1,{$nb-1}) r. 2,$nb,1,1,3 round.
      1,{4*$nb},1,1,1 y a y
    endl [4] sprites3d.. .,1 rm. +3d[-2,-1] fi
    -3d. {$w/2},{$w/2} *3d. {0,0.9*max(w,h)/$w} # Center and scale 3D object.
    r3d. 0,0,1,{if({*,b}&2,{*,x}*360/{*,w},$|*30)} r3d. 1,0,0,120 # Get rotated 3D object.
    +j3d[0] .,50%,65%,30,1,3,0,0
    fps=${-fps} if {$fps>0} to. $fps" fps",5,{h-22},16,2,0.2 fi
    w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {2.25*w},{2.25*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.25*w},{1.25*h}
    elif {{*,CTRLLEFT}&&{*,F}}
      if {!narg($is_fs)} is_fs={*,w},{*,h} fw={min({*,u}*h/w,{*,v}*w/h)} w[] $fw,{$fw*h/w},0,1
      else w[] $is_fs,0,0 is_fs=""
      fi
    fi

    rm[-2,-1] wait 20
    if {{*,b}&1||($|-$time0)>1} ({u*$w};{u*$w};70;0) a[5,-1] x time0={$|-u} fi # Insert new ball.
    if {5,h} l[5,-1] # Manage ball motion and collision.
      sh[0] 2,2,0,0 sh[0] 3,3,0,0 -.. . +. 0.2 rm[-2,-1]
      s[0] x repeat {$!-1} coords={$<,@0-1} if {{$<,@2}<i($coords)} =. {80+{i($coords)}},$coords rm[$<] fi done
      if {$!==1} i[0] 0 else a[0--2] x fi
      endl
    fi
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm w 0 v +

#@cli x_whirl : _opacity>=0
#@cli : Launch the fractal whirls demo.
#@cli : Default values: 'opacity=0.2'.
x_whirl : check "${1=0.2}>=0"
  if {!{*,u}} error[0--3] "Command '$0': No display available." return fi
  v - use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r v +
  e[] "\n
------ "${g}"Fractal whirls"$n" ----------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------"
  v -
  5,5,1,3 256,256,1,3 [-1] w. 384,384,0,"[G"{`39`}"MIC] Fractal Whirls"
  tangle=0 tzoom=0 xc={(w-{-3,w})/2} yc={(h-{-3,h})/2}
  do
    rand... 0,255 j.. [-3],$xc,$yc,0,0
    f.. "*begin(R = rot(8*sin(-"$tangle"))/(1.03+0.02*sin("$tzoom")); C=[w,h]/2); I((R*([x,y]-=C))+=C,0,0)"
    tangle+=0.001
    tzoom+=0.02
    j. [-2],0,0,0,0,$1 w.
    if {{*,CTRLLEFT}&&{*,D}} w[] {3*w},{3*h} elif {{*,CTRLLEFT}&&{*,C}} w[] {1.5*w},{1.5*h} fi
    wait 20
  while {{*}" && "!{*,ESC}" && "!{*,Q}}
  rm[-3,-2] w[] 0 v +

#-------------------------------------
#
# Define menu entries for
# the G'MIC plug-in
#
#-------------------------------------
__help_end : #  <-- don't remove me, used as a end marker for command 'help' !

# Function that returns the list of external sources to be included in the plug-in.
# This command can be superseded on the user '.gmic' file to add sources for the plug-in.
# $1 = try network update
# $2 = try 'gui_filter_sources' defined in local update file.
gui_filter_sources : skip ${1=0},${2=1}

  # Try to update the command 'gui_filter_sources' itself.
  if {$2}
    local=${_path_rc}update$_version.gmic
    if $local m $local gui_filter_sources $1,0 return fi
  fi

  # Try to clean older update files to save disk space.
  if {u>0.95} l[]
    files=${"files "$_path_rc"/update*.gmic"}
    repeat {narg($files)}
      file=${arg\ 1+$>,$files}
      ({'$file'}) z. {[w-8,w-6]} ver={t} rm.
      if {isval($ver)" && "$ver<$_version} 0 o. raw:$file,uchar rm. fi
    done
  onfail
  endl fi

  # Build list of filter sources.
  ({'https://gmic.eu/update$_version.gmic'},1) # Include stdlib update (last 1 -> Override default filters).
  l[] _gui_filter_sources $1 onfail rm endl # Invoke custom command to include other filter sources.
  l[] i cimgz:${_path_rc}gui_filter_sources onfail endl # Include other user-defined filters sources.
  ({'{/$_path_user}'}) # Include local '.gmic' (or 'user.gmic') file.

# Function that always returns a valid preview size.
gui_preview_wh :
  u {0$_preview_width?[0$_preview_width,0$_preview_height]:[400,400]}

# Function used for filters based on parallelization with spatial splitting.
gui_parallel_overlap :
  apo "$1",$3,{if($2,2^($2-1),0)}

# Function that renders a single preview image from multiple preview images.
# Pre-cond : Number of image is $!>1.
gui_preview :
  frame 1,1,0,0,0,255 montage B

# Return name of a layer.
gui_layer_name :
  u ${"_gui_merge_layers[0] name,[unnamed]"}

# Return blending mode of a layer.
gui_layer_mode :
  u ${"_gui_merge_layers[0] mode,alpha"}

# Return opacity of a layer.
gui_layer_opacity :
  u ${"_gui_merge_layers[0] opacity,100"}

# Return (x,y) position of a layer.
gui_layer_pos :
  u ${"_gui_merge_layers[0] pos,0,0"}

# Set name of a layer.
gui_set_layer_name :
  repeat $! l[$>]
    opacity=${-gui_layer_opacity} mode=${-gui_layer_mode} pos=${-gui_layer_pos}
    nm "name($1),mode("$mode"),opacity("$opacity"),pos("$pos")"
  endl done

# Set blending mode of a layer.
gui_set_layer_mode :
  repeat $! l[$>]
    name=${-gui_layer_name} opacity=${-gui_layer_opacity} pos=${-gui_layer_pos}
    nm "name("$name"),mode($1),opacity("$opacity"),pos("$pos")"
  endl done

# Set opacity of a layer.
gui_set_layer_opacity :
  repeat $! l[$>]
    name=${-gui_layer_name} mode=${-gui_layer_mode} pos=${-gui_layer_pos}
    nm "name("$name"),mode("$mode"),opacity($1),pos("$pos")"
  endl done

# Set position of a layer.
gui_set_layer_pos :
  repeat $! l[$>]
    name=${-gui_layer_name} mode=${-gui_layer_mode} opacity=${-gui_layer_opacity}
    nm "name("$name"),mode("$mode"),opacity("$opacity"),pos("{round("$1")},{round("$2")}")"
  endl done

# Flatten list of input layers according to their blending modes, opacities and positions,
# set in each layer name by the G'MIC plug-in.
gui_merge_layers :
  if {!$!} return fi
  mode0=${"_gui_merge_layers. mode,alpha"}
  opacity0=${"_gui_merge_layers. opacity,100"}
  pos0=${"_gui_merge_layers. pos,0,0"}
  if {$opacity0<100" || "['$pos0']!='0,0'} 100%,100%,1,4 fi
  wh0={w},{h}
  wh=${-max_wh} r. $wh,1,100%,0
  repeat {$!-1} l[-2,-1] rv
    mode=${"_gui_merge_layers[1] mode,alpha"}
    opacity=${"_gui_merge_layers[1] opacity,100"}
    pos=${"_gui_merge_layers[1] pos,0,0"}
    to_a[1] r[1] $wh,1,100%,0
    shift[1] ${u\ $pos},0,0
    to_colormode[0,1] 0
    blend $mode,{max(0,min(1,$opacity/100))}
  endl done
  r $wh0,1,100%,0

_gui_merge_layers :
  u {`"
    str = ["{'{n}'}"]; const sstr = size(str);
    def = ['${2--1}'];
    ker = ['$1(']; const sker = size(ker);
    const N = max(size(str),size(def));
    res = vectorN(0);
    p = q = find(str,ker);
    p>=0?(
      q+=sker;
      r = find(str,'),',1,q);
      q = r>=0?r:(str[sstr-1]==_')'?sstr-1:-1);
    );
    q>=0?copy(res,str[p + sker],q - p - sker):(def = ['${2--1}']; copy(res,def,size(def)));
    res"`}

# gui_split_preview : "command",_split_type,_split_posx,_split_posy
# 'split_type' can be { 0=no split | 1=forw. horiz. | 2=forw. vert. | 3=back. horiz. | 4=back. vert. | 5=dupl. left | 6=dupl. top | 7=dupl. bottom | 8=dupl. right | 9=dupl. horiz.l | 10=dupl. vert. | 11=checkered | 12=checkered inv. }
# if 'posx' or 'posy' are equal to 'nan', splitting is done at the middle, and moving is not possible.
# 'compute_entire_image' can be { 0=no | 1=yes }.
gui_split_preview : check "isint(${2=0}) && $2>=0 && $2<=12 && ${5=0}>=0" skip "${3=nan},${4=nan}"
  m "_split_preview : $1 k[0]"
  is_movable={!isnan($3)" && "!isnan($4)}
  posx,posy={$is_movable?cut([$3,$4],0,100):[50,50]}
  pw,ph=${-gui_preview_wh}
  repeat $! l[$>]
    is_timeout=0
    +l apply_timeout _split_preview,0$_preview_timeout onfail gui_timeout_preview is_timeout=1 endl
    if {$is_timeout" || "!$2} k.
    else
      drgba rr2d $pw,$ph,0,2
      r {[max(w#0,w#1),max(h#0,h#1)]},1,100%,0,0,0.5,0.5
      posx,posy={round([$posx,$posy]*([w,h]-1)%)}

      if {$2==1" || "$2==3} # Forward/backward horizontal
        1,[0],1,1,'y>=$posy?($2==1):($2==3)' r. [0],[0],1,1 j[0] [1],0,0,0,0,1,.
      elif {$2==2" || "$2==4} # Forward/backward vertical
        [0],1,1,1,'x>=$posx?($2==2):($2==4)' r. [0],[0],1,1 j[0] [1],0,0,0,0,1,.
      elif {$2==5} # Duplicate top
        j[0] [1],0,$posy
      elif {$2==6} # Duplicate left
        j[0] [1],$posx
      elif {$2==7} # Duplicate bottom
        j[0] [1],0,{$posy-h}
      elif {$2==8} # Duplicate right
        j[0] [1],{$posx-w}
      elif {$2==9} # Duplicate horizontal
        if {!$posy} k. elif {$posy>=h} k.. else r[0] 100%,$posy,1,100%,0,0,0,0.5 r[1] 100%,{h-$posy},1,100%,0,0,0,0.5 a y fi
      elif {$2==10} # Duplicate vertical
        if {!$posx} k. elif {$posx>=h} k.. else r[0] $posx,100%,1,100%,0,0,0.5 r[1] {w-$posx},100%,1,100%,0,0,0.5 a x fi
      elif {$2==11} # Checkered
        1,[0],1,1,'y>=$posy' [0],1,1,1,'x>=$posx' r[-2,-1] [0],[0],1,1 xor[-2,-1]
        j[0] [1],0,0,0,0,1,.
      elif {$2==12} # Checkered reverse
        1,[0],1,1,'y<=$posy' [0],1,1,1,'x>=$posx' r[-2,-1] [0],[0],1,1 xor[-2,-1]
        j[0] [1],0,0,0,0,1,.
      fi
      k[0]

      dir=0
      if {isin($2,1,3,5,7,9,11,12)}
        dir+=1
        line 0,$posy,100%,$posy,0.75,0xF0F0F0F0,255 line 0,$posy,100%,$posy,0.75,0x0F0F0F0F,0
        if $is_movable
          coords={p=[$posx,$posy];[p+[-10,-1],p+[10,-1],p+[0,-11]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
          coords={p=[$posx,$posy];[p+[-10,1],p+[10,1],p+[0,11]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
        fi
      fi
      if {isin($2,2,4,6,8,10,11,12)}
        dir+=2
        line $posx,0,$posx,100%,0.75,0xF0F0F0F0,255 line $posx,0,$posx,100%,0.75,0x0F0F0F0F,0
        if {$2!=9" && "$is_movable}
          coords={p=[$posx,$posy];[p+[-1,-10],p+[-1,10],p+[-11,0]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
          coords={p=[$posx,$posy];[p+[1,-10],p+[1,10],p+[11,0]]} polygon 3,$coords,0.7,255 polygon 3,$coords,0.7,0xFFFFFFFF,0
        fi
      fi
      l[]
        0 +t. "After",0,0,20,1,255 t.. "Before",0,0,20,1,255
        autocrop 0 z[0] {0,[-1,-1,w,h]} z[1] {1,[-1,-1,w,h]}
        if {isin($2,3,4,7,8,12)} rv fi
        +dilate[-2,-1] 3 /[-2,-1] 255 r[-4,-3] 100%,100%,1,3
      endl

      if {-4,"const c1 = "$posx">w+2; const c2 = "$posy">h+2; arg("$dir",c2,c1,c1&&c2)"}
        j[0] [-4],2,2,0,0,1,..
      fi
      if {-3,"const c1 = "$posx"<w#0-w-3; const c2 = $2<11?("$posy"<h#0-h-3):("$posy">h+2); arg("$dir",c2,c1,c1&&c2)"}
        j[0] [-3],{[w#0-3-w,isin($2,11,12)?2:h#0-3-h]},0,0,1,.
      fi
      k[0]
    fi
  endl done
  uncommand _split_preview

# Command to display text on a the G'MIC plug-in preview.
# $1 : header message
# $2 : header font size.
# $3 : main message
# $4 : main font size.
gui_print_preview : skip "${1=},${3=}" check "${2=32}>=0 && ${4=20}>=0"

  # Resize image to output resolution.
  if $! k[0] fi
  drgba
  siz={0$_preview_width?[0$_preview_width,0$_preview_height]:[${fitscreen\ {[max(w,1),max(h,1)]},1,400}]}
  sizw={arg(1,$siz)-8}
  if $! rr2d $siz,2,3 drgba else $siz,1,3,128 fi
  (1;0.5^1;0.5^0;1)
  (0,0.5,0;0.5,1,0.5;0,0.5,0) *. 0.65
  r[-2,-1] ...,3 * c 0,255

  # Render title.
  l[]
    0 t. "$1",0,0,$2,1,255 i.. 100%,100%,1,3 fc.. 255,200,120 a[-2,-1] c r2dx. {min(w,arg(1,$sizw)-8)} r. 100%,140%,1,100%,0,0
  onfail rm
  endl

  # Render message.
  l[]
    0 t. "$3",0,0,$4,1,255 i.. 100%,100%,1,3,255 a c
    ({'"$3"'}) is_err={"crop(0,4)=='*** '"} rm.

    if $is_err
      x={"T = crop(0,0,0,3,32,h,1,1);
          for (c = 32, c<w, ++c, crop(c,0,0,3,32,h,1,1)==T?break());
          c<w?for (0, c<w, ++c, max(crop(#-1,c-2,0,0,3,5,h,1,1))<=0?break());
          c<w?c:0"}
      if $x +z. {$x+1},100% z.. 0,$x sh.. 0,2 fc. 0,255,0 rm. i.. 1,10 fi
    fi

    repeat $! l[$<]
      for {w>$sizw}
        x={"const c0 = "$sizw"-1;
            const c02 = c0/2;
            for (c = c0, c>=c02, --c, max(crop(#-1,c-2,0,0,3,5,h,1,1))<=0?break());
            c<c02?for (c = c0, c>=c02, --c, max(crop(#-1,c,0,0,3,1,h,1,1))<=0?break());
            c<c02?c0:c"}
       +z. {$x+1},100% z.. 0,$x
      done
    endl done
    a y,0
  onfail rm
  endl

  a[^0] y,0.5
  r. [0],[0],1,100%,0,0,0.5,0.5
  blend alpha

gui_no_preview : skip "$*"
  gui_print_preview "",0,"No preview available",32

gui_timeout_preview :
  gui_print_preview "",0,"Preview timeout",32

gui_warning_preview :
  gui_print_preview "Preview warning:",32,"$*",22

gui_error_preview :
  gui_print_preview "Preview error:",32,"$*",20

gui_check_version :
  if {$_version<$1}
    gui_error_preview "This filter requires at least version *"${"strver $1"}"* of the G'MIC framework.\n\n"\
                      "https://gmic.eu/download.shtml"
    u 0
  else u 1
  fi

# Function to auto-crop layers and set their positions.
gui_autocrop_layers :
  repeat $! l[$>]
    nm=${-gui_layer_name}
    mode=${-gui_layer_mode}
    opacity=${-gui_layer_opacity}
    coords=${autocrop_coords\ auto}
    z $coords
    nm mode($mode),opacity($opacity),pos({arg(1,$coords)},{arg(2,$coords)}),name($nm)
  endl done


#@gui ____<i>About</i>
#---------------------

#@gui About G'MIC : _none_, _none_
#@gui : note = note{<center><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAAAuCAMAAACRQELNAAAC/VBMVEUAAADq6url4+afoKDj4+bJyMj09fXz8/R2bHHd3t98hoiPk5q5ucGMiIq2s7VxfoPn5+/k4+T09fXPztDc29urp7VUOVGzrLJxZnXNysujnKTNzM68uL3PxNJYXmjZ2d3FxMXQ0NG/wMluapNdbHTFxcrZ1tqUmJikpqeioLROV13Qz9Dp5+zFusJZVGybgZiSdIi/vMHt6/GLgJNzXqOBk6EzGyPc2eGysbuUeIFlV22ko7G0iLO4tLePj47o5Orp6+9fQ3KKg5Zxc4cnIiRlb4V/X3JyeIhBQVasq60gFByMip2/zteSkLNhS7dNUXZVRpP4+/xxQFo8PVM1PEscQFIkSViqqa0wN0MuQEw7OFo0L1YTOUogPmwaKzRHQXSgq6snO0geMEQtS3U5Pk8zLkstVHwHPDJAOWcWNUMMRDuSlpslR28oQWhBRWc3OmZXODkRIS02WIMgQ2MVNVkvOVRHQUtGP14lOVItQXk5MnckL1hPSGk8SFNtE0MnND8OKDYIGCC2ubtkLUgtKzihoqUjHHcsLmMwQVkiMU4QLUI1J0JmPTg/OokZOmJYP0Q9OkQeOkRZKDxOJzNiW4M2RGYoOV57FFIQMU83MDe9rrg6PnYRTUMGKyI8Rn9JK1NmFU69wMRYKFYVVUlaGElGNDdbDjZVLyptfsJqbrWFk5F2SHo3TXMpM3IyI21oO2dNWGZsKVgvIVSKiaFeWpiBb3kbFWc7LGU9L1YWNjuDg5xWS4IwSU4cS0kmI0RNG0AhHiOvma+Qj62UoaJ+ipYtJo0nT2djPVtQKUmko75LRKh/WYckUnhDVFq8tct8c6qTZqOVkZJOW4dWMmUbLGVXTlkZKFQ/LUPO0dFITY+SVYZlen9sUXNIaGyJNWt2SV1FCiqmsrWmaIQdHDaokp2yU4qlO3mHVG52W2eUI2B+KErp5+rBvtWNfbiMoLW3d6FnU1wYFk6QkNxdaaKyYKJYcYo9WXI7ZI9DJiRWWbifoKw6K53Uk8BIeK98O59P6uXMAAAAVXRSTlMAEgfSDZoaJa00/iUb/pH+b1Y8cko2/v398pGFJv7+ysa3Zf7935Hw57qxqGJHG/7+rHtV/v7+99WukGf76ejWk/6EbjPm3tfWzfHD/efm89mw7uycrUNQWgAAEOhJREFUWMPMlnlMkmEcx5EQoszwRCvSclmWiqamqR3WutZ9bG6wRlvm3k0FRweLGH/ElJqSTUQLNkCGJkERisdii2EZGC4JK5czJPNISy2z+1jPC0oXtLba6vuMP56H9/29n/f7OwDxF4VejkH870ITB1eGobwQ/7UwMqlU2pvph/gnwrg9xEUmeK9ZsxznOkmQSysqBgv+zEo0bm1a2gLcbpz/r65CYVE/nMTPRf9wgoxJMcvscqnebu8hEtYEOu9IlUuHbIb4PyBEzUx5dfjI/twj5849TNoW5ofydOG81qiFwCesH9a5DYqPI3zfEMi0jWqNbWBgqEIqra62201xwrVeKARqD5tdkT7LB+OPBsFRv0Xlj8Viv+7SNrzO/vTp05vsttzDR84deZ20ba2HtMwcaY/Yvr0sghDueM66DIslPX0u5hvGlXrbRH//wNBQBVsqZVcD2TmhOEQMh13dVR+PHiwN3rNxY3KQB67lOBwOjrt904YNm6k7k7a4OKIE1hqgT2/o2YdvHs7Nbbt5M2mNe8qF7e0jWiaP+SzAQbTG8vnzZ6UwxcvFmCofmOgfGKhgg1UBGNlA1XZD9MZq9nBcDnbOwCCHI9fXh/8QN4bBYrGo5GunyVdOgi3jPldEo52gXZ02FXl6uWK8puYlPTu7ra3N8cnNHl3tPiNR7eMKJpfZjg90bL3SOz5bDHhXUtDT+7smJmwVUrlcLpXa2FKQYwCp6VtQbx/uvRMZ09tvK9XLTUbhD4Wceq2sXSeicUVcaibYUrXjNWIB9b4LcnpeDUBU5R3MdohOz247Mzrb1x2i13adVstjii43h062V73FojREur6f1vtxYqxXo5HCjFLYzAoAaReuDgzt4wh9EWP9vTaOyaQx9QV83xObdSMjOgpEEXFZMCRlfFwhVqnEU5BRtJoaxYPjuQcBHf0gsPMNPfdm0mK0u/baqn3AY8ILSnY6iQldtYggdM0Z396PY/0fuzQwpcZmA4RDYIFaBEjehNX+6UMD/TaNXq+RE4XfRU5gjYwkJlJoYJXBkBGKmpdisUhU54RMA4w19OPHxQCS/gasbGDkqxmA4Wclt7YyxY0iHo/Z2B6GBN23FonFoAPDpl7Ib3BszKJRqzUauWYsLo5IBKaCouTE4ZFw2WHnDLOH+m1yvZ4jMwq/m+pbMxItFh1Eg2haB2QZU/sAVKXI6aTPTgXwcf/B/XSxdfTGjaSk0aRXR1SjW34CRCJBNsOSWykRiTwepRGq9IOpvp+0UV3pH7v0Jo1MrjSE4ON9Q/F9QuGT6rg7kzW7srp6eGBYry8FrYP/tp4w3RlKi5lFJu+kOJ1kNeoo3EticbMDcr1VoXhQngcq0vpodqZ3eGhmzoHKRzlB3+JhFq5fPydq67oALzR22ZL2dl771brWyrCfZ6hywjKmlgGpiYsDndwLfcOFBfFTHWpnDw8N60vh1nmy6Jvx4V3UoTR3MBhkGkVXlokB3Q1RIC5XxHSkGxWhULwUAEj6q+uzIp3F7+eb4ov6doaeuMu9e9862npySSQCGfDicnNOuLd3gM9PkKnmiS61TC2RSfoKMF/fMdB7qhxW8tnDw9WlfH4ph8MRznOlCBUiUZu7m5pIDNKkk1kkCgTRaE7IBK1CYS3Py6Nbb1z0/9rEyK+9sul+Q8uHS3ebWzMXzY0Gd2Bmzy8IRcTGRs7z8fGBH/CVZrOyS6nuMHd0mIm+CHeaDuh6SktLHZBxy1zngcHAyAxWE5kBQZOQZIhCBV0Epxt9VaFQCMpVuQBygdu4qXcL343fKhQ9i8dOvsDT9+FeMTNm5RQUCFeFL1jnGxmNcToV1K3s6oJ9lBgWo9xDruDzjRxACUM+wbtcWWeSqTMkJAaZBDVCTshDEBXIARmt0760lpeDETm6BO02rrah5d27W4UN1qf+mMnXXuCFCKysfApEMBjMSrMxjhANQ6XKZF3qYIlE0g0mjkfI/Hz+JGZfNJxqIORSk0xpZhxikJog0qST1wCiwOqAXEfRaQUCgYoueOTrPu6uhsKGhpYW3rsHESkJQTE+sbGxPkFBMxc+M9Tf6yyq7TCnp1uUxrjb0WCuK2VKYyeADClAeIQszS8GmKAsOfa+VVP/B553GpUSBglYCdGcTp69xqKeKqfSYMh9tRQdt1ygUl2dgXUfdxEXUBa+47UU8rS1zMQdu3bsSkzUJjbW1jYVSbqJBuFtPN5gIBKTA/yDZWq1SWKSddSv8gT5ln+huLg4n8/nl5Twn6+afOb686ZutYTBIAFRp5ykCY4KTtFA4yA311IoJ1QqVXnrarTD+J/i4ppfFBa2tNxqKQSOAl2G1dh47RCrDk8QFuDDA/yXL5+7LBS/zC9Yr1Qbg409xjveHp28UAwogUpKqkxVwjTn8T1TcLdEcuwYiZSVdZTqgDzGoJKOAkwwzGP31upoJwQHxXk5KVON/WPgtc3cF4DyQ8stXiGshstMXVlE3W3CSTzhNiEM4bovoahDbSYGP3/yJHOeR8ie3uLiC/n5JflVVcHHQsIdpiSU9BiDO4s6sxhZWVlU1nwH5CEW66iACjsZy4DAT9EJkcg6ey7Cg5C4Z3UUkPMW4CUvcWSkufX9+8qnybfrylhlGd2VCJeiHjd1ZDQ1dXeHeIZ82zN4AVDWV1VVlZTkl5yEBxhyY0+PsbOoKIQBO0kmXXHWJAkikclQM4BsqqVAZK5IFFEfjfAo9BdC7DY0iTiOA7i1ERU51tOyJ6OtoEfogdYTUS9Wq70IIpbnXZfz4cZAp7Z25z3ssMmVXrJ50BJuhbAXvihShmtoD4z1zIIWgrZGRZBBe9GLrSii3vQ7dXJvln/mNsWHj9/f73/3080DvvFv48rP+PpVvnf7v40NYYlEIh5P9K3XlFYFIE0YjIW6LUvmQipCuHyZckNPukNapS/Wnfj6cjgYFPqDBCwM6yogU5iCVModTJraEgpSu1QJbe4xfm1VVdXWreNjT97UPfTP+ONsPG56mEzU7VbNCPDmk6gnmdJVlI6SSxoaGvY2wKrNP/dBaEm3kmT/7+tRt9s97FPOaJ+/vqwJBqf7hSARJLBUV6HcnhSBpgBZuXIkYUomOL+/L10o7X+gmurTp/8+h51+le25N8my8STLtj3YrU4Sa0O76jBMhVwz2tRU39TUJKfXFsoN/QjQ6f4Q/IU0DdUg//oJjIJBKxSinEXCoT2VVJIksCTGcZy/Lj1HpdUD76u/f1/B6pnsicXiLHuTjZueqFp5TQ51og/G2hK6UyrkhK5mFBYUtpgk8NzTaa37ujsail45oKkc/vQJOpJKa4M2xVhCzpYbkC6XCMo+7bKyyGpTnFWMLBgzN2MwR7FvxqpUc2tuxOlyok6sy7euhBQePw7VC3J9EfnbDdvaHcqmDVEgRindkQWHaz7UTBCEVmeHWhM2tNiTRB9KoGR+d6OcK8xxNL1JCxunzMf2PdjM5PdXPbFMjIkxP5hIJBK7N6Qqdy2CcgGaRJ2ECkl92TVNUbJcQk6F5BBFpQeycKsgSb7lwxNZiLDLbhgaQQkbSaJ5JAKnRZIT/UMVlbVnRTEcps83f7yzFEaf+f9H5mZityMgzOBMhGEmY0zm3reNqnZASPFGQBRJz5WdJeTE9FRWlmeRC6PyVFSmJMq+XwdGQZC0q+WsR7Dx+lVHnxGk2WbjPQVkDiPJcJhTRrWTdPhSc3Pzi+an22Ho+j+yunvG38NAhjjD4Dj8ijGTP9+p7rApd0OEU1mAXLy6dOwclbOUgFCzyHp5QpYU5IYjkiwggl7vy+oRxIvoDYsaCdFsNPLkYAHpcgVomoOenHfcAsRz585dazkw58YuvWD3DBPBO1p7cavVCkYmk2Hu+tRTnYUURZomSV3+1vn5npSzkld6LRWRoxIlSBTC27efgRxBmbXrbYjZ6LVXaBoRizlgIYvIERf39m0n9wySPATI84C8/37LIk2Z1XjxbYcVd8AFlrW1g8EB2aL6lLMWCUB7i7R50LCioITdLWURGy9R6SJSkBCEtwFyx+Kc4IX/X9v4R2azraVKsw2xiAGLhS4iYa+0X+rdVzGvsvYCICHK8/cHlpdDesj2DuC1drRCkg4HzuCd+K8W1cOWDNKQJOwd49NTBSMgKT2gvHwxSUmioO143r5R8+7iBa8RQRAzXDUuvrNCs81rsZDQ08480gLGzku9SpLHXgMSlLfub9pQ7gu+7sCvu70Oh8Nq7W1vtzpwh7W9M/xH1ZSVjZdpCx0gaR4ZqNXMzyO7jYNmHgKbTVKCGcL7rxXzCW0aiuN4navDrFg39TD/zD+0dag7qAdFcIoiKHoRTG2gfeRlspK0PcRU6GUkKRS6HAo5OHpYD6O34KHXQHLK6Gm9yRiMHnoWvDnBk9+XbtK63fQb2uY1eS+ffn+/X17zhF7hduTsKiGCLlAqeELm19JU5Bb5JEn1ej108oO0g2hrTQY5K7o8L8u+79ri0xFPzh9lfEYq68XllVwxlystfymVitiQM9XIaLxxlQqVKO1tpqbCPFZ7q9SDY85huD8IrDoKmARe6FT3VgXblqQeh6WhW2qlIklrlQMnd5plTStzgIw8oYbtZxXfz3vVe4ePRY/mq0fXY9/Z6W5xm0ECUNOWl0sNWEnnRnL5TtyQ6rIsr1WE1SCMzEXSARQK4xCSZARBX/sAJyPPset5ni3YUoKbZZBWur7WbIaQurHT1DS+HGeQ90TDB6HrtxWXY+POXkzoZqu/CSPGFHtpVUorH7exWJTLMcZiCZRdMprLUw8EK43AoBKpSnrz8x2h57myTekhpIk8FCRJQE5GzmUoKG3q8XYc8UC4Wc9uty+GkFZT6zayIWQk2vP7MFKBWi191SMtJrMA/8d0X1fRrfgzt43CgUrITO3jvsHhBvtHM1Vi81kZlYgYEp3U+/vpNG/btu6cO4Ckn6gsUQY5Oa9KAs6U00KA6MNJPouN74gwKGM1AakZQ8jZgav4ysZGfgNS8q18vsVeBKk/pudEXV9vItiNRq5YaqCCytrKj64Zvzo6m95OGJbFKjEr03r982dUJe5wvkuc6SGkLlTWZEtnkKeeEwrrZNnoiDEGafKsY7rHqkMwms1suivvARK6VGgpG21sSj6vtNt4x36+1Zs7MVY3tztwslEuf23gDWoUG1qZ/7FXHXvKnLyK08I7L+hYSeIDV3Z1Z5ENclNVJUmy7QyDjLxViWwjhc3g9UToJOXlNM/3xG+nZgXDYj1DJ6HJJ1xICcQQU2G7LbMVRMdX/ZIFagAzh4zEwnoZpdeUtt5UkxN/nRY3DYsHJVAZH3bkrE24g8IxVZW4KgkhZxw0bNulhTORENKVDfgqiKcjUxlTNQxDNQF58HQQtPJtBS4yH0NGQDqYgMd06u4bsUMr8BB4lmXx+983C8mjd4HdAYELvIZ/BHCURZA3XCIOIYmpAlNNBIDEqSaBVCd+OoTEvmm4ZuI9LpZRTRNNLwBkqIlrm56SR7yZoUobjiqemFg4slJyOnp1V9zaSyT29uJbweaVV2fuHDfdR+e4jmAgNzFPWIYl9/vz8fe1mfCQWINEcVAL6+h8VRTRfL8wwUy4JqLFDlaRGDjCNBj8+QM9GZ1z+j4rmjyLej/B1ZYuHbsaHUulru9C0Wh08TK6H6tYdFAr4Mf02Y8pOBxXS96IDY9MT1+4kErduDHsO3l5epp9MzSLNRZTWB2JwTc0INYYufqlahA4HEZ1MGjwcBH9/kFT564tLNyElm6efBw9G/lvOp8Mx11aSM6MPDT8Bttuzroj/32EAAAAAElFTkSuQmCC"/>\n
#@gui : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\nis proposed to you by</center>}
#@gui : note = note(<center><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABBCAMAAABW61JJAAADAFBMVEX27vz06viVWEaZZlbz5/Tv3urwxMeFXE2icmuBUT7w4u7QzeKaaFqRVUPs5vWKVEKBRyvr4vKRWEfSj4d/aGWuaVjkqqaca1+ATjnAfHCVWkh7UD/z6Pbv1d6DVUSGUT2TY1ONWUji1ubv0NiHeoaLd3zEgHW8d2qQYFCOX0+LUDri2uvcnpeQen+md3GKYlaYYlGXXk3p3u3Z0uTFyN7nr62Aa2uoaFehYE93Tz/tvb7su7yYf4XIhHqgb2WRZVieY1KKXk/u1+Lvys/uwcPPi4KkZ1eiZladXk2ZW0nn2unXxNHpwMXqtrXntLPfr7DhpqKtk5yHdXuEcXSoc2uSbWeeZlaIWUjj3u/uzdPTvsrdu8LHrrmjipKQfYZ2ZWalbF9zYF+TaV6gaVurZ1aCYFakYlF9WEyJW0uDWUmPUz5yTDyETDTd1efSyNrRt8HOtsG8pK7go52IgpTMlJCbhY+rbF2QXEt7U0RiSTxXQjJ1PiLv5/bx4/Hw2+Xfztvmxs6WpMLlvMHNsbvCp7CalqqkjpuRh5iefX+iene3eW23c2VhXGWpbmKLZl2wa1unZFN0U0hrT0U/OzlRPC5aPCsrKyrKzOHCw9nnzdffx9K3u9KvudKnsszAtca+r76tqL2UnLfcqqp6iqiGjKWxmKK5mZ7VnZmbipbZmpLUlo68jY1rdY3JioC7f3eveXGfdG6wdmxpY2yIbGqxc2ZRTVNkUk9LQTt6STGFSjBHOS8qJR4gHhkWFxLd2ey5wNjGvM2JmrmvobGCka+mnK6Pk6zZpKNpgaJ+g5mtjJB4eo6UgYu4hYHBh3+ZeHl2anBsV1RwSDM9MytmPig7IxPSz+ShsM3lubvetbl4k7TOq7LFoqnSpqd1hKLHnZ9paXmVcm6FaWRMU2F7XVZDRUpeRTZTMBxgMReaqsezrcC8n6mklaKfkaC/l5pbcY+nhoqvhYNMY4Cnfnx3b3xbY3eOc3W1cGFcWGBiVVZbTEliS0O4qbjSoKBQaYhBSFRDMiYCeYKqAAAKU0lEQVRYw42WBVhaaxjH4XDOoUREUhBEBQRFBLu7u2N2TqdzttO56czN3Kauu7u77rq7u7fb3X2/g9db3OeBv/Dg83D+P/7v+d7vPR8OhmE8Jhx4GSLsSuytFYyHceD9l/+fiPFrwD9/0/FjiHEM3tiYMXaZ9vt/+rVULNxfoHE39oH5MTcex8DhYB03EDCmL+z6+NTPVStWLj+xPAoGtH+GGxNAjPPB57/lOPNS/74D+18m7d7d359/3btTCAj/QowVB0LouLGvnbd+8/2Bw7cOHz584Kf9+3+4keSdMAXRvQxE0Amvzb/ss1f7h5tv3Rr5/ffDzc0/zct/kZ2QMAHWJWgpugu17Mt9Tc0HRppHm0dGR9++bX7blP8y4aMOoc5CG4M/XRkv+/LNyEhzU/lUUVrARKKDQ/GNn35smnVxymKK7sX/V8Hdz74ffjdKLi1tJBBS85KTe32uSH840OSQKTTXTWv8P7yH3+w/cFBOAApzcxvY2ysLYSqz9428zqQY1qrOX/7wI9FI6w8NbRjYa2MWwuTEf/5jQSZiEIBx/rf9xSQMkOof6ubG7sMANS5xl1OqFxkEeO/X/te+JMyv9ncLZbP7zMyYTE6MV/vG9Y8M2m4Pn+c7+HIJav9UcAfC3NhsGzOmkhODCk90P55hgP/4+eusAl9QQVhqqFtDQ2gD20bG5Lh4oojd2exoAxIseOq6hwQAqeAWlLiFjiXgeAajCLKkPhM24BY83UMikQYVRAGZrvEPCy3SAoJRAKD2PKLoByzbmkIicec2jb7//m0yFD6nKLShoXfbhlg0EGntemwA4IPnJBWpeG75zZu3D5LpUAm7kJDWVB6wY3MQJfJUpwGAmbt3qmbtKSb67fDzOGgLsWXbjSx5Nz3SemMojmc+MgBwMufai8+/HSwOMJo41YOn+S7u2UTBQQuaenvcDMrZ9QYA1vTv/Mo75fU8oHKBwK8vfhaoR6D29fklg7JqPWxACf2k2df2TJw7r7z8puBguE2NN2tu01uLbXVxbcKVj/QCjFf2sJJJvgUOxLKpHqIyD3ez2E7XufNul+/d4rIoavlivN4usJ+VsgPsJEVpY5qInkYrkcU8uvhyIj2sZvXqzJ+r2/QCloEm2EEqJKghuoUF3RSaI4uPjd+yk7tXpryfuXij/k78QOWbDABhBD5EmwRB4SV9yuDVzO1m25gcNIOS5WmtL8LSr/J2qUh5oe4REA2CNCVFQ/FI9BYwEWqCUSEyIUGmD7Bw1sCu2aS8VPdwQACvkqJN94VbGmxC4tEg6xkZCdtgfXvRPg8DhLlH8EEJ797R2HmjVwfY3/nUoNbW1tHrz+lLcFySl0wiFWIl2NraVlTQbOp2MZPDi8yUwRnW1pkbMvQ++2eqVMmkwtQICAIEMrlizjaO57PC8O+YMWhG0ON4/Z1ot+KiimTkD4EloNF5PAtan9Kz/aI/2ycWRdEn7doK9N7HnVwN1gOgFeg0/lBI7P3Hu9x8OGhQUHQgzgDdrVUZhdPJPBML3qFDkyLYPkrlFzsIZvEAYA0bkoCxlsRVQ4BQMc3E5BDE3hx/pUAcZlaDZgSO+/VM99OkQjUEKjA1nUQDvczxav80ZQCUkAGPGVsWdnbM+BuhC5v5woig4YM+VJta0N3BAnrGbfFhuqBjBeDxH9SqZLGANX5i021newJB3Qjx1RpL8sEKdkgs+uDJBiUHHdsHeOcLKYShDfBfBz1dQPoF8FhpbOTz+TSybbgN08WrPY7DcUG1sc0ZJ7+Va4qYQlhrNsebm//PTQAPRjkxjUa3oEUMhShdUM/ouDgvdLr2YHX3aQqB7w4AY348rAvArykAE4UoIpN5FlCJjdIlGkWjY70QGPPjl1wqEPPdNyEw5ofxxuYtuhuq1k8sJhInepDJZAtoKORce3Bb8APwk1rAUkmBBhriAABsDsPGeGNYdxXsxfIAAJgqwAjuvXWrH7Q/CMJjUUHiBbVG/PC+GCwB3MLAw/8F4BlLan3VmlIsgQfIwKMXXa17sjpa+OdpFLa7QIhwt8EA5uCkyzBnMIBpvL9aIiuXbH3lQNBAjUTR1LkeHgIyT6BW1f0SgyIUBA8DAmy3JiVijpknBYbh6S3TGY7gsA1WogWhWFm1RmV19fT8Np8M8fmNpSKBQHCTTBaQ1bvqXLxiAx0roygYIP00FyrZ5oVMh7VuR0dHnFNr1ASgqhWf5OS4SoeP3qZBfFNLOkYANYgK6+I80csJFKvjkaAKSvoabvicTVgiBoNh55iezsBNAerI6ly3MTExKTf36LE7h2iQKd80TUTmlfMEctBIKPrxDSF1uqMdSEC9IIaKNnkhiB0jMjLdzsrODldVVZXVvTGhW+LqmpSbf+TYHZMKGoSFEIl4ZNO9Sk8UDTrzZrWTFeVuZIvxaVeyRYQsVohgXiuryZOtcFkd1R9vrM++LGW5uubemH/s2DSTCjCQTC1NIRotXAYGOprRtefqs+qsrI4JCy8Npvn3bj7XBqxO4AWE6zy1rt47J8dbwmK5sjDA+yYmk0ACrcAo8vIK/vQayTc5WUXaqbpy5eoGl/uZ0dZWVKoV1cmJSnXCJdRftgfyTsQA+fNvHQUAWzpkSoNABnaIC4cDxqQvF6iggEtKlm2KRgIXzYCXfeh4nIoJJ5FIpVJ7b3vpdUDInX/k6DsT8FyEsIliCRUx489tAac2LtihRlyuEbeQa8MxpyAIbunZVvMxQE99vSRJai+1T8rPZwHAkTsmh2xtaYBgSYfmMDfXzeYSjLTy8xODUeHuEwgjM6Y7nZxCXagFdHd3f5KTKJV6S3YXu+4ePnLrzjQTW1ADEI3G9pEpr2lP3sCuKA5QyBXQ3hgKskgYebJj5konZ2olrn7FihVnahMT7bt357KuDx89CgAmFSCCRgNBYQ1mLi8xO8FPEUAEe0xhaem/yTqwdfHi89UPOxnOzlSc9/qoyhMf1kq9O7bmsr59M3/fkWKyCbYQ7AECBJWEfDWSJldYitJ4PB65jEgUiSCzGCRwwpTn1acDcZOdnXE52YuWUyvPSj+PWvM1K2ff4a3De1hTsYluI/NtpLtvfk0QK0rp4LwzelsgArtcpOj1QiitWd+cWgkz0gFgbXbb2irqPUm29UmJq/T7fScubEzCCJPMNs8qtXD3zzMCBWAjoqwMBAgQc7c/80QolMpLH0Y5Uo2PO+POZEedX9e6tKfe+t7axKTrw9Vbq2pZL/wqbIdqvnCg204jgFvvJ5djQ6ZULh64uiGuLRBBKJEnVlktWMrAOePWfVL19LJwydps6/fWSpKS3kz49Yvll1gklT+bOTuAZzJNQxAPOsjFAQqxQk4gpPadC0LwAECx6oq8t9IRPxnn3fPRWUnWkq51Ue+tkiQmvqr+LP/TrueslO2y7XLgt9wpHhx0cCBiUmBrwAxGhEIEyGrBw+WRduk4+5yEVZL1lavOLHZeJZEmvlp3vn/2qa9zWbOvXCsDgCdfOwz6OWgJZZallnS+j+eitqBABHTjvTWVTlTGH/5VIUZ4CClbAAAAAElFTkSuQmCC" />&nbsp;&nbsp;<a href="https://tschumperle.users.greyc.fr/">David Tschumperl&#233;</a> &nbsp;&nbsp;&nbsp; and &nbsp;&nbsp;&nbsp;
#@gui : <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAC/VBMVEW3xMQAAADUqJoDAwEICALFmozFqIwGBQG1jYA7O0EfICUdHiMPDAoODASth3svLzYFBQQoKS8LCQM1NTwaGx0SDg0bHSEHBgYJDQTRpZfCmIpuVk4XFxh5XlU3N0C+lIemgnaif3OPcGZ2XFM/P0clJSoXHAoUFQfAloi4kINrVE0QFAgJCAece3BZRj9WQz03LCYODw8UFRjNo5WXdmuEaF6AY1plTkYpKysuJSEYGBwlHhsYFRELEAWotbWxin2ffXEyMzlPPjhMOzVHODMkJi4yJyILCQi0wcGTnp6CZlxPVVVDQ1VxWE9oUUopKzQsLTJDNC8iIyUrIh9nbm6LbWRZWGOGaWBJU15eS0IxMT0gJCkgGhYSEhUUEg8XFguyv7+Ejo7Ep4u7koWphHibeW6ZeG2VdGqJa2JzWlJERE00O0NSQjouMzkhGxkfJgocFgkQEARBQUk3P0diU0ZBREQxNj4uLzoqMDZAMyoyKSY1PyEQERMcIQ8LCwwiGwgYEgYSDwSturqfqqrKoJOvlX2UfmpXW1tJSVFHR1BIT087O0hhTEVZS0UiHxsoIA8nMA6wvLyMlpZ+iIh9YVhPT1hFT1h7aVc6QUlHR0c3OEVdRz86PDwxMzMpJyQnIR4qLxoeGBMcHAocIwjHnZDCpYpubXpvdnZvcnJkZG9XVmyTc2leXWhWVWBOTk5LS0srKzA/Ni47LyovNRofIBQkKxEQGwq8oIVcYmJcXl5RUVtWV1dMS1VHPzgrKRSXoqJhY3iljHVbWnGbhG5naWVQW2WIc2BNTWBTUl0+P0xFSkk4OTZ6hIR4gYFze3ungHFQUGVjYmGDb1xoXlVdWVA+SFBAQFA9QEE4MjIuLy80Lyo5LRmFhJG6k4d1dIC0mX9vbm5UU2eNd2NJSVtGSi04RBYyPRQ6LQ+lsbGapaWAf4tsb4Z5eIVYY299aWlDSlN0Y1JvX09RSEBMQz5CPz4/SxinrKyVmZmNjIufeWF2Z12ObFYuJgeXgXY+PimhEuIiAAAMWklEQVRYw7yTX2hSURzHPZ57UeIqcvE2/IdOiZz5Z+OqUxRnc/iXDUrHGJhOlpuDMIN8mA+p0xJGU2a9jDlXIRgEjUYPG6PtZU+tFVHQ/hD0EKxeeqgoiIqu+1Mrrce+cO49f+75nO/5/X6X9h808O/lMcvfVjKumjIZT3HsX4C3RRrN2eDYR7enNrjE1tbHucTG4rXJ0F995KouZ7XOxcraxw/laDlh8psD0Y1o28yZ238DHPGUxkJ/enT52ogNP4SEFygJwDFjDliyvMk0BAjX45bxT79fovgxYOZgsw6oNI4qIXaTg2EQlnIrDQEGD3fhczF0eOrN3GmHIOJ1MxX6qLHrqk5hw0x+AGYsjQHjuaXqo98cWB4qFWQky6PzeJJmhUqalbrJl60AxC2NAa9y48Xf9zsUZ3t5Ffq+Xko7SOrZa1YWnZb6hHnGF0vVMdehMPowQUXWjUoPALzs3ksVzQ08ri+J0NTdBd9YaPUnemWzhxSPnqWTJP0PWVcbVdTjtuq4J+OJHxTKpIGI8BQROr1Zsntuyy9Atmu1AeDFyczk5NuFjPMAIGwdtSp0tQjubrpDQX5aWGtQCty7S5MZn8+zvnIAGNX0yw8Zp8K3F4MKKdM8qg/i2sy19Zm7S4uPB/YBs9PRTt5hAG8vGJUIaRVw6zP5HBoMU9y5tYMYWPJGwka2qLL0OvE7JVt/Any055e4r0qbc679n9DlafLrjFKyIiLrAD32ygMK4Mw497+lkl+irT4vx59Oeaq1SeeAL795U0u6+3gkX7Vr//BltApFIrRwO3Qst1CdHHAVPZeowqCVVg2LL3IzPgpgcVXj5bI3q4tIVa1aZm1PM/uwhYr6jA84hADi5pnNo7OngXDFQ1szTJWE3IcLb9/QckueYlnozarYIjMw6/v6OujkvgPenb5aZkYuxQN5IlbY3i4AvMAAwOygGcvxMnZm3VdcsVwz5F5wgDc7JOoSCLqvtzq8CrK3km05Zzun9tpPySlAk8GfD2zfYuDpGJ5kJHGHktYUJHAEaVMKuaeFTW2Y0pEYmieIU10Jqa5HOMJDeb3XE8b3l7/NG9UUgPPgCwZYOzvpFJLGWTuxJItmBgDHY0kGUH6/ceOGn0jkmzp7ulVqAnb15LF+Se+dL1cmavpgktBHsGf3TIBRSMfArWQhCWMpQLOD4wAGWRAoX7++HyBknd3XO1qmNRrO1jNp74h/3mS6N/EuqmwavWgy2bTGAHSkYoVYGsdBOgVvAkCj2p5uvl7ehq3t04RdEtaEZecmnmkiNuZgpJ1te/dudjpiPyuax6IExmDFGAA5j4DkDmRRAFATQvXMy4UglMkEmLq7Y1DhZrL1IzKvGB02Dl2fmNA163SivmbbVZGdEWQdh6kLt1iprxCnABACKh0QAYXtWAz49e6AWn1V6pZq+eI+tUksVykEeiYTbRmShZvl7m6RLQU5QQAhA0my0pACpBCIBzngAtgV8eRJoF9uVQgEonBYpjGKmV2Doqtn+WK2VNRuZfcLhqNgXwiCfK1dgWrgxv0TjAPAtEOAarUoKrcyVWa7uOWcTDrUYu206SUSvs6mkAEIaoLwAkgjNQdBanSLFYMIYw9wyjSI8vkoynSjEuMwija3C6xsvlgsR9lhk1qur3llMBgsiOMQT1OAPLXt/vJyAUGOU732jlOz4kE+WhM/3MMcVqHtw2zm7jgik/Uz7YASC+5eASJpqpB+sFQ2IUqEYRyfl/eVmUCHYSt8UQcdrRlnRx0NP1piUFxxwVAwMxEqCb8SpMGFDrUNdSk6SAjZIaIvpSA2otbVW12KDtWlCIqIiKg9dIqgQ3TpHet3GIYXnv888/z/zwyacWCzVjtrQ9BKzwVkVZ4XMJl00O22MGrdMof1tDKCFdA2MAfSEk0UKKQhSYREdcFKhO2F4tFK/FrU7Y67k8XlYpzpX+P9Fj/pJzbstDZaVrKKCIDeAqDRuYWRDVCTrW+DgaTBmlSDgKzYzrzP39m3L1zOlxL5kvVEqcwKbJ6xMMEU0+onreTRBJpkyNbrIShRmqSL+tYWtiFAqEn2ht/h57vHPdalnSuZdNpZDW2UU4V4pxLzt6os6YDkEAEaggUk2UCPAhCLhoIh+I+d9fvqFn89tJLrqDmejzqj+bjcXWowwXTscBb2SCmBXMjUEXFBGejKE2KANUCOFmjI5YjhQsoZVePxYW69HE9Z8jud6rrF4k62AxDUaKDR/6YooXM0oNBYMaSRSHMcGQ+EHLgZDVa8+X5TCPed/VKp0FrMqnJIIInwdlEPmOGh//tAxggoHSARYGIE0nVNH+NZoOBsMJmkW24W98VzsWFiI1RgTIE6exhIpl+kXsEaNCXMV9BmmjLDioY1DWJzkmHWwWQc3mjQE1oOrKSvNRx1byxJglDeCfB870ww/ndHYaRhPJvNtKORCJ4ZSFRE35BJy6lKxuNgvd6kzDgYdZElM8gAhMF/FwDqQWhDCFEAcBo5VeDJy69cylQUp8al4w5vnlUTxfbGkA8XCkIydpptNBJ28A+MTZ3BVP9FIkTdIkwVZQIjr465ADD1Nh+32KjcZsLZ5cCyM7GeYCu8pameDq9IY4I+GG8NpoNfv6a6CEVqjfB1bbImGq4XR0j9Gdeex4+dAsmCp+KRfesCry42u4ybf37h/JufNzYREgfit2+SJo7GYm+MKQNCaEynhkE+ChC+2//g84Mdp085vUmhWiqwQaERdft9xTr/5cfShQ+rn+6u7lrdZud0BU0MGkqiQhlmCxOMUGTTRf57By+/DB3OJoqynBTasQRbDfssjlCx8+VOeOnp+107rnzfdv/jvUNXIpGjoydPJkQAcByHJ2uTva+fXd2z48Dlt7//3M5mni+m2zmmwjc8cpPxpLtf7twJP6puX3149+HFQ9/v7vr+8eO967vRaC7wt6ayCW0aDsN4RCzm/xfTP4kpaA0eEhDxq0Fwxh2MGi8GEouWmFjBXoTUeGhr20npraVd1Yu0q1URD461tm47FWuFtqNrK6hzuokgzrGjil/gB17MBH/393ne530Or8uVvPHg0cQlsRi31HNXn/8Z3nS6PnN0+v7mzee3bVy36/zhx7MBR/3xi4M1b7nJ8SaLr0KW3+WzZ+3XduP9i0cTLx5xghGlw+jck9/7nWvuphztO8Ondq3fuP3QvgPDtn878msikc28/fguDzPVqm+8AbkpUP2IY7ceTg6h1wzo1xi6q8UvPdty89iZg18DgZnIhU0njl05Ox2Zvee4F7n9EOpUtWaaRSZcZHNsbnm5NRhkxrHjbpgh+zhrIXf8U7AIT04c2ToyMhZwBJaW0mPz6XTKYZN6+fMNIng2iVpdujColJTeoqCaZCOEsURTzTA0Ho2rYAHQweT1oZGRvXvvOQLz7bELewKOf/PTvyY5hrGPqHygmVxFknOyXFSrPuYjNi4KUBV8FKHQyHDdjtOj1717926YrQcCS/PtmVWBQGp68pIR7FUk2I9+HsC5FkBRXQZ4iDHLWI0RcC8xjnhe6vqHRqkSGL3+fWRDZEfd8Z/Uq8kbKEfKHbgTfYrmvKUWSBpSh1Y1/F0ZIxmzLzTIMmuAIE0kaDgHnpz7dvd0atV76XSkbuf/8cA1V4JzDFqrFTslmJPXUD2dgTWg9msYp2bjkunJQpcnGPYwxJSuJ0afnrw2vbpBfWa2PT8TGeL1SrArkoSzEPsAPSvyWkCQeeQjCZLF8q6MXQNu22tEMpGFMQU0p+DDB7vbY6tEvqYj1NTKSicXRAS91hYQhF6MJgS/iji7liZGSXiIoqNRCLUoT3hdJGMgnFtz8UL6y90NZ76mD1/DG6GerNe8Ccbr0oTlxVIlyQJfk8jbvfqqmCto1TjNWIiDoEYRIuFnOUjGPUn/cGQs/eXOxZ1ixvtZIX0myWQF65PSEphlvMHhoawPiawdwSTDMLxgRAsgXOAJXZY4WpQVxIeAy3V5WJEInGM/A1+ZdJMiwAuxFX+PMxEtIicNRESSGBJBtBi3V0gYQYHhdcMUqVJUkaBVXLCCMUlnGI4uNTiax1XCFlAkmcapAZ53rnGzXreFAcPSDAXGw0OEpWYggfwxmZclq4AoIRyWlQrQKyLbcIfjRYvktDBoDZrqYg6nPHzflzU5DAF/AqeUboxPJCQ9V4LOWMW/KFmwKcbU7KKkzHWE/DjhmSpoCcLZ1fQO7uMId1VI+rM4zXr/AnoH9FcRhS6kAAAAAElFTkSuQmCC" />&nbsp;&nbsp;<a href="https://foureys.users.greyc.fr/">S&#233;bastien Fourey</a></center>\n\n)
#@gui : url = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","https://www.greyc.fr/?page_id=443&lang=en"}
#@gui : note = note{"\n
#@gui : This plug-in is based on our open-source libraries <b>G'MIC</b> and <b>CImg</b> (C++ Template Image Processing Library),
#@gui : available at:"}
#@gui : note = note(<center><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA/CAMAAABnwz74AAAC/VBMVEUCAwMBAQEDBgcPExQIDQ4KFBcGCwwQGRsPISjxhycoS1YZNT7rgCEkP0g2PTiOVzXidSJ4OxgXGBg3XGkTLDQbEw4eHRxCa3gyGw0aHB/uchSHPxlYVlNwNxkdHRtNKhNNeYgvMT8XEAnvn2vhjkjQfUi2hGWMZEo1SkzXbiQjISAmIiAcGRlnjZoTExM/IArWw7TnhWfti0igTjYmJzKlVizpcyeoqqOoRhfIZR8jIiBmMxQqJyqFpa9VLxhhhI8mIyno3cC8vJqJiHvkqGzujWbukle5e1CBRyyEn6I7XGN/RSJBPj0iICFnOR1aY2SgVBl5nKciIyFEJhRcLg7DvK7nqH3vr22lZ0qsY0TeZT1kOSerSyKTRiHg3NeESSd5VT6PsLuLr7tGRESFiIN0OBM+TlwyGgwODQ1XMhM6QVprSDzSdjloj5suMy6lfWE6VVxxSC2QPROUcFePbVSJjojTx720zdXDazPGurA2U12bgnFybWhjW1YkISAnJCNFM1Tzdx32exgyNzMhHx75liH7nyH4jiFMM1UtMi/5kiDpfS/ZrowrKSf0ih/2za9JRkX8pB+aXj9EQD8rLirteR3ncxz68Obz1sD1wZjUo4DBjWlRNVg6K0D6mSP3hRxsNxe/URb56t7muprtvZjhr4lqa2gyLy70jinwgx/1gBvpx6/uxKbzyKXztITcqYBKcH1mT3hmRGpgOVxOM0w+NzV5QiTuciCmUB/8qhzfZhbVWRP65NPgwp3btJn4yYrOoILBkXL7yW7QjmxaNlZOTEpBLknxjDkvKDLQZSDgbR59ao11XYT3xH14dXNycG/Wm25RP2fCiGCKblw7V1yhdlVtXVJEMVBTUE+daky5ckkyQkFVRz/5oC3CWiKwyL2Rsbn0xai+o47714byp31kYmGvfl1fXV36uVrmmFR2WkayYzSXSCJJMSG1ThfW5+PE1tL72pPmvopxWH9WS3adg3FYT1v7s00+OUX7rDJkj5mrlYVSaG9uaWbbdTHVCtkHAAAAfnRSTlMDAQkhFRoPLij+Vj7+Sf7+/v53aTRHm3pkXf79/LSsqIh4PP7+/v38+/v5zb2ahk7+/v7+/v7+/Pz38uXBr56QU/7+/v7+/v7+/f368N3Yx7enkYtw/v7+/v7+/vzp5uPMu7u3sJuXcGZd/v7+9uzo5OLg39zb2NXUy62ggmXEYn5YAAAF/0lEQVRIx+2UVVAbURSGl92NJ00guBeKFau7u7u7u7tmG0KSxiGQYC0ORQu0RVociksp7nV39053aR+g02VgOn3r95DcmTvny7n/PTfAf/7zbyD9TTGBCOhM2Yy7DRqYzRo+H8CH6MgGR0k1df64qQHo782WZkiZ+rh+MpFKA9aEKIdbAL+ALJy3OkO/ts2SfKVhobFSM9z+R5OpbGh/jF+gJvYj8II5Q9VqdXExy27OAggAZ2kqrf3CfGIzRgF4wATztbQD3tKkQM350Ea6XC6WC/n+4kh1pJw1Z5RRUlIgM85HkY13BMYGCCQxYBNvaUOgptFQuUql4kZFBbhwVfJIVqSqOEUzMFDpo1AwYZwEBr/YgH3rp1cqNTVb5WKBQBCACoQCd4HAn66KSkYNfgrFfTOcesLsly+x+Im77xsZPQ8Q+IsDAtwvowjkqki5MEDlkpzCjFFkDyfgjA9bb+qLg1h3OtZ+KZGClk/u7kJ3d1QhEPP5LREBUVyu+mlNw3ASzgRQR46cPfXmJhAzrC7yb8m5k/OJzxegCjn/Q1lmWYELl8ttnW4G480AzXw0dc/NnW1+Z7r/w1ev7uS0qNAc+OoPdzIzM8uiuC4uV1ai44QDpE0jGFR/1cXWJmL/nNc1NWUP6f4Cf35kTpxNVVhmASooHuLc2TsggQ4ebhaoK0gc8aj2tsfjh3Q+Cn2CTWKhR5gE6+C5CYAPw5FMktXbA8CCVD6fOXbwgEIrihiFMrnPgAEftw/CBEErYHwBRIUB3cR6LQ2TVDG/l9cNXiETFQiFFN+FogHbqpJRQWrQE338p0rEhnlY3gzCviAhJhg/3iZCiEKRjguPj49D6w1TgxpxzwAxqNir23LOWNcoiCWMSB87bnAlJpBTKtDlwsVY/ZWg3NUA3hzMHcnAhsB+fJ+MoXZ01uL0dKkVvd+kXgWSXq9j00MfqQ1TDQ2HxE0n4hi09cy1sX+NE17BaZPpdIrdI0s7yd1bdy0nFrB2TJhgVaS+4mIY9MR3Fu4l0kgwAGsTDwV7eXk/oURESFgsy74TJ/bNDe1lV1Sk5nLRS0yR2mzGSRAmUEkQzJ5LW+WFCu4PlFAoFMn5RX3Rep8KFhelKOXp0rgaM9xJZjuyCSBDj3w0ODgtuoo5cJBEIjnvc36RT6xPxaDk5ORBQxt9s5jzAdwERq5ypMIgDJwMDg7uk+jn12jVzzLU13p5Q25W2PlJkyzjQrJsRpHwh0DbfK0eBGAcV4TWNjdnh8TExipirPv375+lUNyKkVqv0cfyxxeQ9cjkn+utR6Y3Nw9sbfTLkoaEWC3zjQnLbphiAmn8BNcAQG2fbcD28yDnjSsHKpV+vrm+S5ICjYYMQQWdGjAIZAYBe++gjpPpzN4cjmz5EqVSyZyStGKZpPjZMHtTLQugUwXZfK42oGFh2qO6iSfyRDgc16rKyUv7P22V9OsnecZBPEW8XbokPAGBBjPWHWYT502znTY1vkmEIKjhS0hFZcYt9DYLUAEHEfF4PXpo/dkAstcxyFQ9Glx9Mz7+xmdbHtYBp09oWIi3d1pa2t3vCCJrq+cNwxEwHGkgDAEaWtOabOOrm3qg8HjGtY9vR0dHe3tHP0Y8eSgiz2EGOGcACSCRTUNDgpxsRSJbT5FIhAXhmvjuXUb07VqOTOQpQzgznQidhAiPpgKogTzaoOexmTJXV1eOazuQwhEGELYP4EME23qByNrmPS9cuHj10qX8s23k558+c/1tT6DLgNCYhISECxcvXj1z+hTGaRwBPmPelJaihvaChG4JDEpLSt78JtjUHYHW+5KS0vaC03Uf13dHYJr34MH7Syh1dXX5aJSFCEdmDHa9Hp5hHH7P7RzCaQfiNqYbJ3C7dy0cE7Tn3PpuNJAXfi3c4zeBLK/LLeh6GF8rf+Dh2VGA8GaDXbxDD/QE5fWJMk5HZG5dHIURHvXh5d/ceMhvAuTcvC7Va5BGuIWXG2MRdKS3E9g1gQagMyLPLVGGdCzXhYBuAGk59G5fba9FALoL0WKLk6mDg4OprpYOEfgPPj8AH7GtomieWx8AAAAASUVORK5CYII=" />&nbsp;&nbsp;<a href="https://gmic.eu/">https://gmic.eu</a> &nbsp;&nbsp;&nbsp; and &nbsp;&nbsp;&nbsp;
#@gui : <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA/CAMAAABnwz74AAADAFBMVEUAAAD8+/v77u/9+/v8/Pz47vT25Of04+aYbXL03eD+/fzx2tz89/v99/n98PHDn6ns4OnQtLqshov88PP/8/T51NT46evz4evguLmlYWn56PDgwMK7govXp6u0YG/CjZWUd5Dt1tqTXGWIWWLx0eLl0NrAcnnIeYDw4Onlxtf54e3z1+Xs0d/rzNvz5+704ev33ejt2ePdv87vt7ngqqyoconZpqSoUlpwPFndxdHgsbTGorHDm6zMg4XBbHPPaGqjOUW0NUTxzN/jv9PSl7PMj46zYWmfTFv+/P7YvcjuwMLOsLzmvrq1i5/WjZe3Z22oRk6UQk359vf77/TuutbkuM/brsPQqLrXuLXMpbXrrbCxbYi3cHaqWGOEQ2LDT1e8RU+YLDykLDqPHDD17/Lgs8nWqr70oKi+kqa0gpnKf43AdoWVXnvMc3qSU3DEYWTNXGKSQ1WbSVScP0uAJDj66fLrxt3sxNfw2dbqvtPdusvfxcPWoLnKkqq+i57hhZHTfYSpZoK8enqsbnauXGv66ez93N7qzNbrycjJkZ6xeJLTiZHDiIm/gYSxeICjYXudWHfCYG+OUGl6QmB/N1a5T1WvQVCsMj9eHzz0x9/wwNr8zc/VtMPhnaPsmqHYlKHVnp27mZy9fJKYYoSld3yLWXmET3GEXGyZVFqGOU+PNki8g5zkkpvRlJiihI7Xh4yLaHqYb3nbbnFlMU2pP0lxLUn44t7rttDKhpXhkZCaeoavZXSjZ22AS2iXX2ezU2GPTlq7HjH61unt1M/irMuMcoGfWm+bT2mlUWa5WF3psc7/q7fXm6yrfIuzhInfe4Sjb4LafHb98vrm0MvgpMPBiafLn5+ieZW/kZGXcYueZoeQZG2OQ2OiXWKJRFR8Lz+cIjH5zuXhtNP9t7zSnqWUf46kaY17OkX91dj+xMGsjZTth5GFOT5RFjGGEybjxsz7wMjks8H5r7HMrarJgqHjoJhvDinu4NrWjn7NgXOhO12uTFzKaYJvHzpyRElCABtwx6DiAAAAJHRSTlMA/pTZ66c8G5RtyJC8rw7PnpSQfSTMUfTllM/Ev6+U7Ojg3lN8FIp+AAANFUlEQVRIx5SUaYhSURzFm4pWKlopiqB4+hz35ZW4jFuluTsjjUuZa2pOpqVONlZO5VYThZFKuLRQUUMRyCRtYBZUUmBT0AItQn0oilbaC7pWEEHrvV/el/fjnPP/nztgfhsRQ8KSiCRiwKYePGjU+ElDB/zXaWqyETEYEgaLJRIDAaLNZmtrGzV8yL9TmuY3qUlkFANFDpBI0WhUrY6+DV4LnQtOHD5h6L8CsAQGSyyOM3BkHCkQjZbOyZDd8+btZiLPJw4fOvrvgKsBfBebynqWo1IZDBQeFUzI9CdOvHe7e32tBzfuZk4cPvqPGcy/GsB1saXSuJjKQDGaUahn2tmv373r7+da6vxMqsoRoo/MZk4c+RtDg9vagIK4VEqNSxlUMZCASsgA4H0/l5vJ8DN8L9dT4xYKwkUb5s2ePHLCLwA2GwlHwOGwZBQFJQYaxN8BHq4lw+ebvEWvscjl1rj9bg6cP/Jg8tThE34GXFWTCRCOTMZRMJgoMUokBSXI6/fcfi/XwjfxTUVwU7Uat1blcAo1hwJ9Z7fk2Ywx44f8UIAld86R5iAsNkAkkjCkaCyrf30COChmgAdjQ8FjT/fjWjfncPhxOBx2oyWlEFusDs2cNm4IADTWoNPudOp0bDEZhcJSsDEJonjXX+QWLXxwvF6jN9XvDnMO5/NKpbs7XDs8O1R6FlNLOpLhg8MGDJ5vowjmtMvtTl2XLicVU6Xirk1bWtwej7cByFhMIIKiJ4k+qqfRnm84fCn5mE47F4xKEzHFY751CgA0BQhdGjkbAFgEqpQq7tKs27qIrkoZjfV6I0RwTSn3iRZEwpQ87KGXU+H7D2OhZ4novEzFAgBt8wNQczOLpdGwdAxxjioW6zZtRQtTRpPRWgcCjOAjk3KvhPOIJMt83uFL1+4jDyQS3cNsvWKZDjJoImJw+LNnsTiIQkGh8GJqbh0AqFIpk9ViMaWNANHnKbsPL5qt1Say2TvJpGNDXu/qyDoqlToAgDpT8DgIwoJJYkkULBYbZx5xcarVlNds5qV5fV6eiefhhIV3dstC50pBJp3j0AsdPc8vWSoNC4NAnYnYs805AoQnYzBqUgPw4Djs8XC5X/9PeXjpZBKNRu+SyELBUCmWF74s+OFHDiu/UvGPHDCozRbFE3LyWXa2XNecyzFY1FUvNvXASo+nmE4DAM9hNnpVwpY8IpMltKVSKbbxudLfq79kqlTMtIEAACycXdW+dA1b49SwWFKpxr53I5qu6uNxLWZeX5/qcR9QAPeAemuvnwuGrgUfKI7eo8Xo9UolnAWApiY1WbC6/coap12+wM6ya+z2y4tgukpVNVqt5ow53e3pU3E2tMxDZt+UyWSht+C12CjLxgpWS12vBQAbhoKDBAvk7Ro5a06OlWPp2h9shQ1gEbwWqyVj4Z3wqHxHWza0HDmyezYTSVy7ppU8TJQeRqxWh+QcyICIAVNEQZ0QhIdwBDw+3ryaedylLFf7uDyruW5WHe2mG2B40aKefB7Zpadd1wIXz2JZvzXtkES/KYDwBAIoJJglmQxqHX9xWdHidnP7eT4QAd3RQleiOUL46CmXS7HrCMIMXgvGafetfEf+YfxriBSwiasWCATNAogAEORVLy73wG530cNT+T76Vr58Xz0BRzifPn24ePHQva3MxLVgjIl+DABbJHFgYf5VEkSw3zrgdN6yy+Xs9j063daNLoMqBSyYfb1ldMtr+lEDPenzv+ldETn9PBE6Jzvd4Xj6NFM4gkgHAsB8NRlaNXd5+5qlc+V2uY5tX7vpVKRVxUtVn75pvWeAnxTovarkB/+HD2/8EdorbQg5H770lP/0koJ2Mza2AQhQCF26ZWvsm9cs1TjbWRrnplMdIrq5Wu31X1xpQCtfCn2f/G8+fOr1H9rFZO5JZA+G39SemmFaNqH9qiCKau7S7LfrbrCdJ9k5to51ZaNLtNLn8/haRfcMPSsLSrT/jf/zvQuHjh+fvU8meSQqm3lW/0s9DQkNHDCiqY2EwxM6d67u7OyEGq8jBEJUuNAwp1vUGllhUHYbOi7cu33o0IUzrl278gjt0f1I2ZyuXtIj93ftGdkAEPGEuEAggCBCM+jk2bNzXjxQuODublgkuigyRJStC2/vWHzhwpmN+gJaqXikv6/ipY28S3n9S/SDsQCgjuLjccGSnau7Vgk6VwkIAqDgOAxGD9NFEZGho+PgofXHlm87cxc53PqkzDnhKFvNaevTw4oejgH5CiDh57Q7t69bN2udRi7XyZ1rNp8/taK17BP6ey9+6bzcQ5OKozgewaKo6AUVPSgoXfaedu1WGpHXrefKUltdE6KsTBO02rLUpkY15yuVUHv6dtlMEXM5Nam9sJRRura5LVa01Wj/1KA/osdPiCDoQX25f104n3M4v985v3OEL+wmsylsNptfsI6sP1l2bjWZfHnDgQcHPt24cbe3vhDBrt2LllH2qAw+lQxCfFzpUdlRe0uj6MSnnQ9OioTCPrYpDL7P4bo72PXV1Xewd28cP/jg8qcbd4rJVOKlQhLBRbLSJeycKteOSLmIzCepSbQIaZevXD5JE8pNsBEOGcPhOl4pDXvnRvWO44/PndhZLTqCvU5ddeEeAGwCr7uYI40jkIvLJG1fx+VyZO1Koaj003FaUmcwup8DAD+UvEnbX333/v0d6x/f9dbVJ2sJ+251fPg4HgAOYXAUirjK+vBhVWWVpb/fwmRKGzQ8HqgeHjcYaO6Co56gJx3zsooBgFX8+Hoi1qElrFq7dtvp06NHTQC1AB71h2cebsQt3Gixbux/WMUh1dgzGo1aq00Hml+/bg4EAtGhoFOrBlOHun5fR8Zms21ZW1FxoQJEMGF5oStTzjDFnL0cDukwh7SOeTQtcwJlnEE/sPe/9vv9tuiQf8hm6yASCQTb0Afb1rMVFR8enf4IIlhUgqEwSXx+OwRBKgjazk3L0u3pYDDvzAQBoLkQQrM/Gh2K+jOdnWrqrY50dN2QreLsow/3nm0GgJI1eA5TKlDp5XYdxIW4XK5M1p4J5vNarTMf9bwONDd7SEFPwB90ao6do1LrO50AXbPtQoXt3rNHAHBo+eJKSc7gE0A+HZRu50KQ1KfTJhKxmFprb3c97wp0RbcHAkP+fIxXfY5892bCmcgr6+s7nJltbyqmjpqwa/eSqqac0QipDEfXbV8n3rOHIZE22Btqy8sbUb4j8BxonScYzeeTCWwx9g5rUBvLJM8r1J2dV7d4CoBTJRQGI5Wiiy1Vy0BPAx36MCJrsJcfq21EHS5Xt+P5c09B7eB2rS5dT1YMJnvPHyvX9N4i9MbGjpq4e8XCjRRGhG6JWMXi/v6N/RZ6BHlyE+WVFreajHA8Hne5XSEY9kAtwv2rsaW1VEJisJdXo1YSropYU0dNLMHgGJamVDabQp48gVTS7m7IwG6pqytrEwnDRiMMO9wudwiADJ+FIixZoSYStwwm9l3tUL+NiWrHjipatNTSn0XYbD1qQuWoQSVHdXp9S2udsIzWZmYbBaEQ7BowwiDFfWU77lA16lvEbQkl4RLx7Vsv9nwBsFCczY6YULbdgOpQvRyVy3UCua6v9XYbb3gAdoMQunNcd7evRVSGPULWqNW31mqUhLWxV69oJwBg4tNTliwyYrL3SA2o3MFX8XU+Pl9q1zXwykf0Pr6D73IP5LrdcYNQVFZaW8sqDJzEmFJDxr5/t5oFAIdWVkYkqDksRxy5FJ0eSUXodElO+qQBdED9gANyGd3xeAg2ht+JRPt3lO8AI+stgtf7glb97t3+5FQAWNJPjzQ1NUWs1hTdQgfnEYk0IYj0ZtuxRrPAPGwOhcxG2BwO006sXs9i7fD2Ulft03jf9ZG9ClpjIQcYPIPBsVotVrqVHrHSU1kJJLC3DJbdvl33VcBmmz3Dbjg0zAY/VpM1peRiBXUfgapOeoV9XuUXAFgB2gGDwwH2OUQq0CNyA2pgG0yDdW2324b1PewQbObDIbiv7Hxp8X2qQqHRaIhE4pdEYs7YBYUBvgizhoITM6FheY/A1KrvsaMCVCDQ64BDYYs5zh9wG0EW2YY+0N/J5RqFQtn5YebsaWN+DNyTMSVLlzFk8LC+VWfqkfeMjAhUbDYqTzbuP2YXOLoH+G6Xgxvvaz3fyFJmOifNHTdm1E8qOlWy9CKnCTHLe/QmvUkgkaoQnw+paSg/dlMFzPl8h6OrK55Pz5s091cLHQAsXojjZEfCOj3bJ5VJrHQxg8OUPKkBSnc7XIFAV9f8SVOA299o8qIllS9TWUTVBOqxiiG2VlLObN2zh0SqsZH8Uf/2SX9cmAoAXGXlS3ANXnIYFMY1PIWCB9Pyta1bt66ZUfTd7V8AJRsrXxZEweHOnMFv3roGU7Ji1rQf297fAZilOByFcwaPW4MHtjOKpgPbf9HoRUtxeDwes3TRLHC4wPZfVbTp6fIZRYVl+T81fdwY4Pb/9Q3i0ArjHjdFFQAAAABJRU5ErkJggg==" />&nbsp;&nbsp;<a href="http://cimg.eu/">http://cimg.eu</a></center>)
#@gui : note = note{"\n
#@gui : If you appreciate <b>G'MIC</b>, you are welcome to send us a nice postcard from your place, at:\n\n
#@gui : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gui :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gui : Postcards senders automatically enter the <i>Friends Hall of Fame</i> :) !
#@gui : "}

#@gui Contributors : _none_, _none_
#@gui : note = note{"
#@gui : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gui : A big hug to : \n\n
#@gui : <b> -</b> <i>Sylvie Alexandre</i> <small>(packaging, testing &amp; filters)</small>
#@gui : <b> -</b> <i>Partha Bagchi</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Daniel P. Berrang&#233;</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>S&#233;bastien Bougleux</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>J&#233;rome Boulanger</i> <small>(testing &amp; code)</small>
#@gui : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Aur&#233;lien Ceyden</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(testing)</small>
#@gui : <b> -</b> <i>Patrick David</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Maxime Daisy</i> <small>(code &amp; testing)</small>
#@gui : <b> -</b> <i>Fr&#233;d&#233;ric Devernay</i> <small>(code)</small>
#@gui : <b> -</b> <i>Iain Fergusson</i> <small>(filters)</small>
#@gui : <b> -</b> <i>Tobias Fleischer</i> <small>(testing &amp; code)</small>
#@gui : <b> -</b> <i>Roberto Ferramosca</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(testing, code &amp; tutorials)</small>
#@gui : <b> -</b> <i>Andrea Ferrero</i> <small>(testing, code)</small>
#@gui : <b> -</b> <i>Chris Fiedler</i> <small>(gfx)</small>
#@gui : <b> -</b> <i>S&#233;bastien Fourey</i> <small>(G'MIC-Qt, ZArt code &amp; G'MIC online)</small>
#@gui : <b> -</b> <i>Gentlemanbeggar</i> <small>(filters)</small>
#@gui : <b> -</b> <i>David Gowers</i> <small>(testing)</small>
#@gui : <b> -</b> <i>Claes Holmerson</i> <small>(tutorials)</small>
#@gui : <b> -</b> <i>Arto Huotari</i> <small>(filters)</small>
#@gui : <b> -</b> <i>Dan Leinir Turthra Jensen</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Tom Keil</i> <small>(testing, filters &amp; tutorials)</small>
#@gui : <b> -</b> <i>Andy Kelday</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Alan Kwan</i> (afre) <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Angelo Lama</i> <small>(testing &amp; EKD integration)</small>
#@gui : <b> -</b> <i>John Lakkas</i> <small>(filters)</small>
#@gui : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gui : <b> -</b> <i>Mark</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Mahvin</i> <small>(testing &amp; design)</small>
#@gui : <b> -</b> <i>MareroQ</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Ramon Miranda</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Tou Omiya</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Mauro Quercia</i> <small>(translation)</small>
#@gui : <b> -</b> <i>PhotoComiX</i> <small>(testing, translation &amp; filters)</small>
#@gui : <b> -</b> <i>Garry Osgood</i> <small>(documentation &amp; filters)</small>
#@gui : <b> -</b> <i>Jehan Pages</i> <small>(testing &amp; code)</small>
#@gui : <b> -</b> <i>Andreas P&#229;hlsson</i> <small>(filters)</small>
#@gui : <b> -</b> <i>James Prichard</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Guilherme Razgriz</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Karsten Rodenacker</i> <small>(packaging &amp; code)</small>
#@gui : <b> -</b> <i>Marc Roovers</i> <small>(clut data)</small>
#@gui : <b> -</b> <i>Dani Sard&#224;</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Yuri Shemanin</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Silvio Grosso</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Stepanekos</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Thorsten "otto" Stettin</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Lukas Tvrdy</i> <small>(Krita integration)</small>
#@gui : <b> -</b> <i>Martin Wolff</i> <small>(testing &amp; filters)</small>
#@gui : <b> -</b> <i>Bernd Zeimetz</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Matthias Zepper</i> <small>(testing)</small>
#@gui : <b> -</b>"}

#@gui Download External Data : gui_download_all_data, gui_no_preview(1)
#@gui : note = note{"This filter will download all external data files used by some filters of the <i>G'MIC</i> plug-in (<i>Color Grading</i>, <i>Light Leaks</i>, <i>Grain</i>, etc...),
#@gui : and will install them as persistent files on your hard drive. After this operation, you won't need a permanent
#@gui : internet connection anymore in order to use some of the G'MIC filters."}
#@gui : note = note()
#@gui : note = note{"<b><span color="red">Warning:</span></b> A <b>lot of data</b> will be downloaded by this filter. This can take a long time !"}
#@gui : sep = separator()
#@gui : Force re-Download from Scratch = _bool(0)
#@gui : sep = separator()
#@gui : note = note{"<b><span color="red">Alternative (manual) method:</span></b>\nIf, for any reasons, your plug-in is unable to retrieve data from the Internet, you can download all
#@gui : those data files manually (as a single .zip file) at this address :"}
#@gui : url = link{"https://gmic.eu/gmic_all_data.zip"}
#@gui : note = note{"You must then decompress all files contained in this archive at the following location:\n
#@gui : - for <b>Unix</b>-like systems : <span color="blue"><tt>$HOME/.config/gmic/</tt></span>\n
#@gui : - for <b>Windows</b> systems : <span color="blue"><tt>%APPDATA/gmic/</tt></span>
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/16/04</i>.</small>")
gui_download_all_data :

  # Color Grading.
  l[] clut foo rm onfail rm endl

  # Grain.
  _filenames_grain=${-_fx_simulate_grain}
  _url_grain=https://gmic.eu/data_film_presets
  _prefix_grain=grain_
  _ext_grain=cimgz

  # Light leaks.
  _filenames_lightleak=${-_fx_light_leaks}
  _url_lightleak=https://gmic.eu/data_lightleaks
  _prefix_lightleak=
  _ext_lightleak=cimgz

  # Sample images.
  _filenames_sample=${-__sample}
  _url_sample=https://gmic.eu/img
  _prefix_sample=sample_
  _ext_sample=png

  # Demo thumbnails.
  _filenames_demo=gmic_demos
  _url_demo=https://gmic.eu/img
  _prefix_demo=
  _ext_demo=cimgz

  # Manage downloads.
  _n=0
  _N={narg($_filenames_grain,$_filenames_lightleak,$_filenames_logo,$_filenames_sample)}
  progress 0
  _gui_download_all_data[] grain,$1
  _gui_download_all_data[] lightleak,$1
  _gui_download_all_data[] logo,$1
  _gui_download_all_data[] sample,$1
  _gui_download_all_data[] demo,$1
  progress 100

_gui_download_all_data :
   repeat {narg(${_filenames_$1})}
     filename=${_prefix_$1}${arg\ 1+$>,${_filenames_$1}}.${_ext_$1}
     v + e[] "Download "$filename v -
     if {$2" || "!isfile('${_path_rc}$filename')} l[] ${_url_$1}/$filename o ${_path_rc}$filename rm onfail endl fi
     progress {100*$_n/$_N}
     _n+=1
   done

#@gui Filter Design : _none_, _none_
#@gui : note = note{"
#@gui : <b>G'MIC</b> is an <b>open</b> image processing framework. Thus, including
#@gui : <b>user-defined filters</b> into this plug-in is possible.\n\n
#@gui : To do so, you need to create a <span foreground="purple" style="italic">.gmic</span>
#@gui : file in your <i>$HOME/</i> folder (or <i>%APPDATA%/user.gmic</i> on Windows).
#@gui : It will be read each time the plug-in is launched, or when the <i>Refresh</i>
#@gui : button (under the central pane) is pressed. It must be a regular ascii file, containing the declarations and
#@gui : implementations of the filters (written in the <b>G'MIC</b> language) that will be added
#@gui : to the list of available ones."}
#@gui : note = note{"
#@gui : Existing filters are already defined this way.
#@gui : Writing a filter from scratch in <b>G'MIC</b> requires some skills, but
#@gui : can be generally done in very few lines.\n\n
#@gui : <span foreground="purple" underline="single">Example of a valid <i>.gmic</i> entry :</span>"}
#@gui : note = note{"<tt>#@gui My effect : my_effect, my_effect</tt>"}
#@gui : note = note{"<tt>#@gui : Sigma = float(2,0,10)</tt>"}
#@gui : note = note{"<tt>my_effect :\n     +blur $1 n 0,255 xor</tt>"}
#@gui : note = note{"
#@gui : Look at the reference documentation and the tutorial whose links are given below, to learn more.
#@gui : By the way, you are encouraged to share your nice custom filters with us on our forums,
#@gui : for inclusion into next releases of <b>G'MIC</b>.
#@gui : "}
#@gui : sep = separator()
#@gui : url = link(0,"[1] G'MIC reference documentation","https://gmic.eu/reference.shtml")
#@gui : url = link(0,"[2] G'MIC scripting tutorial","https://gmic.eu/tutorial/index.shtml")
#@gui : url = link(0,"[3] G'MIC filter template","https://gmic.eu/template.gmic")

#@gui Friends Hall of Fame : _none_, fx_friends
#@gui : note = note{"\n<span foreground="purple" underline="single">Supporters:</span>"}
#@gui : note = note{" <b>-</b> A big hug goes to these friends who supported the project:"}
#@gui : note = note{"<i>
#@gui : Margaret Wong,
#@gui : Adrian Bottomley,
#@gui : Pamela Young,
#@gui : <a href="http://chrisbowness.com/">Chris Bowness</a>,
#@gui : Peter Howarth,
#@gui : Marlon Montalvo,
#@gui : Christian Freiherr von Malchus,
#@gui : Nolan Tyrrell,
#@gui : Gilles Bouquerel,
#@gui : Mihail Balabanov,
#@gui : Rolf Niepraschk,
#@gui : Volkmar Geske,
#@gui : Menno Tjoelker,
#@gui : <a href="https://borkarabhijeet05.blogspot.com/p/about-me.html">Abhijeet Borkar</a>,
#@gui : <a href="https://www.behance.net/kontaktarl1e0a">Arleta Lesniewska</a>,
#@gui : Nicola Giaccobe,
#@gui : Helmut M&#252;hleisen,
#@gui : Paul Buckley,
#@gui : <a href="http://www.flickr.com/newmikey">Mike Bing</a>,
#@gui : Olivier Lecarme,
#@gui : Edward Ingram,
#@gui : <a href="http://www.gus-verlag.de/verlag/Artelier/">Stefan St&#228;dtler-Ley</a>,
#@gui : Michel Pastor,
#@gui : Sz.U,
#@gui : Sven Kraft,
#@gui : Frederik Elwert,
#@gui : Jessica Leonard,
#@gui : <a href="https://www.viewbug.com/member/KennZaney">Kenneth Simons</a>,
#@gui : <a href="https://www.flickr.com/photos/114936163@N05/">Milos Ciuk</a>,
#@gui : Manlio Barolo,
#@gui : John Lewandowski,
#@gui : <a href="http://mediaklan.com/">Didier Lima</a>,
#@gui : &#381;ygimantas Tauras,
#@gui : Massimo Ferri,
#@gui : <a href="https://github.com/sina-ht">Hiroshi Takekawa</a>,
#@gui : Freelance writer,
#@gui : <a href="https://www.flickr.com/photos/49284009@N04/">Elaine Hutchings</a>,
#@gui : Andr&#225;s Somogyi,
#@gui : <a href="https://www.flickr.com/photos/tonurics">Jason Dora</a>,
#@gui : Boris Hajdukovic,
#@gui : <a href="https://mappish.com/pages/about-us">Jeff Combs / Mappish</a>,
#@gui : <a href="http://flickr.com/photos/btraven">BTraven</a>,
#@gui : <a href="https://500px.com/spodeworld">Steven Brener</a>,
#@gui : Susanne Gabrielski,
#@gui : Andrea Correani,
#@gui : Mads Thomsen,
#@gui : Djek Eykhout,
#@gui : Michael Calabrese,
#@gui : Joachim Steiert
#@gui : Christian Dubettier,
#@gui : J. Casseur,
#@gui : <a href="http://www.gnomelibre.fr/">Okki</a>,
#@gui : Dariusz Duma,
#@gui : <a href="http://www.mahvin.com/">Mahvin</a>,
#@gui : Elleen Hennessy,
#@gui : BluffStuffPlus,
#@gui : <a href="http://www.bertrandchan.eu">Bertrand Chan</a>,
#@gui : Mirella Scotto,
#@gui : <a href="http://www.photopablo.com">Paul Sauve</a>,
#@gui : <a href="https://darktablemaster.de">Lars Mielke</a>,
#@gui : Devin Sorell,
#@gui : <a href="http://www.quesepuedehacerenlinux.net">Pepe Baeza</a>,
#@gui : <a href=" http://www.lesnoy-tanets.com">Andrey Pivovarova</a>,
#@gui : <a href="http://doliver.co.uk/">David Oliver</a>,
#@gui : <a href="https://ello.co/errore">errore</a>,
#@gui : <a href="http://www.anudai.de">Anudai</a>,
#@gui : James Stalnaker,
#@gui : <a href="https://plus.google.com/u/0/b/117441237982283011318/112547676857320288448/about">Paolo Finetti</a>,
#@gui : Luigi Scarselli,
#@gui : <a href="http://blog.patdavid.net/">Pat David</a>,
#@gui : Juan Jose Rodriguez Vela,
#@gui : Thomas Jakob,
#@gui : Kim Bartholomew,
#@gui : <a href="http://www.captivemoment.com">Sudi</a>,
#@gui : Michael Prostka,
#@gui : Arkadi Gelfond,
#@gui : <a href="https://joeysl.wordpress.com/">Sabine Sch&#228;fers</a>,
#@gui : <a href="http://www.viewbug.com/member/KennZaney">Bull O'Woods</a>,
#@gui : Jost Jakob Schaper,
#@gui : Dominik Wefers,
#@gui : Frank McLaughlin,
#@gui : <a href="https://29a.ch/">Jonas Wagner</a>,
#@gui : <a href="www.ixaarii.com​">Void lon iXaarii</a>,
#@gui : Mark Boadey,
#@gui : Laura Haglund,
#@gui : Lee Elliott,
#@gui : Bernard Desenclos,
#@gui : Randy Gordon-Gilmore,
#@gui : Eddie Dedrick,
#@gui : <a href="http://mindprints.org/">Greg FitzPatrick</a>,
#@gui : Zsolt Szabo,
#@gui : Daniel Hanna,
#@gui : Peter Bengtsson,
#@gui : Diego Nassetti,
#@gui : William Tweedy,
#@gui : Shawnee Horn,
#@gui : Stephan Munsch,
#@gui : <a href="http://www.mysticali3n-wear.com">MysticAli3n-Wear</a>,
#@gui : Mika Mantere,
#@gui : Christian Beuschel,
#@gui : Tore Busch,
#@gui : Douc McGregor.
#@gui : Marcel Dahm,
#@gui : Susan Voitel,
#@gui : <a href="https://www.flickr.com/photos/henkkoning">Henk Koning</a>,
#@gui : Arnie Jordan,
#@gui : Carol Jennings,
#@gui : S&#233;bastien Huart,
#@gui : <a href="http://www.jessstryker.com/">Jess Stryker</a>,
#@gui : Rui Luis,
#@gui : <a href="https://www.flickr.com/photos/sallesrenato/">Renato Salles</a>,
#@gui : <a href="http://www.viewbug.com/member/alef0"> Petr Zagalak</a>,
#@gui : <a href="http://www.antonio.cat">Antonio Vici&#233;n Faure</a>,
#@gui : Vincent Bermel,
#@gui : Christian Stocco,
#@gui : <a href="https://www.flickr.com/photos/136307651@N04/">Richard Benedict</a>,
#@gui : Dr. Helmut Jarausch,
#@gui : <a href="http://www.michaeljamesbeck.com">Michael Beck</a>,
#@gui : <a href="http://rickleone.tumblr.com/">Riccardo Leone</a>,
#@gui : Gisela Looram,
#@gui : <a href="https://plus.google.com/u/0/+FrankTegtmeyer/posts">Frank Tegtmeyer</a>,
#@gui : David Kettrey,
#@gui : <a href="https://www.youtube.com/user/kncpt1">Peter Hoge</a>,
#@gui : Alexander Heitmann,
#@gui : <a href="http://harlequin.webcomics.fr/page/episode-1-page-1">Olivier Larski</a>,
#@gui : <a href="http://victorfandrey.blogspot.ca">Victor Fandrey</a>,
#@gui : Stefan Peter,
#@gui : <a href="https://plus.google.com/u/0/+DimitriosPsychogios">Dimitrios Psychogios</a>,
#@gui : <a href="https://plus.google.com/+AnttiLuoma">Antti Luoma</a>,
#@gui : <a href="https://twitter.com/jeyoung">Eddy Young Tie Yang</a>,
#@gui : Thomas Elfstrom,
#@gui : Valentine Boyce,
#@gui : George Harnett,
#@gui : Darius Manka,
#@gui : Chris Knox,
#@gui : <a href="http://tomtappingphotoblog.blogspot.fr/">Thomas Tapping</a>,
#@gui : Phillip R Ziesemer,
#@gui : Jean Francois.
#@gui : Franz Ziereis,
#@gui : Alessandro Renzi,
#@gui : Tsuda Koshi,
#@gui : <a href="http://www.boxrec.com">Boxrec Ltd</a>,
#@gui : <a href="http://www.wolfgangschweizer.com/">Wolfgang Schweizer</a>,
#@gui : <a href="http://www.ramonmiranda.com/">Ramon Miranda</a>,
#@gui : Volker Bradley,
#@gui : <a href="http://plus.google.com/+MarcoZara">Marco Zara</a>,
#@gui : <a href="http://plus.google.com/+MarcoTedaldi">Marco Tedaldi</a>,
#@gui : <a href="http://cybertographer.com">Rodney Lee</a>,
#@gui : Konstantinos Blatzonis,
#@gui : Simon Chanson,
#@gui : Herbert Malle,
#@gui : <a href="http://www.matthias-zepper.de/">Matthias Zepper</a>,
#@gui : Christian Mariucci,
#@gui : M. R.,
#@gui : Mark Link,
#@gui : <a href="http://blog.meetthegimp.org/">Rolf Steinort</a>,
#@gui : <a href="https://plus.google.com/112357088505488756823/posts">Daniel Tauro</a>,
#@gui : <a href="http://geniisoft.com/">Ben Langhinrichs</a>,
#@gui : <a href="http://www.openlabs.it/">Paolo Pedaletti</a>,
#@gui : <a href="http://blog.photomontager.com">Ricardo Corin</a>,
#@gui : <a href="https://plus.google.com/115953666279509959258">James Prichard</a>,
#@gui : <a href="https://plus.google.com/116658221461047313647">Matt Jones</a>,
#@gui : <a href="http://www.flickr.com/people/twekkel/">Eddy Vervest</a>,
#@gui : <a href="http://www.flickr.com/photos/ssshupe/">Steven Shupe</a>,
#@gui : <a href="http://www.flaviocdc.net/wiki/">Flavio Casadei Della Chiesa</a>,
#@gui : <a href="http://www.artwanted.com/artist.cfm?artid=10918">Lyle Kroll</a>.
#@gui : </i>"}
#@gui : sep = separator()
#@gui : note = note{"\n<span foreground="purple" underline="single">Postcard senders:</span>"}
#@gui : note = note{" <b>-</b> We've received <b>44</b> postcards from <b>G'MIC</b> enthusiasts so far.
#@gui :               You could be the <b>45rd</b> sender :)"}
#@gui : note = note{" <b>-</b> A big hug goes to these postcard senders (recently received first) :"}
#@gui : note = note{"<i>
#@gui : <a href="https://cimg.eu/img/postcard70.jpg">Patrick Wanters</a> (USA),
#@gui : <a href="https://cimg.eu/img/postcard69.jpg">Josep Febrer</a> (Pregonda/Menorca),
#@gui : <a href="https://cimg.eu/img/postcard68.jpg">Richard Gledson</a> (Newcastle upon tyne/England),
#@gui : <a href="https://cimg.eu/img/postcard67.jpg">James Jaworski</a> (Winnipeg/Canada),
#@gui : <a href="https://cimg.eu/img/postcard66.jpg">Powlux</a> (France),
#@gui : <a href="https://cimg.eu/img/postcard65.jpg">Volker Doebel</a> (Haldern/Germany),
#@gui : <a href="https://cimg.eu/img/postcard64.jpg">Patrick Wauters</a> (Bilbao/Spain),
#@gui : <a href="https://cimg.eu/img/postcard63.jpg">Sebastien Fourey</a> (Konstanz/Germany),
#@gui : <a href="https://cimg.eu/img/postcard62.jpg">David Revoy</a> (Toulouse/France),
#@gui : <a href="https://cimg.eu/img/postcard61.jpg">Giulio Canevari</a> (Pavia/Italy),
#@gui : <a href="https://cimg.eu/img/postcard60.jpg">Bruno Steinbach</a> (Pondicherry/India),
#@gui : <a href="https://cimg.eu/img/postcard59.jpg">Steve Gillow</a> (Fort Worth/Texas/USA),
#@gui : <a href="https://cimg.eu/img/postcard58.jpg">Peter Neave</a> (Sydney/Australia),
#@gui : <a href="https://cimg.eu/img/postcard57.jpg">Andrea [Photoflow]</a> (Italy),
#@gui : <a href="https://cimg.eu/img/postcard56.jpg">Garry R. Osgood</a> (New York/USA),
#@gui : <a href="https://cimg.eu/img/postcard55.jpg">Justin Pletzfeld</a> (Germany),
#@gui : <a href="https://cimg.eu/img/postcard54.jpg">Werner Meier</a> (Germany),
#@gui : <a href="https://cimg.eu/img/postcard53.jpg">Patrick Wauters</a> (Roma/Italy),
#@gui : <a href="https://cimg.eu/img/postcard52.jpg">Marc Lis</a> (Belgium),
#@gui : <a href="https://cimg.eu/img/postcard51.jpg">ZondeR</a> (France),
#@gui : <a href="https://cimg.eu/img/postcard50.jpg">Bill C.</a> (USA),
#@gui : <a href="https://cimg.eu/img/postcard49.jpg">Michael T.</a> (France),
#@gui : <a href="https://cimg.eu/img/postcard48.jpg">Patrick Wauters</a> (Lisboa),
#@gui : <a href="https://cimg.eu/img/postcard47.jpg">Akky [Gimpchat]</a> (Australia),
#@gui : <a href="https://cimg.eu/img/postcard45.jpg">Michel Thomas</a> (Germany),
#@gui : <a href="https://cimg.eu/img/postcard44.jpg">Pierre-Yves</a> (Ile de Batz/France),
#@gui : <a href="https://cimg.eu/img/postcard43.jpg">Family Hamacher</a> (Trier/Germany),
#@gui : <a href="https://cimg.eu/img/postcard41.jpg">Benoit Gauzere and Francois Lozes</a> (Hokusai/Japan),
#@gui : <a href="https://cimg.eu/img/postcard40.jpg">Dr. Rainer Teubner</a> (Seligenstadt/Germany),
#@gui : <a href="https://cimg.eu/img/postcard39.jpg">Mauro Mitrino</a> (Mantova/Italy),
#@gui : <a href="https://cimg.eu/img/postcard37.jpg">Werner Meier</a> (Mettlach/Germany),
#@gui : <a href="https://cimg.eu/img/postcard36.jpg">Arto Huotari</a> (Helsinki/Finland),
#@gui : <a href="https://cimg.eu/img/postcard33.jpg">Benoit Gauzere</a> (California/USA),
#@gui : <a href="https://cimg.eu/img/postcard30.jpg">Arkadi Gelfond</a> (Foster City - California/USA),
#@gui : <a href="https://cimg.eu/img/postcard29.jpg">Corinne Masimann</a> (Neuchatel/Switzerland),
#@gui : <a href="https://cimg.eu/img/postcard27.jpg">Mahvin</a> (Portland/USA),
#@gui : <a href="https://cimg.eu/img/postcard26.jpg">Vincent Roullier</a> (Caen/France),
#@gui : <a href="https://cimg.eu/img/postcard24.jpg">M????</a> (Munich/Germany),
#@gui : <a href="https://cimg.eu/img/postcard23.jpg">F. Albior</a> (Jaca/Spain),
#@gui : <a href="https://cimg.eu/img/postcard22.jpg">PhotoComIX</a> (Frascati/Italy),
#@gui : <a href="https://cimg.eu/img/postcard21.jpg">Guy Poizat</a> (Cabestany/France),
#@gui : <a href="https://cimg.eu/img/postcard20.jpg">Institut for Biomathematik und Biometrie</a> (Neuherberg/Germany),
#@gui : <a href="https://cimg.eu/img/postcard15.jpg">Jean-Michel Webbe</a> (Guadeloupe/France),
#@gui : <a href="https://cimg.eu/img/postcard14.jpg">Jaime</a> (Barcelona/Spain).
#@gui : </i>"}
#@gui : sep = separator()
#@gui : note = note{"\nMay the force be with you!"}
fx_friends :
  if $! ratio={w/h} else ratio=1 fi
  rm _heart80x73 scale3x r 150%,150%,1,1,0,0,0.5,0.5
  +*. 70 +*.. 110 +*... 255 *[-4] 255 a c
  blur_radial 4 sharpen 300
  i.. ${fitratio_wh\ {w},{h},$ratio},1,3
  rand.. 0,255 sh.. 1,2 /. 2 rm.
  blur_radial.. 20 sharpen.. 50
  r. ..,..,1,4,0,0,0.5,0.5 blend alpha
  143,80,1,1,0 t. "Greetings to\n  all G\47MIC\n  friends!",2,-2,27,1,1
  +dilate. 3 *.. 255 to_rgb.. j... ..,{[w#-3-w#-2,h#-3-h#-2]/2},0,0,1,.
  rm[-2,-1]

_heart80x73 :
  40,73,1,1,0 ellipse 22,22,20,20,0,1,1 polygon 3,7,37,42,72,42,27,1,1 +mirror x a x

#@gui Gmicky - Roddy : fx_gmicky, fx_gmicky_preview
#@gui : Mascot Image = choice{"Gmicky (by Deevad)","Gmicky (by Mahvin)","Gmicky &amp; Wilber (by Mahvin)","Roddy (by Mahvin)"}
#@gui : sep = separator()
#@gui : note = note{"<b><i>Gmicky</i></b> is the name of the <b>G'MIC</b> mascot. He is a small and cute tiger who knows how to do magic.
#@gui : <b><i>Gmicky</i></b> is a tiger, i.e. fast, agile and elegant, just as the <b>G'MIC</b> code is :).
#@gui : As many magicians, <b><i>Gmicky</i></b> knows lot of <b>gimmicks</b>, and he is a direct and friendly competitor of
#@gui : the ImageMagick's wizard, or the GraphicMagick's frog."}
#@gui : note = note{"<b><i>Roddy</i></b> is another mascot designed specifically for the <i>Artistic / Rodilius</i> filter of <b>G'MIC</b>.\n"}
#@gui : note = note{"<b><i>Gmicky</i></b> and <b><i>Roddy</i></b> have been both created and drawn by "}
#@gui : url = link("Mahvelous Mahvin","http://www.mahvin.com/")
#@gui : note = note{"and"}
#@gui : url = link{"David Revoy (Deevad)","http://www.davidrevoy.com/"}
fx_gmicky :
  rm
  if {$1==0} sp gmicky nm "name(Gmicky)"
  elif {$1==1} sp gmicky_mahvin nm "name(Gmicky)"
  elif {$1==2} sp gmicky_wilber nm "name(Gmicky & Wilber)"
  else sp roddy nm "name(Roddy)"
  fi

fx_gmicky_preview :
  fx_gmicky $* rr2d $_preview_width,$_preview_height,0,2

#@gui Release Notes : _none_, _none_
#@gui : note = note{"
#@gui : - <b>2009/01/13</b> : version <i>1.3.0</i> (initial plug-in release).\n
#@gui : - <b>2010/09/03</b> : version <i>1.4.0</i>.\n
#@gui : - <b>2011/07/07</b> : version <i>1.5.0</i>.\n
#@gui : - <b>2014/08/20</b> : version <i>1.6.0</i>.\n
#@gui : - <b>2016/03/25</b> : version <i>1.7.0</i>.\n
#@gui : - <b>2017/05/29</b> : version <i>2.0.0</i>.\n
#@gui : - <b>2017/10/09</b> : version <i>2.1.0</i>.\n
#@gui : - <b>2018/02/15</b> : version <i>2.2.0</i>.\n
#@gui : - <b>2018/06/21</b> : version <i>2.3.0</i>.\n
#@gui : - <span foreground="purple"><b>2019/01/11</b> : version <i>2.4.5</i> (Current stable).</span>\n
#@gui : - <b>2019/01/18</b> : version <i>2.5.0_pre</i> (Current pre-release).</span>\n
#@gui : "}
#@gui : sep = separator()
#@gui : url = link{"View changelog to upcoming major version (2.5.0)","https://discuss.pixls.us/t/on-the-road-to-2-5-0"}
#@gui : url = link{"View latest minor changelog (2.4.0)","https://discuss.pixls.us/t/release-of-gmic-2-4-0"}
#@gui : url = link{"View latest major changelog (2.0.0)","https://discuss.pixls.us/t/release-of-gmic-2-0-0"}

#@gui Privacy Notice : _none_, _none_
#@gui : note = note{"This plugin may download up-to-date filter definitions from the <a href="https://gmic.eu">gmic.eu</a> server.\n\n
#@gui : It is the case when first launched after a fresh installation, and periodically
#@gui : with a frequency which can be set in the settings dialog.
#@gui : The user should be aware that the following information may be retrieved
#@gui : from the server logs: <i>IP address of the client; date and time of the request;</i>
#@gui : as well as a short string, supplied through the HTTP protocol <i>"User Agent"</i> header
#@gui : field, which describes the full plugin version as shown in the window title
#@gui : (e.g. "<i>G'MIC-Qt for GIMP 2.8 - Linux 64 bits - 2.2.1_pre#180301</i>").\n\n
#@gui : Note that this information may solely be used for purely anonymous
#@gui : statistical purposes.
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i>S&#233;bastien Fourey</i>.      Latest Update: <i>2018/03/01</i>.</small>")

#@gui ____<b>Arrays &amp; Tiles</b>
#----------------------------------

#@gui Array [Faded] : fx_array_fade, fx_array_fade_preview(1)
#@gui : X-Tiles = int(2,1,10)
#@gui : Y-Tiles = int(2,1,10)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Fade Start (%) = float(80,1,100)
#@gui : Fade End (%) = float(90,1,100)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axes")
#@gui : Size = _choice("Shrink", "Expand", "Repeat [Memory Consuming!]")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array_fade :
  if {$7&1} mirror x fi if {$7>1} mirror y fi
  array_fade $1,$2,$5,$6,$8
  shift -$3%,-$4%,0,0,2

fx_array_fade_preview :
  fx_array_fade $1,$2,$3,$4,$5,$6,$7,0

#@gui Array [Mirrored] : fx_array_mirror, fx_array_mirror_preview(1)
#@gui : Iterations = int(1,1,10)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Array Mode = choice(2,"X-Axis","Y-Axis","XY-Axes","2XY-Axes")
#@gui : Initialization = choice("Original","Mirror X","Mirror Y","Rotate 90 deg.","Rotate 180 deg.","Rotate 270 deg.")
#@gui : Expand Size = _bool(false)
#@gui : Crop (%) = int(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array_mirror : skip ${7=0}
  if {$5==1} mirror x
  elif {$5==2} mirror y
  elif {$5==3} rotate 90
  elif {$5==4} rotate 180
  elif {$5==5} rotate 270
  fi
  if $7
    if {$4==0} columns 0,{100-$7}%
    elif {$4==1} rows 0,{100-$7}%
    elif {$4==2} z 0,0,{100-$7}%,{100-$7}%
    elif {$4==3} z {$7/2}%,{$7/2}%,{100-$7/2}%,{100-$7/2}%
    fi
  fi
  shift -$2%,-$3%,0,0,2
  array_mirror $1,$4,$6

fx_array_mirror_preview :
  fx_array_mirror $1,$2,$3,$4,$5,0,$7

#@gui Array [Random] : array_random, array_random(1)
#@gui : Source X-Tiles = int(5,1,20)
#@gui : Source Y-Tiles = int(5,1,20)
#@gui : Destination X-Tiles = int(7,1,20)
#@gui : Destination Y-Tiles = int(7,1,20)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Array [Random Colors] : fx_array_color, fx_array_color(1)
#@gui : X-Tiles = int(5,1,20)
#@gui : Y-Tiles = int(5,1,20)
#@gui : Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array_color :
  repeat $! l.
    $1,$2,1,3 rand. 0,255 to_colormode. {-2,s} r. .. *. $3 *.. {1-$3} +[-2,-1]
  endl mv. 0 done

#@gui Array [Regular] : fx_array, fx_array_preview(1)
#@gui : X-Tiles = int(2,1,10)
#@gui : Y-Tiles = int(2,1,10)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axes")
#@gui : Size = _choice("Shrink", "Expand", "Repeat [Memory Consuming!]")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_array :
  shift -$3%,-$4%,0,0,2
  if {$5&1} mirror x fi if {$5>1} mirror y fi
  array $1,$2,$6

fx_array_preview :
  fx_array $1,$2,$3,$4,$5,0

#@gui Ascii Art : fx_asciiart, fx_asciiart_preview(0)+
#@gui : Charset = choice(5,"Custom","Binary Digits","Digits","Lowercase Letters","Uppercase Letters","Ascii","Card Suits","Math Symbols")
#@gui : Custom Dictionary = text{" .oO0"}
#@gui : Analysis Scale = int(16,8,103)
#@gui : Analysis Smoothness = float(15,0,100)
#@gui : Synthesis Scale = int(16,8,103)
#@gui : Result Type = choice(2,"White on Black","Black on White","Colored on Black","Colored on Transparent")
#@gui : sep = separator()
#@gui : Gamma = float(0,-3,3)
#@gui : Smoothness = float(0.2,0,5)
#@gui : Colors = choice("Full Colors","2 Colors","3 Colors","4 Colors","8 Colors","12 Colors","16 Colors",
#@gui :                 "Grayscale","2 Grays","3 Grays","4 Grays","8 Grays","12 Grays","16 Grays")
#@gui : sep = separator()
#@gui : Output Ascii File = _bool(0)
#@gui : Output Folder = _folder()
#@gui : Output Filename = _text("gmic_asciiart.txt")
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=10047")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/27/03</i>.</small>")
fx_asciiart : skip ${10=},"${11=}","${12=}"
  repeat $! l[$>] to_rgb
    apply_gamma {10^$7} b $8% n 0,255
    if {$1==0} dict="$2"
    elif {$1==1} dict=" 01"
    elif {$1==2} dict=" 0123456789"
    elif {$1==3} dict=" abcdefghijklmnopqrstuvwxyz"
    elif {$1==4} dict=" ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    elif {$1==5} dict=" !\042#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~"
    elif {$1==6} dict=" \16\17\20\21"
    elif {$1==7} dict=" \200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231"
    fi
    if {$6==1} negate fi
    if $-3 +img2ascii $dict,$3,$4%,$5,"$-2"/"$-1"
    else +img2ascii $dict,$3,$4%,$5
    fi
    wh=${}
    if {$6==0} k. n 0,255
    elif {$6==1} k. negate n 0,255
    elif {$6==2||$6==3}
      r[0] $wh,1,100%,1
      if {$9>=7} luminance[0] fi
      if {$9%7} quantize[0] {arg($9%7,2,3,4,8,12,16)-1},1,0 fi
      r[0] [1],[1],1,100% *[0] [1]
      if {$6==2} rm[1]
      else *[1] 255 a c
      fi
    fi
  endl done

fx_asciiart_preview :
  repeat $! l[$>]
    w={w} h={h}
    fx_asciiart $1,"$2",${3-9},0,foo,foo
    r $w,$h,1,100%,0,0,0.5,0.5
  endl done

#@gui Chessboard : fx_chessboard, fx_chessboard_preview(0)
#@gui : First Size = int(64,1,512)
#@gui : Second Size = int(64,1,512)
#@gui : First Offset = int(0,0,512)
#@gui : Second Offset = int(0,0,512)
#@gui : Angle = float(0,0,180)
#@gui : Opacity = float(0.5,0,1)
#@gui : First Color = color(0,0,0,255)
#@gui : Second Color = color(255,255,255,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_chessboard :
  to_rgba chessboard ${1-14}

fx_chessboard_preview :
  gui_split_preview "fx_chessboard $*",${-3--1}

#@gui Dices : fx_dices, fx_dices(0)
#@gui : Resolution = float(2,1,10)
#@gui : Size = int(24,8,64)
#@gui : Color Model = choice(1,"Black Dices","White Dices","Dices with Colored Numbers","Dices with Colored Sides")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/06</i>.</small>")
fx_dices :

    # Create dice patterns.
    repeat 6 {2*$2},{2*$2} _dice$> done
    if {$3%2} negate[-6--1] fi
    frame_round[-6--1] 10,10,0,0,128,128,128,0
    r2dy[-6--1] $2 a[-6--1] x

    repeat {$!-1} l[$>,-1]

      # Prepare input images.
      +luminance[0] rv[1,2] r[0,1] {100*$1/$2}%,{100*$1/$2}%,1,100%,2 quantize[1] 6,0

      # Convert input image to dices pattern.
      *.. $2 channels.. 0,1 r.. {$2*100}%,{$2*100}%
      $2,$2,1,2,'if(c,y,x)' r. ...,...,1,2,0,2 +[-3,-1] +warp. ..,0,0 rm...

      if {$3<2} rm[0] mv. 0
      else r[0] [2],[2],1,100% rv[0,-1] blend[0,-1] multiply
      fi

    endl done rm.

_dice0 : ellipse. 50%,50%,5.2%,5.2%,0,1,255
_dice1 : ellipse. 25%,25%,5.2%,5.2%,0,1,255 ellipse. 75%,75%,5.2%,5.2%,0,1,255
_dice2 : _dice1 _dice0
_dice3 : _dice1 ellipse. 25%,75%,5.2%,5.2%,0,1,255 ellipse. 75%,25%,5.2%,5.2%,0,1,255
_dice4 : _dice3 _dice0
_dice5 : _dice3 ellipse. 25%,50%,5.2%,5.2%,0,1,255 ellipse. 75%,50%,5.2%,5.2%,0,1,255

#@gui Drawn Montage : fx_drawn_montage, fx_drawn_montage_preview(1)
#@gui : Layer = choice("1st","2nd","3rd","4th","5th","6th","7th","8th","9th","10th","11th","12th","13th","14th","15th","16th")
#@gui : Associated Color = color(0,0,0)
#@gui : Zoom = float(-10,0,10)
#@gui : X-Centering (%) = float(50,0,100)
#@gui : Y-Centering (%) = float(50,0,100)
#@gui : Angle = choice("0 deg.","90 deg.","180 deg.","270 deg.")
#@gui : Pargs = value(-1)
#@gui : Args0 = value(0:0:0:0:50:50:0)
#@gui : Args1 = value(0:0:0:0:50:50:0)
#@gui : Args2 = value(0:0:0:0:50:50:0)
#@gui : Args3 = value(0:0:0:0:50:50:0)
#@gui : Args4 = value(0:0:0:0:50:50:0)
#@gui : Args5 = value(0:0:0:0:50:50:0)
#@gui : Args6 = value(0:0:0:0:50:50:0)
#@gui : Args7 = value(0:0:0:0:50:50:0)
#@gui : Args8 = value(0:0:0:0:50:50:0)
#@gui : Args9 = value(0:0:0:0:50:50:0)
#@gui : Args10 = value(0:0:0:0:50:50:0)
#@gui : Args11 = value(0:0:0:0:50:50:0)
#@gui : Args12 = value(0:0:0:0:50:50:0)
#@gui : Args13 = value(0:0:0:0:50:50:0)
#@gui : Args14 = value(0:0:0:0:50:50:0)
#@gui : Args15 = value(0:0:0:0:50:50:0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter requires a top layer containing the desired montage layout defined as free-form shapes of different colors. You can then assign each
#@gui : layer to a layout color to create the montage.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/01/29</i>.</small>")
_fx_drawn_montage :
  nb_layers={min(16,$!-1)}

  if {!$nb_layers}
    error="A top layout layer is missing for this filter to make it work properly!"
    if $-1 gui_warning_preview $error return
    else error $error
    fi
  fi

  # Manage parameter changes.
  pargs,args0,args1,args2,args3,args4,args5,args6,args7,args8,args9,args10,args11,args12,args13,args14,args15=${9-25}
  if {$1!=$pargs} # Get back saved parameters for selected layer
    ({'${args$1}'}) replace. {':'},{','} arg_R,arg_G,arg_B,arg_zoom,arg_xcenter,arg_ycenter,arg_angle=${u\ {t}} rm.
  else # Set new parameters for selected #L
    arg_R,arg_G,arg_B,arg_zoom,arg_xcenter,arg_ycenter,arg_angle=${2-8}
  fi
  args$1=$arg_R:$arg_G:$arg_B:$arg_zoom:$arg_xcenter:$arg_ycenter:$arg_angle
  status=\{$1\}\{$arg_R,$arg_G,$arg_B\}\{$arg_zoom\}\{$arg_xcenter\}\{$arg_ycenter\}\{$arg_angle\}\{$1\}\{$args0\}\{$args1\}\{$args2\}\{$args3\}\{$args4\}\{$args5\}\{$args6\}\{$args7\}\{$args8\}\{$args9\}\{$args10\}\{$args11\}\{$args12\}\{$args13\}\{$args14\}\{$args15\}

  # Read parameters for all layers.
  c= repeat $nb_layers ({'${args$>}'}) replace. {':'},{','} R$>,G$>,B$>,zoom$>,xcenter$>,ycenter$>,angle$>=${u\ {t}} cols=$cols$c${R$>},${G$>},${B$>} c=, rm. rotate[{1+$>}] {90*${angle$>}} done

  # Get bounding boxes for each associated color in layout layer, as well as labeled layout layer.
  to_rgb[0] to_rgba[^0] $nb_layers,1,1,4,[inf,inf,-inf,-inf] [0],[0]
  f[0] "
    begin(colors = [ "$cols" ]);
    for (l = 0, l<"$nb_layers", ++l,
      I==colors[3*l,3]?(
        if (x<i(#-2,l,0,0,0), i(#-2,l,0,0,0) = x);
        if (y<i(#-2,l,0,0,1), i(#-2,l,0,0,1) = y);
        if (x>i(#-2,l,0,0,2), i(#-2,l,0,0,2) = x);
        if (y>i(#-2,l,0,0,3), i(#-2,l,0,0,3) = y);
        i(#-1,x,y) = l + 1;
      );
    ); I"

  thumbnail=0 boundaries=0
  if $-1

    # Render thumbnail of current layer, for preview.
    l={1+$1}
    if {$l<=$nb_layers}
      if {$l,w>h} +r2dx[$l] {(0$_preview_width?0$_preview_width:400)/6}
      else +r2dy[$l] {(0$_preview_height?0$_preview_height:400)/6} fi
      frame. 1,1,0,0,0,255 drgba. to. "#"$l,0,-2,13 to_rgba.
      mv. -3
      thumbnail=1
    fi

    # Render region boundaries of layout layer, for preview.
    +f. "const boundaries = 1; V = crop(x-2,y-2,5,5); if (min(V)==max(V),0,i)"
    (0,0,0,$cols) r. 3,{$nb_layers+1},1,1,-1 1,100%,1,1,y?255:0 a[-2,-1] x permute. yzcx map.. . rm.

    repeat $nb_layers
      xmin,ymin,xmax,ymax={-3,I[$>]}
      if {!isinf($xmin)" && "!isinf($ymin)" && "!isinf($xmax)" && "!isinf($ymax)}
        xc$>,yc$>={0,0.5*([$xmin,$ymin]+[$xmax,$ymax]-6)*100/[w,h]}
      else xc$>,yc$>=-1024
      fi
    done

    mv. -3
    boundaries=1
  fi

  # Render montage.
  if {iM>0}

    # Resize layers to fit proposed layout.
    repeat $nb_layers
      l={$>+1} xmin,ymin,xmax,ymax={-2,I[$>]}
      if {!isinf($xmin)" && "!isinf($ymin)" && "!isinf($xmax)" && "!isinf($ymax)}
        dx={$xmax-$xmin+1}
        dy={$ymax-$ymin+1}
        nw,nh={$l,round(min(w/$dx,h/$dy)*[$dx,$dy]/(1+3*(${zoom$>}/10)^2))}
        r[$l] $nw,$nh,1,100%,0,0,{(100-${xcenter$>})%},{(100-${ycenter$>})%}  # Centered crop
        r[$l] $dx,$dy,1,100%,6                                                # Resize
      else r[$l] 1,1 # Save a bit of memory!
      fi
    done

    # Draw image pixels over layout layer.
    to_rgba[0]
    f[0] "
      l = i#-1;
      l1 = l - 1;
      l<=0?I:(
        xmin = i(#-2,l1,0,0,0);
        ymin = i(#-2,l1,0,0,1);
        rx = x - xmin;
        ry = y - ymin;
        crop(#l,rx,ry,0,0,1,1,1,4);
      )"
  fi
  rm[-2,-1]

  # Manage preview.
  if $boundaries blend[0,-1] alpha fi # Add shape boundaries.
  if $thumbnail # Add current layer thumbnail over preview
    drgba[0] rr2d[0] ${-gui_preview_wh}
    j[0] .,3,3,0,0,0.75
    rm.
  fi
  if $-1 repeat $nb_layers
    to "#"{1+$>},${xc$>}%,${yc$>}%,13,1,0.75
  done fi


  k[0] c 0,255
  u $status

fx_drawn_montage :
  _fx_drawn_montage $*,0

fx_drawn_montage_preview :
  _fx_drawn_montage $*,1

#@gui Extract Objects : fx_extract_objects, fx_extract_objects_preview(1)
#@gui : Background Point (%) = point(0,0)
#@gui : sep = separator()
#@gui : Color Tolerance = int(20,0,256)
#@gui : Opacity Threshold (%) = int(50,0,100)
#@gui : Minimal Area = float(0.3,0,5)
#@gui : Connectivity = choice("Low","High")
#@gui : Output As = _choice(0,"Crop","Segmentation")
#@gui : sep = separator()
#@gui : Preview Guides = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/23/02</i>.</small>")
#@gui : url = link("Filter explained here","http://gimpchat.com/viewtopic.php?f=28&t=7905")
fx_extract_objects :
  if $5 min_area=$5% else min_area=6 fi
  repeat $! l[$<] to_rgba
    nm=${-gui_layer_name}
    w={w} h={h}
    x={$1%*(w-1)}
    y={$2%*(h-1)}
    color={I($x,$y)}
    if {$7==0} # Output: Crop.
      +replace_color $3,0,$color,0,0,0,0 autocrop_components. $4%,$min_area,$6,2
      repeat {w}
        +z[0] {1,i($>,0)},{1,i($>,1)},{1,i($>,3)},{1,i($>,4)}
        nm. pos({1,i($>,0)},{1,i($>,1)}),name($nm" "[$>])
      done rm[0,1]
    elif {$7==1} # Output: Segmentation.
      replace_color $3,0,$color,0,0,0,0
      +autocrop_components[0] $4%,$min_area,$6,2
      autocrop_components[0] $4%,$min_area,$6,1
      repeat {w} nm[$>] pos({i($>,0)},{i($>,1)}),name($nm" "[$>]) done rm.
    fi
    $w,$h,1,4 fc. $color nm. name($nm" [background]")
  endl done

fx_extract_objects_preview :
  x0,y0=${1,2}
  if $5 min_area=$5% else min_area=5 fi
  repeat $! l[$>] to_rgba
    x={$x0%*(w-1)}
    y={$y0%*(h-1)}
    color={I($x,$y)}
    +replace_color $3,0,$color,0,0,0,0
    autocrop_components. $4%,$min_area,$6,2
    repeat {w}
      xycoords={1,i($>,0)},{1,i($>,1)},{1,i($>,3)},{1,i($>,4)}
      rectangle[0] $xycoords,0.3,0,0,255,255
      rectangle[0] $xycoords,1,0xFFFFFFFF,0,0,0,255
    done
    drgba[0]
    to[0] {w}" objects",2,2,13,2,0.3,255,255,255,255
    k[0]
    if $8
      line 0,$y0%,100%,$y0%,0.5,0xF0F0F0F0,255 line 0,$y0%,100%,$y0%,0.5,0x0F0F0F0F,0
      line $x0%,0,$x0%,100%,0.5,0xF0F0F0F0,255 line $x0%,0,$x0%,100%,0.5,0x0F0F0F0F,0
    fi
    circle $x,$y,3,1,0,255,0 circle $x,$y,3,1,0xFFFFFFFF,0
  endl done

#@gui Grid [Cartesian] : fx_imagegrid, fx_imagegrid(0)
#@gui : X-Size = int(10,2,100)
#@gui : Y-Size = int(10,2,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_imagegrid :
  imagegrid $1,$2

#@gui Grid [Hexagonal] : fx_imagegrid_hexagonal, fx_imagegrid_hexagonal(1)
#@gui : Resolution = int(32,1,128)
#@gui : Outline = float(0.1,0,0.5)
#@gui : Anti-Aliasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/12/01</i>.</small>")
fx_imagegrid_hexagonal :
  repeat $! l[$>]
    if $3 r 200%,200%,1,100% fi
    imagegrid_hexagonal $1,$2
    if $3 r 50%,50%,1,100%,2 fi
  endl done

#@gui Grid [Triangular] : fx_imagegrid_triangular, fx_imagegrid_triangular(0)
#@gui : Pattern Width = int(10,8,128)
#@gui : Pattern Height = int(18,8,128)
#@gui : Pattern Type = choice(0,"Horizontal","Vertical","Crossed","Cube","Decreasing","Increasing")
#@gui : Outline Color = color(255,255,255,128)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/08/07</i>.</small>")
fx_imagegrid_triangular :
  repeat $! l[$>] split_opacity l[0] to_rgb
    imagegrid_triangular ${1-3},{$7/255},${4-6}
  endl a c endl done

#@gui Make Seamless [Diffusion] : fx_make_seamless, fx_make_seamless_preview(1)
#@gui : Equalize Light = float(0,0,100)
#@gui : sep = separator(),
#@gui : Preview Original = bool(0)
#@gui : Tiled Preview = choice(3,"None","2x1","1x2","2x2","3x3","4x4")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> This filter helps in converting your input pattern as a <b>seamless</b> (a.k.a periodic) texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/24/02</i>.</small>")
fx_make_seamless :
  repeat $! l[$>]
    if $1 +b {20.5-$1/50}% -[0] [1] fc. ${average_colors.} + fi
  endl done
  periodize_poisson c 0,255

fx_make_seamless_preview :
  u={arg($3,2,1,2,3,4)} v={arg($3,1,2,2,3,4)}
  gui_split_preview "if {!$2} fx_make_seamless $* fi if $3 array "$u","$v" fi",${-3--1}

#@gui Make Seamless [Patch-Based] : fx_frame_seamless, fx_frame_seamless_preview(0)
#@gui : Frame Size = int(32,0,256)
#@gui : Patch Size = int(9,3,64)
#@gui : Blend Size = int(0,0,64)
#@gui : Frame Type = choice(1,"Inner","Outer")
#@gui : Equalize Light = float(100,0,100)
#@gui : sep = separator(),
#@gui : Preview Original = bool(0)
#@gui : Tiled Preview = choice(3,"None","2x1","1x2","2x2","3x3","4x4")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> This filter helps in converting your input pattern as a <b>seamless</b> (a.k.a periodic) texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/15/12</i>.</small>")
fx_frame_seamless :
  repeat $! l[$>]
    if $5 +b {20.5-$5/50}% -[0] [1] fc. ${average_colors.} + fi
  endl done
  frame_seamless ${1-4} c 0,255

fx_frame_seamless_preview :
  u={arg($7,2,1,2,3,4)} v={arg($7,1,2,2,3,4)}
  gui_split_preview "if {!$6} fx_frame_seamless $* fi if $7 array "$u","$v" fi",${-3--1}

#@gui Ministeck : fx_ministeck, fx_ministeck_preview(1)
#@gui : Number of Colors = int(8,2,24)
#@gui : Resolution (px) = int(64,16,256)
#@gui : Piece Size (px) = int(8,1,64)
#@gui : Piece Complexity = int(2,1,10)
#@gui : Relief Amplitude = float(100,0,256)
#@gui : Relief Size = float(0.3,0,1)
#@gui : Add 1px Outline = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/14/01</i>.</small>")
fx_ministeck :
  repeat $! l[$>]
    if {w>h} r2dx {min($2,w)} else r2dy {min($2,h)} fi
    split_opacity l[0]
      +colormap. $1 index.. .
      [0],[0],1,1 rand[2] 0,1 dilate[2] $4 +[0,2]
      r[0] $3""00%,$3""00%
      +g[0] xy,1 !=[-2,-1] 0 +f[0] 'i(x+1,y+1)-i(x,y)' !=[-3--1] 0 -|[-3--1]
      z[0,-1] 0,0,{w-2},{h-2}
      if $7 . fi
      +shift. 1,1 *.. -1 +[-2,-1] b. {$6*$3/5} n. -$5,$5
      map[0] [1] rm[1] +[0,-1]
      if $7 ==[1] 0 * fi
    endl r. [0],[0],1,100% a c
  endl done
  c 0,255

fx_ministeck_preview :
  repeat $! l[$>]
    w={w} h={h}
    fx_ministeck $*
    r $w,$h,1,100%,0,0,0.5,0.5
  endl done

#@gui Montage : fx_montage, fx_montage_preview(1)
#@gui : Montage Type = choice("Auto","Custom Layout","Horizontal","Vertical","Horizontal Array","Vertical Array")
#@gui : Custom Layout = text{"V(H(0,1),H(2,V(3,4)))"}
#@gui : Merging Mode = choice(1,"Aligned","Scaled")
#@gui : Centering / Scale = float(0.5,0,1)
#@gui : Padding (px) = int(0,0,128)
#@gui : sep = separator()
#@gui : Frame (px) = int(0,0,128)
#@gui : Frame Color = color(0,0,0,255)
#@gui : sep = separator()
#@gui : Angle = float(0,0,360)
#@gui : Angle Variations = float(0,0,180)
#@gui : sep = separator()
#@gui : Cycle Layers = int(0,-255,255)
#@gui : Revert Layer Order = bool()
#@gui : Output As = _choice("Single Layer","Multiple Layers")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Instructions:</b>\n
#@gui : - Don't forget to set the <i>Input layers...</i> option on the left if you have multiple input layers for your montage.\n
#@gui : - The <i>Custom layout</i> parameter is only active when <i>Montage type</i> is set to <i>Custom layout</i>.
#@gui : This is basically a string containing expressions such as:\n
#@gui : \n     . <i>H(a,b)</i> or <i>V(a,b)</i> stand respectively for an horizontal and vertical merge of two blocks <i>a</i> and <i>b</i>.
#@gui : \n     . <i>R(a)</i>, stands for a 90-deg. rotated version of a block <i>a</i>. Use <i>RR(a)</i> and <i>RRR(a)</i> for resp. 180-deg and 270-deg. rotations.
#@gui : \n     . <i>M(a)</i>, stands for a X-mirrored version of a block <i>a</i>. Use <i>MRR(a)</i> for a Y-mirrored version of <i>a</i>.\n\n
#@gui : - A block <i>a</i> can be a layer index or a nested montage expression itself.\n
#@gui : - Layer indices start from <i>0 (top layer)</i> and are treated periodically.
#@gui : </small>"}
#@gui : url = link("Click here for a tutorial","http://blog.patdavid.net/2014/05/gmic-montage.html")
#@gui : url = link("+ video tutorial","http://www.youtube.com/watch?v=iM42vx22gwg")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/22/12</i>.</small>")
fx_montage : skip "${2=A}"
  if {!$!} return fi
  code0=X code1="$2" code2=H code3=V code4=A code5=B
  if {$3==1&&$4<0.5} r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 fi
  to_rgba if $14 rv fi if {$13%$!} mv[{$13%$!}--1] 0 fi
  if {$11||$12} repeat $! rotate[$>] {$11+u(-$12,$12)},1,0 done fi
  montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},$15,\
    "if {$""7%2} mirror x fi if {$""8%2} mirror y fi "\
    "rotate {90*$""6} "\
    "if {$5||$6} "\
    "r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 "\
    "frame $6,$6,${7-10} "\
    "r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
    "else r $""4,$""5,1,100%,2 fi "
  if $15 gui_autocrop_layers fi
  gui_set_layer_name "[Montage]"

fx_montage_preview : skip "${2=A}"
  if {!$!} return fi
  w={w} h={h}
  if {$3==1&&$4<0.5} r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 fi
  drgba
  code0=X code1="$2" code2=H code3=V code4=A code5=B
  to_rgba if $14 rv fi if {$13%$!} mv[{$13%$!}--1] 0 fi
  if {$11||$12} repeat $! rotate[$>] {$11+u(-$12,$12)},1,0 done fi
  montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},0,\
    "if {$""7%2} mirror x fi if {$""8%2} mirror y fi "\
    "rotate {90*$""6} "\
    "if {$5||$6} "\
    "  r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 fs={min(53,max(w,h)/3)} "\
    "  frame $6,$6,${7-10} "\
    "  r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
    "  0 t. \#$""1,0,0,$fs,1,255 expand_xy. 3,0 [-1]x3 a[-4--2] c dilate. {3+2*$fs/20} a.. .,c j[0] [1],{5+$5+$6},{$5+$6},0,0,1,[2],255 k[0] "\
    "else "\
    "  r $""4,$""5,1,100%,2 fs={min(53,max(w,h)/3)} "\
    "  0 t. \#$""1,0,0,$fs,1,255 expand_xy. 3,0 [-1]x3 a[-4--2] c dilate. {3+2*$fs/20} a.. .,c j[0] [1],5,0,0,0,1,[2],255 k[0] "\
    "fi "
  nw={w} nh={h}
  resize_ratio2d $w,{$h-16},2,2
  drgba
  i[0] 100%,15,1,3,240 t[0] "Estimated size : "{round(100*$nw/$w)}%" x "{round(100*$nh/$h)}%,2,0,16 r[0] 100%,16,1,3,0
  a y

#@gui Puzzle : fx_puzzle, fx_puzzle_preview(1)
#@gui : note = note("<small><b>Pattern parameters:</b></small>")
#@gui : X-Tiles = int(5,2,32)
#@gui : Y-Tiles = int(5,2,32)
#@gui : Curvature = float(0.5,0,1.5)
#@gui : Connectors Centering = float(0,0,1)
#@gui : Connectors Variability = float(0,0,2)
#@gui : sep = separator()
#@gui : note = note("<small><b>Blending parameters:</b></small>")
#@gui : Relief Smoothness = float(0.3,0,3)
#@gui : Relief Contrast = float(100,0,255)
#@gui : Outline Smoothness = float(0.2,0,3)
#@gui : Outline Contrast = float(255,0,255)
#@gui : sep = separator()
#@gui : note = note("<small><b>Recomposition parameters:</b></small>")
#@gui : Scale = float(100,0,150)
#@gui : Scale Variations = float(0,0,100)
#@gui : Angle = float(0,-180,180)
#@gui : Angle Variations = float(0,0,180)
#@gui : Shuffle Pieces = bool(0)
#@gui : Additional Outline = bool(0)
#@gui : Output Each Piece on a Different Layer = _bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/06/01</i>.</small>")
fx_puzzle :
  repeat $! l[$<]
    w={w} h={h} to_rgb
    puzzle $w,$h,$1,$2,$3,$4,$5
    +b. $6%,0 g. xy +[-2,-1] n. -$7,$7 +[0,-1]  # Relief.
    +b. $8%,0 n. 0,1 *. -1 +. 1 n. {(255-$9)/255},1 *[0,-1] c 0,255  # Outline.

    if {$10!=100||$11||$12||$13||$14||$15||$16}

      # Decompose puzzle into set of pieces.
      +-. 1 label_fg. 0
      +area_fg. 0,0 <. 50% -|... . ==. 0 *[-2,-1]
      distance.. 0 *.. -1 watershed. .. rm.. label. 0,0

      repeat {iM+1}
        +==[1] $>
        coords=${autocrop_coords.\ 0}
        +z[0] $coords z.. $coords rv[-2,-1] *.. . *. 255 a[-2,-1] c
        x$>={arg(1,$coords)+round(w/2)} y$>={arg(2,$coords)+round(h/2)}
      done
      rm[0,1]

      # Recompose puzzle.
      if $14 sort_list +,u fi

      if $16 # One piece by layer.
        repeat $! l[$<]
          r2dy {max(0.1,$10+$11*u(-1,1))}% rotate {$12+$13*u(-1,1)}
          if $15 expand_xy 1,0 fi
          cx={round(w/2)} cy={round(h/2)}
          sh 100% if $15 dilate. 3 fi
          i[0] $w,$h,1,4
          j[0] ..,{${x$<}-$cx},{${y$<}-$cy},0,0,1,.,255 rm[-2,-1]
        endl done

      else # All pieces on the same layer.
        i[0] $w,$h,1,{s}
        repeat {$!-1}
          r2dy. {max(0.1,$10+$11*u(-1,1))}% rotate. {$12+$13*u(-1,1)}
          if $15 expand_xy. 1,0 fi
          cx={round(w/2)} cy={round(h/2)}
          sh. 100% if $15 dilate. 3 fi
          j[0] ..,{${x$<}-$cx},{${y$<}-$cy},0,0,1,.,255 rm[-2,-1]
        done
      fi

    else rm.
    fi
  endl done

fx_puzzle_preview :
  fx_puzzle ${1-15},0

#@gui Taquin : fx_taquin, fx_taquin(1)
#@gui : X-Tiles = int(7,1,20)
#@gui : Y-Tiles = int(7,1,20)
#@gui : Remove Tile = choice("None","First","Last","Random")
#@gui : sep = separator()
#@gui : Relief = float(50,0,255)
#@gui : Border Thickness (%) = float(5,0,100)
#@gui : Border Outline = int(0,0,16)
#@gui : Ouline Color = color(0,0,0,255)
#@gui : sep = separator()
#@gui : Random Seed = int(0,0,65535)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/13/01</i>.</small>")
fx_taquin :
  to_a repeat $! l[$>] srand $11 taquin $1,$2,$3,$4,$5%,$6,${7-10} endl done

#@gui Tileable Rotation : fx_rotate_tileable, fx_rotate_tileable_preview(1)
#@gui : Angle = float(45,0,360)
#@gui : Maximum Size Factor = int(8,0,20)
#@gui : Array Mode = choice(0,"None","x-axis","y-axis","xy-axes","2xy-axes")
#@gui : sep = separator(), note = note("<small><b>Note:</b> This filter implements the tileable rotation technique described by <b>Peter Yu</b>, at:</small>")
#@gui : url = link("[Peter Yu] Create rotated tileable patterns","http://www.peteryu.ca/tutorials/gimp/rotate_tileable_patterns")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/26/05</i>.</small>")
fx_rotate_tileable :
  if $3 array_mirror 1,{$3-1},1 fi
  rotate_tileable $1,{if($3==0,$2,$2/2)}

fx_rotate_tileable_preview :
  l fx_rotate_tileable $*
  onfail gui_warning_preview "Invalid image size" endl

#@gui Tiled Rotation : fx_rotate_tiles, fx_rotate_tiles(1)
#@gui : X-Tiles = int(5,1,80)
#@gui : Y-Tiles = int(5,1,80)
#@gui : Angle = float(15,0,360)
#@gui : X-Shadow = float(3,-20,20)
#@gui : Y-Shadow = float(3,-20,20)
#@gui : Smoothness = float(1.8,0,5)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_rotate_tiles :
  to_rgba rotate_tiles $3,$1,$2 drop_shadow $4%,$5%,$6%

#@gui Tiled Normalization : fx_normalize_tiles, fx_normalize_tiles(1)
#@gui : X-Tiles = int(25,1,80)
#@gui : Y-Tiles = int(25,1,80)
#@gui : Minimal Value = float(0,0,255)
#@gui : Maximal Value = float(255,0,255)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_normalize_tiles :
  repeat $! l. split_tiles $1,$2 n $3,$4 append_tiles $1,$2 endl mv. 0 done

fx_normalize_tiles :
  ac "_fx_normalize_tiles ${1-4}",$-1

#@gui Tiled Random Shifts : fx_shift_tiles, fx_shift_tiles(1)
#@gui : X-Tiles = int(10,1,30)
#@gui : Y-Tiles = int(10,1,30)
#@gui : Amplitude = float(10,0,100)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_shift_tiles :
  to_rgba shift_tiles $1,$2,$3
  if {$4<1} repeat $! s. c *. $4 a[-4--1] c mv. 0 done fi

#@gui Tiled Parameterization : fx_parameterize_tiles, fx_parameterize_tiles(1)
#@gui : X-Tiles = int(10,1,30)
#@gui : Y-Tiles = int(10,1,30)
#@gui : Fitting Function = choice("Linear","Quadratic")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_parameterize_tiles :
  if $3
    quadratize_tiles $1,$2
  else
    linearize_tiles $1,$2
  fi
  c 0,255

#@gui Tiled Isolation : fx_isolate_tiles, fx_isolate_tiles(0)
#@gui : X-Size = float(10,0,100)
#@gui : Y-Size = float(10,0,100)
#@gui : X-Border = float(5,0,100)
#@gui : Y-Border = float(5,0,100)
#@gui : Keep Tiles Square = bool(1)
#@gui : Keep Borders Square = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/13/04</i>.</small>")
fx_isolate_tiles :
  repeat $! l[$>] to_rgba
    if $5 sx={round(min(w,h)*max($1,$2)/100)} sy=$sx else sx={round(w*$1/100)} sy={round(h*$2/100)} fi
    if $6 bx={max($3,$4)} by=$bx else bx=$3 by=$4 fi
    s x,-$sx
    repeat $! l[$>] s y,-$sy r 100%,{100+$by}%,1,100%,0,0,0.5,0.5 a y endl done
    r {100+$bx}%,100%,1,100%,0,0,0.5,0.5 a x
  endl done


#@gui ____<b>Artistic</b>
#-------------------------

#@gui Bokeh : fx_bokeh, fx_bokeh_preview(1)
#@gui : Number of Scales = int(3,1,10)
#@gui : Shape = choice(8,"Triangle","Square","Diamond","Pentagon","Hexagon","Octogon","Decagon","Star","Circular")
#@gui : Random Seed = int(0,0,65535)
#@gui : sep = separator(), note = note{"<small><b>Starting parameters:</b></small>"}
#@gui : Density = int(30,1,256)
#@gui : Radius (%) = float(8,0,50)
#@gui : Outline (%) = float(4,0,100)
#@gui : Inner Shade = float(0.3,0,1)
#@gui : Smoothness = float(0.2,0,8)
#@gui : Color = color(210,210,80,160)
#@gui : Color Dispersion = float(0.7,0,1)
#@gui : sep = separator(), note = note{"<small><b>Ending parameters:</b></small>"}
#@gui : Density = int(30,1,256)
#@gui : Radius (%) = float(20,0,50)
#@gui : Outline (%) = float(20,0,100)
#@gui : Inner Shade = float(1,0,1)
#@gui : Smoothness = float(2,0,8)
#@gui : Color = color(170,130,20,110)
#@gui : Color Dispersion = float(0.15,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/02/07</i>.</small>")
fx_bokeh :
  _shape=$2
  srand $3
  repeat $! l[$<] nm=${-gui_layer_name} pos=${-gui_layer_pos}
    100%,100%,1,3
    (${4-13};${14-23}) if {$1>2} r. 100%,$1,1,1,3 fi
    repeat $1
      +rows. $> _fx_bokeh... {^} rm.
    done
    rm. nm. name($nm),opacity(100),mode(screen),pos($pos)
    rv
    if {0$_output_mode==0} gui_merge_layers
    elif {0$_output_mode<2} rm.
    fi
  endl done

_fx_bokeh0 : shape_star $1,3        # Triangle.
_fx_bokeh1 : $1,$1,1,1,1             # Square.
_fx_bokeh2 : shape_diamond $1       # Diamond.
_fx_bokeh3 : shape_polygon $1,5,45  # Pentagon.
_fx_bokeh4 : shape_polygon $1,6,45  # Hexagon.
_fx_bokeh5 : shape_polygon $1,8,45  # Octogon.
_fx_bokeh6 : shape_polygon $1,10,45 # Decagon.
_fx_bokeh7 : shape_star $1,5        # Star.
_fx_bokeh8 : shape_circle $1        # Circle.

fx_bokeh_preview :
  gui_split_preview "_output_mode=0 fx_bokeh $*",${-3--1}

# [internal] Draw one step of bokeh with specified geometry on last image.
# $1=density, $2=size(in %), $3=outline(in %), $4=shade (in [0,1]), $5=smoothness (in %),
# $6,$7,$8,$9=RGBA (in [0,255]), $10 = color dispersion (in [0,1])
_fx_bokeh :
  radius1={r=max(w,h)*$2%;r+1-(r%2)}
  radius2={r=$radius1-($radius1*$3%);r+1-(r%2)}

  random3d $1 *3d. {-2,w},{-2,h},0
  _fx_bokeh$_shape $radius1
  if {$radius2>=1} _fx_bokeh$_shape $radius2 r. ..,0,0,0.5,0.5 *. {max(0,min(1,1-$4))} -[-2,-1] fi
  sigma={-3,$5%*w}
  r. {w+5*$sigma},{h+5*$sigma},1,1,0,0,0.5,0.5
  b. $sigma,0 n. 0,255
  sprites3d[1] [2],1 rm[2]
  l.
    s3d r.. 3,{-2,h/3},1,1,-1 s.. x
    d={$10*255}
    rand[-4] {$6-$d},{$6+$d}
    rand... {$7-$d},{$7+$d}
    rand.. {$8-$d},{$8+$d}
    a[-4--2] x c.. 0,255 y a y
  endl
  j3d[0] [1],0,0,0,{$9/255},1,0,0 rm[1]

#@gui Brushify : fx_brushify, fx_brushify_preview(0)
#@gui : note = note("<small><b>Brush parameters:</b></small>")
#@gui : Shape = choice(7,"Bottom layer","Top layer","Rectangle","Diamond","Pentagon","Hexagon","Octogon","Ellipse","Gaussian","Star","Heart")
#@gui : Ratio = float(0.25,0,1)
#@gui : Number of Sizes = int(4,1,16)
#@gui : Maximal Size = int(64,1,128)
#@gui : Minimal Size (%)= float(25,0,100)
#@gui : Number of Orientations = int(12,1,24)
#@gui : Fuzzyness = float(0,0,10)
#@gui : Smoothness = float(2,0,10)
#@gui : Light Type = choice(4,"None","Flat","Darken","Lighten","Full")
#@gui : Light Strength = float(0.2,0,1)
#@gui : Opacity = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Painting parameters:</b></small>")
#@gui : Density (%) = float(30,0,100)
#@gui : Contour Coherence = float(1,0,1)
#@gui : Orientation Coherence = float(1,0,1)
#@gui : Gradient Smoothness = float(1,0,10)
#@gui : Structure Smoothness = float(5,0,10)
#@gui : Primary Angle = float(0,-180,180)
#@gui : Angle Dispersion = float(0.2,0,1)
#@gui : sep = separator()
#@gui : Preview Brush = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/22/04</i>.</small>")
fx_brushify :
  _fx_brushify $*
  s0=0--3 s1=1--2 s2=0--2
  l[${s{$1==0?0:$1==1?1:2}},-1] brushify[^-1] .,$3,{$5%},$6,$9,$10,$11,$12%,$13,$14,$15,$16,$17,$18 rm. endl

_fx_brushify : # Insert brush at the end of the list
  N={0.9*$4}
  if {$1==0} +autocrop. i.. 100%,100%,1,3,1 blend[-2,-1] alpha rr2d. $N,$N,0,3
  elif {$1==1} +autocrop[0] i.. 100%,100%,1,3,1 blend[-2,-1] alpha rr2d. $N,$N,0,3
  elif {$1==2} $4,$4 rectangle. 10%,10%,90%,90%,1,1
  elif {$1==3} shape_diamond. $N
  elif {$1==4} shape_polygon $N,5
  elif {$1==5} shape_polygon $N,6
  elif {$1==6} shape_polygon $N,8
  elif {$1==7} shape_circle. $N
  elif {$1==8} $4,$4 gaussian. 30%,30%,0
  elif {$1==9} shape_star $N
  elif {$1==10} shape_heart $N
  fi
  norm. r. 100%,{max(0.01,100*$2)}%,1,1,2 r. $4,$4,1,1,0,0,0.5,0.5
  spread. $7 b. $8% n. 0,1

fx_brushify_preview :
  if {$1<2" && "$!<2}
    gui_error_preview "When a custom brush (bottom or top layer) is specified, at least two layers are required for this filter to work.In this case, don't forget to set the 'Input layers' option!"
    return
  fi
  fx_brushify $*
  if $19
    _fx_brushify $*
    if {$1==0} rm.. elif {$1==1} rm[0] fi
    rr2d. {0,max(1,w/5)},{0,max(1,h/5)},0,2 n. 0,255
    frame. 3,3,0 frame. 1,1,255 frame. 1,1,0
    to_rgb. to. "Brush",4,2,13,2,1,255,255,0 to_a.
    j[^-1] .,2,2 rm.
  else
    if {$1==0} rm. elif {$1==1} rm[0] fi
  fi

#@gui Cartoon : cartoon, fx_cartoon_preview(0)
#@gui : Smoothness = float(3,0,10)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge Threshold = float(20,1,30)
#@gui : Edge Thickness = float(0.25,0,1)
#@gui : Color Strength = float(1.5,0,3)
#@gui : Color Quantization = int(8,2,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_cartoon_preview :
  gui_split_preview "cartoon $*",${-3--1}

#@gui Circle Abstraction : fx_circle_abstraction, fx_circle_abstraction_preview(1)
#@gui : Number of Colors = int(8,2,16)
#@gui : Density = int(5,1,100)
#@gui : Opacity = float(0.8,0,1)
#@gui : Smoothness = float(0,0,4)
#@gui : Filled Circles = bool(1)
#@gui : Fill Transparent Holes = bool(1)
#@gui : Normalize Colors = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/16/06</i>.</small>")
fx_circle_abstraction :
  repeat $! l[$>]
    b $4%
    +colormap $1 index[0] [1],0,0
    [0],[0],1,4,0

    repeat $1
      rprogress {$>*100/$1}
      +==[0] $>
      skeleton3d. 2,2,0,1,0
      if {@7} # Process only non empty objects.
        s3d. l[-6--1]
          r[2] 3,{2,h/3},1,1,-1
          1,{2,h/2*$2%},1,1,1 r. 1,{2,h/2},1,1,4 r. 3,200% *[2,-1] y
        endl
        a[-6--1] y col3d. {1,I($>)}

        [0],[0],1,4,0
        j3d. ..,0,0,0,1,{1+$5},0,0
        sh. 3 col3d... 255 j3d. ...,0,0,0,$3,{1+$5},0,0 rm.
        rm..
        blend[2,-1] alpha
      fi
    done
    k[2]
    if $6 +channels 3 <. 1 inpaint[0] [1],0,1 rm. channels. 0,2 fi
    if $7 n 0,255 fi
    rprogress 100
  endl done

fx_circle_abstraction_preview :
  gui_split_preview "fx_circle_abstraction $*",${-3--1}

#@gui Cubism : fx_cubism, fx_cubism_preview(1)
#@gui : Iterations = int(2,0,10)
#@gui : Density = float(50,0,200)
#@gui : Thickness = float(10,0,50)
#@gui : Angle = float(90,0,360)
#@gui : Opacity = float(0.7,0.01,1)
#@gui : Smoothness = float(0,0,5)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/05/06</i>.</small>")
fx_cubism :
  repeat $1 cubism ${2--1} done

fx_cubism_preview :
  gui_split_preview "fx_cubism $*",${-3--1}

#@gui Cutout : fx_cutout, fx_cutout_preview(1)
#@gui : Number of Levels = int(4,2,32)
#@gui : Edge Simplicity = float(0.5,0,3)
#@gui : Edge Fidelity = int(4,0,10)
#@gui : Normalize = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Garagecoder</i>.      Latest Update: <i>2014/03/06</i>.</small>")
fx_cutout :
  repeat $! l[$>] split_opacity l[0]
    median {10-$3}
    quantize $1
    +area. 0,1 med=${-med} rm.
    inpaint_holes {$med*$2%},0,1
    if $4 n 0,255 fi
  endl a c endl done

fx_cutout_preview :
  gui_split_preview "fx_cutout $*",${-3--1}

#@gui Diffusion Tensors : fx_diffusiontensors, fx_diffusiontensors_preview(0)
#@gui : Resolution (%) = float(10,0,20)
#@gui : Size = float(5,0,16)
#@gui : Color Mode = choice(3,"Monochrome","Grayscale","Orientation","Color")
#@gui : Outline = int(1,0,16)
#@gui : sep = separator()
#@gui : Sharpness = float(0.15,0,1)
#@gui : Anisotropy = float(1,0,1)
#@gui : Gradient Smoothness = float(0,0,10)
#@gui : Tensor Smoothness = float(3,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/19/10</i>.</small>")
fx_diffusiontensors :
  repeat $! l[$>]
    wh={[w,h]}
    +diffusiontensors ${5-8}
    r2dx. $1%
    dt. {round(125/$1)},$2,{$3<3?$3:0},$4
    if {$3==3}
      remove_opacity.. r.. .,.,1,100%,3 blend[0] [1],shapeaverage0 dilate. {1+2*$4} a c
    else k. fi
    r. $wh,1,100%,2
  endl done

fx_diffusiontensors_preview :
  gui_split_preview "fx_diffusiontensors $*",${-3--1}

#@gui Ellipsionism : fx_ellipsionism, fx_ellipsionism_preview(0)
#@gui : Primary Radius = float(20,1,100)
#@gui : Secondary Radius = float(10,1,100)
#@gui : Smoothness = float(0.5,0,10)
#@gui : Opacity = float(0.7,0,1)
#@gui : Outline = float(3,1,3)
#@gui : Density = float(0.5,0.1,2)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_ellipsionism :
  ellipsionism ${^0}

fx_ellipsionism_preview :
  gui_split_preview "fx_ellipsionism $*",${-3--1}

#@gui Felt Pen : fx_feltpen, fx_feltpen_preview(0)
#@gui : Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(1,0,10)
#@gui : Opacity = float(0.1,0,1)
#@gui : Edge = float(20,0,100)
#@gui : Thickness = int(5,2,32)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/25/10</i>.</small>")
fx_feltpen :
  repeat $! l[$>] +fx_hardsketchbw ${1-5},0,0 blend hardlight erode_oct $6 endl done

fx_feltpen_preview :
  gui_split_preview "fx_feltpen $*",${-3--1}

#@gui Fractalize : fractalize, fractalize(1)
#@gui : Detail Level = float(0.8,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Note:</b> This filter uses lot of random values to generate its result, so running it twice will give you different results !</small>")
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=10036")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/25/04</i>.</small>")

#@gui Hard Sketch : fx_hardsketchbw, fx_hardsketchbw_preview(0)
#@gui : Amplitude = float(300,0,4000)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(1,0,10)
#@gui : Opacity = float(0.1,0,1)
#@gui : Edge = float(20,0,100)
#@gui : Fast Approximation = bool(0)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_hardsketchbw :
  b $3
  if {$7==4} repeat $! l[$>] +hardsketchbw $1,$2,$4,$5,$6 blend hardlight endl done return fi
  hardsketchbw $1,$2,$4,$5,$6
  if {$7&1} negate fi
  if {$7==2} r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
  elif {$7==3} r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
  fi

fx_hardsketchbw_preview :
  gui_split_preview "fx_hardsketchbw $*",${-3--1}

#@gui Highlight Bloom : fx_highlight_bloom, fx_highlight_bloom_preview(0)
#@gui : Details Strength (%) = float(90,0,400)
#@gui : Details Scale = float(60,0,255)
#@gui : Smoothness = float(60,0,255)
#@gui : Highlight (%) = int(30,0,100)
#@gui : Contrast (%) = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/24/10</i>.</small>")
#@gui : sep = separator(), note = note("This effect has been inspired by:")
#@gui : url = link("This tutorial by Sebastien Guyader and Patrick David","https://pixls.us/articles/highlight-bloom-and-photoillustration-look/")
fx_highlight_bloom :
  repeat $! l[$>] split_opacity l[0]
    +smooth $2,0.3,0.8,1,2
    -.. .
    amp=$3 do smooth. {min(50,$amp)},0.1,1,1,2 amp-=50 while {$amp>0}
    +retinex. 16,lab,0,15 j.. .,0,0,0,0,{$4%} rm.
    ac. "normalize_local {$5%},5",lab_l
    *.. {$1%}
    + c 0,255
  endl a c endl done

fx_highlight_bloom_preview :
  gui_split_preview "fx_highlight_bloom $*",${-3--1}

#@gui Hope Poster : fx_poster_hope, fx_poster_hope_preview(0)+
#@gui : Gamma = float(0,-3,3)
#@gui : Smoothness = float(3,0,20)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/07/11</i>.</small>")
fx_poster_hope :
  repeat $! l[$>] split_opacity l[0]
    apply_gamma {10^$1} poster_hope $2
  endl a c endl done

fx_poster_hope_preview :
  gui_split_preview "fx_poster_hope $*",${-3--1}

#@gui Hough Sketch : fx_houghsketchbw, fx_houghsketchbw_preview(0)
#@gui : Smoothness = float(1.25,0,10)
#@gui : Density = float(10,0,70)
#@gui : Radius = int(5,0,30)
#@gui : Threshold = float(80,0,100)
#@gui : Opacity = float(0.1,0,1)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/18/05</i>.</small>")
fx_houghsketchbw :
  b $1 n 0,255
  if {$6==4} repeat $! l[$>] +houghsketchbw ${2-5} blend hardlight endl done return fi
  houghsketchbw ${2-5}
  if {$6&1} negate fi
  if {$6==2} r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
  elif {$6==3} r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
  fi

fx_houghsketchbw_preview :
  gui_split_preview "fx_houghsketchbw $*",${-3--1}

#@gui Kuwahara : fx_kuwahara, fx_kuwahara_preview(0)
#@gui : Iterations = int(2,1,20)
#@gui : Radius = int(5,1,30)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/31/05</i>.</small>")
fx_kuwahara :
  ac "repeat $1 kuwahara $2 done",$3,$4

fx_kuwahara_preview :
  gui_split_preview "fx_kuwahara $*",${-3--1}

#@gui Linify : fx_linify, fx_linify_preview(0)
#@gui : Density = float(40,0,100)
#@gui : Spreading = float(2,0,10)
#@gui : Resolution (%) = float(40,0,100)
#@gui : Line Opacity = float(10,0,30)
#@gui : Line Precision = int(24,1,128)
#@gui : Color Mode = choice(0,"Subtractive","Additive")
#@gui : sep = separator(), Preview Progression While Running = _bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<b>Note:</b>\n\n
#@gui : - This filter is our own implementation of the nice algorithm proposed on the webpage
#@gui : <a href="http://linify.me">http://linify.me</a>.\n
#@gui : - This is a quite resource-demanding filter, so please be patient when running it.\n
#@gui : - It actually renders better when applied on small images (&lt;1024).
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/11/21</i>.</small>")
fx_linify :
  repeat $! l[$>]
    if $7 _debug=1 w ${-fitscreen\ {[w,h]}},0,"[Preview] G'MIC: Linify" fi
    linify $1,$2,$3%,$4,$5,$6
  endl done

fx_linify_preview :
  if {!${"-gui_check_version 216"}} return fi
  gui_split_preview "fx_linify ${1-6},0",${-3--1}

#@gui Lylejk's Painting : fx_lylejk_painting, fx_lylejk_painting_preview(0)
#@gui : Iterations = int(10,1,20)
#@gui : Abstraction = int(2,1,20)
#@gui : Radius = int(4,1,30)
#@gui : Canvas = float(10,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/23/02</i>.</small>")
#@gui : url = link("Filter Explained here","http://www.gimpchat.com/viewtopic.php?f=10&t=2624")
fx_lylejk_painting :
  repeat $! l[$>]
    nm={0,n}
    +l repeat $1 b 0.75 unsharp 0.75,10.49 c 0,255 mv. 0 done endl
    smooth. 300,0.26,1,0,7
    . rv[-3--1]
    blend[-2,-1] lighten,0.5
    blend[-2,-1] grainmerge,1
    fx_kuwahara. $2,$3,0,0
    texturize_canvas. $4,4
    nm $nm
  endl done

fx_lylejk_painting_preview :
  gui_split_preview "fx_lylejk_painting $*",${-3--1}

#@gui Painting : fx_painting, fx_painting_preview(0)+
#@gui : Abstraction = int(5,1,10)
#@gui : Details Scale = float(2.5,0,5)
#@gui : Color = float(1.5,0,4)
#@gui : Smoothness = float(50,0,1000)
#@gui : Sharpen Shades = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i>, <i>Angelo Lama</i> and <i>David Tschumperl&#233;</i>.\nLatest Update: <i>2011/28/02</i>.</small>")
fx_painting : skip ${4=0},${5=0}
  repeat $! l[$>]
    to_colormode {max(3,s)} split_opacity rv
    repeat $1 fx_normalize_local. 10,6,5,20,1,11 done
    fx_smooth_anisotropic. {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
    fx_mix_lab. 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
    if $5 fx_segment_watershed. 10,1,0 fi
    smooth. $4,0,1,1,1
    rv a c
  endl done

fx_painting_preview :
  gui_split_preview "fx_painting $*",${-3--1}

#@gui Pen Drawing : fx_pen_drawing, fx_pen_drawing_preview(0)+
#@gui : Amplitude = float(10,0,30)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_pen_drawing :
  drawing $1

fx_pen_drawing_preview :
  gui_split_preview "fx_pen_drawing $*",${-3--1}

#@gui Polygonize [Delaunay] : fx_polygonize_delaunay, fx_polygonize_delaunay_preview(0)
#@gui : Density (%) = float(40,0,100)
#@gui : Edges = float(5,0,100)
#@gui : Boundaries (%) = float(75,0,100)
#@gui : Smoothness = float(0.5,0,8)
#@gui : Filling = choice(3,"Black","White","Random","Average","Linear")
#@gui : Outline (%) = float(50,0,100)
#@gui : Outline Color = color(0,0,0,255)
#@gui : Anti-Aliasing = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/06/05</i>.</small>")
fx_polygonize_delaunay :
  repeat $! l[$>] to_rgba
    wh={[w,h]} if $11 r 150%,150%,1,100%,3 fi

    # Compute Delaunay triangulation.
    mM={[im,iM]} b $4 n $mM
    +to_rgb. gradient_norm. ge. $2 f. "!x || !y || x==w-1 || y==h-1?(u^0.25<$3%):(u^0.25<$1%?i:0)" {is+1},1,1,2 f.. ">begin(p = 0); i?(I[#-1,++p] = [x,y];p):0"
    delaunay..

    # Render filling.
    if {$5==4} # Linear
      +f[0] 0 f... "*i?(
        p = I(#1); P0 = I[#2,p[0]]; P1 = I[#2,p[1]]; P2 = I[#2,p[2]];
        W = solve([P0[0],P1[0],P2[0],P0[1],P1[1],P2[1],1,1,1],[x,y,1]);
        I(#-1) = cut(W[0]*I(#0,P0) + W[1]*I(#0,P1) + W[2]*I(#0,P2),0,255);
      );I"
    elif {$5==3} # Average
      +f[0] 0 f... "*i?(
        p = I(#1); P0 = I[#2,p[0]]; P1 = I[#2,p[1]]; P2 = I[#2,p[2]];
        I(#-1) = (I(#0,P0) + I(#0,P1) + I(#0,P2))/3;
      );I"
    elif {$5==2} # Random
      +norm[1] label_fg. 0 {iM+1},1,1,3 rand. 0,255 to_rgba. point. 0 map.. . rm.
    else # Black or white
      +norm[1] !=. 0 *. 255 channels. -3,0
      if $5 sh. 0,2 f. 255 rm. fi
    fi
    rm[0,2]

    # Render outlines.
    if $6
      norm[0] f[0] "i!=j(1) || i!=j(0,1)" # thinning[0] 1
      +fc. ${7-10} j.. .,0,0,0,0,{$6%},... rm.
    fi

    k.
    if $11 r $wh,1,100%,2 fi

  endl done

fx_polygonize_delaunay_preview :
  gui_split_preview "fx_polygonize_delaunay $*",${-3--1}

#@gui Polygonize [Energy] : fx_polygonize, fx_polygonize_preview(0)
#@gui : Amplitude = int(300,0,2000)
#@gui : Smoothness = float(10,0,100)
#@gui : Minimal Area = float(10,0,100)
#@gui : X-Resolution = float(10,1,256)
#@gui : Y-Resolution = float(10,1,256)
#@gui : Outline Color = color(0,0,0,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=9174")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/02/12</i>.</small>")
fx_polygonize :
  polygonize $1,$2,{$3^2},$4,$5
  if $9 repeat $! l[$>]  # has outline.
    +norm g. xy,1 !=[-2,-1] 0 -|[-2,-1] r. 100%,100%,1,4
    replace_color. 0,0,1,1,1,1,$6,$7,$8,$9
    blend alpha
  endl done fi

fx_polygonize_preview :
  gui_split_preview "fx_polygonize $*",${-3--1}

#@gui Poster Edges : fx_poster_edges, fx_poster_edges_preview(0)
#@gui : Image Smoothness = float(20,0,100)
#@gui : Edge Threshold = float(60,0,100)
#@gui : Edge Shade = float(5,0,30)
#@gui : Edge Thickness = float(0,0,5)
#@gui : Edge Antialiasing = float(10,0,100)
#@gui : Posterization Level = int(0,0,15)
#@gui : Posterization Antialiasing = float(0,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.davidrevoy.com/article147/gmic-new-filter-poster-edges")
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>David Revoy</i>.      Latest Update: <i>2012/30/11</i>.</small>")
fx_poster_edges :
  if $1 bilateral 10,$1 fi
  poster_edges ${2-7}

fx_poster_edges_preview :
  gui_split_preview "fx_poster_edges $*",${-3--1}

#@gui Posterize : fx_posterize, fx_posterize_preview(0)
#@gui : Smoothness = float(150,0,800)
#@gui : Edges (%) = float(30,0,100)
#@gui : Paint = float(1,0,10)
#@gui : Colors = int(12,2,32)
#@gui : Minimal Area = int(0,0,64)
#@gui : Outline (%) = float(0,0,100)
#@gui : Normalize Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/25/10</i>.</small>")
fx_posterize :
  repeat $! l[$>] split_opacity l[0]
    . amp=$1 do smooth. {min(50,$amp)},{$2%},1,$3,{2*$3} amp-=50 while {$amp>0}
    bilateral.. .,5,10 rm.
    srgb2rgb +colormap $4 rgb2srgb
    index.. .,0,0
    if $5 +area.. 0,0 <. $5 inpaint... .,0,3 rm. fi
    map.. . rm.
    if $6 +norm (0,1,0;1,1,1;0,1,0) +dilate.. . rm.. -[-2,-1] !=. 0 100%,100%,1,{0,s} j... .,0,0,0,0,{$6%},.. rm[-2,-1] fi
    if $7 n 0,255 fi
  endl a c endl done

fx_posterize_preview :
  gui_split_preview "fx_posterize $*",${-3--1}

#@gui Quadtree Variations : fx_quadtree, fx_quadtree_preview(1)
#@gui : Mode = choice("Squares","Sierpinksi Design","Ellipse Painting")
#@gui : Precision = int(1024,2,4096)
#@gui : Homogeneity = float(0.5,0,2)
#@gui : Outline = int(0,0,4)
#@gui : sep = separator()
#@gui : note = note{"<small><b>For 'Ellipse painting' only:</b></small>"}
#@gui : Primary Radius = float(3,0,5)
#@gui : Secondary Radius = float(1.5,0,5)
#@gui : Anisotropy = float(1,0,4)
#@gui : Only Leafs = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/15/06</i>.</small>")
fx_quadtree :
  mode,precision,homogeneity,outline,radius1,radius2,anisotropy,only_leafs=${1-8}
  m "_qt : sh 3 u {w>1&&h>1?iv*(w*h)^"$homogeneity":-0.1} k[0]" # Function used to split quads
  repeat $! l[$>]
    to_rgb

    # Decompose image with quadtree.
    keep_only_leafs={$mode!=2" || "$only_leafs}
    +norm. a c
    _qt ({d=max(w,h);[0,0,d-1,d-1]},0,${})
    repeat $precision
      +columns. 100% n={yM} rm.
      x0,y0,x1,y1,level={crop(0,$n,5,1)}
      xc={round(($x1+$x0)/2)} yc={round(($y1+$y0)/2)}
      xc1,yc1={[$xc,$yc]-1}
      level1={$level+1}
      B0=$x0,$y0,$xc1,$yc1 +crop[0] $B0,3 _qt. B0.=,$level1,${} rm.
      B1=$xc,$y0,$x1,$yc1 +crop[0] $B1,3 _qt. B1.=,$level1,${} rm.
      B2=$x0,$yc,$xc1,$y1 +crop[0] $B2,3 _qt. B2.=,$level1,${} rm.
      B3=$xc,$yc,$x1,$y1 +crop[0] $B3,3 _qt. B3.=,$level1,${} rm.
      if $keep_only_leafs
        sh. $n,$n,0,0 f. $B0 rm.
        ($B1;$B2;$B3) a[-2,-1] y # Insert new leafs
      else
        =. -1,5,$n # Mark as not terminal leaf anymore
        ($B0;$B1;$B2;$B3) a[-2,-1] y # Insert new leafs
      else
      fi
    done
    shift. 2,0,0,0,2 sort. +,y levelmax={i(0,h-1)} shift. -2,0,0,0,2 # Sort by quadtree level order

    # Estimate data average in each quad.
    channels[0] 0,2 +structuretensors[0] a[0,-1] c
    r. {w+6},100%,1,1,0
    repeat {h}
      x0,y0,x1,y1={crop(0,$>,4,1)}
      +crop[0] $x0,$y0,$x1,$y1,3 r. 1,1,1,100%,2 y. x
      j.. .,{-2,w-6},$> rm.
    done

    # Synthetize image.
    permute. cyzx
    channels[0] 0,3 f[0] 0

    if {$mode==0} # Squares
      f. ">
        rectangle(ind,P0,P1,opacity,color) = (
          _P0 = P0;
          _P2 = P1;
          _P1 = [ _P2[0], _P0[1] ];
          _P3 = [ _P0[0], _P2[1] ];
          polygon(#ind,4,_P0,_P1,_P2,_P3,opacity,color);
        );
        begin(colo = [ 0,0,0,255 ]);
        P = I;
        Xpp = P[0,2];
        Xnn = P[2,2];
        col = [ P[6,3],255 ];
        if ("$outline"<=0,
          rectangle(#0,Xpp,Xnn,1,col);
        _(else),
          rectangle(#0,Xpp,Xnn,1,colo);
          rectangle(#0,Xpp + "$outline",Xnn - "$outline",1,col);
        );
        I"

    elif {$mode==1} # Sierpinski design
      f. ">
        P = I;
        Xpp = P[0,2];
        Xnn = P[2,2];
        Xnp = [ Xnn[0],Xpp[1] ];
        Xpn = [ Xpp[0],Xnn[1] ];
        col1 = [ P[6,3],255 ];
        col2 = [ P[6,3],64 ];
        T = [ P[9],P[10],P[10],P[11] ];
        eig = eig(T);
        angle = atan2(eig[5],eig[4])*180/pi;
        if ((angle>=0 && angle<90) || angle<-90,
          polygon(#0,3,Xpp,Xnp,Xnn,1,col1);
          polygon(#0,3,Xpp,Xnn,Xpn,1,col2);
        _(else),
          polygon(#0,3,Xnp,Xnn,Xpn,1,col1);
          polygon(#0,3,Xnp,Xpp,Xpn,1,col2)
        );
        I"

    else # Ellipse painting
      f. ">
        begin(colo = [ 0,0,0,255 ]);
        P = I;
        Xpp = P[0,2];
        Xnn = P[2,2];
        Xcc = (Xpp + Xnn)/2;
        R = (Xnn[0] - Xpp[0])/2;
        col = [ P[6,3],255 ];
        r = "$radius2"*R;
        R*="$radius1";
        T = [ P[9],P[10],P[10],P[11] ];
        eig = eig(T);
        anisotropy = (1 + eig[1])/(1 + eig[0]);
        r*=anisotropy^"$anisotropy";
        angle = atan2(eig[5],eig[4])*180/pi;
        if ("$outline">0, ellipse(#0,Xcc,R,r,angle,1,colo));
        ellipse(#0,Xcc,R - "$outline",r - "$outline",angle,1,col);
        I"
      if {!$outline} sh[0] 100% if {!im} solidify[0] 10% fi fi
    fi
    k[0]
  endl done
  uncommand _qt

fx_quadtree_preview :
  gui_split_preview "fx_quadtree $*",${-3--1}

#@gui Rodilius : fx_rodilius, fx_rodilius_preview(1)
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(5,2,36)
#@gui : Offset = float(30,0,180)
#@gui : Smoothness = int(0,0,5)
#@gui : Color Mode = choice(1,"Darker","Lighter")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=RC07VUpzwGc")
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Rod/GimpChat</i>.      Latest Update: <i>2013/05/03</i>.</small>")
fx_rodilius :
  ac "rodilius ${1-5,7} repeat $6 smooth 10,0,1,1,1,0.8,45 sharpen 30 done c 0,255",$8,$9

fx_rodilius_preview :
  gui_split_preview "fx_rodilius $*",${-3--1}

#@gui Shapeism : fx_shapeism, fx_shapeism_preview(0)+
#@gui : Shape = choice(2,"Squares","Triangles","Circles","Diamond","Hexagon","Octagon","Stars","Custom")
#@gui : Branches = int(7,3,16)
#@gui : Thickness = float(0.38,0,1)
#@gui : Angle = float(0,0,360)
#@gui : note = note("<small><b>Note:</b> Parameters <i>Branches</i>, <i>Thickness</i> and <i>Angle</i> are used only for <i>Custom</i> shapes.</small>")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator()
#@gui : Scales = int(5,1,16)
#@gui : Maximal Size = int(32,1,256)
#@gui : Minimal Size = int(8,1,256)
#@gui : Allow Angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gui : Spacing = int(1,-5,5)
#@gui : Precision = int(5,1,10)
#@gui : Edges = float(0.5,0,2)
#@gui : Smoothness = float(1,0,10)
#@gui : Background = color(0,0,0,255)
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=7500&sid=5b483979826903b8f8fc8fdaf1767dae")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/11/06</i>.</small>")
fx_shapeism :
  repeat $! l[$>]
    to_rgb
    +gradient_norm b. $13% ^. $12 quantize. $6,0,0
    100%,100%,1,2
    repeat $6

      # Create map of possible locations.
      +channels[2] 100% +>[1] $> !=.. 0 -|[-2,-1] a[2,-1] c

      # Create shape at given scale.
      size={if($6<=1,$7,$7+($8-$7)*$>/($6-1))}
      if {$size<1} break fi
      if $5 {2*$size},{2*$size} _fx_shapeism$1. ${2-4} r2dy. $size
      else $size,$size _fx_shapeism$1. ${2-4}
      fi
      +!=. 0 expand_xy[-2,-1] 1,0 n[-2,-1] 0,1
      if {$10<1} dilate. 3 fi
      . a[-3--1] c

      # Pack sprites for given scale
      rprogress "pack_sprites[-2,-1] 1,100,$9,$10,$11",{$>*100/$6},{($>+1)*100/$6}
      channels. 0,1

    done

    rprogress 97
    rm[1]
    channels. 0 +!=. 0 blend[0,-1] shapeaverage0 *[1] 255 a c
    i[0] 100%,100%,1,4 fc[0] $14,$15,$16,$17
    blend alpha
    rprogress 100
  endl done

fx_shapeism_preview :
  gui_print_preview ""
  50%,50% _fx_shapeism$1. ${2-4} frame. 1,1,0 >=. 50% n. 0,255 r. 100%,100%,1,4
  r. [0],0,0,0.5,0.5 -|

_fx_shapeism0 : # Square
  f 255 skip $*

_fx_shapeism1 : # Triangle
  polygon 3,50%,0,0,100%,100%,100%,1,1 skip $*

_fx_shapeism2 : # Circle
  shape_circle {w} rm.. skip $*

_fx_shapeism3 : # Diamond
  shape_diamond {w} rm.. skip $*

_fx_shapeism4 : # Hexagon
  star3d 3,1 *3d. {0,min(w,h)/2} j3d[0] .,50%,50%,0,1,2,0 k[0] skip $*

_fx_shapeism5 : # Octogon
  star3d 4,1 *3d. {0,min(w,h)/2} j3d[0] .,50%,50%,0,1,2,0 k[0] skip $*

_fx_shapeism6 : # Star
  star3d 5 *3d. {0,min(w,h)/2} j3d[0] .,50%,50%,0,1,2,0 k[0] skip $*

_fx_shapeism7 : # Custom
  star3d $1,$2 *3d. {0,min(w,h)/2} r3d. 0,0,1,$3 j3d[0] .,50%,50%,0,1,2,0 k[0]

#@gui Sharp Abstract : fx_sharp_abstract, fx_sharp_abstract_preview(0)
#@gui : Spatial Scale = float(4,0,32)
#@gui : Value Scale = float(10,0,16)
#@gui : Precision = float(0.5,0,2)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/09</i>.</small>")
fx_sharp_abstract :
  ac "rolling_guidance ${1-3}",$4

fx_sharp_abstract_preview :
  gui_split_preview "fx_sharp_abstract $*",${-3--1}

#@gui Sketch : fx_sketchbw, fx_sketchbw_preview(0)
#@gui : Number of Orientations = int(3,1,16)
#@gui : Starting Angle = float(45,0,180)
#@gui : Angle Range = float(180,0,180)
#@gui : Stroke Length = float(30,0,1000)
#@gui : Contour Threshold = float(1.75,0,10)
#@gui : Opacity = float(0.02,0,0.3)
#@gui : Background Intensity = float(0.5,0,2)
#@gui : Density = float(0.75,0,5)
#@gui : Sharpness = float(0.1,0,1)
#@gui : Anisotropy = float(0.7,0,1)
#@gui : Smoothness = float(3,0,10)
#@gui : Coherence = float(6,0,10)
#@gui : Boost Stroke = bool(0)
#@gui : Curved Stroke = bool(1)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/05/11</i>.</small>")
fx_sketchbw :
  if {$15==4} repeat $! l[$>] +sketchbw ${1-14} blend hardlight endl done return fi
  sketchbw ${1-14}
  if {$15&1} negate fi
  if {$15==2} r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
  elif {$15==3} r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
  fi

fx_sketchbw_preview :
  gui_split_preview "fx_sketchbw $*",${-3--1}

#@gui Smooth Abstract : fx_smooth_abstract, fx_smooth_abstract_preview(0)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(0,"Isotropic","Delaunay-oriented","Edge-oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Geometry = float(1,0,5)
#@gui : Details = float(30,0,50)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/06/04</i>.</small>")
fx_smooth_abstract :
  repeat $! l[$>] split_opacity l[0]
    srgb2rgb
    mM={[im,iM]} +b $4 n. $mM gradient_norm. <=. {50-$5}
    inpaint_diffusion[0] [1],$1%,$2,$3 rm.
    rgb2srgb c 0,255
  endl a c endl done

fx_smooth_abstract_preview :
  gui_split_preview "fx_smooth_abstract $*",${-3--1}

#@gui Vector Painting : fx_vector_painting, fx_vector_painting_preview(1)
#@gui : Details = float(9,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.\nLatest Update: <i>2015/25/08</i>.</small>")
fx_vector_painting :
  repeat $! l[$>]
    +luminance b. {10-$1}%,1,1
    f. "dmax = -1; nmax = 0;
        for (n = 0, ++n<=8,
          p = arg(n,-1,0,1,-1,1,-1,0,1);
          q = arg(n,-1,-1,-1,0,0,1,1,1);
          d = (j(p,q,0,0,0,1) - i)^2;
          if (d>dmax,dmax = d; nmax = n,nmax)
        )"
    blend shapeaverage
  endl done

fx_vector_painting_preview :
  gui_split_preview "fx_vector_painting $*",${-3--1}

#@gui Warhol : warhol, warhol(1)
#@gui : X-Tiles = int(3,1,10)
#@gui : Y-Tiles = int(3,1,10)
#@gui : Smoothness = float(2,0,10)
#@gui : Color = float(40,0,60)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Whirl Drawing : fx_draw_whirl, fx_draw_whirl_preview(0)
#@gui : Amplitude = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_draw_whirl :
  repeat $! l[$>] split_opacity draw_whirl[0] $* a c endl done

fx_draw_whirl_preview :
  gui_split_preview "fx_draw_whirl $*",${-3--1}

#@gui ____<b>Black &amp; White</b>
#---------------------------------

#@gui Black &amp; White : fx_blackandwhite, fx_blackandwhite_preview(1)+
#@gui : Red Level = float(0.299,0,1)
#@gui : Red Smoothness = float(0,0,10)
#@gui : Green Level = float(0.587,0,1)
#@gui : Green Smoothness = float(0,0,10)
#@gui : Blue Level = float(0.114,0,1)
#@gui : Blue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator()
#@gui : Grain (Shadows) = float(0,0,200)
#@gui : Grain (Midtones) = float(0,0,200)
#@gui : Grain (Highlights) = float(0,0,200)
#@gui : Grain Tone Fading = float(2,0,10)
#@gui : Grain Scale = float(0,0,3)
#@gui : Grain Type = choice("Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui : sep = separator()
#@gui : Local Contrast = float(0,0,60)
#@gui : Radius = int(16,1,512)
#@gui : Contrast Smoothness = float(4,0,10)
#@gui : sep = separator()
#@gui : Pseudo-Gray Dithering = int(0,0,5)
#@gui : Use Maximum Tones = bool(false)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/20/02</i>.</small>")
fx_blackandwhite :
  repeat $!
    l. split_opacity rv to_rgb. s. c      # Isolate opacity
    *... $1 b... $2%                      # Red level + smoothness
    *.. $3 b.. $4%                        # Green level + smoothness
    *. $5 b. $6%                          # Blue level + smoothness
    +[-3--1] /. {$1+$3+$5} c. 0,255       # (R,G,B) -> B&W
    adjust_colors ${7-11},0,255
    if {$12||$13||$14}
      100%,100% [-1]x2                          # Create noise for shadows, midtones and highlights.
      noise... 100,$17 b... $16% n... -$12,$12  # Scaled grain on shadows.
      noise.. 100,$17 b.. $16% n.. -$13,$13     # Scaled grain on midtones.
      noise. 100,$17 b. $16% n. -$14,$14        # Scaled grain on highlights.
      +tones[-4] 3 b[-3--1] $15%                # Get smoothed tones.
      *[-6,-3] *[-4,-2] *[-2,-1]                # Get noisy tones.
      +[-4--1] c. 0,255                         # Compose them with the B&W image.
    fi
    rv a c endl mv. 0 done                      # Re-compose opacity and loop to next image.
  if $18 normalize_local $18,$19,$20,2%,1,0,255 fi
  if $22 n 0,255 fi
  if $21 to_pseudogray $21,1 fi

fx_blackandwhite_preview :
  gui_split_preview "fx_blackandwhite $*",${-3--1}

#@gui B&amp;W Stencil : fx_stencilbw, fx_stencilbw_preview(0)
#@gui : Threshold = float(10,0,30)
#@gui : Smoothness = float(10,0,30)
#@gui : Hue = float(0,0,360)
#@gui : Saturation = float(0,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_stencilbw :
  stencilbw $1,$2
  if {$3||$4} repeat $! l[$>] split_opacity
    /[0] 255 i[0] 100%,100%,1,1,$4 i[0] 100%,100%,1,1,$3 a[0-2] c hsv2rgb[0]
  a c endl done fi

fx_stencilbw_preview :
  gui_split_preview "fx_stencilbw $*",${-3--1}

#@gui Charcoal : fx_charcoal, fx_charcoal_preview(0)
#@gui : Granularity = int(65,0,800)
#@gui : Lowlights Crossover Point = int(70,0,255)
#@gui : Highlights Crossover Point = int(170,0,255)
#@gui : Boost Contrast = bool(0)
#@gui : Resize Image for Optimum Effect = bool(1)
#@gui : Add Chalk Highlights = bool(0)
#@gui : Minimal Highlights = int(50,0,255)
#@gui : Maximal Highlights = int(70,0,255)
#@gui : Background Color = color(255,255,255)
#@gui : Foreground Color = color(0,0,0)
#@gui : Invert Background / Foreground = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/17/03</i>.</small>")
#@gui : note = note("<small>Inspired from the Charcoal script by <i>micomicon</i> :</small>")
#@gui : url = link("http://registry.gimp.org/node/25078")
fx_charcoal :
  repeat $! l[$>] split_opacity l[0]
    compose_channels max
    w={w} h={h}
    if $5 r. 150%,150%,1,1,6 fi
    if $4 equalize. n. 0,255 fi
    sharpen {$1*3} cut 0,255
    if $6 +ir $7,$8 fi  # Add highlights layer if required.
    ir[0] $2,$3
    if {!$15} ==[0] 0 fi
    -|
    +*[0] $10 +*[0] $11 *[0] $9
    a[-3--1] c replace_color 0,0,0,0,0,$12,$13,$14
    r $w,$h,1,100%,2
  endl a c endl done

fx_charcoal_preview :
  gui_split_preview "fx_charcoal $*",${-3--1}

#@gui Colorize [Interactive] : fx_colorize_interactive, fx_colorize_interactive_preview
#@gui : Input Type = _choice("B&amp;W Photograph","Lineart")
#@gui : Output Type = _choice{"Colorized Image (1 Layer)","Colors Only (1 Layer)","Image + Colors (2 Layers)","Image + Colors (Multi-Layers)"}
#@gui : View Resolution = _choice{1,"Small (Faster)","Medium","High (Slower)","Very High (Even Slower)"}
#@gui : 1st Additional Palette (.gpl) = _filein()
#@gui : 2nd Additional Palette (.gpl) = _filein()
#@gui : Image to Grab Color from (.png) = _filein()
#@gui : sep = separator()
#@gui : note = note{"<small><b>Description:</b>\n
#@gui : This filter allows to quickly colorize a B&amp;W image or lineart.
#@gui : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the G'MIC interactive window and start adding color control points.
#@gui : When you're done, exit the interactive window: your colored result will be transferred back to the host software.\n\n
#@gui : If you are not satisfied with the result, <i>Undo it (CTRL+Z)</i>, and click on <i>Apply</i> once again to modify your control points defined previously.
#@gui : To clear all control points, click on the <i>Reset</i> button above.
#@gui : </small>"}
#@gui : Clear Control Points = button(0.5)
#@gui : Last Image Size = value(0,0)
#@gui : Control Points = value(-1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive window to manage your colorization :\n\n
#@gui : - <b>Left mouse button</b> creates a new color control point (or move an existing one).\n
#@gui : - <b>Right mouse button</b> or key <b>X</b> over a control point deletes it.\n
#@gui : - <b>Right mouse button</b> or key <b>P</b> anywhere else picks a color from the image.\n
#@gui : - <b>Mouse wheel</b>, or keys <b>CTRL+arrows up/down</b> zoom view in/out.\n
#@gui : - <b>CTRL+mouse wheel</b>, <b>SHIFT+wheel</b> or arrow keys move image in zoomed view.\n
#@gui : - Key <b>SPACE</b> updates the extrapolated color field.\n
#@gui : - Key <b>TAB</b> toggles markers view modes.\n
#@gui : - Key <b>BACKSPACE</b> deletes the last control point added.\n
#@gui : - Key <b>PAGE UP</b> increases image contrast.\n
#@gui : - Key <b>PAGE DOWN</b> decreases image contrast.\n
#@gui : - Key <b>R</b> enters/exits color replace mode.\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> resets window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>You can find more information on how to use this filter here :</small>")
#@gui : url = link("David Revoy's G'MIC Colorization Page","http://www.davidrevoy.com/article240/gmic-line-art-colorization")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/12/07</i>.</small>")
fx_colorize_interactive : skip "${4=},${5=},${6=}"
  N=$! nm={n}
  resolution={arg(1+$3,512,1024,2048,0)}
  nm "[G"{`39`}"MIC] Colorize"
  if {$9==-1" || "$8!=w" || "$9!=h} _gui_control_points= else _gui_control_points=${10--1} fi
  N=$!

  arg_palette1=0 l[] 0 nm. "$4" ext={x} rm if {same(['$ext'],'gpl',-1,0)} input_gpl "$4" arg_palette1=1 fi onfail rm endl if $arg_palette1 arg_palette1=[{$!-1}] fi
  arg_palette2=0 l[] 0 nm. "$5" ext={x} rm if {same(['$ext'],'gpl',-1,0)} input_gpl "$5" arg_palette2=1 fi onfail rm endl if $arg_palette2 arg_palette2=[{$!-1}] fi
  arg_grabber=0 l[] 0 nm. "$6" ext={x} rm i "$6" to_rgb arg_grabber=1 onfail rm endl if $arg_grabber arg_grabber=[{$!-1}] fi

  repeat $N
    status=${x_colorize[$>]\ $1,$resolution,$2,$arg_palette1,$arg_palette2,$arg_grabber}
  done
  k[0-{$N-1}]

  if {$2==1} repeat $! l[$<] # Output : colors only (1 layer).
      channels {s-3},{s-1}
    endl done
  elif {$2>=2} repeat $! l[$<] # Output : Lineart + Colors (2 layers).
      +channels {s-3},{s-1} channels.. 0,{0,s-4}
    endl done
    if {$2>=3} split_colors[1] 0,256,8 fi # Split colors into layers.
  fi
  nm $nm
  if {!narg($status)} status=-1 fi
  u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{"$6"\}\{0\}\{{w},{h}\}\{$status\}

fx_colorize_interactive_preview : skip "${4=},${5=},${6=}"
  if $7  # Clear control points.
    gui_print_preview "No preview\n  available",,"(Control points cleared)"
    u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{"$6"\}\{0\}\{{w},{h}\}\{-1\}
  else gui_no_preview ,
  fi

#@gui Colorize [Photographs] : fx_recolorize, fx_recolorize_preview(1)
#@gui : Smoothness = int(2,0,6)
#@gui : Anisotropy = float(0.2,0,1)
#@gui : Output Mode = choice("Merge Brightness / Colors","Split Brightness / Colors")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter needs two layers to work properly. The bottom layer must be a B&amp;W image, while the
#@gui : top layer contains color patches that will be extrapolated in a smart way (edge-directed) to fill the entire image. At the end,
#@gui : you get a completely recolored image.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/16/01</i>.</small>")
fx_recolorize :
  repeat {int($!/2)}
    if $3 s=$>,{$>+1} else s={2*$>},{2*$>+1} fi
    l[$s] rv[0,1]
      channels[0] 0 to_rgb.. # Convert to pure gray.
      to_rgba. split_opacity. !=. 0  # Retrieve mask of color patches.
      srgb2rgb[-3,-2] rgb2lab8[-3,-2] channels... 0 channels.. 1,2 # Now, list is [0]=lightness / [1]=chroma / [2]=mask.
      +.. 1 *.. . +gradient_norm... *. -1 watershed... . rm. -.. 1 # Get first estimate for the color interpolation.
      +diffusiontensors... $2,1,0.5,0.5 ==.. 0 *. .. rm..
      smooth.. .,{$1*80},0.8,60 rm.
      a[-2,-1] c lab82rgb. rgb2srgb.
      if $3 rgb2hsv. s. c i[2] 100%,100%,1,1,1 i[3] 100%,100%,1,2,0 a[0-2] c a[^0] c hsv2rgb rv fi
    endl
  done

fx_recolorize_preview :
  fx_recolorize $* a x

#@gui Colorize [with Colormap] : fx_bwrecolorize, fx_bwrecolorize_preview
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Normalize Input = bool(0)
#@gui : sep = separator()
#@gui : Gradient Preset = choice("User-Defined","Black to White","White to Black","Sepia","Solarize")
#@gui : Interpolation Type = choice(1,"Nearest","Linear","Cubic","Lanczos")
#@gui : Preserve Initial Brightness = bool(0)
#@gui : sep = separator(), note = note("<small><u>User-defined gradient :</u></small>")
#@gui : Number of Tones = int(5,2,8)
#@gui : 1st Tone = color(0,0,0,255)
#@gui : 2nd Tone = color(43,25,55,255)
#@gui : 3rd Tone = color(158,137,189,255)
#@gui : 4th Tone = color(224,191,228,255)
#@gui : 5th Tone = color(255,255,255,255)
#@gui : 6th Tone = color(255,255,255,255)
#@gui : 7th Tone = color(255,255,255,255)
#@gui : 8th Tone = color(255,255,255,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_bwrecolorize :
  remove_opacity
  if $4 n 0,255 fi
  if {$5==0}  # User-defined gradient
    (${9--2}) r. 4,$8,1,1,-1 permute. yzcx
  elif {$5==1} # Black to white
    (0,255^0,255^0,255^255,255)
  elif {$5==2} # White to black
    (255,0^255,0^255,0^255,255)
  elif {$5==3} # Sepia
    (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200^255,255,255,255,255,255)
  else         # Solarize
    (0,359^1,1^1,1^255,255) r. 256,1,1,4,3 sh. 0,2 hsv2rgb. rm.
  fi
  if {$6==0} r. 256,1,1,4,1
  elif {$6==1} r. 256,1,1,4,3
  elif {$6==2} r. 256,1,1,4,5 c. 0,255
  else r. 256,1,1,4,6
  fi
  if {$7==1} sh. 0,2 rgb2hsv. sh. 2 f. x/w hsv2rgb.. rm[-2,-1] fi
  l[^-1] luminance adjust_colors ${1-3} endl map[^-1] . rm.

fx_bwrecolorize_preview :
  gui_split_preview "fx_bwrecolorize ${^0}",${-3--1}

#@gui Colorize Lineart [Auto-Fill] : fx_autofill_lineart, fx_autofill_lineart_preview(0)
#@gui : Contour Threshold (%) = float(90,0,100)
#@gui : Contour Normalization = bool(1)
#@gui : Minimal Region Area = int(8,0,256)
#@gui : Tolerance to Gaps = int(0,0,10)
#@gui : Preview Type = choice("Lineart + Colors","Colors Only")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/12/11</i>.</small>")
fx_autofill_lineart :
  repeat $! l[$>] nm=${-gui_layer_name}

    # Format input lineart to expected format.
    is_alpha={s==2||s==4}
    if $is_alpha sh 100% is_alpha={im<128&&iM>128} rm. fi # Check is alpha-channel contains lineart
    if $is_alpha +channels 100% negate.
    else +norm fi
    n. 0,255
    l.

      # Start multi-scale filling.
      repeat {1+$4}
        fact={2^-$<}
        nw={0,max(1,round(w*$fact))}
        nh={0,max(1,round(h*$fact))}
        +r[0] $nw,$nh,1,1,2 if $2 normalize_local. , fi +>=. {min(99.5,$1)}%

        if $colors
          scale2x[colors] r[colors] .,1 *[colors,-1] rv[-2,-1]
        fi

        label_fg. 0,1 b.. 0.8 watershed. .. rm.. nm. colors
      done

      # Inpaint regions that are too small.
      +area. 0,1 label_maxarea={"P=[xM,yM];i(#-2,P)-1"}
      if {$3>1}
        >. {$3*sqrt($3)} *[-2,-1]
        b.. 0.8 watershed. ..
      else
        rm.
      fi
      rm..

      # Colorize regions.
      N={iM}
      if $N
        -. 1
        srand 0 {iM+1},1,1,3,">[j(-1) + u(135,225),u(0,0.7),u(0.4,0.9)]"
        hsv2rgb. round. point. $label_maxarea,0,0,1,255
        map.. . rm.
      fi
    endl

    # Format output layers.
    if {!$is_alpha} gui_set_layer_mode.. multiply fi
    gui_set_layer_name. $nm" [colors]"
  endl done

fx_autofill_lineart_preview :
  repeat $! l[$>]
    fx_autofill_lineart ${1-4}
    if $5 k. else rv blend multiply fi
  endl done

#@gui Colorize Lineart [Smart Coloring] : fx_colorize_lineart_smartcoloring, fx_colorize_lineart_smartcoloring_preview(0)
#@gui : Colorize Mode = choice("Generate Random-Colors Layer","Extrapolate Color Spots on Transparent Top Layer","Auto-Clean Bottom Color Layer")
#@gui : sep = separator(), note = note{"<small><b>Global geometry parameters:</b></small>"}
#@gui : Contour Detection (%) = float(95,0,100)
#@gui : Discard Contour Guides = bool(0)
#@gui : note = note{"<small>Add strokes with a saturated color having value 255 (e.g. pure red) on your lineart allows to guide the colorization algorithm with virtual contours.</small>"}
#@gui : Output Region Delimiters = _bool(0)
#@gui : sep = separator(), note = note{"<small><b>For <i>Random colors</i> mode only:</b></small>"}
#@gui : Make Hue Depends on Region Size = float(1,0,1)
#@gui : Maximal Color Saturation = int(24,0,255)
#@gui : Minimal Color Intensity = int(200,0,255)
#@gui : sep = separator(), note = note{"<small><b>For <i>color spots</i> mode only:</b></small>"}
#@gui : Color Shading (%) = int(0,0,100)
#@gui : sep = separator(), note = note{"<small><b>Connection parameters:</b></small>"}
#@gui : End Point Rate (%) = float(75,0,100)
#@gui : End Point Connectivity = int(2,1,5)
#@gui : Spline Max Length (px) = float(60,0,256)
#@gui : Segment Max Length (px) = float(20,0,256)
#@gui : Spline Max Angle (deg) = float(90,0,180)
#@gui : Spline Roundness = float(1,0,2)
#@gui : Minimal Region Area = float(10,0,100)
#@gui : Allow Self Intersections = bool(1)
#@gui : sep = separator(), Preview Type = choice(0,"Colored geometry","Colored regions","Colored lineart")
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>, <i>S&#233;bastien Fourey</i> and <i>David Revoy</i>.      Latest Update: <i>2018/11/09</i>.</small>")
fx_colorize_lineart_smartcoloring :
  _fx_colorize_lineart_smartcoloring $*,-1 round

fx_colorize_lineart_smartcoloring_preview :
  if {$1==1" && "$!<2} gui_warning_preview "A top layer with color spots is missing, for this colorization mode." return
  elif {$1==2" && "$!<2} gui_warning_preview "A bottom color layer is missing, for this colorization mode." return
  fi
  _fx_colorize_lineart_smartcoloring ${1-3},0,${5--1}

_fx_colorize_lineart_smartcoloring :
  if {$1==1" && "$!<2} error "A top layer with color strokes is missing, for this colorization mode."
  elif {$1==2" && "$!<2} error "A bottom color layer is missing, for this colorization mode."
  fi
  min_color_area={$15^2}

  repeat {$1?1:$!} inds=${arg\ 1+!!$1,$<,0--1} l[$inds]

    ind_lineart={$1==1?1:0}
    nm=${gui_layer_name[$ind_lineart]} nm[$ind_lineart] lineart

    if {$!>1} ind_colors={$1==1?0:1} nmc={$ind_colors,n} nm[$ind_colors] colors fi
    if {$!>=3} rm[2--1] fi # Delete old color and added contour layers if any

    # Constrain input lineart to be a binary, single channel image.
    [lineart]
    is_alpha={s==2||s==4}
    if $is_alpha sh. 100% is_alpha={iM-im>64} rm. fi
    if $is_alpha channels. 100%
    else luminance. negate. fi
    >. {255*(1-$2%)}
    nm. strokes

    # Retrieve closed binary shape.
    _keep_keycoords={$-1==0}
    [strokes] close_binary. ${9-14},$min_color_area,$16 nm. new_strokes

    if {$-1==0} # Render estimated geometry
      +negate[strokes] *. 255 to_rgb.
      +-[new_strokes] [strokes] dilate. 2
      100%,100%,1,3,[0,128,255] j... .,0,0,0,0,1,.. rm[-2,-1]
      if {narg($keycoords)} f[keycoords] "ellipse(#-1,(I)[0,2],3,3,0,1,[255,0,0]);I" rm[keycoords] fi
      nm. geometry
    fi

    # Label color regions and inpaint strokes.
    if {$1==1} # Mode: Color spots-guided colorization
      to_rgba[$colors] [colors],[colors]
      f[colors] "i(#-1) = A<255?0:norm(R,G+0.3,B+0.6);I"
      label_fg. 0 {1+iM},1,1,{colors,s+1}
      f.. ">I[#-1,i]+=[ I(#"$colors"),1 ];I"
      s. c,{-s+1} /[-2,-1]
      +l[new_strokes] * -1 + 1 +b 1% b.. 1 min endl
      watershed... .,0 rm. map.. . rm.

      if {!$8} rm[strokes] # No color shading
      else # Shade colors
        j[strokes] [new_strokes] distance[strokes] 0 *[strokes] -1
        eq[new_strokes] 0 label_fg[new_strokes] 0,0
        if $min_color_area +area_fg[new_strokes] 0,0 >. $min_color_area *[new_strokes,-1] fi
        watershed[new_strokes] [strokes],0 rm[strokes]
        srgb2rgb. guided. [new_strokes],{1+$8/5},0 rgb2srgb.
      fi
      rm[new_strokes]
      nm. new_colors

    elif {$1==2} # Mode: Clean color layer
      j[strokes] [new_strokes] distance[strokes] 0 *[strokes] -1
      eq[new_strokes] 0 label_fg[new_strokes] 0,0
      if $min_color_area +area_fg[new_strokes] 0,0 xy_bg={[xM,yM]} >. $min_color_area *[new_strokes,-1] fi
      watershed[new_strokes] [strokes],0 rm[strokes]
      to_color[colors] sh[colors] 0,2 rgb2hsv8. rm. blend[colors,new_strokes] shapemedian sh[colors] 0,2 hsv82rgb. rm.
      nm[colors] new_colors

    else # Mode: Random colorization
      j[strokes] [new_strokes] distance[strokes] 0 *[strokes] -1
      eq[new_strokes] 0 label_fg[new_strokes] 0,0
      if $min_color_area +area_fg[new_strokes] 0,0 xy_bg={[xM,yM]} >. $min_color_area *[new_strokes,-1] fi
      watershed[new_strokes] [strokes],0 rm[strokes]
      label[new_strokes] 0,0
      +histogram[new_strokes] {new_strokes,[iM+1,0,iM]} equalize. 1024 n. 0,240
      ind_bg={xM}
      channels. 0,2 srand 0
      f. "[i,u(1,max(3,$6))/255,u(min(252,$7),255)/255]"
      . sh. 0 rand. 0,360 rm.
      hsi2rgb[-2,-1] *.. $5 *. {1-$5} +[-2,-1] round.
      point. $ind_bg,0,0,1,255 point. 0,0,0,1,255

      map[new_strokes] . rm.
      nm[new_strokes] new_colors
    fi

    # Final rendering
    ind_lineart=$lineart
    ind_colors=$new_colors

    if $4 # Output region delimiters
      100%,100%,1,1,"const boundary = 1; J(#"$new_colors",1)!=I(#"$new_colors") || J(#"$new_colors",0,1)!=I(#"$new_colors")"
      *. 255 channels. -3,0 sh. 0,2 fc. 255,0,0 rm.
      gui_set_layer_name. $nm" [region delimiters]"
      mv. {$lineart+1}
    fi
    if {!narg($nmc)} gui_set_layer_name[$ind_colors] $nm" [colors]" fi
    gui_set_layer_name[$ind_lineart] $nm

    if {$-1==-1} # Rendering : Lineart and color layers
      if {!$is_alpha} gui_set_layer_mode[$ind_lineart] multiply fi

      if $3 l[0] # Discard contour guides
        if $is_alpha
          100%,100%,1,3,255 blend. [0],alpha,1 rgb2hsv. channels. 2 *. 255 negate.
          channels.. 0,{0,s-2} s={0,s} luminance[0] to_colormode[0] $s a c
        else
          s={s} to_rgb rgb2hsv channels 2 * 255 to_colormode $s
        fi
      endl fi

    elif {$-1==0} # Preview : Colored geometry
      if {$is_alpha} channels[$ind_lineart] 100% negate[$ind_lineart] fi to_rgb[$ind_lineart]
      n[$ind_lineart] 180,255
      blend[$ind_lineart,$ind_colors] multiply
      +select_color[geometry] 0,255,255,255 ==. 0 j[$ind_lineart] [geometry],0,0,0,0,1,. k[$ind_lineart]
    elif {$-1==1} # Preview : Colored regions
      k[$ind_colors]
    else # Preview : Colored lineart
      if {$is_alpha} channels[$ind_lineart] 100% negate[$ind_lineart] fi to_rgb[$ind_lineart]
      if $3 l[$ind_lineart] s={s} to_rgb rgb2hsv channels 2 * 255 to_colormode $s endl fi
      blend[$ind_lineart,$ind_colors] multiply k[$ind_lineart]
    fi

  endl done

#@gui Colorize Lineart [Propagation] : fx_colorize_lineart, fx_colorize_lineart_preview(1)
#@gui : note = note("<b>Layers ordering:</b>")
#@gui : Input Layers = choice{0,"Color Spots + Lineart","Lineart + Color Spots","Color Spots + Extrapolated Colors + Lineart","Lineart + Color Spots + Extrapolated Colors"}
#@gui : Output Layers = _choice{1,"Single (Merged)","Extrapolated Colors + Lineart","Lineart + Extrapolated Colors","Color Spots + Extrapolated Colors + Lineart","Lineart + Color Spots + Extrapolated Colors"}
#@gui : Extrapolate Colors As = choice("One Layer","Two Layers","Three Layers","Four Layers","Five Layers","Six Layers","Seven Layers","Eight Layers","Nine Layers","Ten Layers","One Layer per Single Color","One Layer per Single Region")
#@gui : sep = separator()
#@gui : Smoothness = float(0.05,0,1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> You probably need to select <i>All</i> for the <i>Input layers</i> option on the left.\n
#@gui : <i>Color Spots</i> = your layer with color indications.\n
#@gui : <i>Lineart</i> = your layer with line-art (b&amp;w or transparent).\n
#@gui : <i>Extrapolated Colors</i> = the G'MIC generated layer with flat colors.\n\n
#@gui : <b>Warnings:</b>
#@gui : \n  - Do not rely too much on the preview, it is probably not accurate !
#@gui : \n  - Activate option <i>Extrapolate color as one layer per single color/region</i> only if you have <i>a lot</i> of available memory !
#@gui : </small>"}
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://www.gimpchat.com/viewtopic.php?f=28&t=7567")
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>, <i>Timoth&#233;e Giet</i> and <i>David Revoy</i>.      Latest Update: <i>2013/19/06</i>.</small>")
fx_colorize_lineart :
  if {$!<2} return fi
  if {$1<2} selection=0,1 else selection=0,1,2 fi
  l[$selection]

    # Format input layers.
    if {$1==0}              # Color strokes + drawing
    elif {$1==1} rv        # Drawing + color strokes
    elif {$1==2} rm[1]     # Color strokes + extrapolated colors + drawing
    elif {$1==3} rm[2] rv # Drawing + color strokes + extrapolated colors.
    fi

    # Here we have only 'color strokes + drawing' -> process.
    +to_rgba[0] split_opacity. +.. 1 !=. 0 *[-2,-1]   # Map of color labels to spread.
    +norm[1] n. 0,1 +histogram. 2,0,1
    if {i(0)>i(1)} *.. -1 +.. 1 fi rm.          # Determine color model of the drawing.
    b. $4% watershed.. . rm.                         # Priority map.
    -. 1
    # Here we have 'color strokes + drawing + extrapolated colors'.

    # Format output layers.
    if {$2==0} rm[0] rv blend[0,1] multiply ind=-1
    elif {$2==1} rm[0] rv ind=0
    elif {$2==2} rm[0] ind=1
    elif {$2==3} rv[1,2] ind=1
    elif {$2==4} rv[0,1] ind=2
    fi

    # Separate extrapolated colors as multiple layers.
    if {$3&&$ind>=0} l[$ind]
      +mix_channels (65536,256,1)
      if {$3==10} do  # Split by colors.
        iM={1,iM}
        if {$iM>=0}
          +==[1] $iM area={is} replace[1] $iM,-1
          +r. 100%,100%,1,3 *. [0]
          rv[-2,-1] *. 255 a[-2,-1] c nm. $area
        fi
      while {$iM>=0} else  # Split by disconnected regions.
        label.
        if {$3<10} %. {$3+1} fi
        repeat {iM+1} +==[1] $< area={is} +r. 100%,100%,1,[0] *. [0] rv[-2,-1] *. 255 a[-2,-1] c nm. $area done
      fi
      rm[0,1]
      sort_list +,n
    endl fi

  endl

fx_colorize_lineart_preview :
  fx_colorize_lineart $1,0,$3,$4

#@gui Dithering : fx_ditheredbw, fx_ditheredbw_preview(0)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue = float(0,0,360)
#@gui : Saturation (%) = float(0,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_ditheredbw :
  repeat $! l[$>] split_opacity l[0]
    luminance  adjust_colors ${1-3} b $6
    ditheredbw
    if {$4" || "$5} / 255 i[0] 100%,100%,1,2 fc[0] $4,{$5%} a c hsv2rgb fi
  endl a c endl done

fx_ditheredbw_preview :
  gui_split_preview "fx_ditheredbw $*",${-3--1}

#@gui Engrave : fx_engrave, fx_engrave_preview(0)
#@gui : note = note("<small><b>Black &amp; White foreground:</b></small>")
#@gui : Radius = float(0.5,0,2)
#@gui : Density = float(50,0,200)
#@gui : Edges = float(0,0,10)
#@gui : Coherence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal Area = int(0,-256,256)
#@gui : Flat Regions Removal = float(0,0,10)
#@gui : sep = separator(), note = note("<small><b>Color background:</b></small>")
#@gui : Add Color Background = bool()
#@gui : Quantization = float(10,0,40)
#@gui : Shading = int(1,0,5)
#@gui : Hue = float(0,-180,180)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Lightness (%) = float(0,-100,100)
#@gui : sep = separator()
#@gui : Anti-Aliasing = choice(1,"Disabled","x1.5","x2","x3")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>03/13/2015</i>.</small>")
fx_engrave :
  f={arg(1+$14,1,1.5,2,3)}
  r={$f*(0.2+$1)}
  repeat $! l[$<]
    nm=${-gui_layer_name} pos=${-gui_layer_pos}
    if $8 [0] fi  # Keep copy for color background.
    l[0] split_opacity l[0]
      wh={w},{h}
      norm
      if $14 r {100*$f}%,{100*$f}%,1,1,3 fi
      if {$7>0} [0] fi  # Keep copy for flat regions removal.
      l[0]
        amount={(0.5+$2)^2}
        repeat 5 b $r unsharp $r,{1+$2} c 0,255 done
        smooth 100,0.1,1,{$f*$3},{$f*$4}
        >= {100-$5}%
      endl
      if {$7>0} # Flat region removal.
        gradient_norm[1] b[1] $3 <[1] $7 max[0,1]
      fi
      if {$6<0} area_fg 0,0 > {$f*$6*$6}
      elif {$6>0} == 0 area_fg 0,0 > {$f*$6*$6} == 0
      fi
      * 255
      if $14 r $wh,1,1,2 fi
    endl a c endl

    # Process color background.
    if {$!>1}
      l[1] split_opacity l[0]
        f={arg(1+$14,1,1.5,2,3)}
        if $14 r {100*$f}%,{100*$f}%,1,100%,3 fi
        b {$f*$9} segment_watershed 5
        if $14 r $wh,1,100%,2 fi
        repeat $10 guided 10,{$10*80} done
        rgb2hsv s c +... $11 +.. {$12%} +. $13% a c hsv2rgb
      endl a c endl
      nm[0] mode(darken),name($nm),pos($pos)
      nm[1] name($nm" [colors]"),pos($pos)
    fi

 endl done

fx_engrave_preview :
  repeat $! l[$<]
    gui_split_preview "nm foo fx_engrave $* gui_merge_layers",${-3--1}
  endl done

#@gui Freaky B&amp;W : fx_freaky_bw, fx_freaky_bw_preview
#@gui : Strength (%) = float(90,0,100)
#@gui : Oddness (%) = float(20,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/30/09</i>.</small>")
fx_freaky_bw :
  repeat $! l[$>] split_opacity l[0]
    to_rgb

    # Estimate gradient field of B&W result.
    +expand_xy 1,0 channels. 0,4
    f. ">if (c!=4,i,
          Rx = i(x+1,y,0,0) - i(x,y,0,0);
          Ry = i(x,y+1,0,0) - i(x,y,0,0);
          Rn = Rx^2 + Ry^2;
          Gx = i(x+1,y,0,1) - i(x,y,0,1);
          Gy = i(x,y+1,0,1) - i(x,y,0,1);
          Gn = Gx^2 + Gy^2;
          Bx = i(x+1,y,0,2) - i(x,y,0,2);
          By = i(x,y+1,0,2) - i(x,y,0,2);
          Bn = Bx^2 + By^2;
          n = 1e-5 + max(Rn,Gn,Bn)^"{$2%}";
          val = 0;
         if (Rn>=Gn && Rn>=Bn,
           i(x,y,0,3) = Rx/n; val=Ry/n,
         if (Gn>=Rn && Gn>=Bn,
           i(x,y,0,3) = Gx/n; val=Gy/n,
           i(x,y,0,3) = Bx/n; val=By/n));
         val
        )"
    channels. 3,4
    luminance[0] ia={0,ia}

    # Estimate laplacian of final image and invert it.
    s. c
    f.. "i - i(x-1,y,0,0)"
    f. "i - i(x,y-1,0,0)"
    +[-2,-1]
    ilaplacian. 0
    shrink_xy. 1 +. $ia n. 0,255

    # Merge result with original color image.
    j[0] [1],0,0,0,0,{$1%} rm.
    adjust_colors ${3-5}
  endl a c endl done

fx_freaky_bw_preview :
  gui_split_preview "fx_freaky_bw $*",${-3--1}

#@gui Ink Wash : fx_ink_wash, fx_ink_wash(0)
#@gui : note = note("Ink wash controls")
#@gui : Size = float(0.14,0,4)
#@gui : Amplitude = float(23,0,200)
#@gui : sep = separator()
#@gui : note = note("Check if you wish visual control on this step")
#@gui : Skip All Other Steps = bool(false)
#@gui : note = note ("UNcheck to reactivate the other controls")
#@gui : sep = separator()
#@gui : Smoother Sharpness = float(0.5,0,2)
#@gui : Smoother Edge Protection = float(0.54,0,1)
#@gui : Smoother Softness = float(2.25,0,10)
#@gui : sep = separator()
#@gui : Stretch Contrast = choice("None","Automatic","Automatic &amp; Contrast Mask","Manual Controls")
#@gui : note = note ("To activate the sliders below chose 'Manual Controls'")
#@gui : sep = separator()
#@gui : LN Amplitude = float(2,0,60)
#@gui : LN Size = float(6,0,64)
#@gui : LN Neightborhood-Smoothness = float(5,0,40)
#@gui : LN Average-Smoothness = float(20,0,40)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest Update: <i>2011/05/04</i>.</small>")
#@gui : url = link(0,"Forum thread about the filter discussion","http://gimpchat.com/viewtopic.php?f=10&t=914")
fx_ink_wash :
  repeat $! l[$>] split_opacity l[0]
    fx_pencilbw. $1,$2,0,0,0
    if {$3==1} continue
    elif {$3==0} fx_smooth_anisotropic. 60,$4,$5,$6,1.1,0.8,30,2,0,1,1,0,1,16
    fi
    if {$7==1} normalize_local. 2,6,5,24,1,0,255
    elif {$7==2} normalize_local. 2,6,5,24,1,0,255 fx_contrast_swm 2,0,0.512
    elif {$7==3} fx_normalize_local. $8,$9,$10,$11,1,3,0
    fi
  endl a c endl done

#@gui Pencil : fx_pencilbw, fx_pencilbw_preview(0)
#@gui : Size = float(0.3,0,5)
#@gui : Amplitude = float(60,0,200)
#@gui : Hue = float(0,0,360)
#@gui : Saturation = float(0,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/05/03</i>.</small>")
fx_pencilbw :
  pencilbw $1,$2
  if {$3||$4} repeat $! l[$>] split_opacity
    /[0] 255 i[0] 100%,100%,1,1,$4 i[0] 100%,100%,1,1,$3 a[0-2] c hsv2rgb[0]
  a c endl done fi

fx_pencilbw_preview :
  gui_split_preview "fx_pencilbw $*",${-3--1}

#@gui Pencil Portrait : fx_pencil_portraitbw, fx_pencil_portraitbw_preview(0)
#@gui : Stroke Length = float(30,0,500)
#@gui : Stroke Angle = float(120,0,180)
#@gui : Contour Threshold = float(1,0,10)
#@gui : Opacity = float(0.5,0,1)
#@gui : Color = color(144,79,21)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Jamac4k</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_pencil_portraitbw :
  repeat $! l[$>] split_opacity l[0]
    +b 2%
    +blend divide rm.. luminance.
    fx_ink_wash.. 0,167,0,0.5,0.54,2.25,0,2,6,5,20
    +fx_hardsketchbw. 80,32,1.89,0.21,31.46,0,0
    +fx_sketchbw.. 1,$2,180,$1,$3,0.03,0,0.6,0.1,0.6,0.25,1,0,1,0
    blend[0,1] darken
    blend[0,1] multiply,0.5
    blend[0,1] lighten,$4
    normalize_local ,
    to_rgb +fc ${5-7} blend softlight
  endl a c endl done

fx_pencil_portraitbw_preview :
  gui_split_preview "fx_pencil_portraitbw $*",${-3--1}

#@gui Stamp : fx_stamp, fx_stamp_preview(0)
#@gui : Auto-Threshold = bool(1)
#@gui : Threshold = int(50,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Sharpening = float(0,0,30)
#@gui : Grain = float(0,0,100)
#@gui : Negative = bool()
#@gui : Anti-Aliasing = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Antaron</i>, <i>Mahvin</i> and <i>David Tschumperl&#233;</i>.             Latest Update: <i>2015/16/03</i>.</small>")
fx_stamp :
  repeat $! l[$>] split_opacity l[0]
    wh={w},{h}
    norm
    if $7 r 150%,150%,1,1,3 fi
    noise $5
    if $1 otsu 256 else >= $2% fi
    b {if($7,1.5,1)*$3},0 sharpen $4 n 0,255
    apply_curve 1,0,0,101,33,170,229,255,255
    if $7 r $wh,1,1,2 fi
    if $6 negate fi
  endl a c endl done

fx_stamp_preview :
  gui_split_preview "fx_stamp $*",${-3--1}


#@gui ____<b>Colors</b>
#----------------------

#@gui Abstraction : fx_color_abstraction, fx_color_abstraction_preview(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Levels = int(10,2,100)
#@gui : Contrast = float(0.2,0.01,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/19/10</i>.</small>")
fx_color_abstraction :
  repeat $! l[$>] split_opacity l[0] to_rgb
    b $1 s c quantize $2,1,0 area 0 ^ $3 n 0,255
  endl a c endl done

fx_color_abstraction_preview :
  gui_split_preview "fx_color_abstraction $*",${-3--1}

#@gui Apply External CLUT : fx_apply_haldclut, fx_apply_haldclut_preview(1)+
#@gui : Specify HaldCLUT As = choice(2,"Top Layer","Bottom Layer","Filename")
#@gui : HaldCLUT Filename = filein()
#@gui : note = note("<small><b>Note:</b> Do not forget to set the <i>Input layers</i> option if you select <i>Top layer</i> or <i>Bottom layer</i>.</small>")
#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_apply_haldclut : skip "${2=}"
  if {$1<2}
    if {$!<2} gui_warning_preview "Input layer with HaldCLUT is missing" return fi
    ind={if($1,-1,0)} map_clut[^$ind] [$ind] rm[$ind]
  else
    l
      0 nm. "$2" ext={x} rm.
      if {lowercase(['$ext'])=='cube'} input_cube "$2"
      else i "$2"
      fi
    onfail gui_warning_preview "Specified HaldCLUT filename not found" return
    endl
    map_clut[^-1] . rm.
    if {iM>255} / 255 fi # Was possibly a 16bits HaldCLUT.
  fi
  _fx_cluts 0,1,${3--1}

fx_apply_haldclut_preview : skip "${2=}"
  if {$1<2} gui_warning_preview "No preview available in this mode" return fi
  gui_split_preview "fx_apply_haldclut $1,\"$2\",${3--2}",${-3--1}

#@gui Basic Adjustments : fx_adjust_colors, fx_adjust_colors_preview
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/16/06</i>.</small>")
fx_adjust_colors :
  adjust_colors ${1-5},0,255

fx_adjust_colors_preview :
  gui_split_preview "fx_adjust_colors $*",${-3--1}

#@gui Boost Chromaticity : fx_boost_chroma, fx_boost_chroma_preview(1)
#@gui : Amplitude (%) = float(50,0,100)
#@gui : Color Space = choice{"YCbCr (Distinct)","YCbCr (Mixed)","Lab (Distinct)","Lab (Mixed)"}
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/19/07</i>.</small>")
fx_boost_chroma :
  repeat $! l[$>] split_opacity l[0]
    +to_rgb
    if {$2>=2}
      srgb2rgb rgb2lab.
      if {$2==2} sh. 1 sh.. 2 equalize[-2,-1] rm[-2,-1]
      else sh. 1,2 equalize. rm.
      fi
      lab2rgb. rgb2srgb
    else
      rgb2ycbcr.
      if {$2==0} sh. 1 sh.. 2 equalize[-2,-1] rm[-2,-1]
      else sh. 1,2 equalize. rm.
      fi
      ycbcr2rgb.
    fi
    j.. .,0,0,0,0,{$1%} rm.
  endl a c endl done

fx_boost_chroma_preview :
  gui_split_preview "fx_boost_chroma $*",${-3--1}

#@gui Boost-Fade : fx_boost_fade, fx_boost_fade_preview
#@gui : Amplitude = float(5,0,10)
#@gui : Chromaticity From = choice("YCbCr","Lab")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/11/26</i>.</small>")
fx_boost_fade :
  repeat $! l[$>]
    100%,100%,1,3 rand. 0,1 b. {10-10*($1/10)^0.5} n. 0,255
    to_colormode 0 a z
    ac "s z transfer_histogram.. . rm.",${"arg 1+$2,ycbcr_cbcr,lab_ab"}
  endl done

fx_boost_fade_preview :
  gui_split_preview "fx_boost_fade $1,$2",${-3--1}

#@gui Channel Processing : fx_channel_processing, fx_channel_processing_preview(1)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Value Action = choice("None","Cut","Cut &amp; Normalize","Normalize","Threshold")
#@gui : Low Value = float(0,0,100)
#@gui : High Value = float(100,0,100)
#@gui : Quantization = int(256,1,256)
#@gui : Equalization = bool(0)
#@gui : Negation = bool(0)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator()
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_channel_processing :
  adjust_colors ${1-3} b. $4%
  if {$5==1} c. $6%,$7%
  elif {$5==2} c. $6%,$7% n. 0,255
  elif {$5==3} n. $6%,$7%
  elif {$5==4} ir. $6%,$7% *. 255
  fi
  if {$8!=256} quantize. $8,1,0 fi
  if $9 equalize. fi
  if $10 negate. fi

fx_channel_processing :
  repeat $! l. split_opacity rv to_rgb.
    fx_start_mix $11,$12
    ac. "_fx_channel_processing $1,$2,$3,$4,$5,$6,$7,$8,$9,$10",$13,1
    fx_end_mix $11
  if {$!!=3} rv a c fi endl mv. 0 done

fx_channel_processing_preview :
  gui_split_preview "fx_channel_processing $*",${-3--1}

#@gui Channels to Layers : fx_channels2layers, fx_channels2layers_preview
#@gui : Colorspace = choice("RGB","CMY","HSV")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/15/07</i>.</small>")
fx_channels2layers :
  repeat $! l[$<] nm=${-gui_layer_name} to_rgb
    if {$1==0} # RGB
      s[0] c
      r[0] 100%,100%,1,3,0,0,0,0,0,0 nm[0] name($nm" "[red]),mode(add)
      r[1] 100%,100%,1,3,0,0,0,0,0,0.5 nm[1] name($nm" "[green]),mode(add)
      r[2] 100%,100%,1,3,0,0,0,0,0,1 nm[2] name($nm" "[blue]),mode(add)
    elif {$1==1} # CMY
      rgb2cmy[0] -[0] 255 s[0] c
      r[0] 100%,100%,1,3,0,0,0,0,0,0 nm[0] name($nm" "[cyan]),mode(difference)
      r[1] 100%,100%,1,3,0,0,0,0,0,0.5 nm[1] name($nm" "[magenta]),mode(difference)
      r[2] 100%,100%,1,3,0,0,0,0,0,1 nm[2] name($nm" "[yellow]),mode(difference)
      +[0-2] 255
      i[0] 100%,100%,1,3,255 nm[0] name($nm" "[base]),mode(difference)
    else # HSV
      rgb2hsv[0] s[0] c,-2
      r[0] 100%,100%,1,3,0,0 sh[0] 2 f. 1 rm. nm[0] name($nm" "[color]),mode(normal)
      r[1] 100%,100%,1,3,0,0,0,0,0,1 nm[1] name($nm" "[value]),mode(value)
      hsv2rgb[0,1] rv[0,1]
    fi
  endl done

fx_channels2layers_preview :
  repeat $! l[$>]
    fx_channels2layers $*
    repeat $! l[$>] to "#"{1+$>},1,1,43,7,1,255 endl done
    frame 1,1,0 frame 3,3,255 append_tiles ,
  endl done

#@gui Color Balance : fx_balance_gamma, fx_balance_gamma_preview
#@gui : Neutral Color = color(128,128,128)
#@gui : Stretch Colors = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/01/07</i>.</small>")
fx_balance_gamma :
  repeat $! l[$>] split_opacity
    if {$!>1} +!=. 0 *[0,-1] fi
    l[0]
      balance_gamma ${1-3}
      if $4 n 0,255 fi
    endl
    a c endl
  done

fx_balance_gamma_preview :
  gui_split_preview "fx_balance_gamma $*",${-3--1}

#@gui Color Blindness : colorblind, fx_colorblind_preview
#@gui : Blindness Type = choice("Protanopia","Protanomaly","Deuteranopia","Deuteranomaly","Tritanopia","Tritanomaly","Achromatopsia","Achromatomaly")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter simulates different types of colorblindness vision.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/04</i>.</small>")
fx_colorblind_preview :
  gui_split_preview "colorblind $*",${-3--1}

#@gui Color Presets : fx_color_presets, fx_color_presets_preview(1)+
#@gui : Category = choice{"Creative Pack","FilterGrade Cinematic","Lutify.Me","ON1 Photography","PictureFX","RocketStock","SmallHD Movie Look","Others"}

##### Creative Pack
#@gui : Preset = choice{"None",
#@gui : "Anime","Bleach Bypass 1","Bleach Bypass 2","Bleach Bypass 3","Bleach Bypass 4","Candle Light","Color Negative","Crisp Warm",
#@gui : "Crip Winter","Drop Blues","Edgy Ember","Fall Colors","Foggy Night","Futuristic Bleak 1","Futuristic Bleak 2","Futuristic Bleak 3","Futuristic Bleak 4",
#@gui : "Horror Blue","Late Sunset","Moonlight","Night From Day","Red Blue Yellow","Smokey","Soft Warming","Teal Magenta Gold",
#@gui : "Teal Orange","Teal Orange 1","Teal Orange 2","Teal Orange 3","Tension Green 1","Tension Green 2","Tension Green 3","Tension Green 4" }_2

##### FilterGrade Cinematic
#@gui : Preset = choice{"None", "Cine Basic", "Cine Bright", "Cine Cold", "Cine Drama", "Cine Teal Orange 1", "Cine Teal Orange 2",
#@gui : "Cine Vibrant", "Cine Warm"}_0

##### Lutify.Me
#@gui : Preset = choice{"None","Hackmanite","Herderite","Heulandite","Hiddenite","Hilutite","Howlite","Hypersthene"}_0

##### ON1 Photography
#@gui : Preset = choice{"None","2-Strip Process","Aqua","Aqua and Orange Dark","Berlin Sky","Blues",
#@gui : "Black & White-1","Black & White-2","Black & White-3","Black & White-4","Black & White-5","Black & White-6","Black & White-7","Black & White-8","Black & White-9","Black & White-10","Chrome 01",
#@gui : "Cinematic-1","Cinematic-2","Cinematic-3","Cinematic-4","Cinematic-5","Cinematic-6","Cinematic-7","Cinematic-8","Cinematic-9","Cinematic-10",
#@gui : "Classic Teal and Orange","Earth Tone Boost","Fade to Green","Film Print 01","Film Print 02","French Comedy","Green Blues","Green Yellow",
#@gui : "Landscape-1","Landscape-2","Landscape-3","Landscape-4","Landscape-5","Landscape-6","Landscape-7","Landscape-8","Landscape-9","Landscape-10",
#@gui : "Lifestyle & Commercial-1","Lifestyle & Commercial-2","Lifestyle & Commercial-3","Lifestyle & Commercial-4","Lifestyle & Commercial-5","Lifestyle & Commercial-6","Lifestyle & Commercial-7","Lifestyle & Commercial-8","Lifestyle & Commercial-9","Lifestyle & Commercial-10",
#@gui : "Moody-1","Moody-2","Moody-3","Moody-4","Moody-5","Moody-6","Moody-7","Moody-8","Moody-9","Moody-10",
#@gui : "Nature & Wildlife-1","Nature & Wildlife-2","Nature & Wildlife-3","Nature & Wildlife-4","Nature & Wildlife-5","Nature & Wildlife-6","Nature & Wildlife-7","Nature & Wildlife-8","Nature & Wildlife-9","Nature & Wildlife-10","Oranges",
#@gui : "Portrait-1","Portrait-2","Portrait-3","Portrait-4","Portrait-5","Portrait-6","Portrait-7","Portrait-8","Portrait-9","Portrait10",
#@gui : "Purple","Reds","Reds Oranges Yellows","Studio Skin Tone Shaper","Vintage Chrome"}_0

##### Picture FX
#@gui : Preset = choice{"None",
#@gui : "AnalogFX - Anno 1870 Color","AnalogFX - Old Style I","AnalogFX - Old Style II","AnalogFX - Old Style III",
#@gui : "AnalogFX - Sepia Color","AnalogFX - Soft Sepia I","AnalogFX - Soft Sepia II",
#@gui : "GoldFX - Bright Spring Breeze","GoldFX - Bright Summer Heat","GoldFX - Hot Summer Heat",
#@gui : "GoldFX - Perfect Sunset 01min","GoldFX - Perfect Sunset 05min","GoldFX - Perfect Sunset 10min",
#@gui : "GoldFX - Spring Breeze","GoldFX - Summer Heat",
#@gui : "TechnicalFX - Backlight Filter","ZilverFX - B&amp;W Solarization","ZilverFX - InfraRed","ZilverFX - Vintage B&amp;W"}_0

##### RocketStock
#@gui : Preset = choice{"None", "Arabica 12", "Ava 614", "Azrael 93", "Bourbon 64", "Byers 11", "Chemical 168", "Clayton 33", "Clouseau 54",
#@gui : "Cobi 3", "Contrail 35", "Cubicle 99", "Django 25", "Domingo 145", "Faded 47", "Folger 50", "Fusion 88", "Hyla 68", "Korben 214",
#@gui : "Lenox 340", "Lucky 64", "McKinnon 75", "Milo 5", "Neon 770", "Paladin 1875", "Pasadena 21", "Pitaya 15", "Reeve 38", "Remy 24",
#@gui : "Sprocket 231", "Teigen 28", "Trent 18", "Tweed 71", "Vireo 37", "Zed 32", "Zeke 39"}_0

##### SmallHD Movie Look
#@gui : Preset = choice{"None","Apocalypse This Very Moment","B-Boyz 2","Bob Ford","Life Giving Tree","Moonrise","Saving Private Damon","The Matrices"}_0

##### Others
#@gui : Preset = choice{"None","60's","60's (faded)","60's (faded alt)","Alien green","Black &amp; White","Bleach bypass","Blue mono",
#@gui : "Color (rich)","Faded","Faded (alt)","Faded (analog)","Faded (extreme)","Faded (vivid)","Expired (fade)","Expired (polaroid)","Extreme","Fade",
#@gui : "Faux infrared","Golden","Golden (bright)","Golden (fade)","Golden (mono)","Golden (vibrant)","Green mono","Hong Kong","Light (blown)","Lomo",
#@gui : "Mono tinted","Muted fade","Mute shift","Natural (vivid)","Nostalgic","Orange tone","Pink fade","Purple","Retro","Rotate (muted)","Rotate (vibrant)",
#@gui : "Rotated","Rotated (crush)",
#@gui : "Smooth crome-ish","Smooth fade","Soft fade","Solarize color","Solarized color2","Summer","Summer (alt)","Sunny","Sunny (alt)","Sunny (warm)",
#@gui : "Sunny (rich)","Super warm","Super warm (rich)","Sutro FX","Vibrant","Vibrant (alien)","Vibrant (contrast)","Vibrant (crome-ish)",
#@gui : "Vintage","Vintage (alt)","Vintage (brighter)","Warm","Warm (highlight)","Warm (yellow)"}_0

#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs proposed in this filter come from various free sources :</small>")
#@gui : note = note{"<small><b>*</b> Creative Pack: <a href="https://rawpedia.rawtherapee.com/Film_Simulation">RawTherapee Film Simulation</a>.</small>"}
#@gui : note = note{"<small><b>*</b> FilterGrade Cinematic: <a href="https://filtergrade.com/free-cinematic-luts-video-editing/">FilterGrade Free Cinematic LUTs Pack</a>.</small>"}
#@gui : note = note{"<small><b>*</b> Lutify.Me: <a href="https://lutify.me/free-luts/">Lutify.Me Free LUTs</a>.</small>"}
#@gui : note = note{"<small><b>*</b> ON1 Photography: <a href="https://www.on1.com/free/lut-packs/">ON1 Free Photography LUTs</a>.</small>"}
#@gui : note = note{"<small><b>*</b> PictureFX: <a href="http://www.digicrea.be/haldclut-set-style-a-la-nik-software">PictureFX - A Free HaldCLUT Set</a>.</small>"}
#@gui : note = note{"<small><b>*</b> RocketStock: <a href="https://www.rocketstock.com/free-after-effects-templates/35-free-luts-for-color-grading-videos/">RocketStock 35 Free LUTs for Color Grading</a>.</small>"}
#@gui : note = note{"<small><b>*</b> SmallHD Movie Look: <a href="https://www.smallhd.com/community/movie-looks-download">SmallHD Free Movie Look Pack</a>.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2019/02/27</i>.</small>")
fx_color_presets :
  category=${arg\ 1+$1,creative,filtergrade,lutifyme,on1,picturefx,rocketstock,smallhd,others}
  presets=${-_fx_cluts_$category}
  index={arg(1+$1,${2-9})}
  preset=${arg\ {max(1,$index)},$presets}
  _fx_cluts $index,$preset,${10--1}

fx_color_presets_preview :
  gui_split_preview "fx_color_presets $*",${-3--1}
  u "{$1}{$2}_"{2*($1==0)}\
        "{$3}_"{2*($1==1)}\
        "{$4}_"{2*($1==2)}\
        "{$5}_"{2*($1==3)}\
        "{$6}_"{2*($1==4)}\
        "{$7}_"{2*($1==5)}\
        "{$8}_"{2*($1==6)}\
        "{$9}_"{2*($1==7)}\
        "{$10}{$11}{$12}{$13}{$14}{$15}{$16}{$17}{$18,$19}"

_fx_cluts :
  if $1
    clut "$2"
    repeat {$!-1}
      if {$9%2} balance_gamma[$>] , fi
      if {$3<100} +map_clut[$>] . j[$>] .,0,0,0,0,{$3%} rm.
      else map_clut[$>] .
      fi
    done
    rm.
  fi
  adjust_colors ${4-8},0,255
  if {$9>1} repeat $! l[$>] split_opacity n[0] 0,255 a c endl done fi

_fx_cluts_creative :
  u anime,bleachbypass_1,bleachbypass_2,bleachbypass_3,bleachbypass_4,candlelight,colornegative,crispwarm,crispwinter,dropblues,edgyember,\
    fallcolors,foggynight,futuristicbleak_1,futuristicbleak_2,futuristicbleak_3,futuristicbleak_4,horrorblue,latesunset,moonlight,nightfromday,\
    redblueyellow,smokey,softwarming,tealmagentagold,tealorange,tealorange_1,tealorange_2,tealorange_3,tensiongreen_1,tensiongreen_2,tensiongreen_3,\
    tensiongreen_4

_fx_cluts_filtergrade :
  u fgcinebasic,fgcinebright,fgcinecold,fgcinedrama,fgcinetealorange_1,fgcinetealorange_2,fgcinevibrant,fgcinewarm

_fx_cluts_lutifyme :
  u hackmanite,herderite,heulandite,hiddenite,hilutite,howlite,hypersthene

_fx_cluts_on1 :
  u 2-strip-process,aqua,aqua_and_orange_dark,berlin_sky,blues,\
    bw_1,bw_2,bw_3,bw_4,bw_5,bw_6,bw_7,bw_8,bw_9,bw_10,chrome_01,\
    cinematic-1,cinematic-2,cinematic-3,cinematic-4,cinematic-5,cinematic-6,cinematic-7,cinematic-8,cinematic-9,cinematic-10,\
    classic_teal_and_orange,earth_tone_boost,fade_to_green,film_print_01,film_print_02,french_comedy,green_blues,green_yellow,\
    landscape_1,landscape_2,landscape_3,landscape_4,landscape_5,landscape_6,landscape_7,landscape_8,landscape_9,landscape_10,\
    lc_1,lc_2,lc_3,lc_4,lc_5,lc_6,lc_7,lc_8,lc_9,lc_10,\
    moody_1,moody_2,moody_3,moody_4,moody_5,moody_6,moody_7,moody_8,moody_9,moody_10,\
    nw-1,nw-2,nw-3,nw-4,nw-5,nw-6,nw-7,nw-8,nw-9,nw-10,oranges,\
    portrait_1,portrait_2,portrait_3,portrait_4,portrait_5,portrait_6,portrait_7,portrait_8,portrait_9,portrait_10,\
    purple_2,reds,reds_oranges_yellows,studio_skin_tone_shaper,vintage_chrome

_fx_cluts_picturefx :
  u analogfx_anno_1870_color,analogfx_old_style_i,analogfx_old_style_ii,analogfx_old_style_iii,\
    analogfx_sepia_color,analogfx_soft_sepia_i,analogfx_soft_sepia_ii,\
    goldfx_bright_spring_breeze,goldfx_bright_summer_heat,goldfx_hot_summer_heat,\
    goldfx_perfect_sunset_01min,goldfx_perfect_sunset_05min,goldfx_perfect_sunset_10min,\
    goldfx_spring_breeze,goldfx_summer_heat,technicalfx_backlight_filter,\
    zilverfx_bw_solarization,zilverfx_infrared,zilverfx_vintage_bw

_fx_cluts_rocketstock :
  u arabica_12,ava_614,azrael_93,bourbon_64,byers_11,chemical_168,clayton_33,clouseau_54,cobi_3,contrail_35,cubicle_99,django_25,domingo_145,\
    faded_47,folger_50,fusion_88,hyla_68,korben_214,lenox_340,lucky_64,mckinnon_75,milo_5,neon_770,paladin_1875,pasadena_21,pitaya_15,reeve_38,\
    remy_24,sprocket_231,teigen_28,trent_18,tweed_71,vireo_37,zed_32,zeke_39

_fx_cluts_smallhd :
  u apocalypse_this_very_moment,bboyz_2,bob_ford,life_giving_tree,moonrise,saving_private_damon,the_matrices

_fx_cluts_others :
  u 60s,60s_faded,60s_faded_alt,alien_green,black_and_white,bleach_bypass,blue_mono,\
    color_rich,faded,faded_alt,faded_analog,faded_extreme,faded_vivid,expired_fade,expired_polaroid,extreme,fade,\
    faux_infrared,golden,golden_bright,golden_fade,golden_mono,golden_vibrant,green_mono,hong_kong,light_blown,lomo,\
    mono_tinted,muted_fade,mute_shift,natural_vivid,nostalgic,orange_tone,pink_fade,purple,retro,rotate_muted,rotate_vibrant,\
    rotated,rotated_crush,\
    smooth_cromeish,smooth_fade,soft_fade,solarized_color,solarized_color_2,summer,summer_alt,sunny,sunny_alt,sunny_warm,\
    sunny_rich,super_warm,super_warm_rich,sutro_fx,vibrant,vibrant_alien,vibrant_contrast,vibrant_cromeish,\
    vintage,vintage_alt,vintage_brighter,warm,warm_highlight,warm_yellow

#@gui Colorful Blobs : fx_colorful_blobs, fx_colorful_blobs_preview
#@gui : Colorspace = choice(1,"sRGB","Linear RGB","Lab")
#@gui : Background Color = color(200,200,200,0)
#@gui : Display Blob Controls = bool(1)
#@gui : sep = separator()
#@gui : Blob 1 = point(25,25,1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 1 Color = color(255,0,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob2 = point(75,25,1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 2 Color = color(0,255,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 3 = point(50,75,1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 3 Color = color(0,0,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 4 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 4 Color = color(255,255,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 5 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 5 Color = color(255,0,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 6 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 6 Color = color(0,255,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 7 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 7 Color = color(255,255,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 8 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 8 Color = color(0,0,0)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 9 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 9 Color = color(255,128,64)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 10 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 10 Color = color(255,64,128)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 11 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 11 Color = color(128,64,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : Blob 12 = point(5,90,-1,1,0,0,0,0,5)
#@gui : Radius = point(50,50,0,1,0,0,0,0,5,0)
#@gui : Blob 12 Color = color(64,128,255)
#@gui : Previous = value(-1,-1,-1,-1)
#@gui : sep = separator()
#@gui : note = note("This filter can be used to create custom palettes with given color shades. It has been inspired by <a href="https://research.adobe.com/project/playful-palette-an-interactive-parametric-color-mixer-for-artists/">Adobe's Playful Palette</a>.")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/08/26</i>.</small>")
fx_colorful_blobs :
  N=12
  colorspace,bgR,bgG,bgB,bgA,display_controls,\
  x0,y0,rx0,ry0,R0,G0,B0,p_x0,p_y0,p_rx0,p_ry0,\
  x1,y1,rx1,ry1,R1,G1,B1,p_x1,p_y1,p_rx1,p_ry1,\
  x2,y2,rx2,ry2,R2,G2,B2,p_x2,p_y2,p_rx2,p_ry2,\
  x3,y3,rx3,ry3,R3,G3,B3,p_x3,p_y3,p_rx3,p_ry3,\
  x4,y4,rx4,ry4,R4,G4,B4,p_x4,p_y4,p_rx4,p_ry4,\
  x5,y5,rx5,ry5,R5,G5,B5,p_x5,p_y5,p_rx5,p_ry5,\
  x6,y6,rx6,ry6,R6,G6,B6,p_x6,p_y6,p_rx6,p_ry6,\
  x7,y7,rx7,ry7,R7,G7,B7,p_x7,p_y7,p_rx7,p_ry7,\
  x8,y8,rx8,ry8,R8,G8,B8,p_x8,p_y8,p_rx8,p_ry8,\
  x9,y9,rx9,ry9,R9,G9,B9,p_x9,p_y9,p_rx9,p_ry9,\
  x10,y10,rx10,ry10,R10,G10,B10,p_x10,p_y10,p_rx10,p_ry10,\
  x11,y11,rx11,ry11,R11,G11,B11,p_x11,p_y11,p_rx11,p_ry11,\
  =$"*"
  if {!0$_is_preview} display_controls=0 fi
  if {$1==1} srgb2cs=srgb2rgb cs2srgb=rgb2srgb
  elif {$1==2} srgb2cs=srgb2lab cs2srgb=lab2srgb
  fi

  {0,s=min(w,h);[s,s]},1,4 k. 100%,100%,1,1,1e-8

  repeat $N
    # If center point has been moved -> Update radius point.
    rx$>,ry$>={"P = ["${x$>},${y$>}"]; R = ["${rx$>},${ry$>}"]; oP = ["${p_x$>},${p_y$>}"]; oP==[-1,-1]?P + [10,0]:P!=oP?R + P - oP:R"}

    if {!isnan(${x$>})}
      x,y,rx,ry,R,G,B={"const w1 = (w - 1)%; const h1 = (h -1)%; "round([${x$>}*w1,${y$>}*h1,${rx$>}*w1,${ry$>}*h1,${R$>},${G$>},${B$>}])}
      r={max(1,round(norm($x-$rx,$y-$ry)))}
      if $1 ($R^$G^$B) $srgb2cs. R,G,B={^} rm. fi
      f. "*
        pexp(x) = x<2?(res = 1; px = x^2; res+=-1.17282*px; px*=x; res+=0.683221*px; px*=x; res+=-0.110353*px):0;
        const r = 1.2*"($r)";
        dist = norm(x-"$x",y-"$y")/r;
        w = pexp(dist);
        j(#0,0,0,0) += w*"$R";
        j(#0,0,0,0,1) += w*"$G";
        j(#0,0,0,0,2) += w*"$B";
        i + w;
      "
    fi
  done
  sh[0] 0,2 /. [1] if $1 $cs2srgb. fi
  f[0] "*begin(bg = [ "$bgR,$bgG,$bgB,$bgA" ]); i(#1)<0.5?bg:[R,G,B,255]" k[0]

  repeat $N
    if {!isnan(${x$>})" && "$display_controls}
    x,y,rx,ry,R,G,B={"const w1 = (w - 1)%; const h1 = (h -1)%; "round([${x$>}*w1,${y$>}*h1,${rx$>}*w1,${ry$>}*h1,${R$>},${G$>},${B$>}])}
      circle $x,$y,3,0.85,0xFFFFFFFF,{v=avg(crop($x-3,$y-3,7,7))>128?0:255;[v,v,v,255]}
      rectangle {"const x = "$rx"; const y = "$ry"; [x-2,y-2,x+2,y+2]"},0.85,0xFFFFFFFF,{v=avg(crop($rx-3,$ry-3,7,7))>128?0:255;[v,v,v,255]}
      line $x,$y,$rx,$ry,0.5,0xF0F0F0F0,255 line $x,$y,$rx,$ry,0.5,0x0F0F0F0F,0,0,0,255
    fi
  done

  if 0$_is_preview
    u \{$colorspace\}\{$bgR,$bgG,$bgB,$bgA\}\{$display_controls\}\
      \{$x0,$y0\}\{$rx0,$ry0\}\{$R0,$G0,$B0\}\{$x0,$y0,$rx0,$ry0\}\
      \{$x1,$y1\}\{$rx1,$ry1\}\{$R1,$G1,$B1\}\{$x1,$y1,$rx1,$ry1\}\
      \{$x2,$y2\}\{$rx2,$ry2\}\{$R2,$G2,$B2\}\{$x2,$y2,$rx2,$ry2\}\
      \{$x3,$y3\}\{$rx3,$ry3\}\{$R3,$G3,$B3\}\{$x3,$y3,$rx3,$ry3\}\
      \{$x4,$y4\}\{$rx4,$ry4\}\{$R4,$G4,$B4\}\{$x4,$y4,$rx4,$ry4\}\
      \{$x5,$y5\}\{$rx5,$ry5\}\{$R5,$G5,$B5\}\{$x5,$y5,$rx5,$ry5\}\
      \{$x6,$y6\}\{$rx6,$ry6\}\{$R6,$G6,$B6\}\{$x6,$y6,$rx6,$ry6\}\
      \{$x7,$y7\}\{$rx7,$ry7\}\{$R7,$G7,$B7\}\{$x7,$y7,$rx7,$ry7\}\
      \{$x8,$y8\}\{$rx8,$ry8\}\{$R8,$G8,$B8\}\{$x8,$y8,$rx8,$ry8\}\
      \{$x9,$y9\}\{$rx9,$ry9\}\{$R9,$G9,$B9\}\{$x9,$y9,$rx9,$ry9\}\
      \{$x10,$y10\}\{$rx10,$ry10\}\{$R10,$G10,$B10\}\{$x10,$y10,$rx10,$ry10\}\
      \{$x11,$y11\}\{$rx11,$ry11\}\{$R11,$G11,$B11\}\{$x11,$y11,$rx11,$ry11\}
   fi

fx_colorful_blobs_preview :
  _is_preview=1
  rm {s=min($_preview_width,$_preview_height)/2;[s,s]},1,1
  fx_colorful_blobs $*

#@gui Colormap : fx_colormap,fx_colormap_preview
#@gui : Colormap = choice{2,"Adaptive","Custom","Standard (256)","HSV (256)","Lines (256)","Hot (256)","Cool (256)","Jet (256)","Flag (256)","Cube (256)"}
#@gui : Dithering = float(1,0,1)
#@gui : sep = separator()
#@gui : Number of Tones = int(32,2,256)_0
#@gui : Number of Colors = int(8,2,8)_0
#@gui : 1st Color = color(0,0,0)_0
#@gui : 2nd Color = color(255,255,255)_0
#@gui : 3rd Color = color(255,0,0)_0
#@gui : 4th Color = color(0,255,0)_0
#@gui : 5th Color = color(0,0,255)_0
#@gui : 6th Color = color(255,255,0)_0
#@gui : 7th Color = color(255,0,255)_0
#@gui : 8th Color = color(0,255,255)_0+
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/27/12</i>.</small>")
fx_colormap :
  repeat $! l[$>] split_opacity to_rgb[0]
    if {$1>=2}                # Pre-defined colormap.
      index[0] {$1-2},$2,1
    elif {$1==1}              # Custom colormap.
      (${5-28}) z. 0,{3*$4-1}
      r. 3,{w/3},1,1,-1 permute. yzcx r. $3,1,1,3,3
      index[0] .,$2,1 rm.
    else                      # Adaptive colormap.
      autoindex[0] $3,$2,{if($3<=32,1,0)}
    fi
    a c
  endl done

fx_colormap_preview :
  gui_split_preview "fx_colormap $*",${-3--1}
  is_ad,is_cu={2*[$1==0||$1==1,$1==1]}
  u "{$1}{$2}"\
    "{$3}_"$is_ad\
    "{$4}_"$is_cu\
    "{${5-7}}_"$is_cu\
    "{${8-10}}_"$is_cu\
    "{${11-13}}_"$is_cu\
    "{${14-16}}_"$is_cu\
    "{${17-19}}_"$is_cu\
    "{${20-22}}_"$is_cu\
    "{${23-25}}_"$is_cu\
    "{${26-28}}_"$is_cu\
    "{$29}{$30,$31}"

#@gui Color Mask [Interactive] : fx_mask_color, gui_no_preview
#@gui : Color Metric = _choice(13,"RGB [all]","RGB [red]","RGB [green]","RGB [blue]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [all]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [all]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [all]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [all]","HSI [intensity]","HSL [all]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Spatial Tolerance = _float(10,0,100)
#@gui : Color Tolerance = _float(5,0,100)
#@gui : sep = separator()
#@gui : Output Mode = _choice(0,"Masked image","Color mask")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter is CPU consuming, so use it at least with 4+ cores (or reduce the size of the interactive window to speed up computation).</small>"}
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive window to build your color mask :\n\n
#@gui : - <b>Left mouse button</b> make the color pointed by the mouse wanted for the mask.\n
#@gui : - <b>Right mouse button</b> make the color pointed by the mouse unwanted for the mask.\n
#@gui : - <b>Middle mouse button</b> or key <b>R</b> resets color mask.\n
#@gui : - Key <b>SPACE</b> or <b>TAB</b> toggles view modes (half/full-masked RGB or color mask).\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> resets window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>01/20/2017</i>.</small>")
fx_mask_color :
  cs=rgb,rgb_r,rgb_g,rgb_b,lrgb,lrgb_r,lrgb_g,lrgb_b,ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,lab,lab_l,lab_ab,lab_a,lab_b,lch,lch_c,lch_h,\
     hsv,hsv_h,hsv_s,hsv_v,hsi,hsi_i,hsl,hsl_l,cmyk_c,cmyk_m,cmyk_y,cmyk_k,yiq_y,yiq_iq
  repeat $! l[$<] to_rgb nm={n} nm ${-gui_layer_name}
    +x_mask_color ${arg\ 1+$1,$cs},$2,$3
    if {$4==1} channels. 100% fi
    nm $nm rv
  endl done

#@gui Curves : fx_curves_interactive, fx_curves_interactive_preview
#@gui : Colorspace = choice{"RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr"}
#@gui : Output Preset as a HaldCLUT Layer = _choice("Disable","Lowres CLUT","Highres CLUT")
#@gui : Apply Transformation From = _choice("New Curves [Interactive]","Curves Previously Defined")
#@gui : Colorspace = value(0)
#@gui : Keypoints = value(0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Description:</b>\n
#@gui : This filter allows to apply color curves on your images, in many different colorspaces.
#@gui : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the G'MIC interactive windows and start building your color curves.
#@gui : When you're done, exit the main image window: your modified result will be transferred back to the host software.\n\n
#@gui : Once you've set curves, you can save them by pressing the <b>Add to faves</b> button below the filter tree.
#@gui : To clear control points for your curves, click on the <i>Reset</i> button above.
#@gui : </small>"}
#@gui : sep = separator()
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive windows to manage your colorization :\n\n
#@gui : - <b>Left mouse button</b> on a curve creates a new color control point (or move an existing one).\n
#@gui : - <b>Right mouse button</b> on a control point deletes it.\n
#@gui : - <b>Left mouse button</b> on the main image window shows the initial image until button is released.\n
#@gui : - <b>Right mouse button</b> on the main image window adds a keypoint to all curves from picked color.\n
#@gui : - Key <b>R</b> on a curve resets it.\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> resets window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> close the current window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>09/28/2014</i>.</small>")
fx_curves_interactive :
  nm "Color curves"
  repeat 4 __xcc_C$>=0,0,100,100 done
  if {$4==$1} l[] (${5--1}) s -,-1 repeat $! __xcc_C$>={$>,^} done rm endl fi
  if $3 _xcc_colorbase=${arg\ {$4+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr} x_color_curves last # Apply transformation from previously defined curves.
  else # Run interactive curve builder.
    x_color_curves ${arg\ {$1+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr}
    u "{$1}{$2}{$3}{$1}{"$__xcc_C0,-1,$__xcc_C1,-1,$__xcc_C2,-1,$__xcc_C3,-1,$__xcc_C4"}"
  fi
  if $2 # Add HaldCLUT layer.
    (0,255) (0;255) (0/255) r[-3--1] 2,2,2 a[-3--1] c
    if {$2==2} r. 256,256,256,3,3 r. 4096,4096,1,3,-1 # High-res HaldCLUT.
    else r. 64,64,64,3,3 r. 512,512,1,3,-1 # Low-res HaldCLUT.
    fi
    x_color_curves. last
  fi

fx_curves_interactive_preview :
  fx_curves_interactive $1,0,1,${4--1}

#@gui Customize CLUT : fx_customize_clut,fx_customize_clut_preview(1)+
#@gui : Keypoint Influence (%) = float(100,0,100)
#@gui : Lock Uniform Sampling = choice{0,"None","8 Keypoints (RGB Corners)","27 Keypoints","64 Keypoints","125 Keypoints","216 Keypoints","343 Keypoints"},
#@gui : Spatial Regularization = int(10,0,30)
#@gui : sep = separator()
#@gui : note = note("<small><b>Global correction:</b></small>")
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Post-Normalize = bool(0)
#@gui : sep = separator()
#@gui : Output Corresponding CLUT = _choice("Disable","512x512 Layer","4096x4096 Layer")
#@gui : Preview Type = choice{8,"Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Horizontal","Duplicate Vertical","HaldCLUT","3D CLUT (Fast)","3D CLUT (Precise)"}
#@gui : CLUT Opacity = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Color correspondences:</b></small>")
#@gui : Action #1 = choice(1,"Ignore","Lock Source","Replace Source by Target"), Source Color #1 = color(0,0,0), Target Color #1 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #2 = choice(1,"Ignore","Lock Source","Replace Source by Target"), Source Color #2 = color(255,255,255), Target Color #2 = color(255,196,128)
#@gui : sep = separator()
#@gui : Action #3 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #3 = color(0,0,0), Target Color #3 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #4 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #4 = color(0,0,0), Target Color #4 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #5 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #5 = color(0,0,0), Target Color #5 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #6 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #6 = color(0,0,0), Target Color #6 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #7 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #7 = color(0,0,0), Target Color #7 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #8 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #8 = color(0,0,0), Target Color #8 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #9 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #9 = color(0,0,0), Target Color #9 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #10 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #10 = color(0,0,0), Target Color #10 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #11 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #11 = color(0,0,0), Target Color #11 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #12 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #12 = color(0,0,0), Target Color #12 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #13 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #13 = color(0,0,0), Target Color #13 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #14 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #14 = color(0,0,0), Target Color #14 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #15 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #15 = color(0,0,0), Target Color #15 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #16 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #16 = color(0,0,0), Target Color #16 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #17 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #17 = color(0,0,0), Target Color #17 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #18 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #18 = color(0,0,0), Target Color #18 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #19 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #19 = color(0,0,0), Target Color #19 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #20 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #20 = color(0,0,0), Target Color #20 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #21 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #21 = color(0,0,0), Target Color #21 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #22 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #22 = color(0,0,0), Target Color #22 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #23 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #23 = color(0,0,0), Target Color #23 = color(0,0,0)
#@gui : sep = separator()
#@gui : Action #24 = choice("Ignore","Lock Source","Replace Source by Target"), Source Color #24 = color(0,0,0), Target Color #24 = color(0,0,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/14/06</i>.</small>")
fx_customize_clut :

  # Build CLUT.
  if {!narg($_N)} N=64 else N=$_N fi N1={$N-1}
  $N,$N,$N,4

  if $2 # Lock uniform sampling
    uniform_distribution {(1+$2)^3},3
    repeat {w} point.. {round($N1*I[$>])},1,{255*I[$>]},1 done rm.
  fi

  $=arg # Add user-defined color correspondences
  repeat 24
    mode=${arg{13+7*$<}}
    if $mode
      sr=${arg{14+7*$<}} sg=${arg{15+7*$<}} sb=${arg{16+7*$<}}
      tr=${arg{17+7*$<}} tg=${arg{18+7*$<}} tb=${arg{19+7*$<}}
      xyz={round(($N1/255)*[$sr,$sg,$sb])}
      point. $xyz,1,{$mode==2?[$tr,$tg,$tb]:[$sr,$sg,$sb]},1
    fi
  done

  s c,-3
  if {$1<100} # Need to compute a weighting map.
    +distance. 1
    if $1 ^. {1/(0.05+4*$1%)} else f. 0 fi
    n. 0,1 nm. influence mv. -3
  fi
  ==. 0 inpaint_diffusion.. .,100%,1,20 rm. c. 0,255

  if $influence
    100%,100%,100%,3,[x,y,z] n. 0,255
    j. ..,0,0,0,0,1,...
    rm[-3,-2]
  fi

  # Apply CLUT on input layers + global color corrections.
  if {!$3} map_clut[^-1] . # w/o spatial regularization
  else repeat {$!-1}       # w/ spatial regularization
    +luminance[$>] +map_clut[$>] .. -. [$>]
    repeat $3 guided. ..,2,50 done +[$>,-1] rm.
  done fi
  adjust_colors ${4-8},0,255
  if $9 repeat $! l[$>] split_opacity n[0] 0,255 a c endl done fi
  if $10
    if {$10==2} r. 256,256,256,3,5 c. 0,255 fi
    siz={w^1.5} r. $siz,$siz,1,3,-1
    mv. 0
  else rm.
  fi

fx_customize_clut_preview :
  if {$11<7} gui_split_preview "fx_customize_clut ${1-9},0,0,${12--1}",$11
  elif {$11==7} # HaldCLUT preview
    rm fx_customize_clut ${1-9},1,0,${12--1}
  elif {$11>=8} # 3D CLUT preview
    _N={$11>=9?64:32}
    k[0] to_rgb w={w} h={h}
    +fx_customize_clut ${1-9},1,0,${12--1} mv. 1
    r. $_N,$_N,$_N,3,-1 pointcloud3d. o3d. $12
    l[]
      if $2 # Lock uniform sampling
        uniform_distribution {(1+$2)^3},3
        repeat {w} circle3d {0,round($_N*I[$>])},0.75 col3d. {0,255*I[$>]} done rm[0]
      fi
      $=arg # Add user-defined color correspondences
      repeat 24
        mode=${arg{13+7*$<}}
        if $mode
          sr=${arg{14+7*$<}} sg=${arg{15+7*$<}} sb=${arg{16+7*$<}}
          tr=${arg{17+7*$<}} tg=${arg{18+7*$<}} tb=${arg{19+7*$<}}
          xy={round(($_N/255)*[$sr,$sg])}
          z={round(($_N/255)*$sb)-0.1}
          circle3d $xy,$z,0.75 col3d. {$mode==2?[$tr,$tg,$tb]:[$sr,$sg,$sb]}
        fi
      done
      colorcube3d *3d. {$_N/255} o3d. 0.5 col3d. 0 p3d. 1
    endl
    +3d[2--1]
    pose3d. 5.10656,2.04904,2.723,-316.115,-0.0815767,4.97762,-3.59262,-41.7094,-3.40685,2.95212,4.16756,-118.811,0,0,203,1

    # Try to find the best layout for displaying preview.
    if {$w>$h} # Landscape mode
      r2dx[0,1] {0,round(w/2)}
      to[0] "Before",2,0,13,1,0.75
      to[1] "After",2,0,13,1,0.75
      a[0,1] y r[0] 100%,$h,1,3,0
    else # Portrait mode.
      r2dy[0,1] {0,round(h/2)}
      to[0] "Before",2,0,13,1,0.75
      to[1] "After",2,0,13,1,0.75
      a[0,1] x r[0] $w,100%,1,3,0
    fi

    snapshot3d. {0,1.1*min(w,h)},1.2,64,64,64 autocrop. -. 64 r. {0,max(w,$w-w)},{0,max(h,$h-h)},1,3,0,0,0.5,0.5 +. 64
    to. "RGB CLUT",2,0,13,1,0.75
    a {`$w>$h?_'x':_'y'`}
  fi

#@gui Decompose Channels : fx_decompose_channels, fx_decompose_channels_preview
#@gui : Color Basis = choice(7,"RGB","HSV","HSL","HSI","YUV","YCbCr","XYZ","Lab","Lch","CMY","CMYK","YIQ")
#@gui : Action = choice("Decompose","Recompose")
#@gui : Output Multiple Layers = _bool(0)
#@gui : Include Opacity Layer = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/19/07</i>.</small>")
fx_decompose_channels :
  if {!$2} # Decompose
    if $4 to_rgba else to_rgb fi
    repeat $! l[$<] nm={0,n}
      split_opacity
      _s3=A _s4=A
      _fx_decompose_channels$1[0]
      s[0] c
      if {!$3} a x nm $nm
      else nm=${-gui_layer_name} repeat $! gui_set_layer_name[$>] {``$nm}" ["${_s$>}"]" done
      fi
    endl done
  else # Recompose
    channels 0 nbc={3+($1==10)} nb={$nbc+$4}
    if $3 repeat {int($!/$nb)} l[0-{$nb-1}]
      a[0-{$nbc-1}] c _fx_recompose_channels$1[0] a c
    endl mv. 0 done
    else repeat $! l[$>]
      s x,$nb a[0-{$nbc-1}] c _fx_recompose_channels$1[0] a c
    endl mv. 0 done fi
  fi

fx_decompose_channels_preview :
  repeat $! l[$<]
    _s3=A _s4=A
    fx_decompose_channels $1,$2,1,$4
    if {!$2}
      fs={round(min(w,h)*15%)}
      repeat $! to[$>] ${_s$>},5,3,$fs,{max(2,round($fs/15))} done
      to_rgba
    fi
  endl done
  append_tiles ,

_fx_decompose_channels0 : _s0=R _s1=G _s2=B
_fx_decompose_channels1 : rgb2hsv8 _s0=H _s1=S _s2=V
_fx_decompose_channels2 : rgb2hsl8 _s0=H _s1=S _s2=L
_fx_decompose_channels3 : rgb2hsi8 _s0=H _s1=S _s2=I
_fx_decompose_channels4 : rgb2yuv8 _s0=Y _s1=U _s2=V
_fx_decompose_channels5 : rgb2ycbcr _s0=Y _s1=Cb _s2=Cr
_fx_decompose_channels6 : rgb2xyz8 _s0=X _s1=Y _s2=Z
_fx_decompose_channels7 : rgb2lab8 _s0=L _s1=a _s2=b
_fx_decompose_channels8 : rgb2lch8 _s0=L _s1=c _s2=h
_fx_decompose_channels9 : rgb2cmy _s0=C _s1=M _s2=Y
_fx_decompose_channels10 : rgb2cmyk _s0=C _s1=M _s2=Y _s3=K
_fx_decompose_channels11 : rgb2yiq8 _s0=Y _s1=I _s2=Q

_fx_recompose_channels0 :
_fx_recompose_channels1 : hsv82rgb
_fx_recompose_channels2 : hsl82rgb
_fx_recompose_channels3 : hsi82rgb
_fx_recompose_channels4 : yuv82rgb
_fx_recompose_channels5 : ycbcr2rgb
_fx_recompose_channels6 : xyz82rgb
_fx_recompose_channels7 : lab82rgb
_fx_recompose_channels8 : lch82rgb
_fx_recompose_channels9 : cmy2rgb
_fx_recompose_channels10 : cmyk2rgb
_fx_recompose_channels11 : yiq82rgb

#@gui Detect Skin : fx_detect_skin, fx_detect_skin_preview(1)
#@gui : Skin Estimation = choice(1,"Manual","Automatic")
#@gui : sep = separator()
#@gui : Tolerance = float(0.5,0,1)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Threshold = float(1,0,10)
#@gui : Pre-Normalize Image = bool(1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Manual estimation:</b>\n
#@gui : Use the sliders below to target as much skin pixels as you can.</small>")
#@gui : X-Coordinate = float(50,0,100)
#@gui : Y-Coordinate = float(50,0,100)
#@gui : Radius = float(5,0,25)
#@gui : sep = separator()
#@gui : Output Mode = choice(1,"Probability Map","Opaque Skin","Transparent Skin")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/03/01</i>.</small>")
fx_detect_skin :
  to_rgb
  m "_fx_detect_skin :
       if $5 balance_gamma 128,128,128 fi
       if $1 detect_skin $2 else detect_skin $2,$6%,$7%,$8% fi
       M={iM} b $3% * {255*$M/iM} * $4 c 0,255"
  repeat $! l[$>]
    if $9  # Opaque/transparent skin.
      +_fx_detect_skin a c
      if {$9>1} sh 100% *. -1 +. 255 rm. fi
    else _fx_detect_skin # Probability mask.
    fi
  endl done
  uncommand _fx_detect_skin

fx_detect_skin_preview :
  gui_split_preview "fx_detect_skin $*",${-3--1}
  to_rgba
  if {!$1}
    circle $6%,$7%,$8%,0.3,0,255,0,255
    circle $6%,$7%,$8%,1,0xFFFFFFFF,0,255,0,255
    line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
    line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
  fi

#@gui Equalize HSV : fx_hsv_equalizer, fx_hsv_equalizer_preview
#@gui : Preview Bands = bool(false)
#@gui : sep = separator()
#@gui : Hue Band = float(180,0,360)
#@gui : Band Width = float(40,1,360)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Saturation Correction = float(0,-0.99,0.99)
#@gui : Value Correction = float(0,-0.99,0.99)
#@gui : sep = separator()
#@gui : Hue Band = float(180,0,360)
#@gui : Band Width = float(40,1,360)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Saturation Correction = float(0,-0.99,0.99)
#@gui : Value Correction = float(0,-0.99,0.99)
#@gui : sep = separator()
#@gui : Hue Band = float(180,0,360)
#@gui : Band Width = float(40,1,360)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Saturation Correction = float(0,-0.99,0.99)
#@gui : Value Correction = float(0,-0.99,0.99)
#@gui : sep = separator()
#@gui : note = note("<small>Author: <i>J&#233;rome Ferrari</i>.      Latest Update: <i>01/14/2011</i>.</small>")
#@gui : url = link("Filter explained here","http://www.flickr.com/groups/gmic/discuss/72157625798533482")
fx_hsv_equalizer :
  repeat $! l[$>]
  to_rgb rgb2hsv s c
# From now on 0,1,2 are H,S,V
#3 masks:
  +f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
  +f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
  +f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0)
# From now on 3,4,5 are Masks
  +threshold[1,2] 0.01 *[-1,-2] [-1]x2 *[-1,3] *[-1,4] *[-1,5]	#0 saturation and value not in mask
# Hue shift:
  +*[3] $4 +*[4] $9 +*[5] $14 +[-1,-2,-3]
  +[-1,0] %[0] 360
# Saturation :
  if {$5>=0} +*[3] -$5 else +*[3] {1/(1+$5)-1} fi +. 1
  if {$10>=0} +*[4] -$10 else +*[4] {1/(1+$10)-1} fi +. 1
  if {$15>=0} +*[5] -$15 else +*[5] {1/(1+$15)-1} fi +. 1
  *[-1,-2,-3] ^[1,-1]
# Value :
  if {$6>=0} +*[3] -$6 else +*[3] {1/(1+$6)-1} fi +. 1
  if {$11>=0} +*[4] -$11 else +*[4] {1/(1+$11)-1} fi +. 1
  if {$16>=0} +*[5] -$16 else +*[5] {1/(1+$16)-1} fi +. 1
  *[-1,-2,-3] ^[2,-1]
#reconstruction
  rm[3,4,5] a[0,1,2] c hsv2rgb
  endl done

fx_hsv_equalizer_preview :
  l.
  if {$1==0} fx_hsv_equalizer $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
  else
    to_rgb rgb2hsv s c
    (0,359) r. ..,{{0,h}/10},1,1,3 . f. 1	#create lower band
    j[0] [3],0,91% j[1] [4],0,91% j[2] [4],0,91% rm[-1,-2] #paste lower band
    +f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
    +f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
    +f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0) #masks
    -|[-3--1] +. 0.33 /. 1.33	#1 and 0.25
    *[2,-1] a c hsv2rgb
  fi endl

#@gui Equalize HSI-HSL-HSV : fx_equalize_hsv, fx_equalize_hsv_preview(0)+
#@gui : Colorspace = choice(1,"HSI","HSL","HSV")
#@gui : Opacity (%) = float(100,0,100)
#@gui : Value Blending = float(0,0,64)
#@gui : Color Blending = float(0,0,64)
#@gui : sep = separator()
#@gui : Preview Mapping = choice("None","Grey","Color")
#@gui : sep = separator(), note = note("<small><b>Black:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Near black:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Dark grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Mi-dark grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Middle grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Mid-light grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Light grey:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>Highlights:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), note = note("<small><b>White:</b></small>")
#@gui : Hue Offset = float(0,-180,180)
#@gui : Saturation Offset = float(0,-1,1)
#@gui : Value Offset = float(0,-1,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>David Revoy</i>.      Latest Update: <i>2018/01/19</i>.</small>")
fx_equalize_hsv :
  cs=${"arg 1+$1,hsi,hsl,hsv"}
  repeat $! l[$>] split_opacity l[0]
    to_rgb
    9,1,1,4,\
    {"V = [${6-30:3}]*pi/180; [cos(V),sin(V)]"},${7-31:3},\
    {"V = [${8-32:3}];
      const sV = size(V);
      for (k = 0, k<sV, ++k,
        v0 = k/sV;
        v1 = (k+1)/sV;
        V[k]*=(V[k]>0?(1 - v0):v1);
      ); V"}
    r. 256,1,1,4,1
    sh. 3 b. $3 rm.   # Value smoothness
    f. "[ atan2(G,R)*180/pi,B,A,0 ]" channels. 0,2
    +rgb2$cs.. +channels. 100% *. 256 round. map. ...
    +[-2,-1] rm.. +channels. 100% ${cs}2rgb..
    if $4 # Spatial smoothness
      *. 255 bilateral.. .,$4,{2+$4}
      rgb2$cs.. /. 255 j.. .,0,0,0,2 ${cs}2rgb..
    fi
    rm.
    blend alpha,{$2%}
  endl a c endl done

fx_equalize_hsv_preview :
  if $5
    cs=${"arg 1+$1,hsi,hsl,hsv"}
    rm {0.8*[${-gui_preview_wh}]},1,3,\
    "$5==1?
       (H = S = 0; V = y/(h-1)):
       (H = x*360/(w-1); S = y/(h-1); V = y/(h-1));
     [H,S,V]"
    ${cs}2rgb.
  fi
  gui_split_preview "fx_equalize_hsv $*",${-3--1}
  if $5 r. ${-gui_preview_wh},1,3,0,0,0.5,0.5 fi

#@gui Mixer [CMYK] : fx_mix_cmyk, fx_mix_cmyk_preview(1)+
#@gui : Cyan Factor = float(1,0,4)
#@gui : Cyan Shift = float(0,-255,255)
#@gui : Cyan Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Magenta Factor = float(1,0,4)
#@gui : Magenta Shift = float(0,-255,255)
#@gui : Magenta Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Yellow Factor = float(1,0,4)
#@gui : Yellow Shift = float(0,-255,255)
#@gui : Yellow Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Key Factor = float(1,0,4)
#@gui : Key Shift = float(0,-255,255)
#@gui : Key Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_cmyk :
  repeat $! l. split_opacity rv to_rgb.
    fx_start_mix $13,$14
    rgb2cmyk. s. c
    *[-4] $1 +[-4] $2 b[-4] $3%
    *... $4 +... $5 b... $6%
    *.. $7 +.. $8 b.. $9%
    *. $10 +. $11 b. $12%
    a[-4--1] c cmyk2rgb.
    fx_end_mix $13
  if {$!!=3} rv a c fi endl mv. 0 done

fx_mix_cmyk_preview :
  gui_split_preview "fx_mix_cmyk $*",${-3--1}

#@gui Mixer [HSV] : fx_mix_hsv, fx_mix_hsv_preview(1)+
#@gui : Hue Factor = float(1,0,4)
#@gui : Hue Shift = float(0,-180,180)
#@gui : Hue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Saturation Factor = float(1,0,4)
#@gui : Saturation Shift = float(0,-1,1)
#@gui : Saturation Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Value Factor = float(1,0,4)
#@gui : Value Shift = float(0,-1,1)
#@gui : Value Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_hsv :
  repeat $! l. split_opacity rv to_rgb.
    fx_start_mix $10,$11
    rgb2hsv. s. c -[-2,-1] 0.5
    *... $1 +... $2 b... $3%
    *.. $4 +.. $5 b.. $6%
    *. $7 +. $8 b. $9%
    %... 360 +[-2,-1] 0.5 c[-2,-1] 0,1 a[-3--1] c hsv2rgb.
    fx_end_mix $10
  if {$!!=3} rv a c fi endl mv. 0 done

fx_mix_hsv_preview :
  gui_split_preview "fx_mix_hsv $*",${-3--1}

#@gui Mixer [Lab] : fx_mix_lab, fx_mix_lab_preview(1)+
#@gui : Lightness Factor = float(1,0.5,1.5)
#@gui : Lightness Shift = float(0,-50,50)
#@gui : Lightness Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : A-Color Factor = float(1,0,4)
#@gui : A-Color Shift = float(0,-20,20)
#@gui : A-Color Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : B-Color Factor = float(1,0,4)
#@gui : B-Color Shift = float(0,-20,20)
#@gui : B-Color Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_lab :
  repeat $! l[$>] split_opacity to_rgb[0]
    gui_parallel_overlap[0] "_fx_mix_lab $*",0,{3*max($3,$6,$9)}
    a c
  endl mv[$>] 0 done

_fx_mix_lab :
  fx_start_mix $10,$11
  rgb2lab. s. c
  *... $1 +... $2 b... $3%
  *.. $4 +.. $5 b.. $6%
  *. $7 +. $8 b. $9%
  a[-3--1] c lab2rgb.
  fx_end_mix $10

fx_mix_lab_preview :
  gui_split_preview "fx_mix_lab $*",${-3--1}

#@gui Mixer [PCA] : fx_mix_pca, fx_mix_pca_preview(1)+
#@gui : Primary Factor = float(0,-1.5,1.5)
#@gui : Primary Shift = float(0,-255,255)
#@gui : Primary Twist = float(0,-180,180)
#@gui : sep = separator()
#@gui : Secondary Factor = float(0,-1.5,1.5)
#@gui : Secondary Shift = float(0,-255,255)
#@gui : Secondary Twist = float(0,-180,180)
#@gui : sep = separator()
#@gui : Tertiary Factor = float(0,-1.5,1.5)
#@gui : Tertiary Shift = float(0,-255,255)
#@gui : Tertiary Twist = float(0,-180,180)
#@gui : sep = separator()
#@gui : Display Color Axes = bool(1)
#@gui : Stats = value(-1,-1,-1,-1)
#@gui : Avg Covariance = value(0,0,0,0,0,0,0,0,0,0,0,0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/07/18</i>.</small>")
fx_mix_pca :
  repeat $! l[$>] split_opacity l[0] to_rgb

    # Get image covariance (and remember it to speed up multiple calls of the filter).
    if {[${11-14}]==round(stats()[0,4],0.1)} _avg=${15-17} C=${18-26} status=
    else
      +rr2d 256,256,0,2 C=${"covariance_colors. _avg"} rm.
      __status="{$1}{$2}{$3}{$4}{$5}{$6}{$7}{$8}{$9}{$10}{"{round(stats()[0,4],0.1)}"}{"$_avg,$C"}{$27}{${28,29}}"
    fi

    f "begin(
         avg = ["$_avg"];
         eig = eig(["$C"]);
         for (k = 3, k<12, k+=3, eig[k]<0?copy(eig[k],eig[k,3]*=-1,3));
         Pt = eig[3,9];
         P = transp(Pt,3);
         T = mul(P,mul(diag(10^[$1,$4,$7]),Pt,3),3);

         R1 = rot(eig[3,3],$3);
         R2 = rot(eig[6,3],$6);
         R3 = rot(eig[9,3],$9);
         T = mul(R1,mul(R2,mul(R3,T,3),3),3);
         avg_shift = avg + $2*eig[3,3] + $5*eig[6,3] + $8*eig[9,3];

         if ("0$_is_preview",
           L = [ 2,5,10]*sqrt(1e-5 + eig[0,3]);
           ext('__cols=',vtos(round([
             avg - L[0]*eig[3,3],
             avg + L[0]*eig[3,3],
             avg - L[1]*eig[6,3],
             avg + L[1]*eig[6,3],
             avg - L[2]*eig[9,3],
             avg + L[2]*eig[9,3] ])));
         );
       );
       avg_shift + T*(I - avg)"
    c 0,255
  endl a c endl done u $__status

fx_mix_pca_preview :
  _is_preview=1
  __status=
  repeat $! l[$>]
    gui_split_preview "fx_mix_pca $*",${-3--1}
    if $10
      rr2d ${-gui_preview_wh},0,1
      ($__cols) r. 3,6,1,1,-1 permute. yzcx s. x,3
      r[-3--1] {w#0/2},13,1,3,3 c[-3--1] 0,255
      frame[-3--1] 1,1,0
      to[0] Primary,4,2,13,1 j[0] ...,64,4
      to[0] Secondary,4,17,13,1 j[0] ..,64,19
      to[0] Tertiary,4,32,13,1 j[0] .,64,34
      k[0]
    fi
  endl done
  u $__status

#@gui Mixer [RGB] : fx_mix_rgb, fx_mix_rgb_preview(1)+
#@gui : Red Factor = float(1,0,4)
#@gui : Red Shift = float(0,-255,255)
#@gui : Red Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Green Factor = float(1,0,4)
#@gui : Green Shift = float(0,-255,255)
#@gui : Green Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Blue Factor = float(1,0,4)
#@gui : Blue Shift = float(0,-255,255)
#@gui : Blue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_start_mix :
  if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
  elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
  elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
  fi
fx_end_mix :
  if {$1==1} *[-3,-1] +[-2,-1]
  elif {$1==2} *[-2,-1] +[-2,-1]
  elif {$1==3} *[-2,-1] +[-2,-1]
  fi
  c 0,255

fx_mix_rgb :
  repeat $! l. split_opacity rv to_rgb.
    fx_start_mix $10,$11
    -. 128 s. c
    *... $1 +... $2 b... $3%
    *.. $4 +.. $5 b.. $6%
    *. $7 +. $8 b. $9%
    a[-3--1] c +. 128 c. 0,255
    fx_end_mix $10
  if {$!!=3} rv a c fi endl mv. 0 done

fx_mix_rgb_preview :
  gui_split_preview "fx_mix_rgb $*",${-3--1}

#@gui Mixer [YCbCr] : fx_mix_ycbcr, fx_mix_ycbcr_preview(1)+
#@gui : Luminance Factor = float(1,0,4)
#@gui : Luminance Shift = float(0,-255,255)
#@gui : Luminance Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Blue Chroma Factor = float(1,0,4)
#@gui : Blue Chroma Shift = float(0,-255,255)
#@gui : Blue Chroma Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Red Chroma Factor = float(1,0,4)
#@gui : Red Chroma Shift = float(0,-255,255)
#@gui : Red Chroma Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Tones Range = choice("All Tones","Shadows","Mid-Tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_mix_ycbcr :
  repeat $! l. split_opacity rv to_rgb.
    fx_start_mix $10,$11
    rgb2ycbcr. -. 128 s. c
    *... $1 +... $2 b... $3%
    *.. $4 +.. $5 b.. $6%
    *. $7 +. $8 b. $9%
    a[-3--1] c +. 128 c. 0,255 ycbcr2rgb.
    fx_end_mix $10
  if {$!!=3} rv a c fi endl mv. 0 done

fx_mix_ycbcr_preview :
  gui_split_preview "fx_mix_ycbcr $*",${-3--1}

#@gui CLUT from After / Before Layers : fx_clut_from_ab, fx_clut_from_ab_preview
#@gui : Output CLUT Resolution = _choice("512 x 512","4096 x 4096")
#@gui : Influence of Color Samples (%) = float(50,0,100)
#@gui : sep = separator()
#@gui : note = note{"<b>What is this filter for?</b>\n\n
#@gui : This filter requires at least two input layers to work properly.\n
#@gui : It assumes you have an input top layer <b>A</b> and a base layer <b>B</b> such that <b>A</b> and <b>B</b> both represent the same image but with only color variations
#@gui : (typically <b>A</b> has been obtained from <b>B</b> using the color curves tool).\n\n
#@gui : This filter is then able to estimate and outputs a color HaldCLUT <b>H</b> so that applying <b>H</b> on the base layer <b>B</b> gives back <b>A</b>.\n\n
#@gui : This is useful when you have a color transformation between two images, that you want to recover and re-apply on a bunch of other images.
#@gui : "}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/07/25</i>.</small>")
fx_clut_from_ab :
  if {$!<2} error "At least two input layers are needed to run this filter." fi
  repeat {$!-1} l[$<,-1] nm=${gui_layer_name..}
    64,64,64,4 f[0] ">I(#2,round(I(#1)*(w#2-1)/255))+=[R,G,B,1]; I" rm[0]
    s. c,-3 +max. 1 /[-3,-1] ==. 0
    inpaint_diffusion.. .,75%,1
    distance. 0 *. {-1/(1+$2)} exp.
    f.. "f = i(#-1); f*I + (1-f)*[x,y,z]*255/(w-1)"
    rm.
    if $1 r. 256,256,256,3,3 fi
    r. {s=whd^0.5;[s,s]},1,3,-1
    rv nm[0] "name(CLUT to '"$nm"')"
  endl done
  if $_output_mode rm. fi


fx_clut_from_ab_preview :
  if {$!<2} gui_warning_preview "At least two input layers are needed to run this filter." return fi
  fx_clut_from_ab 0,$2

#@gui Retinex : fx_retinex, fx_retinex_preview(0)+
#@gui : Strength (%) = float(75,0,100)
#@gui : Value Offset = float(16,1,256)
#@gui : Colorspace = choice(1,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Min Cut (%) = float(1,0,100)
#@gui : Max Cut (%) = float(1,0,100)
#@gui : Regularization = float(5,0,32)
#@gui : sep = separator()
#@gui : Low Scale = float(15,1,512)
#@gui : Middle Scale = float(80,1,512)
#@gui : High Scale = float(250,1,512)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> This filter implements the <i>Multiscale Color Retinex</i> algorithm, as described in:</small>")
#@gui : url = link{"http://www.ipol.im/pub/art/2014/107/"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/13/09</i>.</small>")
fx_retinex :
  repeat $! l[$>]
    +retinex $2,${"arg 1+$3,hsi,hsv,lab,lrgb,rgb,ycbcr"},$4,$5,${7--1}
    if $6 guided. ..,$6,$6 fi
    j[0] .,0,0,0,0,{$1%} rm.
    c 0,255
  endl done

fx_retinex_preview :
  gui_split_preview "fx_retinex $*",${-3--1}

#@gui Retro Fade : fx_retrofade, fx_retrofade_preview
#@gui : Iterations = int(20,1,64)
#@gui : Colors = int(6,2,32)
#@gui : Grain = float(40,1,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/25/10</i>.</small>")
fx_retrofade :
  repeat $! l[$>] split_opacity l[0]
    +f 0
    repeat $1
      +noise[0] $3 c. 0,255 autoindex. $2,0,0
      +[-2,-1]
      progress {$>*100/$1}
    done
    k. n 0,255
    progress 100
  endl a c endl done

fx_retrofade_preview :
  gui_split_preview "fx_retrofade $*",${-3--1}

#@gui Select-Replace Color : fx_select_color, fx_select_color_preview(0)
#@gui : Similarity Space = choice(0,"RGB[A]","RGB","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue &amp; Red Chrominances","Hue","Saturation")
#@gui : Tolerance = float(20,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Fill Holes = int(0,0,256)
#@gui : Selected Color = color(255,255,255,255)
#@gui : Output As = choice(0,"Selected Colors","Selected Mask","Rejected Colors","Rejected Mask","Replaced Color")
#@gui : Replacement Color = color(255,0,0,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_select_color :
  if {$1==1} to_rgb                            # RGB
  elif {$1==2} to_rgb rgb2ycbcr               # YCbCr
  elif {$1==3} channels 0                      # R
  elif {$1==4} channels 1                      # G
  elif {$1==5} channels 2                      # B
  elif {$1==6} to_rgba channels 3             # Opacity
  elif {$1==7} to_rgb rgb2ycbcr channels 0   # Luminance
  elif {$1==8} to_rgb rgb2ycbcr channels 1,2 # B&R chrominances
  elif {$1==9} to_rgb rgb2hsv channels 0     # Hue
  elif {$1==10} to_rgb rgb2hsv channels 1    # Saturation
  fi

fx_select_color :
  ($5^$6^$7^$8) _fx_select_color. $1 color={^} rm.
  repeat $! l[$>] to_rgba
    +_fx_select_color $1
    select_color[1] $2%,$color
    if $4 +area. 0,0 <=. {round($4^1.5)} inpaint.. .,0,3 rm. fi # Fill holes.
    b[1] $3 n[1] 0,255
    if {$9==0} sh[0] 100% &. [1]                        # Selected colors.
    elif {$9==1} rm[0]                                   # Selected mask.
    elif {$9==2} -[1] 255 *[1] -1 sh[0] 100% &. [1]   # Rejected colors.
    elif {$9==3} rm[0] - 255 * -1                      # Rejected mask.
    else # Replaced color.
      /[1] 255 +*[0,1] +*[1] $11 +*[1] $12 +*[1] $13 *[1] $10 a[1,-3--1] c -[1,2] +
    fi
    k[0]
  endl done

fx_select_color_preview :
  gui_split_preview "fx_select_color $*",${-3--1}

#@gui Selective Desaturation : fx_selective_desaturation, fx_selective_desaturation_preview(1)
#@gui : Reference Color = color(255,255,255)
#@gui : Desaturate = choice("Reference Color","All but Reference Color")
#@gui : Strength = float(3,0,10)
#@gui : Regularization = int(0,0,20)
#@gui : Maximum Saturation = choice("From Input","From Reference Color","Maximum Value")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/15/07</i>.</small>")
fx_selective_desaturation :
  repeat $! l[$>] to_color split_opacity l[0]
    +fc $1,$2,$3
    -[1] [0] norm[1] /[1] {1e-6+iM}
    if $4 *[1] -{max(0.01,$5)} +[1] 1
    else >=[1] {5*$5}%
    fi
    c[1] 0,1
    rgb2hsl[0] s[0] c
    mM={[im,iM]} repeat $6 guided. [2],1,0.1 done n. $mM # Regularization step.
    if {$7==0} *[1,-1]
    elif {$7==1} ($1^$2^$3) rgb2hsl. *[1] {i[1]} rm[-2,-1]
    else rv[1,-1] rm.
    fi
    a c hsl2rgb
  endl a c endl done

fx_selective_desaturation_preview :
  gui_split_preview "fx_selective_desaturation $*",${-3--1}

#@gui Sepia : fx_sepia, fx_sepia_preview(1)+
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sepia :
  sepia adjust_colors ${1-3},0,0,0,255

fx_sepia_preview :
  gui_split_preview "fx_sepia $*",${-3--1}

#@gui Simulate Film : fx_simulate_film, fx_simulate_film_preview(1)+
#@gui : Category = choice{"Black & White","Instant [Consumer]","Instant [Pro]","Fuji XTrans III","Negative [Color]","Negative [New]","Negative [Old]","Print Films","Slide [Color]"}

##### Black & White
#@gui : Preset = choice{"None",
#@gui : "Agfa APX 100","Agfa APX 25","Fuji Neopan 1600","Fuji Neopan Acros 100","Ilford Delta 100","Ilford Delta 3200","Ilford Delta 400","Ilford FP4 Plus 125",
#@gui : "Ilford HP5 Plus 400","Ilford HPS 800","Ilford Pan F Plus 50","Ilford XP2","Kodak BW 400 CN","Kodak HIE (HS Infra)","Kodak T-Max 100","Kodak T-Max 3200",
#@gui : "Kodak T-Max 400","Kodak Tri-X 400","Polaroid 664","Polaroid 667","Polaroid 672","Rollei IR 400","Rollei Ortho 25","Rollei Retro 100 Tonal","Rollei Retro 80s"}_2

##### Instant [Consumer]
#@gui : Preset = choice{"None",
#@gui : "Polaroid PX-100UV+ Cold --","Polaroid PX-100UV+ Cold -","Polaroid PX-100UV+ Cold","Polaroid PX-100UV+ Cold +","Polaroid PX-100UV+ Cold ++","Polaroid PX-100UV+ Cold +++",
#@gui : "Polaroid PX-100UV+ Warm --","Polaroid PX-100UV+ Warm -","Polaroid PX-100UV+ Warm","Polaroid PX-100UV+ Warm +","Polaroid PX-100UV+ Warm ++","Polaroid PX-100UV+ Warm +++",
#@gui : "Polaroid PX-680 --","Polaroid PX-680 -","Polaroid PX-680","Polaroid PX-680 +","Polaroid PX-680 ++",
#@gui : "Polaroid PX-680 Cold --","Polaroid PX-680 Cold -","Polaroid PX-680 Cold","Polaroid PX-680 Cold +","Polaroid PX-680 Cold ++","Polaroid PX-680 Cold ++a",
#@gui : "Polaroid PX-680 Warm --","Polaroid PX-680 Warm -","Polaroid PX-680 Warm","Polaroid PX-680 Warm +","Polaroid PX-680 Warm ++",
#@gui : "Polaroid PX-70 --","Polaroid PX-70 -","Polaroid PX-70","Polaroid PX-70 +","Polaroid PX-70 ++","Polaroid PX-70 +++",
#@gui : "Polaroid PX-70 Cold --","Polaroid PX-70 Cold -","Polaroid PX-70 Cold","Polaroid PX-70 Cold +","Polaroid PX-70 Cold ++",
#@gui : "Polaroid PX-70 Warm --","Polaroid PX-70 Warm -","Polaroid PX-70 Warm","Polaroid PX-70 Warm +","Polaroid PX-70 Warm ++",
#@gui : "Polaroid Time Zero (Expired) ---","Polaroid Time Zero (Expired) --","Polaroid Time Zero (Expired) -","Polaroid Time Zero (Expired)","Polaroid Time Zero (Expired) +","Polaroid Time Zero (Expired) ++",
#@gui : "Polaroid Time Zero (Expired) Cold ---","Polaroid Time Zero (Expired) Cold --","Polaroid Time Zero (Expired) Cold -","Polaroid Time Zero (Expired) Cold"}_0

##### Instant [Pro]
#@gui : Preset = choice{"None",
#@gui : "Fuji FP-100c --","Fuji FP-100c -","Fuji FP-100c","Fuji FP-100c (alt)","Fuji FP-100c +","Fuji FP-100c ++","Fuji FP-100c ++a","Fuji FP-100c +++",
#@gui : "Fuji FP-100c Cool --","Fuji FP-100c Cool -","Fuji FP-100c Cool","Fuji FP-100c Cool +","Fuji FP-100c Cool ++",
#@gui : "Fuji FP-100c Negative --","Fuji FP-100c Negative -","Fuji FP-100c Negative","Fuji FP-100c Negative +","Fuji FP-100c Negative ++","Fuji FP-100c Negative ++a","Fuji FP-100c Negative +++",
#@gui : "Fuji FP-3000b --","Fuji FP-3000b -","Fuji FP-3000b","Fuji FP-3000b +","Fuji FP-3000b ++","Fuji FP-3000b +++",
#@gui : "Fuji FP-3000b HC",
#@gui : "Fuji FP-3000b Negative --","Fuji FP-3000b Negative -","Fuji FP-3000b Negative","Fuji FP-3000b Negative +","Fuji FP-3000b Negative ++","Fuji FP-3000b Negative +++",
#@gui : "Fuji FP-3000b Negative Early",
#@gui : "Polaroid 665 --","Polaroid 665 -","Polaroid 665","Polaroid 665 +","Polaroid 665 ++",
#@gui : "Polaroid 665 Negative -","Polaroid 665 Negative","Polaroid 665 Negative +",
#@gui : "Polaroid 665 Negative HC",
#@gui : "Polaroid 669 --","Polaroid 669 -","Polaroid 669","Polaroid 669 +","Polaroid 669 ++","Polaroid 669 +++",
#@gui : "Polaroid 669 Cold --","Polaroid 669 Cold -","Polaroid 669 Cold","Polaroid 669 Cold +",
#@gui : "Polaroid 690 --","Polaroid 690 -","Polaroid 690","Polaroid 690 +","Polaroid 690 ++",
#@gui : "Polaroid 690 Cold --","Polaroid 690 Cold -","Polaroid 690 Cold","Polaroid 690 Cold +","Polaroid 690 Cold ++",
#@gui : "Polaroid 690 Warm --","Polaroid 690 Warm -","Polaroid 690 Warm","Polaroid 690 Warm +","Polaroid 690 Warm ++"}_0

#### Fuji XTrans III
#@gui : Preset = choice{"None",
#@gui : "Acros","Acros+G","Acros+R","Acros+Ye","Astia","Classic Chrome","Mono","Mono+G","Mono+R","Mono+Ye",
#@gui : "Pro Neg Hi","Pro Neg Std","Provia","Sepia","Velvia"}_0

##### Negative [Color]
#@gui : Preset = choice{"None",
#@gui : "Agfa Ultra Color 100","Agfa Vista 200","Fuji Superia 200","Fuji Superia HG 1600","Fuji Superia Reala 100","Fuji Superia X-Tra 800","Kodak Ektar 100",
#@gui : "Kodak Elite 100 XPRO","Kodak Elite Color 200","Kodak Elite Color 400","Kodak Portra 160 NC","Kodak Portra 160 VC","Lomography Redscale 100"}_0

##### Negative [New]
#@gui : Preset = choice{"None",
#@gui : "Fuji 160C -","Fuji 160C","Fuji 160C +","Fuji 160C ++",
#@gui : "Fuji 400H -","Fuji 400H","Fuji 400H +","Fuji 400H ++",
#@gui : "Fuji 800Z -","Fuji 800Z","Fuji 800Z +","Fuji 800Z ++",
#@gui : "Fuji Ilford HP5 -","Fuji Ilford HP5","Fuji Ilford HP5 +","Fuji Ilford HP5 ++",
#@gui : "Kodak Portra 160 -","Kodak Portra 160","Kodak Portra 160 +","Kodak Portra 160 ++",
#@gui : "Kodak Portra 400 -","Kodak Portra 400","Kodak Portra 400 +","Kodak Portra 400 ++",
#@gui : "Kodak Portra 800 -","Kodak Portra 800","Kodak Portra 800 +","Kodak Portra 800 ++","Kodak Portra 800 HC",
#@gui : "Kodak T-MAX 3200 -","Kodak T-MAX 3200","Kodak T-MAX 3200 +","Kodak T-MAX 3200 ++","Kodak T-MAX 3200 (alt)",
#@gui : "Kodak TRI-X 400 -","Kodak TRI-X 400","Kodak TRI-X 400 +","Kodak TRI-X 400 ++","Kodak TRI-X 400 (alt)"}_0

##### Negative [Old]
#@gui : Preset = choice{"None",
#@gui : "Fuji Ilford Delta 3200 -","Fuji Ilford Delta 3200","Fuji Ilford Delta 3200 +","Fuji Ilford Delta 3200 ++",
#@gui : "Fuji Neopan 1600 -","Fuji Neopan 1600","Fuji Neopan 1600 +","Fuji Neopan 1600 ++",
#@gui : "Fuji Superia 100 -","Fuji Superia 100","Fuji Superia 100 +","Fuji Superia 100 ++",
#@gui : "Fuji Superia 400 -","Fuji Superia 400","Fuji Superia 400 +","Fuji Superia 400 ++",
#@gui : "Fuji Superia 800 -","Fuji Superia 800","Fuji Superia 800 +","Fuji Superia 800 ++",
#@gui : "Fuji Superia 1600 -","Fuji Superia 1600","Fuji Superia 1600 +","Fuji Superia 1600 ++",
#@gui : "Kodak Portra 160 NC -","Kodak Portra 160 NC","Kodak Portra 160 NC +","Kodak Portra 160 NC ++",
#@gui : "Kodak Portra 160 VC -","Kodak Portra 160 VC","Kodak Portra 160 VC +","Kodak Portra 160 VC ++",
#@ŋui : "Kodak Portra 400 NC -","Kodak Portra 400 NC","Kodak Portra 400 NC +","Kodak Portra 400 NC ++",
#@gui : "Kodak Portra 400 UC -","Kodak Portra 400 UC","Kodak Portra 400 UC +","Kodak Portra 400 UC ++",
#@gui : "Kodak Portra 400 VC -","Kodak Portra 400 VC","Kodak Portra 400 VC +","Kodak Portra 400 VC ++"}_0

##### Print Films
#@gui : Preset = choice{"None","Fuji 3510 (Constlclip)","Fuji 3510 (Constlmap)","Fuji 3510 (Cuspclip)",
#@gui : "Fuji 3513 (Constlclip)","Fuji 3513 (Constlmap)","Fuji 3513 (Cuspclip)",
#@gui : "Kodak 2383 (Constlclip)","Kodak 2383 (Constlmap)","Kodak 2383 (Cuspclip)",
#@gui : "Kodak 2393 (Constlclip)","Kodak 2393 (Constlmap)","Kodak 2393 (Cuspclip)"}_0

#### Slide [Color]
#@gui : Preset = choice{"None",
#@gui : "Agfa Precisa 100","Fuji Astia 100F","Fuji FP 100C","Fuji Provia 100F","Fuji Provia 400F","Fuji Provia 400X","Fuji Sensia 100",
#@gui : "Fuji Superia 200 XPRO","Fuji Velvia 50","Generic Fuji Astia 100","Generic Fuji Provia 100","Generic Fuji Velvia 100",
#@gui : "Generic Kodachrome 64","Generic Kodak Ektachrome 100 VS","Kodak E-100 GX Ektachrome 100","Kodak Ektachrome 100 VS","Kodak Elite Chrome 200",
#@gui : "Kodak Elite Chrome 400","Kodak Elite ExtraColor 100","Kodak Kodachrome 200","Kodak Kodachrome 25","Kodak Kodachrome 64","Lomography X-Pro Slide 200",
#@gui : "Polaroid 669","Polaroid 690","Polaroid Polachrome"}_0

#@gui : sep = separator()
#@gui : Strength (%) = float(100,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : Normalize Colors = choice("None","Pre-Process","Post-Process","Both")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> The color LUTs proposed in this filter come from various free sources :</small>")
#@gui : note = note{"<small><b>*</b> <a href="https://rawpedia.rawtherapee.com/Film_Simulation">RawTherapee Film Simulation</a>.</small>"}
#@gui : note = note{"<small><b>*</b> <a href="https://patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html">Pat David Film Emulation</a>.</small>"}
#@gui : note = note{"<small><b>*</b> <a href="http://blog.sowerby.me/fuji-film-simulation-profiles">Fuji Film Simulation Profiles</a>.</small>"}
#@gui : note = note{"<small><b>*</b> <a href="http://juanmelara.com.au/print-film-emulation-luts-for-download/">Print Film LUTs For Download</a>.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2019/02/27</i>.</small>")
fx_simulate_film :
  category=${arg\ 1+$1,bw,instant_consumer,instant_pro,fujixtransiii,negative_color,negative_new,negative_old,print,colorslide}
  presets=${-_fx_cluts_$category}
  index={arg(1+$1,${2-10})}
  preset=${arg\ {max(1,$index)},$presets}
  _fx_cluts $index,$preset,${11--1}

fx_simulate_film_preview :
  gui_split_preview "fx_simulate_film $*",${-3--1}
  u "{$1}{$2}_"{2*($1==0)}\
        "{$3}_"{2*($1==1)}\
        "{$4}_"{2*($1==2)}\
        "{$5}_"{2*($1==3)}\
        "{$6}_"{2*($1==4)}\
        "{$7}_"{2*($1==5)}\
        "{$8}_"{2*($1==6)}\
        "{$9}_"{2*($1==7)}\
        "{$10}_"{2*($1==8)}\
        "{$11}{$12}{$13}{$14}{$15}{$16}{$17}{$18}{$19,$20}"

_fx_cluts_bw :
  u agfa_apx_100,agfa_apx_25,fuji_neopan_1600,fuji_neopan_acros_100,ilford_delta_100,ilford_delta_3200,ilford_delta_400,ilford_fp_4_plus_125,\
    ilford_hp_5_plus_400,ilford_hps_800,ilford_pan_f_plus_50,ilford_xp_2,kodak_bw_400_cn,kodak_hie_hs_infra,kodak_t-max_100,kodak_t-max_3200,\
    kodak_t-max_400,kodak_tri-x_400,polaroid_664,polaroid_667,polaroid_672,rollei_ir_400,rollei_ortho_25,rollei_retro_100_tonal,rollei_retro_80s

_fx_cluts_instant_consumer :
  u polaroid_px-100uv+_cold_--,polaroid_px-100uv+_cold_-,polaroid_px-100uv+_cold,polaroid_px-100uv+_cold_+,polaroid_px-100uv+_cold_++,polaroid_px-100uv+_cold_+++,\
    polaroid_px-100uv+_warm_--,polaroid_px-100uv+_warm_-,polaroid_px-100uv+_warm,polaroid_px-100uv+_warm_+,polaroid_px-100uv+_warm_++,polaroid_px-100uv+_warm_+++,\
    polaroid_px-680_--,polaroid_px-680_-,polaroid_px-680,polaroid_px-680_+,polaroid_px-680_++,\
    polaroid_px-680_cold_--,polaroid_px-680_cold_-,polaroid_px-680_cold,polaroid_px-680_cold_+,polaroid_px-680_cold_++,polaroid_px-680_cold_++_alt,\
    polaroid_px-680_warm_--,polaroid_px-680_warm_-,polaroid_px-680_warm,polaroid_px-680_warm_+,polaroid_px-680_warm_++,\
    polaroid_px-70_--,polaroid_px-70_-,polaroid_px-70,polaroid_px-70_+,polaroid_px-70_++,polaroid_px-70_+++,\
    polaroid_px-70_cold_--,polaroid_px-70_cold_-,polaroid_px-70_cold,polaroid_px-70_cold_+,polaroid_px-70_cold_++,\
    polaroid_px-70_warm_--,polaroid_px-70_warm_-,polaroid_px-70_warm,polaroid_px-70_warm_+,polaroid_px-70_warm_++,\
    polaroid_time_zero_expired_---,polaroid_time_zero_expired_--,polaroid_time_zero_expired_-,polaroid_time_zero_expired,polaroid_time_zero_expired_+,polaroid_time_zero_expired_++,\
    polaroid_time_zero_expired_cold_---,polaroid_time_zero_expired_cold_--,polaroid_time_zero_expired_cold_-,polaroid_time_zero_expired_cold

_fx_cluts_instant_pro :
  u fuji_fp-100c_--,fuji_fp-100c_-,fuji_fp-100c,fuji_fp-100c_alt,fuji_fp-100c_+,fuji_fp-100c_++,fuji_fp-100c_++_alt,fuji_fp-100c_+++,\
    fuji_fp-100c_cool_--,fuji_fp-100c_cool_-,fuji_fp-100c_cool,fuji_fp-100c_cool_+,fuji_fp-100c_cool_++,\
    fuji_fp-100c_negative_--,fuji_fp-100c_negative_-,fuji_fp-100c_negative,fuji_fp-100c_negative_+,fuji_fp-100c_negative_++,fuji_fp-100c_negative_++_alt,fuji_fp-100c_negative_+++,\
    fuji_fp-3000b_--,fuji_fp-3000b_-,fuji_fp-3000b,fuji_fp-3000b_+,fuji_fp-3000b_++,fuji_fp-3000b_+++,fuji_fp-3000b_hc,\
    fuji_fp-3000b_negative_--,fuji_fp-3000b_negative_-,fuji_fp-3000b_negative,fuji_fp-3000b_negative_+,fuji_fp-3000b_negative_++,fuji_fp-3000b_negative_+++,fuji_fp-3000b_negative_early,\
    polaroid_665_--,polaroid_665_-,polaroid_665,polaroid_665_+,polaroid_665_++,\
    polaroid_665_negative_-,polaroid_665_negative,polaroid_665_negative_+,polaroid_665_negative_hc,\
    polaroid_669_--,polaroid_669_-,polaroid_669,polaroid_669_+,polaroid_669_++,polaroid_669_+++,\
    polaroid_669_cold_--,polaroid_669_cold_-,polaroid_669_cold,polaroid_669_cold_+,\
    polaroid_690_--,polaroid_690_-,polaroid_690,polaroid_690_+,polaroid_690_++,\
    polaroid_690_cold_--,polaroid_690_cold_-,polaroid_690_cold,polaroid_690_cold_+,polaroid_690_cold_++,\
    polaroid_690_warm_--,polaroid_690_warm_-,polaroid_690_warm,polaroid_690_warm_+,polaroid_690_warm_++

_fx_cluts_fujixtransiii :
  u fuji_xtrans_iii_acros,fuji_xtrans_iii_acros+g,fuji_xtrans_iii_acros+r,fuji_xtrans_iii_acros+ye,fuji_xtrans_iii_astia,\
    fuji_xtrans_iii_classic_chrome,fuji_xtrans_iii_mono,fuji_xtrans_iii_mono+g,fuji_xtrans_iii_mono+r,fuji_xtrans_iii_mono+ye,\
    fuji_xtrans_iii_pro_neg_hi,fuji_xtrans_iii_pro_neg_std,fuji_xtrans_iii_provia,fuji_xtrans_iii_sepia,fuji_xtrans_iii_velvia

_fx_cluts_negative_color :
  u agfa_ultra_color_100,agfa_vista_200,fuji_superia_200,fuji_superia_hg_1600,fuji_superia_reala_100,fuji_superia_x-tra_800,kodak_ektar_100,\
    kodak_elite_100_xpro,kodak_elite_color_200,kodak_elite_color_400,kodak_portra_160_nc,kodak_portra_160_vc,lomography_redscale_100

_fx_cluts_negative_new :
  u fuji_160c_-,fuji_160c,fuji_160c_+,fuji_160c_++,\
    fuji_400h_-,fuji_400h,fuji_400h_+,fuji_400h_++,\
    fuji_800z_-,fuji_800z,fuji_800z_+,fuji_800z_++,\
    ilford_hp_5_-,ilford_hp_5,ilford_hp_5_+,ilford_hp_5_++,\
    kodak_portra_160_-,kodak_portra_160,kodak_portra_160_+,kodak_portra_160_++,\
    kodak_portra_400_-,kodak_portra_400,kodak_portra_400_+,kodak_portra_400_++,\
    kodak_portra_800_-,kodak_portra_800,kodak_portra_800_+,kodak_portra_800_++,kodak_portra_800_hc,\
    kodak_tmax_3200_-,kodak_tmax_3200,kodak_tmax_3200_+,kodak_tmax_3200_++,kodak_tmax_3200_alt,\
    kodak_tri-x_400_-,kodak_tri-x_400,kodak_tri-x_400_+,kodak_tri-x_400_++,kodak_tri-x_400_alt

_fx_cluts_negative_old :
  u ilford_delta_3200_-,ilford_delta_3200,ilford_delta_3200_+,ilford_delta_3200_++,\
    fuji_neopan_1600_-,fuji_neopan_1600,fuji_neopan_1600_+,fuji_neopan_1600_++,\
    fuji_superia_100_-,fuji_superia_100,fuji_superia_100_+,fuji_superia_100_++,\
    fuji_superia_400_-,fuji_superia_400,fuji_superia_400_+,fuji_superia_400_++,\
    fuji_superia_800_-,fuji_superia_800,fuji_superia_800_+,fuji_superia_800_++,\
    fuji_superia_1600_-,fuji_superia_1600,fuji_superia_1600_+,fuji_superia_1600_++,\
    kodak_portra_160_nc_-,kodak_portra_160_nc,kodak_portra_160_nc_+,kodak_portra_160_nc_++,\
    kodak_portra_160_vc_-,kodak_portra_160_vc,kodak_portra_160_vc_+,kodak_portra_160_vc_++,\
    kodak_portra_400_nc_-,kodak_portra_400_nc,kodak_portra_400_nc_+,kodak_portra_400_nc_++,\
    kodak_portra_400_uc_-,kodak_portra_400_uc,kodak_portra_400_uc_+,kodak_portra_400_uc_++,\
    kodak_portra_400_vc_-,kodak_portra_400_vc,kodak_portra_400_vc_+,kodak_portra_400_vc_++

_fx_cluts_print :
  u fuji_3510_constlclip,fuji_3510_constlmap,fuji_3510_cuspclip,\
    fuji_3513_constlclip,fuji_3513_constlmap,fuji_3513_cuspclip,\
    kodak_2383_constlclip,kodak_2383_constlmap,kodak_2383_cuspclip,\
    kodak_2393_constlclip,kodak_2393_constlmap,kodak_2393_cuspclip

_fx_cluts_colorslide :
  u agfa_precisa_100,fuji_astia_100f,fuji_fp_100c,fuji_provia_100f,fuji_provia_400f,fuji_provia_400x,fuji_sensia_100,\
    fuji_superia_200_xpro,fuji_velvia_50,fuji_astia_100_generic,fuji_provia_100_generic,fuji_velvia_100_generic,\
    kodak_kodachrome_64_generic,kodak_ektachrome_100_vs_generic,kodak_e-100_gx_ektachrome_100,kodak_ektachrome_100_vs,kodak_elite_chrome_200,\
    kodak_elite_chrome_400,kodak_elite_extracolor_100,kodak_kodachrome_200,kodak_kodachrome_25,kodak_kodachrome_64,lomography_x-pro_slide_200,\
    polaroid_669,polaroid_690,polaroid_polachrome

#@gui Transfer Colors [Variational] : fx_transfer_rgb, fx_transfer_rgb_preview(1)+
#@gui : Regularization = int(8,0,32)
#@gui : Preserve Luminance = float(0.2,0,1)
#@gui : Precision = _choice(1,"Low","Normal","High","Very High")
#@gui : Reference Colors = choice("Bottom Layer","Top Layer")
#@gui : Add User-Defined Constraints (Interactive) = _bool(0)
#@gui : sep = separator()
#@gui : Preview Reference = choice(1,"None","Up-Left","Up-Right","Bottom-Left","Bottom-Right")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Instructions:</b>\n
#@gui : - This filter transfers the colors of one layer to all the others.\n
#@gui : - This is a <b>highly</b> experimental filter, it may be unstable or particularly long to render.\n
#@gui : - Don't forget to set the <i>Input layers...</i> option on the left to manage your input layers.\n
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/04/04</i>.</small>")
fx_transfer_rgb :
  to_rgb
  ref={if($4,0,-1)}
  transfer_rgb[^$ref] [$ref],0.25,$1,$2,{2^(4+$3)},$5,0

fx_transfer_rgb_preview :
  if {$!<2} gui_print_preview "Warning:",,"This filter requires at least two input layers to work properly." return fi
  ref={if($4,0,-1)}
  pf=${-path_tmp}gmic_tmp o[$ref] $pf
  gui_split_preview[^$ref] "i "$pf" fx_transfer_rgb $1,$2,0,0,0 rm.",${-3--1}
  if $4 mv[0] $! fi
  if $6 repeat {$!-1} l[$>,-1]
    +r2dy. {0,h/3} to. Reference,2,2,13,1,1,255 frame. 2,2,255 frame. 1,1,0
    if {$6==1} j[0] .,5,5
    elif {$6==2} j[0] .,{{0,w}-w-6},6
    elif {$6==3} j[0] .,5,{{0,h}-h-6}
    else j[0] .,{{0,w}-w-6},{{0,h}-h-6}
    fi
    rm.
  endl done fi

#@gui Transfer Colors [Histogram] : fx_transfer_histogram, fx_transfer_histogram_preview(1)+
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note: </b>
#@gui : The bottom layer contains the reference colors.\n
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/11/26</i>.</small>")
fx_transfer_histogram :
  to_colormode 0
  repeat {$!-1} l[$>,-1]
    nm0={0,n} nm1={1,n}
    m "_split : s z r.. "{[w#0,h#0,1,s#0,0]}" r. "{[w#1,h#1,1,s#1,0]}
    a z
    ac "_split transfer_histogram.. . a z",$1
    _split uncommand _split
    nm[0] $nm0 nm[1] $nm1
  endl done

fx_transfer_histogram_preview :
  to_colormode 0
  repeat {$!-1} l[$>,-1]
    i[0] [0] fx_transfer_histogram[-2,-1] $1 rm.
    a z gui_split_preview "s z k.",${-3--1}
  endl done

#@gui User-Defined : fx_custom_transform, fx_custom_transform
#@gui : Red - Green - Blue - Alpha = text{"i"}
#@gui : Red - Green - Blue = text{"i + 90*(x/w)*cos(i/10)"}
#@gui : Red = text{"i"}
#@gui : Green = text{"i"}
#@gui : Blue = text{"i"}
#@gui : Alpha = text{"i"}
#@gui : Value Normalization = choice("None","RGB","RGBA")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_custom_transform :
  to_rgba repeat $!
    f. "$1"
    s. c a[-4--2] c f.. "$2"
    s.. c f[-4] "$3" f... "$4" f.. "$5" f. "$6"
    if {$7==0} a[-4--1] c c. 0,255
    elif {$7==1} a[-4--2] c n.. 0,255 c. 0,255 a[-2,-1] c
    else a[-4--1] c n. 0,255
    fi
  mv. 0 done


#@gui ____<b>Contours</b>
#------------------------

#@gui Convolve : fx_convolve, fx_convolve_preview(0)
#@gui : Kernel = choice("Custom","Average 3x3","Average 5x5","Average 7x7","Average 9x9","Prewitt-X","Prewitt-Y","Sobel-X","Sobel-Y","Rotinv-X","Rotinv-Y","Laplacian","Robert Cross 1","Robert Cross 2","Impulses 5x5","Impulses 7x7","Impulses 9x9")
#@gui : Boundary = choice(1,"Dirichlet","Neumann")
#@gui : sep = separator(), note = note("<small><b>Note:</b> If parameter <i>Kernel</i> is set to <i>Custom</i>, it uses the custom convolution kernel defined below. Use commas and semicolons as separators for res. matrix columns and rows.</small>")
#@gui : Custom Kernel = text("0,1,0;1,-4,1;0,1,0")
#@gui : sep = separator(), note = note("<small><b>Note:</b> Kernel multiplier is useful only when parameter <i>Value range</i> is set to <i>Cut</i>.</small>")
#@gui : Value Range = choice(1,"Cut","Normalize")
#@gui : Kernel Multiplier = float(1,0,50)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/06/06</i>.</small>")
fx_convolve : skip "${3=1}"
  ac "_fx_convolve $1,$2,\"$3\",${4--5}",$-4

_fx_convolve :
  if $1 _fx_convolve$1[] else ($3) fi
  if {!$4} *. $5 fi
  convolve[0--2] .,$2
  if $4 n 0,255 else c 0,255 fi
  rm.

_fx_convolve1 : 3,3 f 1 normalize_sum  # Average 3x3
_fx_convolve2 : 5,5 f 1 normalize_sum  # Average 5x5
_fx_convolve3 : 7,7 f 1 normalize_sum  # Average 7x7
_fx_convolve4 : 9,9 f 1 normalize_sum  # Average 9x9
_fx_convolve5 : (1,0,-1;1,0,-1;1,0,-1) # Prewitt-X
_fx_convolve6 : (1,1,1;0,0,0;-1,-1,-1) # Prewitt-Y
_fx_convolve7 : (1,0,-1;2,0,-2;1,0,-1) # Sobel-X
_fx_convolve8 : (1,2,1;0,0,0;-1,-2,-1) # Sobel-Y
_fx_convolve9 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,0,-$a;$b,0,-$b;$a,0,-$a)  # Rotinv-X
_fx_convolve10 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,$b,$a;0,0,0;-$a,-$b,-$a) # Rotinv-Y
_fx_convolve11 : (0,1,0;1,-4,1;0,1,0)   # Laplacian
_fx_convolve12 : (1,0;0,-1)             # Robert Cross1
_fx_convolve13 : (0,1;-1,0)             # Robert Cross2
_fx_convolve14 : 3,3 f 1 r 7,7,1,1,4,0,0.5,0.5 autocrop normalize_sum # Impulse 5x5
_fx_convolve15 : 3,3 f 1 r 9,9,1,1,4,0,0.5,0.5 autocrop normalize_sum # Impulse 7x7
_fx_convolve16 : 3,3 f 1 r 11,11,1,1,4,0,0.5,0.5 autocrop normalize_sum # Impulse 9x9

fx_convolve_preview : skip "${3=1}"
  gui_split_preview "fx_convolve $1,$2,\"$3\",${4--1}",${-3--1}

#@gui Curvature : fx_curvature, fx_curvature_preview(0)
#@gui : Smoothness = float(2,0,10)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Absolute Value = bool(0)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_curvature :
  repeat $! l[$>] split_opacity l[0]
    b $1 iee
    if $4 abs fi
    c $2%,$3%
    if $5 negate fi
    n 0,255
  endl a c endl done

fx_curvature_preview :
  gui_split_preview "fx_curvature ${^0}",${-3--1}

#@gui Difference of Gaussians : fx_dog, fx_dog_preview(1)
#@gui : 1st Variance = float(1.4,0,5)
#@gui : 2nd Variance = float(1.5,0,5)
#@gui : Threshold = float(0,0,49)
#@gui : Negative Colors = bool(0)
#@gui : Monochrome = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_dog :
  dog $1%,$2%
  if $5 norm fi
  c $3%,{100-$3}%
  if $4 negate fi
  n 0,255

fx_dog_preview :
  gui_split_preview "fx_dog ${^0}",${-3--1}

#@gui Distance Transform : fx_distance, fx_distance_preview(0)
#@gui : Value = int(128,0,255)
#@gui : Metric = choice(2,"Chebyshev","Manhattan","Euclidean","Squared-Euclidean")
#@gui : Normalization = choice(2,"Cut","Normalize","Modulo")
#@gui : Modulo Value = int(32,1,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/07/04</i>.</small>")
fx_distance :
  repeat $! l[$>] split_opacity l[0]
    distance $1,$2
    if {$3==0} c 0,255
    elif {$3==1} n 0,255
    else % $4 n 0,255
    fi
  endl a c endl done

fx_distance_preview :
  gui_split_preview "fx_distance ${^0}",${-3--1}

#@gui Edges : fx_edges, fx_edges_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_edges :
  to_rgb b $1% edges $2%
  if $3 negate fi
  n 0,255

fx_edges_preview :
  gui_split_preview "fx_edges ${^0}",${-3--1}

#@gui Edges Offsets : fx_edge_offsets, fx_edge_offsets_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Scale = int(4,0,32)
#@gui : Thickness = int(1,0,16)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_edge_offsets :
  repeat $!
    os={s}
    b. $1% gradient_norm. >=. $2% skeleton. 0 distance. 1 round. 1 %. $3 >=. {max(1,$3-$4)}
    if {!$5} negate. fi
    n. 0,255 to_colormode. $os
  mv. 0 done

fx_edge_offsets_preview :
  gui_split_preview "fx_edge_offsets ${^0}",${-3--1}

#@gui Extract Foreground [Interactive] : fx_extract_foreground, gui_no_preview
#@gui : Feathering = _float(0,0,4)
#@gui : Dilation = int(0,-32,32)
#@gui : Output Mode = choice{3,"RGBA Image (Full-Transparency / 1 Layer)","RGBA Image (Updatable / 1 Layer)","RGB Image + Binary Mask (2 Layers)","RGBA Foreground + Background (2 Layers)"}
#@gui : View Resolution = _choice{1,"Small (Faster)","Medium","High (Slower)","Very High (Even Slower)"}
#@gui : sep = separator()
#@gui : note = note{"<small><b>Description:</b>\n
#@gui : This filter allows to quickly extract foreground objects from background in opaque RGB images.
#@gui : Click on the <i>Apply</i> or <i>OK</i> buttons below to open the interactive window and start adding foreground and background control points.
#@gui : When you're done, exit the interactive window: your extracted foreground will be transferred back to the host software.\n\n
#@gui : If you are not satisfied with the result, click on <i>Apply</i> once again to modify your control points defined previously.
#@gui : To remove all control points, click on the <i>Reset</i> button above.
#@gui : </small>"}
#@gui : Last Image Size = value(0,0)
#@gui : Control Points = value(-1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Interactions:</b>\n
#@gui : Use the following actions in the interactive window to build your extraction mask :\n\n
#@gui : - <b>Left mouse button</b> or key <b>F</b> create a new <b>foreground</b> control point (or move an existing one).\n
#@gui : - <b>Right mouse button</b> or key <b>B</b> create a new <b>background</b> control point (or move an existing one).\n
#@gui : - <b>Mouse wheel</b>, or keys <b>CTRL+arrows UP/DOWN</b> zoom view in/out.\n
#@gui : - Key <b>SPACE</b> updates the extraction mask.\n
#@gui : - Key <b>TAB</b> toggles background view modes.\n
#@gui : - Key <b>M</b> toggles marker view modes.\n
#@gui : - Key <b>BACKSPACE</b> deletes the last control point added.\n
#@gui : - Key <b>PAGE UP</b> increases background opacity.\n
#@gui : - Key <b>PAGE DOWN</b> decreases background opacity.\n
#@gui : - Keys <b>CTRL+D</b> increase window size.\n
#@gui : - Keys <b>CTRL+C</b> decrease window size.\n
#@gui : - Keys <b>CTRL+R</b> reset window size.\n
#@gui : - Keys <b>ESC</b>, <b>Q</b> or <b>ENTER</b> exit the interactive window.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/29/09</i>.</small>")
fx_extract_foreground :
  if {!$!} return fi
  resolution={arg(1+$3,512,1024,2048,0)}
  repeat $! l[$<]
    nm=${-gui_layer_name}
    nm "[G"{`39`}"MIC] Interactive Foreground Extraction"
    if {$7==-1||$5!=w||$6!=h} _gui_control_points= else _gui_control_points=${7--1} fi
    status=${x_segment\ $resolution}
    sh 3 b. $1% if {$2>0} dilate. {1+2*$2} elif {$2<0} erode. {1-2*$2} fi
    rm.
    if {$3==1} sh 3 max. 1 rm.
    elif {$3==2} s c,-3 r. 100%,100%,1,4 rv nm[0] name(Mask) nm[1] name($nm)
    elif {$3==3}
      .
      sh.. 0,2 +channels... 3,3 >=. 3 *[-2,-1] rm.
      sh. 0,2 +channels.. 3,3 <=. {255-3} *[-2,-1] rm.
      sh. 3 *. -1 +. 255 rm.
      gui_autocrop_layers[0]
      pos0=${gui_layer_pos[0]} pos1=${gui_layer_pos[1]}
      nm[0] name($nm" [foreground]"),pos($pos0)
      nm[1] name($nm" [background]"),pos($pos1)
    fi
  endl done
  if {narg($status)>=4} u \{$1\}\{$2\}\{$3\}\{$4\}\{{w},{h}\}\{$status\} else u "" fi

#@gui Gradient Norm : fx_gradient_norm, fx_gradient_norm_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_gradient_norm :
  b $1 gradient_norm ^ $2
  c $3%,$4%
  if $5 negate fi
  n 0,255

fx_gradient_norm_preview :
  gui_split_preview "fx_gradient_norm ${^0}",${-3--1}

#@gui Gradient RGB : fx_gradient2rgb, fx_gradient2rgb_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Orientation Only = bool(0)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_gradient2rgb :
  b $1 gradient2rgb $4
  c $2%,$3%
  if $5 negate fi
  n 0,255

fx_gradient2rgb_preview :
  gui_split_preview "fx_gradient2rgb ${^0}",${-3--1}

#@gui Isophotes : fx_isophotes, fx_isophotes_preview(0)
#@gui : Levels = int(8,1,256)
#@gui : Smoothness = float(0,0,5)
#@gui : Filling = choice(1,"Transparent","Colors")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_isophotes :
  if $3
    topographic_map $1,$2
  else
    b $2 isophotes $1
  fi

fx_isophotes_preview :
  gui_split_preview "fx_isophotes ${^0}",${-3--1}

#@gui Laplacian : fx_laplacian, fx_laplacian_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Absolute Value = bool(0)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_laplacian :
  b $1 laplacian
  if $4 abs fi
  c $2%,$3%
  if $5 negate fi
  n 0,255

fx_laplacian_preview :
  gui_split_preview "fx_laplacian ${^0}",${-3--1}

#@gui Local Orientation : fx_local_orientation, fx_local_orientation_preview(1)
#@gui : Smoothness = float(0,0,5)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_local_orientation :
  repeat $! l[$>] split_opacity l[0]
    b $1% gradient_orientation 2 complex2polar rm[0--1:2]
    c $2%,$3%
    if $4 negate fi
    n 0,255
  endl a c endl done

fx_local_orientation :
  ac "_fx_local_orientation $1,$2,$3,$4",$5,2

fx_local_orientation_preview :
  gui_split_preview "fx_local_orientation ${^0}",${-3--1}

#@gui Morphological Filter : fx_morpho_v2, fx_morpho_v2_preview(0)
#@gui : Action = choice{"Erosion","Dilation","Opening","Closing","Original - Erosion","Dilation - Original","Original - Opening","Closing - Original","Original - (Opening + Closing)/2","Closing - Opening"}
#@gui : Kernel = choice(0,"Square","Octagonal","Circular","Custom")
#@gui : Size = int(5,2,60)
#@gui : note = note("<small>Parameter <i>Size</i> is inactive for <i>Custom</i> kernel.</small>")
#@gui : Custom Kernel = text("1,0,1; 0,1,0; 1,0,1")
#@gui : Negative = bool()
#@gui : Process Transparency = bool(0)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Stretch")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/22/06</i>.</small>")
fx_morpho_v2 :
  ac "_fx_morpho_v2 ${1-3},\"$4\",${5-6}",$7,$8

fx_morpho_v2_preview :
  gui_split_preview "fx_morpho_v2 ${1-3},\"$4\",${5--1}",${-3--1}
  if {$2==3}
    ({'"$4"'}) f. "(i>=_'0' && i<=_'9') || i==_',' || i==_';'?i:-1" discard. -1 ({t}) rr2d. {0,max(24,w/6)},{0,max(24,h/6)},0,1 >. 0 *. 255
    to_rgba. frame. 1,1,0,0,0,0,255 frame. 1,1,255 frame. 1,1,0,0,0,0,255
    j[^-1] .,2,2,0,0,0.75 rm.
  else
  fi

_fx_morpho_v2 :
  ({'"$4"'}) f. "(i>=_'0' && i<=_'9') || i==_',' || i==_';'?i:-1" discard. -1 ckernel={t} rm.
  if {$2==0} m "my_erode: erode $""1" m "my_dilate: dilate $""1"
  elif {$2==1} m "my_erode: erode_oct $""1" m "my_dilate: dilate_oct $""1"
  elif {$2==2} m "my_erode: erode_circ $""1" m "my_dilate: dilate_circ $""1"
  else
    m "my_erode : ("$ckernel") erode[^-1] . rm."
    m "my_dilate : ("$ckernel") dilate[^-1] . rm."
  fi
  # Erosion
  if {$1==0} m "my_action : my_erode $3"
  # Dilation
  elif {$1==1} m "my_action : my_dilate $3"
  # Opening
  elif {$1==2} m "my_action : my_erode $3 my_dilate $3"
  # Closing
  elif {$1==3} m "my_action : my_dilate $3 my_erode $3"
  # Original - Erosion
  elif {$1==4} m "my_action : +my_erode $3 -"
  # Dilation - Original
  elif {$1==5} m "my_action : +my_dilate $3 rv -"
  # Original - Opening
  elif {$1==6} m "my_action : +my_erode $3 my_dilate. $3 -"
  # Closing - Original
  elif {$1==7} m "my_action : +my_dilate $3 my_erode. $3 rv -"
  # Original - (Opening + Closing)/2
  elif {$1==8} m "my_action : +my_erode $3 my_dilate. $3 +my_dilate.. $3 my_erode. $3 +[-2,-1] /. 2 -"
  # Closing - Opening
  else m "my_action : +my_erode $3 my_dilate. $3 my_dilate.. $3 my_erode.. $3 -"
  fi
  repeat $! l[$>]
    if {!$6} split_opacity fi
    my_action[0]
    a c
  endl done
  if $5 repeat $! l[$>] split_opacity negate[0] a c endl done fi
  uncommand my_erode,my_dilate,my_action

#@gui Segmentation : fx_segment_watershed, fx_segment_watershed_preview(0)
#@gui : Edge Threshold = float(2,0,15)
#@gui : Smoothness = float(1,0,5)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_segment_watershed : skip ${4=1}
  ac "b $2 segment_watershed $1",$3,$4

fx_segment_watershed_preview :
  gui_split_preview "fx_segment_watershed ${^0}",${-3--1}

#@gui Skeleton : fx_skeleton, fx_skeleton_preview(1)
#@gui : Method = choice{"Distance (Fast)","Thinning (Slow)"}
#@gui : Smoothness = float(0,0,10)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/07/04</i>.</small>")
fx_skeleton :
  remove_opacity
  b $2% >= 50%
  if $1 thinning 1
  else
    distance 0 sharpen 1e10 >= 100%
    repeat $! +erode[$>] 2 -[$>,-1] done
  fi
  * 255

fx_skeleton_preview :
  gui_split_preview "fx_skeleton ${^0}",${-3--1}

#@gui Super-Pixels : fx_superpixels, fx_superpixels_preview(0)
#@gui : Size = int(16,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border Opacity = float(1,0,1)
#@gui : Border Color = color(0,0,0,255)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/11/16</i>.</small>")
fx_superpixels :
  repeat $! l[$>]
    +srgb2lab slic. ${1-3}
    if $4 +blend shapeaverage else +map. 2,2 fi
    if $5 f[1] "i!=j(1,0) || i!=j(0,1)" [0],[0],1,4 fc. ${6-9} to_rgba.. j.. .,0,0,0,0,$5,... k..
    else k.
    fi
  endl done

fx_superpixels_preview :
  gui_split_preview "fx_superpixels ${^0}",${-3--1}

#@gui Thin Edges : fx_thin_edges, fx_thin_edges_preview(0)
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_thin_edges :
  b $1% gradient_norm >= $2% thinning 1
  if {!$3} negate fi
  n 0,255

fx_thin_edges_preview :
  gui_split_preview "fx_thin_edges ${^0}",${-3--1}


#@gui ____<b>Deformations</b>
#----------------------------

#@gui Cartesian Transform : fx_custom_deformation, fx_custom_deformation(1)
#@gui : X-Warping = text{"(w+h)/20 * cos(y*20/h)"}
#@gui : Y-Warping = text{"(w+h)/20 * sin(x*20/w)"}
#@gui : Relative Warping = bool(1)
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_custom_deformation :
  if {!$5} to_a fi
  repeat $!
    +norm. . f.. "$1" f. "$2"
    a[-2,-1] c warp.. .,$3,$4,$5,1 rm.
  mv. 0 done

#@gui Circle Transform : fx_circle_transform, fx_circle_transform_preview(1)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Radius = point(75,50,0,1)
#@gui : X-Scale = float(-2,-16,16)
#@gui : Y-Scale = float(-2,-16,16)
#@gui : Symmetry = choice("None","Inside","Outside")
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Preview Reference Circle = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/08/01</i>.</small>")
fx_circle_transform :
  repeat $! l[$>] to_rgba
    r={dx=($3-$1)*(w-1)%;dy=($4-$2)*(h-1)%;norm(dx,dy)}
    if {$7==0} cond="i(X,Y,z,c,$8,$9)"
    elif {$7==1} cond="if(N<"$r",i(X,Y,z,c,$8,$9),i)"
    else cond="if(N>"$r",i(X,Y,z,c,$8,$9),i)"
    fi
    f "U = x - w*$1%;
       V = y - h*$2%;
       N = sqrt(U*U + V*V);
       Nr = N - "$r";
       X = x + $5*Nr*U/N;
       Y = y + $6*Nr*V/N;
       "$cond
  endl done

fx_circle_transform_preview :
  fx_circle_transform $*
  if $10
    rr2d ${-gui_preview_wh},0,1
    repeat $! l[$>]
      x0,y0={[$1,$2]*([w,h]-1)%}
      r={dx=($3-$1)*(w-1)%;dy=($4-$2)*(h-1)%;norm(dx,dy)}
      circle $x0,$y0,{$r-1},1,0xFFFFFFFF,0,0,0,255
      circle $x0,$y0,{$r+1},1,0xFFFFFFFF,0,0,0,255
      circle $x0,$y0,$r,1,0xFFFFFFFF,0,255,0,255
    endl done
  fi

#@gui Conformal Maps : fx_conformal_maps, fx_conformal_maps_preview(1)
#@gui : Mapping = choice{8,"Custom Formula","z","(z-1)/(z+1)","cos(z)","sin(z)","tan(z)","exp(z)","log(z)","Dipole: 1/(4*z^2-1)","Star: -5*(z^3/3-z/4)/2"}
#@gui : Exponent (Real) = float(1,-16,16)
#@gui : Exponent (Imaginary) = float(0,-16,16)
#@gui : Custom Formula = text{1,"((1.1 + i*z/6)/(1.04 - i*z/6))^6.2"}
#@gui : sep = separator()
#@gui : Zoom = float(0,-4,4)
#@gui : Angle = float(0,-180,180)
#@gui : Aspect Ratio = float(0,-1,1)
#@gui : X-Shift = float(0,-5,5)
#@gui : Y-Shift = float(0,-5,5)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Anti-Aliasing = int(0,0,3)
#@gui : sep = separator()
#@gui : Specify Different Output Size = _bool(0)
#@gui : Output Width = _text("1024")
#@gui : Output Height = _text("1024")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/15/02</i>.</small>")
fx_conformal_maps :
  to_a
  expr0="$4"
  expr1="z"
  expr2="(z+1)/(z-1)"
  expr3="cos(z)"
  expr4="sin(z)"
  expr5="tan(z)"
  expr6="exp(z)"
  expr7="log(z)"
  expr8="1/(4*z^2-1)"
  expr9="-5*(z^3/3-z/4)/2"

  ({'${expr$1}'})
  replace_str. "*","**"
  replace_str. "/","//"
  replace_str. "^","^^"
  replace_str. "exp(","cexp("
  replace_str. "log(","clog("
  replace_str. "cos(","ccos("
  replace_str. "sin(","csin("
  replace_str. "tan(","ctan("
  expr={t}
  rm.

  repeat $! l[$>]
    wh={$12?[$13,$14]:[w,h]}
    {(1+$11)*[$wh]},1,100%
    f. "begin(
          ccos(z) = (iz = [ -z[1],z[0] ]; (cexp(iz) + cexp(-iz)/2));
          csin(z) = (iz = [ -z[1],z[0] ]; (cexp(iz) - cexp(-iz)/2));
          ctan(z) = csin(z)//ccos(z);
          boundary = $10;
          interpolation = 1;
          const f = max(w,h);
          const f0 = max(w#0,h#0);
          i = [0,1];
        );
        z = (2*[ x,y ] - [ w,h ])/f;
        z = rot(-$6)*z;
        z-= [ $8, $9 ];
        z/=[ 10^($5 + $7), 10^$5 ];
        z = ("$expr");
        if ($1, z = z^^[$2,$3]);
        z = rot($6)*z;
        z = 0.5*(f0*z + [w#0,h#0]);
        I(#0,z)"
      r. $wh,1,100%,2
    rm..
  endl done

fx_conformal_maps_preview :
  fx_conformal_maps ${1-3},"$4",${5-11},0,0,0

#@gui Crease : fx_crease,fx_crease(0)
#@gui : Amplitude = float(30,0,300)
#@gui : Frequency (%) = float(10,0,100)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/01/22</i>.</small>")
fx_crease :
  repeat $! l[$>]
    if {!$3} to_a fi
    2,2,1,2,{"const w1 = w#-1-1; const h1 = h#-1 - 1; [ 0,w1,0,w1,0,0,h1,h1 ];"}
    r. {0,D=$2*[w,h]%;[max(D[0],1),max(D[1],1)]},1,2,3 noise. $1,1
    r. ..,..,1,2,3 warp.. .,0,1,$3 rm.
  endl done

#@gui Distort Lens : fx_distort_lens, fx_distort_lens(1)
#@gui : Amplitude = float(0.1,-1,1)
#@gui : Aspect Ratio = float(0,-2,2)
#@gui : Zoom = float(0,-4,4)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/18/02</i>.</small>")
fx_distort_lens :
  if {!$6} to_a fi
  undistort ${1-3},$4%,$5%,$6

#@gui Drop Water : fx_drop_water, fx_drop_water_preview(1)
#@gui : note = note("<small><b>Shape geometry:</b></small>")
#@gui : Shapes = choice("Procedural","Opaque Regions on Top Layer")
#@gui : Density = float(20,0,100)
#@gui : Radius = float(2,0,5)
#@gui : Variability = float(80,0,100)
#@gui : Random Seed = int(0,0,16384)
#@gui : note = note("<small>Parameters <i>Density</i>, <i>Radius</i>, <i>Variability</i> and <i>Random seed</i> are used only in <i>Procedural shapes</i> mode.</small>")
#@gui : sep = separator(), note = note("<small><b>Light parameters:</b></small>")
#@gui : Refraction = float(3,0,20)
#@gui : Light Angle = float(35,0,360)
#@gui : Specular Size = float(10,0,100)
#@gui : Specular Intensity = float(1,0,1)
#@gui : Specular Centering = float(0.5,0,1)
#@gui : sep = separator(), note = note("<small><b>Shadow parameters:</b></small>")
#@gui : Shadow Size = float(0.25,0,3)
#@gui : Shadow Intensity = float(0.5,0,1)
#@gui : Shadow Smoothness = float(0.75,0,3)
#@gui : Diffuse Shadow = float(0.05,0,3)
#@gui : sep = separator()
#@gui : Smoothness = float(0.15,0,3)
#@gui : Output as Separate Layers = _bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/21/07</i>.</small>")
fx_drop_water :
  N={$!-$1}
  if {$N<=0} error "At least two layers are required in this mode." fi

  repeat $N l[{$!-$>-1}] nm0={n} nm=${-gui_layer_name}
    nm img

    # Create binary shapes (i.e. opacity map).
    srand $5
    if $1 # Shape from top layer.
      pass[0] 0 to_a. channels. 100% >=. 50%
      r. [0],[0],1,1,0,0,0.5,0.5
    else # Procedural shape.
      100%,100%
      rmin={max(0.1,$3*(1-$4%))} rmax={max(0.1,$3)}
      repeat 10
        100%,100%
        random3d {max(1,$2)} *3d. {-2,w},{-2,h},0
        j3d.. .,0,0,0,1,1,0,0 rm.
        b. {$rmin+($rmax-$rmin)*$>/9}%,0,1
        j.. .,0,0,0,0,0.5 rm.
      done
      >=. 10%
    fi
    nm. shape

    # Create elevation map.
    +b[shape] 1% n. 0,30
    nm. elevation

    # Warp image.
    g[elevation] xy a[-2,-1] c nm. grad
    +*[grad] {grad,$6*max(w,h)/100} *. [shape] b. $15%
    +warp[img] .,1,1,1 rm.. nm. refraction

    # Compute specular spots.
    +*[grad] -1 100%,100%,1,1,1 a[-2,-1] c orientation.  # 3D normal map.
    a={$7*pi/180} ca={-cos($a)} sa={-sin($a)}
    mix_channels. ({(1-$10)*$ca},{(1-$10)*$sa},1) c. {100-$8}%,100% n. 0,1
    *. [shape] nm. spots

    # Compute ambiant light (gradient).
    mix_channels[grad] ($ca,$sa)
    n[grad] 0,1 *[grad] [shape]

    # Drop shadow.
    +shift[shape] {-$11*$ca}%,{-$11*$sa}%,0,0,1
    -. [shape] >=. 1 b. $13% n. 0,1
    nm. shadow
    b[shape] $14% n. 0,1  # Add diffuse shadow around each drop.

    # Prepare layers for output.
    nm[img] name($nm)

    *[shadow] 255 channels[shadow] -1,0 mv[shadow] 1
    nm[shadow] name($nm" [shadow]"),mode(alpha),opacity({$12*100})

    to_a[refraction] sh[refraction] 100% +b[shape] $15% *[-2,-1] rm.
    mv[refraction] 2
    nm[refraction] name($nm" [refraction]"),mode(alpha)

    channels[spots] -1,0 sh[spots] 0 f. 1 rm. *[spots] 255
    nm[spots] name($nm" [specular spots]"),mode(alpha),opacity({$9*100})

    rv[shape,grad] a[grad,shape] c *[grad] 255 b[grad] $15%
    nm[grad] name($nm" [gradient]"),mode(grainmerge)

    rv
    if {!$16} gui_merge_layers nm $nm0 fi
  endl done
  if $1 rm[0] fi

fx_drop_water_preview :
  N={$!-$1}
  if {$N<=0} gui_warning_preview "At least two layers are required in this mode." return fi
  if $1
    repeat $N l[{$!-$>-1}]
      pass[0] 0 mv. 0
      fx_drop_water $* gui_merge_layers
    endl done
    rm[0]
  else
    repeat $! l[$>]
      fx_drop_water $* gui_merge_layers
    endl done
  fi

#@gui Equirectangular to Nadir-Zenith : fx_equirectangular2nadirzenith, fx_equirectangular2nadirzenith(1)
#@gui : Mode = choice{"to Nadir / Zenith","to Equirectangular"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/29/12</i>.</small>")
fx_equirectangular2nadirzenith :
  if $1 nadirzenith2equirectangular else equirectangular2nadirzenith fi

#@gui Euclidean - Polar : fx_euclidean2polar, fx_euclidean2polar(1)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Stretch Factor = float(1,0.1,10)
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui : Inverse Transform = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_euclidean2polar :
  if {!$4} to_a fi
  if $5 polar2euclidean $1%,$2%,$3,$4 else euclidean2polar $1%,$2%,$3,$4 fi

#@gui Fish-Eye : fisheye, fisheye(1)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : Radius = float(70,0,100)
#@gui : Amplitude = float(1,0,2)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Flower : fx_flower, fx_flower_preview(1)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Amplitude / Angle = point(75,50,0,1)
#@gui : Petals = int(6,2,20)
#@gui : Offset (%) = float(0,0,100)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_flower :
  if {!$7} to_a fi
  amplitude,angle={dx=$3-$1;dy=$4-$2;[norm(dx,dy),-atan2(dy,dx)*180/pi]}
  flower $amplitude,$5,$6%,$angle,$1%,$2%,$7

fx_flower_preview :
  fx_flower $*
  line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,0
  line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,255

#@gui Kaleidoscope [Blended] : fx_rotoidoscope, fx_rotoidoscope(1)
#@gui : Center (%) = point(50,50)
#@gui : Angular Tiles = int(10,1,72)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_rotoidoscope :
  if {!$5} to_a fi
  rotoidoscope $1%,$2%,$3,$4%,$5

#@gui Kaleidoscope [Polar] : fx_kaleidoscope, fx_kaleidoscope(1)
#@gui : Center (%) = point(50,50)
#@gui : X-Offset (%) = float(0,0,100)
#@gui : Y-Offset (%) = float(0,0,100)
#@gui : Radius Cut = float(100,0,100)
#@gui : Angle Cut = float(10,0,100)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_kaleidoscope :
  if {!$7} to_a fi
  shift $3%,$4%,0,0,2 kaleidoscope $1%,$2%,$5,$6,$7

#@gui Kaleidoscope [Symmetry] : fx_symmetrizoscope, fx_symmetrizoscope(1)
#@gui : Iterations = int(4,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Symmetry Sides = choice("Backward","Forward","Swap")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/07/01</i>.</small>")
fx_symmetrizoscope :
  if {!$3} to_a fi
  repeat $1
    ang={$2+180*$>/max(1,$1-1)}
    symmetrize 50%,50%,$ang,$3,0,{if($4!=2,$4,$>%2)}
  done

#@gui Perspective : fx_warp_perspective, fx_warp_perspective(1)
#@gui : X-Angle = float(1.73,-4,4)
#@gui : Y-Angle = float(0,-4,4)
#@gui : Zoom = float(1,0.1,4)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : X-Offset = float(0,0,100)
#@gui : Y-Offset = float(0,0,100)
#@gui : Boundary = choice(2,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_warp_perspective :
  if {!$8} to_a fi
  shift $6%,$7%,0,0,2 warp_perspective $1,$2,$3,$4,$5,$8

#@gui Polar Transform : fx_transform_polar, fx_transform_polar(1)
#@gui : Preset = choice("Custom Transform","Inverse Radius","Swap Radius / Angle")
#@gui : Center (%) = point(50,50,0,1)
#@gui : Radius = text{"r + R/10*cos(a*5)"}
#@gui : Angle = text{"a"}
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_transform_polar :
  if {!$6} to_a fi
  if {$1==0}
    transform_polar "$4","$5",$2%,$3%,$6
  elif {$1==1}
    transform_polar R-r,a,$2%,$3%,$6
  else
    transform_polar a*R/(2*pi),r*2*pi/R,$2%,$3%,$6
  fi

#@gui Quadrangle : fx_quadrangle, fx_quadrangle_preview(1)
#@gui : Top-Left Vertex (%) = point(5,5,0,1,255,0,0)
#@gui : Top-Right Vertex (%) = point(95,25,0,1,0,255,0)
#@gui : Bottom-Right Vertex (%) = point(60,95,0,1,64,128,255)
#@gui : Bottom-Left Vertex (%) = point(40,95,0,1,255,255,0)
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Preview Type = choice(1,"Input","Output","Both")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/10/11</i>.</small>")
fx_quadrangle :
  at_quadrangle $1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,${9-10}

fx_quadrangle_preview :
  repeat $! l[$>]
    if {!$10} to_a fi
    if $11 +fx_quadrangle $* rr2d. {0,[w,h]},2,3 fi
    polygon[{$11==1?1:0}] 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,0.25,255
    if {$11>=2}
      circle[0] $1%,$2%,4,1,0 circle[0] $1%,$2%,3,1,255,0,0
      circle[0] $3%,$4%,4,1,0 circle[0] $3%,$4%,3,1,0,255,0
      circle[0] $5%,$6%,4,1,0 circle[0] $5%,$6%,3,1,64,128,255
      circle[0] $7%,$8%,4,1,0 circle[0] $7%,$8%,3,1,255,255,0
    elif {$11>0}
      rm[0]
    fi
    if {$!==2}
      drgba to[0] Quadrangle to[1] Result frame 1,1,0
      +a x a[0,1] y rr2d ${-gui_preview_wh},0,3
      k[{max(w#0,h#0)>max(w#1,h#1)?0:1}]
    fi
  endl done

#@gui Raindrops : raindrops, raindrops(0)
#@gui : Amplitude = float(80,0,300)
#@gui : Density = float(0.1,0,1)
#@gui : Wavelength = float(1,0,2)
#@gui : Merging Steps = int(0,0,20)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/28/11</i>.</small>")

#@gui Random : deform, deform(0)
#@gui : Amplitude = float(10,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Ripple : ripple, ripple(0)
#@gui : Amplitude = float(10,0,100)
#@gui : Bandwidth = float(20,1,300)
#@gui : Shape = choice(2,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,0,360)
#@gui : Offset = float(0,0,500)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/23/08</i>.</small>")

#@gui Reflection : fx_reflect, fx_reflect(1)
#@gui : Height = float(50,0,100)
#@gui : Attenuation = float(1,0.1,4)
#@gui : Color = color(110,160,190,64)
#@gui : Waves Amplitude = float(0,0,100)
#@gui : Waves Smoothness = float(1.5,0,4)
#@gui : X-Angle = float(0,-10,10)
#@gui : Y-Angle = float(-3.30,-10,10)
#@gui : Focale = float(7,0,10)
#@gui : Zoom = float(1.5,1,5)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_reflect :
  repeat $!
    to_rgba. +rows. {100-$1}%,100% mirror. y water. $7,$8
    s. c
    f[-4] "(i*(255-$6) + $6*$3)/255"
    f... "(i*(255-$6) + $6*$4)/255"
    f.. "(i*(255-$6) + $6*$5)/255" a[-4--1] c
    *. '(h^$2-y^$2)/h^$2' a[-2,-1] y
    100%,100%,100%,1,$11*$12*(x/w-0.5)
    100%,100%,100%,1,$11*$12*(y/h-0.5)
    100%,100%,100%,1,"$10*(x/w-0.5) + $9*(y/h-0.5) + $11"
    /... . +... 0.5 *... {-3,w}
    /[-2,-1] +. 0.5 *. {h}
    a[-2,-1] c warp.. .,0,1,0 rm.
  mv. 0 done
  autocrop 0,0,0,0

#@gui Seamcarve : fx_seamcarve, fx_seamcarve_preview(1)
#@gui : Width (%) = float(85,0,200)
#@gui : Height (%) = float(100,0,200)
#@gui : Maximal Seams per Iteration (%) = float(15,0,100)
#@gui : Use Top Layer as a Priority Mask = bool(0)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : You can define a transparent top layer that will help the seam-carving algorithm to preserve or force removing image structures:\n
#@gui : \n  - Draw areas in <i>red</i> to force removing them.
#@gui : \n  - Draw areas in <i>green</i> to preserve them.
#@gui : \n  - Don't forget also to set the <i>Input layers...</i> parameter to input both layers to the filter.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i>Garagecoder</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/02/06</i>.</small>")
fx_seamcarve :
  if $4
    if {$!<2} error "Priority mask (top layer) is missing!" fi
    _fx_seamcarve
  fi
  seamcarve $1%,$2%,$4,$5,$3%
  if $4 repeat $! channels[$>] 0,{$>,s-2} done fi
  c 0,255

fx_seamcarve_preview :
  if $4
    if {$!<2} to_rgb to "Priority mask (top layer) is missing!",5,5,18,2 return fi
    _fx_seamcarve
  fi
  repeat $! l[$>]
    w={w} h={h}
    seamcarve $1%,$2%,$4,$5,{max($3,10)}%
    if $4 channels 0,{s-2} fi
    to_rgba r $w,$h,1,100%,0,0,0.5,0.5
  endl done
  c 0,255

_fx_seamcarve :
  mv[0] $!
  l.
    s c k[0,1]
    >[1] [0] !=[0] 0 -[0] [1] *[0] -1 + * 256
  endl
  repeat {$!-1} a[$>] .,c done rm.

#@gui Sphere : fx_map_sphere, fx_map_sphere_preview(1)
#@gui : Width = _int(512,1,4096)
#@gui : Height = _int(512,1,4096)
#@gui : Radius = float(90,0,400)
#@gui : Dilation = float(0.5,0,1)
#@gui : Angle = float(0,-50,50)
#@gui : Border Smoothness = float(0,0,200)
#@gui : Border Width = float(20,0,100)
#@gui : Orientation = choice("0 deg.","90 deg.","180 deg.","270 deg.")
#@gui : Background = choice("Transparent","Mean Color")
#@gui : Fading = float(0,0,100)
#@gui : Fading Shape = float(0.5,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/07/11</i>.</small>")
fx_map_sphere :
  rotate {$8*90}
  if $6
    repeat $!
      shift. {round(w/2)},0,0,0,2 +columns. {(1-$7/100)*w/2},{(1+$7/100)*w/2}
      100% gaussian. {0.1*w},{h},0 100% 100% a[-3--1] c r. ..,..,1,3
      smooth.. .,$6,5,0 rm.
      j.. .,{(1-$7/100)*{-2,w}/2} rm. shift. -{round(w/2)},0,0,0,2
    mv. 0 done
  fi
  shift $5%,0,0,0,2 to_rgba
  if $9
    repeat $!
      +rows[$>] 0 r. 1,1,1,4,2 RGBA$>={^}
      r. [$>],[$>],1,4 -[$>,-1]
    done
  fi
  map_sphere $1,$2,$3,$4,$10,$11
  if $9
    repeat $!
      (${RGBA$>}) y. c r. [$>],[$>],1,4 +[$>,-1]
    done
  fi

fx_map_sphere_preview :
  fx_map_sphere {w},{h},${3--1}

#@gui Spherize : fx_spherize, fx_spherize_preview(1)
#@gui : Radius (%) = float(50,0,300)
#@gui : Strength = float(1,-10,10)
#@gui : Smoothness (%) = float(0,0,4)
#@gui : Center (%) = point(50,50,0,1,255,255,255,170,10)
#@gui : Ratio = float(0,-2,2)
#@gui : Angle = float(0,-90,90)
#@gui : Interpolation = choice(2,"Nearest Neighbor","Linear","Cubic")
#@gui : Preview Grid = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/10/03</i>.</small>")
fx_spherize :
  ratio={10^$6}
  spherize $1%,$2,$3%,$4%,$5%,$ratio,$7,$8
  cut 0,255

fx_spherize_preview :
  cx,cy=${4,5}
  if $9 grid 5%,5%,50%,50%,0.6,255 fi
  fx_spherize ${1-3},$cx,$cy,${6--1}

#@gui Square to Circle : fx_square_circle, fx_square_circle
#@gui : Mode = choice(0,"Square to Circle","Circle to Square")
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator()
#@gui : X-Factor (%) = float(0,-100,100)
#@gui : Y-Factor (%) = float(0,-100,100)
#@gui : X-Offset (%) = float(0,-300,300)
#@gui : Y-Offset (%) = float(0,-300,300)
#@gui : sep = separator(), note = note("<small>This filter implements the mapping functions described in this page, by <i>C. Fong</i>:</small>")
#@gui : url = link("http://squircular.blogspot.com/2015/09/mapping-circle-to-square.html")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/10/30</i>.</small>")
fx_square_circle :
  mode,interp,boundary,factx,facty,offx,offy=${1-7}
  if {!$boundary} to_a fi
  base="const interpolation = "$interp";
        const boundary = "$boundary";
        const offx = "$offx"%;
        const offy = "$offy"%;
        const factx = 10^-("$factx"%);
        const facty = 10^-("$facty"%);
        const w2 = int(w/2);
        const h2 = int(h/2);"
  if {!$mode} # Square to circle
    f $base"
       const tst = 2*sqrt(2);
       U = (2*x/(w-1) - 1)*factx + offx;
       V = (2*y/(h-1) - 1)*facty + offy;
       U2 = U^2;
       V2 = V^2;
       U2mV2 = U2 - V2;
       X = 0.5*(sqrt(max(0,2 + tst*U + U2mV2)) - sqrt(max(0,2 - tst*U + U2mV2)));
       Y = 0.5*(sqrt(max(0,2 + tst*V - U2mV2)) - sqrt(max(0,2 - tst*V - U2mV2)));
       (X+=1)*=w2 - 0.5;
       (Y+=1)*=h2 - 0.5;
       I(X,Y)"
  else # Circle to square
    f $base"
       X = (2*x/(w-1) - 1)*factx + offx;
       Y = (2*y/(h-1) - 1)*facty + offy;
       U = X*sqrt(abs(1 - 0.5*Y^2));
       V = Y*sqrt(abs(1 - 0.5*X^2));
       (U+=1)*=w2 - 0.5;
       (V+=1)*=h2 - 0.5;
       I(U,V)"
  fi

#@gui Stereographic Projection : fx_project_stereographic, fx_project_stereographic_preview(1)
#@gui : Transform = choice("Direct","Inverse")
#@gui : Center (%) = point(50,50,0,1,255,255,255,170)
#@gui : Radius / Angle = point(50,75,0,1,255,0,255,170)
#@gui : Horizon Leveling (deg) = float(0,-10,10)
#@gui : Left / Right Blur (%) = float(0,0,20)
#@gui : Dilation = float(0,-2,2)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axis")
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : Last Center = value(50,50)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/07/04</i>.</small>")
fx_project_stereographic :
  is_inverse,centerx,centery,radangx,radangy,rechor,lrblur,dilation,mirror,boundary,ocenterx,ocentery=${1-12}

  if {$centerx!=$ocenterx" || "$centery!=$ocentery}
    deltax,deltay={[$radangx,$radangy]-[$ocenterx,$ocentery]}
    radangx,radangy={[$centerx,$centery]+[$deltax,$deltay]}
  fi
  status=\{$is_inverse\}\{$centerx,$centery\}\{$radangx,$radangy\}\{$rechor\}\{$lrblur\}\{$dilation\}\{$mirror\}\{$boundary\}\{$centerx,$centery\}
  nradangx,nradangy={[$centerx,$centery]+rot(-90)*([$radangx,$radangy]-[$centerx,$centery])} # So that preview line does not hide left/right frontier
  init="const boundary = "$is_inverse?$boundary:2";
        const interpolation = 1;
        const dilation = 2^"$dilation";
        const centerx = "$centerx"%*(W-1);
        const centery = "$centery"%*(H-1);
        const radangx = "$nradangx"%*(W-1) - centerx;
        const radangy = "$nradangy"%*(H-1) - centery;
        const R = sqrt(radangx^2 + radangy^2);
        const theta0 = atan2(radangy,radangx);
        const pi2 = 2*pi;"
  m "_fx_project_stereographic_mirror : if {!$""1} mirror y elif {$""1==1} mirror xy elif {$""1==3} mirror x fi"
  repeat $! l[$>]
    if {!$boundary} to_a fi
    if $rechor rotate $rechor,1,3 fi
    if $lrblur
      100%,1,1,1,!x||x==w-1 shift {round(w/2)},0,0,0,2 b. x,$lrblur% n. 0,1 +b.. x,$lrblur%
      r.. .,.,1,1 j... .,0,0,0,0,1,.. k[0] shift {-round(w/2)},0,0,0,2
    fi
    if $is_inverse
      100%,50%,1,100%,"*
        const W = w#0;
        const H = h#0;
        "$init"
        theta = theta0 + x*pi2/w;
        phi = (y/h - 0.5)*pi;
        z = R*sin(phi);
        rho = ((R + z)/(R - z))^(0.5/dilation)*R;
        X = centerx + rho*cos(theta);
        Y = centery + rho*sin(theta);
        I(#0,X,Y)"
      _fx_project_stereographic_mirror $mirror
    else
      _fx_project_stereographic_mirror $mirror
      {u=0$_is_preview?min(w,h):max(w,h);[u,u,1,s]},"*
        const W = w;
        const H = h;
        "$init"
        X = x - centerx;
        Y = y - centery;
        theta = atan2(Y,X);
        beta = ((X^2 + Y^2)/R^2)^dilation;
        z = R*(beta - 1)/(beta + 1);
        phi = asin(z/R);
        theta = ((theta - theta0)*w#0/pi2)%w#0;
        phi = (h#0*(phi/pi + 0.5))%h#0;
        I(#0,theta,phi)"
    fi
  k. endl done uncommand _fx_project_stereographic

  if $_is_preview
    line $centerx%,$centery%,$radangx%,$radangy%,0.75,0xF0F0F0F0,255,255,255,255
    line $centerx%,$centery%,$radangx%,$radangy%,0.75,0x0F0F0F0F,0,0,0,255
  fi
  u $status

fx_project_stereographic_preview :
  _is_preview=1
  fx_project_stereographic $*

#@gui Symmetrize : fx_symmetrize, fx_symmetrize_preview(1)
#@gui : Point 1 = point(50,50,0,1,0,255,0,170,10)
#@gui : Point 2 = point(50,75,-1,1,255,255,0,170,10)
#@gui : Angle = float(0,-180,180)
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : Type = choice("Symmetry","Antisymmetry")
#@gui : Swap Sides = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/06/11</i>.</small>")
fx_symmetrize :
  if {!$6} to_a fi
  angle={isnan($3)?$5:atan2($4-$2,$3-$1)*180/pi}
  symmetrize $1%,$2%,$angle,${6-8}

fx_symmetrize_preview :
  fx_symmetrize $*
  rr2d ${-gui_preview_wh},0,1
  u,v={angle=isnan($3)?$5*pi/180:atan2($4-$2,$3-$1);[cos(angle),sin(angle)]}
  repeat $! l[$>]
    x0,y0,x1,y1={V=[$u,$v];([${1,2},${1,2}]+10000*[V,-V])*([w,h,w,h]-1)%}
    line $x0,$y0,$x1,$y1,1,0x0F0F0F0F,0,0,0,255
    line $x0,$y0,$x1,$y1,1,0xF0F0F0F0,255
  endl done

#@gui Textured Glass : fx_textured_glass, fx_textured_glass_preview(0)
#@gui : X-Amplitude = float(40,0,400)
#@gui : Y-Amplitude = float(40,0,400)
#@gui : X-Smoothness = float(1,0,5)
#@gui : Y-Smoothness = float(1,0,5)
#@gui : Edge Attenuation = float(0,0,1)
#@gui : Edge Influence = float(2,0,10)
#@gui : Noise Scale = int(0,0,16)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/21/11</i>.</small>")
fx_textured_glass :
  repeat $! l[$>]
    100%,100%,1,1
    if $7 plasma. 1,1,$7 else rand. 0,1 fi
    g. xy
    if $5
      +gradient_norm... +. 1 b. $6 ^. -$5
      *... . *[-2,-1]
    fi
    blur_xy[-2,-1] $3,$4
    *.. {-2,$1/max(abs(im),abs(iM))}
    *. {$2/max(abs(im),abs(iM))}
    a[-2,-1] c
    warp.. .,1,1 rm.
  endl done

fx_textured_glass_preview :
  gui_split_preview "fx_textured_glass $*",${-3--1}

#@gui Twirl : fx_twirl, fx_twirl(1)
#@gui : Amplitude = float(1,-5,5)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_twirl :
  if {!$4} to_a fi
  twirl $1,$2%,$3%,$4

#@gui Water : water, water(0)
#@gui : Amplitude = float(30,0,300)
#@gui : Smoothness = float(1.5,0,4)
#@gui : Angle = float(45,0,180)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/07/10</i>.</small>")

#@gui Wave : wave, wave(1)
#@gui : Amplitude = float(10,0,30)
#@gui : Frequency = float(0.4,0,2)
#@gui : Center (%) = point(50,50,0,1,255,255,255,170,10)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Wind : fx_wind, fx_wind_preview(0)
#@gui : Amplitude = int(20,0,500)
#@gui : Angle = float(0,0,360)
#@gui : Attenuation = float(0.7,0,1)
#@gui : Threshold = float(20,0,100)
#@gui : Mode = choice(1,"Darker","Brighter")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/13/07</i>.</small>")
fx_wind :
  if {!$5} negate fi
  ac "wind ${1-4}",$6,$7
  if {!$5} negate fi

fx_wind_preview :
  gui_split_preview "fx_wind $*",${-3--1}

#@gui Zoom : fx_zoom, fx_zoom(1)
#@gui : Factor = float(2,0.01,10)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_zoom :
  if {!$4" && "$1<1} to_a fi
  zoom $1,{$2%},{$3%},0,$4


#@gui ____<b>Degradations</b>
#-----------------------------

#@gui Add Grain : fx_simulate_grain, fx_simulate_grain_preview(0)
#@gui : Preset = choice{"Orwo NP20-GDR","Kodak TMAX 400","Kodak TMAX 3200","Kodak TRI-X 1600","Unknown"}
#@gui : Blend Mode = choice(1,"Alpha","Grain Merge","Hard Light","Overlay","Soft Light","Grain Only")
#@gui : Opacity = float(0.2,0,1)
#@gui : Scale = float(100,30,200)
#@gui : Colored Grain = bool()
#@gui : sep = separator()
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : Preview Grain Alone = bool()
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/02/08</i>.</small>")
fx_simulate_grain :
  __fx_simulate_grain ${arg\ {1+$1},${-_fx_simulate_grain}},${2-10},0,0

_fx_simulate_grain :
  u grain_orwo_np20,grain_kodak_tmax400,grain_kodak_tmax3200,grain_kodak_trix1600,grain_unknown

fx_simulate_grain_preview :
  gui_split_preview "_fx_simulate_grain_preview $*",$-2

_fx_simulate_grain_preview :
  __fx_simulate_grain ${arg\ {1+$1},${-_fx_simulate_grain}},${2-12}

__fx_simulate_grain :
  bm0=alpha bm1=grainmerge bm2=hardlight bm3=overlay bm4=softlight bm5=alpha
  if ${_path_rc}$1.cimgz i ${_path_rc}$1.cimgz
  else i https://gmic.eu/data_film_presets/$1.cimgz o. ${_path_rc}$1.cimgz
  fi

  repeat {$!-1} l[$>,-1] split_opacity[0]
    +syntexturize. {0,max(10,100*w/$4)},{0,max(10,100*h/$4)}
    if $5 +syntexturize.. {w},{h} +syntexturize... {w},{h} a[-3--1] c fi
    r. {0,w},{0,h},1,100%,5 c. 0,255
    adjust_colors. ${6-10}
    if $12 k[0,-1] rv
    else blend[0,-1] ${bm$2},{if($2<=4,$3,1)}
    fi
  a[^-1] c endl done rm.

#@gui Blur [Angular] : fx_blur_angular, fx_blur_angular_preview(1)
#@gui : Amplitude (%) = float(2,0,20)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Sharpness = float(0,0,500)
#@gui : Preview Guides = bool(1)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/16/01</i>.</small>")
fx_blur_angular :
  ac "blur_angular $1%,$2%,$3% sharpen $4",$6,$7

fx_blur_angular_preview :
  fx_blur_angular $*
  if $5
    line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
    line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
  fi

#@gui Blur [Bloom] : fx_blur_bloom, fx_blur_bloom_preview(0)
#@gui : Amplitude = float(1,0,10)
#@gui : Ratio = float(2,0,5)
#@gui : Iterations = int(5,0,100)
#@gui : Operator = choice("Add","Max","Min")
#@gui : Kernel = choice("Quasi-Gaussian","Gaussian","Box","Triangle","Quadratic")
#@gui : Normalize Scales = bool(0)
#@gui : Anisotropy = float(0,0,1)
#@gui : Angle = float(0,-180,180)
#@gui : note = note("Parameter <i>Angle</i> is only active when <i>Anisotropy</i>&gt;0")
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/03/02</i>.</small>")
fx_blur_bloom :
  op=${"arg 1+$4,+,max,min"}
  if {!$7} ac "blur_bloom ${1-3},"$op",${5-6},xy",$9
  else
    wh={[w,h]}
    rotate $8,2,1
    ac "blur_bloom ${1-3},"$op",${5-6},x blur_bloom {$1*(1-$7)},${2-3},"$op",${5-6},y",$9
    rotate {-$8},2,1
    r $wh,1,100%,0,0,0.5,0.5 c 0,255
  fi

fx_blur_bloom_preview :
  gui_split_preview "fx_blur_bloom $*",${-3--1}

#@gui Blur [Depth-of-Field] : fx_blur_dof, fx_blur_dof_preview(1)
#@gui : Blur Amplitude = float(3,0,20)
#@gui : Blur Precision = int(16,2,64)
#@gui : Depth-of-Field Type = choice{"Gaussian","User-Defined (Bottom Layer)"}
#@gui : Invert Blur = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small><b>Gaussian depth-of-field:</b></small>")
#@gui : Center (%) = point(50,50,0,0,255)
#@gui : First Radius = float(30,0,200)
#@gui : Second Radius = float(30,0,200)
#@gui : Angle = float(0,0,180)
#@gui : Sharpness = float(1,0,8)
#@gui : Preview Guides = bool(1)
#@gui : sep = separator()
#@gui : note = note("<small><b>User-defined depth-of-field:</b></small>")
#@gui : Gamma = float(0,-2,2)
#@gui : note = note("<small>You can specify your own depth-of-field image, as a <b>bottom layer</b> image whose luminance encodes the depth for each pixel.
#@gui : Don't forget to modify the <b>Input layers</b> combo-box to make this layer active for the filter.</small>")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/25/02</i>.</small>")
fx_blur_dof :
  _$0 ${1-10},0,$12

fx_blur_dof_preview :
  _fx_blur_dof $*

_fx_blur_dof :
  if {!$3}  # Gaussian DOF.
    repeat $! l[$>] if $11 drgba fi split_opacity l[0]
      rmax={(w*w+h*h)^0.5} R={$7*$rmax/100} r={$8*$rmax/100}
      t={$9*pi/180} u={cos($t)} v={sin($t)}
      l1={($rmax/(1e-8+$R))^2} l2={($rmax/(1e-8+$r))^2}
      a={$l1*($u)^2+$l2*($v)^2} b={$u*$v*($l1-$l2)} c={$l1*($v)^2+$l2*($u)^2}
      100%,100%,1,1,'X=(x-$5*w/100)/max(w,h);Y=(y-$6*h/100)/max(w,h);f=$a*X*X+2*$b*X*Y+$c*Y*Y;exp(-f^$10/2.5)'
      -[1] 1 *[1] -$1 ms={im} Ms={iM}

      if $11 # With preview of guides.
        +isoline3d[1] {0.1*$1} col3d. 255,255,0
        +isoline3d[1] {0.5*$1} col3d. 255,128,0
        +3d[-2--1]
        __fx_dof_blur[0,1] $2,$ms,$Ms,$4
        [0],[0],1,3 j3d. ..,0,0,0,1,1,0,0 rm..
        circle. $5%,$6%,3,1,255,255,255
        +compose_channels. + !=. 0 dilate. 3
        j[0] ..,0,0,0,0,0.5,.,1 rm[-2,-1]
      else __fx_dof_blur[0,1] $2,$ms,$Ms,$4 # Without preview.
      fi
    endl if $11 k[0] fi a c endl done
  elif {$!>1} # User-defined DOF (as bottom layer).
    luminance. n. 0,1 ^. {10^$12}
    repeat {$!-1} +r. {$>,w},{$>,h},1,1,3 l[$>,-1] split_opacity[0]
      __fx_dof_blur[0,-1] $2,0,$1,$4
    a c endl done rm.
  else drgba to "Depth-of-field (bottom layer) is missing !",2,2,13,2,1,255
  fi

# Render DOF blur (generic)
# [0] = Input image
# [1] = continuous DOF field (with same size as [0]).
# $1 = nb quantization levels.
# $2 = minimal blur level.
# $3 = maximal blur level.
# $4 = invert blur.
__fx_dof_blur :
  n[1] 0,{$1-1} round[1]
  [0],[0],1,{0,s+1}
  s=0
  repeat $1
    +==[1] {if($4,$<,$>)} b. 2%
    j.. [0],0,0,0,0,-1,.,1
    j.. .,0,0,0,100%,-1
    rm.
     ns={$2+($3-$2)*($>+1)/($1-1)}
     b[0] {sqrt($ns^2-$s^2)}%
     s=$ns
  done
  s. c,{-s+1} /[-2,-1] rm[0,1]

#@gui Blur [Gaussian] : fx_gaussian_blur, fx_gaussian_blur_preview(0)
#@gui : XY-Amplitude = float(3,0,20)
#@gui : X-Amplitude = float(0,0,20)
#@gui : Y-Amplitude = float(0,0,20)
#@gui : Boundary = choice(1,"Black","Nearest")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_gaussian_blur :
  b $1,$4
  if {$2>0} repeat $! l. s y b $2,$4 a y endl mv. 0 done fi
  if {$3>0} repeat $! l. s x b $3,$4 a x endl mv. 0 done fi

fx_gaussian_blur :
  ac "_fx_gaussian_blur $1,$2,$3,$4",$5,$6

fx_gaussian_blur_preview :
  gui_split_preview "fx_gaussian_blur $*",${-3--1}

#@gui Blur [Glow] : fx_glow, fx_glow_preview(0)
#@gui : Amplitude = float(6,0,20)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_glow :
  ac "glow $1",$2,$3

fx_glow_preview :
  gui_split_preview "fx_glow $*",${-3--1}

#@gui Blur [Linear] : fx_blur_linear, fx_blur_linear_preview(1)
#@gui : Tangent Radius = float(10,0,100)
#@gui : Orthogonal Radius = float(0.5,0,100)
#@gui : Angle = float(0,0,180)
#@gui : Sharpness = float(0,0,500)
#@gui : Boundary = choice(1,"Black","Nearest")
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_blur_linear :
  ac "blur_linear $1,{$2*$1/100},$3,$5 sharpen $4",$6,$7

fx_blur_linear_preview :
  gui_split_preview "fx_blur_linear $*",${-3--1}

#@gui Blur [Radial] : fx_blur_radial, fx_blur_radial_preview(1)
#@gui : Amplitude = float(3,0,20)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Sharpness = float(0,0,500)
#@gui : Preview Guides = bool(1)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/16/01</i>.</small>")
fx_blur_radial :
  ac "blur_radial $1%,$2%,$3% sharpen $4",$6,$7

fx_blur_radial_preview :
  fx_blur_radial $*
  if $5
    line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
    line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
  fi

#@gui Chromatic Aberrations : fx_chromatic_aberrations, fx_chromatic_aberrations_preview(0)
#@gui : Primary Color = color(255,0,0)
#@gui : X-Shift = float(2,-16,16)
#@gui : Y-Shift = float(2,-16,16)
#@gui : sep = separator()
#@gui : Secondary Color = color(0,255,0)
#@gui : X-Shift (px) = float(0,-16,16)
#@gui : Y-Shift (px) = float(0,-16,16)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/05/07</i>.</small>")
fx_chromatic_aberrations :

  # Compute orthonormal color basis.
  l[]
    (${1-3}) (${6-8}) y c orientation[0]
    +*[0,1] +*[0] {is} -[1,3] rm[2] orientation[1]
    _cross3d {0,^},{^} y x a y
    M={^} transpose Minv={^} rm
  endl

  # Shift images.
  repeat $! l[$>] to_color split_opacity l[0]
    mix_rgb $M
    s c
    100%,100%,1,2 fc. {($9-$4)/2},{($10-$5)/2} warp[0] .,1,2,1 rm.
    100%,100%,1,2 fc. {($4-$9)/2},{($5-$10)/2} warp[1] .,1,2,1 rm.
    100%,100%,1,2 fc. {(-$4-$9)/2},{(-$5-$10)/2} warp[2] .,1,2,1 rm.
    a c
    mix_rgb $Minv
  endl a c endl done
  c 0,255

fx_chromatic_aberrations_preview :
  gui_split_preview "fx_chromatic_aberrations $*",${-3--1}

#@gui Dirty : fx_dirty, fx_dirty_preview(0)
#@gui : Amplitude = float(30,0,100)
#@gui : Monochrome = bool(1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/24/11</i>.</small>")
fx_dirty :
  ac "_fx_dirty ${1-2}",$3,$4

fx_dirty_preview :
  gui_split_preview "fx_dirty ${1--2}",${-3--1}

_fx_dirty :
  repeat $! l[$>]
    dct 100%,100%,1,{if($2,1,s)} noise. $1,2
    ==. 0 point. 0,0,0,1,1
    * idct c 0,255
  endl done

#@gui Flip &amp; Rotate Blocs : fx_flip_blocs,fx_flip_blocs_preview(0)
#@gui : X-Size (px) = int(4,1,128)
#@gui : Y-Size (px) = int(4,1,128)
#@gui : Flip = choice(3,"None","X-axis","Y-axis","XY-axes")
#@gui : Rotate = choice(1,"-90 deg.","0 deg.","90 deg.")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/01/09</i>.</small>")
fx_flip_blocs :
  repeat $! l[$>]
    if $5 ac "_fx_flip_blocs ${1-4}",$5
    else _fx_flip_blocs ${1-4}
    fi
  endl done

_fx_flip_blocs :
  if {($3%2)" && "$1>1} s x,-$1 mirror x a x fi
  if {($3>1)" && "$2>1} s y,-$2 mirror y a y fi
  if {$4!=1" && "$1>1" && "$2>1}
    s y,-$2 N=$!
    s x,-$1 M={$!/$N}
    ap "rotate {($4-1)*90}"
    append_tiles $M,$N
  fi

fx_flip_blocs_preview :
  gui_split_preview "fx_flip_blocs $*",${-3--1}

#@gui JPEG Artefacts : fx_jpeg_artefacts, fx_jpeg_artefacts_preview(0)
#@gui : note = note("<small>This filter simulates the JPEG compression artifacts, using DCT quantization on 8x8 blocs.</small>")
#@gui : Quality (%) = int(50,1,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/05/07</i>.</small>")
fx_jpeg_artefacts :

  # Input all 8x8 DCT and iDCT kernels.
  # (Generated with: l[] 8,8,64,1,"y*w+x==z" s z +ap idct a[-64--1] z ap[^-1] dct a[0--2] z nm idct,dct endl)
  base642img "MSBmbG9hdCBsaXR0bGVfZW5kaWFuCjggOCA2NCAxICMyMjIyCnic5Vs9q51FEC60kKtWMYpaCirYKCoI767iR6UoSangtdM/EAM2Fgab2FhaWdgIUXOqVO8sXEHBVDFia6kgCBaCQSyu+5w8c3nv5p55Bg+3uSmGs19nP2Z2Zt752P39/bJ/G8PHF5+qD1y4v77+yNWyeulegPWy9bbW+9pJ7z9XH6s/f3KxdLBeRr2hjDb0nfR+4OZyxwlw8UbHS4f1nehtBTg66f3kAyOU261OfDTiA/ehEV91ga8T208+cDlg5JNKPiknvR8ykfKwLuRlo7y0k96PegS8MxsB80RAnROBRYC9R0AZtxF45o1w+cXz9fHvztTnP7y7nv7z5dLBern1NvTht37/75P17Qt/lOsPPQqwXrbeth6D/6Hv3F2fl2/++WXqMPfyegzmwZz439e9755fHwbMvTxjHqwFQBlt6MMYjMV/8F/MgbkwJ+bGGlgLa2Jt7AF7wRjMg/+hD3vG3nmGxr0Y5/S+euPGe/XVJ/ZKB+vlBkAZbeh77ctX6re/f1E6WC83AMpoQ9+Zd++oV6+8WTpYLzcAymhD30+fPlee/e2zqcPcywZAGW3oO6J+aPw437jeuJ9xv+N5xvMCD/d1vABPL3QcdVjjpbcV4rb+2PGK8jsdxx3QjrZCvJevOl2A3/c7jTqs8dvbJtKkgK7A/eU+rsMEGoDOpJehjDb0YQzG4j+kpWEuzIm5sQbWwpqkc8NesCfsDXvEXrFn3oGGs+BMOBvOiLPizPgP+fzgW3Gsu87wb4mxTj53fixjfeDxo+qb2suC/2+Z1+ub9uX1TefyOundSG/HlxFfjfRupHclvo34dno30tvpNZNeRnob6V1I75n0nknvQnr7fZl4XybSu5Lexvs28b45vSvp7fe18L4W0ruS3n7fC+97JV808oWRLyr5ppCvGvnKyFeVfFfIl418aeTLSr4t5GsjX8/ka+f76Yj6ofHjfON6437G/Y7nGc/rMtZlJfVBoz5weXrAS9QHjfrAKI+N8tj1gVEfuDyfKc+N+sCoD2bqg4n6oPia1AeuTwr1SaU+KNQHE/VRoT5yfVBd9lCfVeoz1wfVdZPbSJvAv6ECsAjc5vq/oOZX+1Pncx3nusp1zkJ3lL1+p37gXcad7GXb490CoIw212MYi//4XcNcmNPvNdbCmn4vo341v9qfOt8HH71V/7rzSulgvYx6Qxlt3vfg36cBxnZDGW3+v6F+aPw4n1pv7Ffzq/2p9YCb6x0nwMXZjpcOa7z3trUcAW6f6TgFLv07BDjvbRNwDEAZbf5dgrH4zx5lEebCnJgba2AtrOlyK+pX86v9qfO5LeQ20lgfeHzk+RK0L30ut8ybrav51f7UOsRHIz6cHkZ6NOLTiM9Cesykh5EehfQw0mMiPQrpWUnPRnoU0qOqfjW/2p86H/nA5YDzbCWfFPKR85mRz5zvyxH1Q+PH+dR6Y7+aX+1PrUd52yhvG+Vlo7w0ylujvDXKW6O8nSlvC+VtobwulNcT5W2lvHV5Xynvi+pX86v9qfMp+x6+ogiUfU0fVAQlAuWfgF8rAuUfUPb9Kdrnl/p32E7/VuswXaJ93vvKKrCvV7Qhdm/aCQf2H77bd29+m69tMpTR5vYfxuI/+O8q8E9g7VP0L2BP2Bv2eIn+hVP85o/8A9QxZW9h37ucQd+1fkee7veow9TLBYAy2q5Rr0T29dmF/U55d2C/uz4a6ofGK//EuJ9xv+N5xvMu7XvgfHew74Ez4BV4Bo6BW+B1h/a529erhX29WtjXmBPf9+g732ncYU1XfN9jLQDKaEMfxmAs/rNL2w5zrRb+idXCP4E9YC/YE/aGPWKvO/QvLP0DXO+Qf0DZ9+Rz5ycb68q+Hnh85HkL2m3B/xvt+E378rryD+wG9j1wRXqXnYV9zvuAvsl5dLSvSa9KelfS20jvifQupHcjvQvvy7z87+oI/4TLFtLbdhb+Bd4H3Nd5N/APYL29hb3s37P+nYA+8lUhX03kKyPfzcq+9m+Qswv7fcH3dkT90Hjlnxj3M+53PM94XmXfU55OlKeF+qBQH0xL+xo0WQ32NeV5oTx3fVDcN+Q+HuqDRn1g1Afz0j+BuVeDf4L6aKY+MuoDoz6YlX8gESO3LWHbGP2xrp+InzfGSw58kxjLeEpN9G8bvz/W9RPx823j7dvG7491/UT8fB07Zbx0rZsYT/VvZ9W/bfz+WNdPxMu3jbNvG68/1vUT8XMjvmxBr0J8lkT/tvH7Y10/ET/fNt6+bfz+WNdPxM+N8tS/Pz3uZQt5GvVvG78/1vUT9nccP9f2t8ohCO3zhP8h9A8o/0PC/g7t+4T9HfoXlH2e8D+E/gHlf0jY36F9n7C/Q/+Css8T/ofQP6D8Dwn7O7TvE/Z36F9Q9nnC/xD6B5T/IWF/h/Z9wv4O/QvKPk/4H0L/gPI/JOzv0L5P2N+hf0HZ5wn/Q+gfUP6HhP0d2vcJ+zv0Lyj7POF/CP0Dyv+QsL9D+z5hf4f+BWWfJ/wPoX9A+R8S8XMVo1f5Ayp+r/IHwvnV/tT5EvFzFb9X+QMqfq/yB8L5E/kD4fkS8XMVv1f5Ayp+r/IHVL6Ayh8I10vEz1X8XuUPqPi9yh8I50/kD4TnS8TPVbxe5Q+o+L3KH1B5Aip/IFwnET9X8XuVP6Di9yp/IJw/kT8Qni8RP1fxe5U/oOL3Kn9A5Quo/IFwvUT8XMXvVf6Ait+r/IFw/kT+QHg+lZ+fyL8P7XvlP1D2u/IPJN4fhO8LVH5+Iv8+tO9V/n3i/UHoH0i8PwjfF6j8/ET+ffg+QPkPEu8Pwvz+xPuD8H2Bys9P5N+H7wNU/n3i/UGY3594fxC+L1D5+Yn8+9C+V/4DZb8r/0Di/UH4vkDl5yfy78P3ASr/PvH+IMzvT7w/CN8XqPz8RP59+D5A+Q8S7w/C/P7E+4PwfYHKz0/k34f2vcq/T7w/CP0DifcH4fuC/wBiGjbi"
  base642img "MSBmbG9hdCBsaXR0bGVfZW5kaWFuCjggOCA2NCAxICMyOTE3CnicjVsxjybFEV0JB4iDyHdYhhAJIznBAiSS6ZbBkb3YS4glHOI/4ENyQuDTOsAJIRGBEyP7di+6cKo5yZY4J95DmxKChIREYMln5ODo1/OqXd9KU1XZzX37Tc+rqqlX9aq+o6Ojevr+T+rvlh/VH9x6uh716189d79c/un9cue1pwo+O//pu/Xhw9/WF/5+Mv62vnet/vzHn5Qb37xe8D189vs//Lr+4i8/G/d5853H6r+/d7d89sGrBffE9/DZP/734jjjN7e+Lp989efy4Jnny6NHj4o9H9e/NOfj3zgP98T3cP3u4x+V+3ffKufffr7g7/AsOA/3xDU+++F/bpRXvvxwwT3wnHgWnIdrfA+fPfnFswvw4lx87/y1p6Rft/48rT9Pe+O5+4Jnw/PjjO9/8zquW7dH65hbee8a/m5gw/kPPnhV8D181u3RTt55rOHewI1n+9czz0u/bv1+rX+nvX3rawFePf+sn9+vxZ4PvMANTH/79vO1X0u3R+v2aDcf/0jwPdwbeF/68sO1X0t/VunPI5/efUuAF7iB99oXz679Wro9pNtDbvf7Af8bm73HucDf7VDUH8BfNn8LcONvuh2KxgP+7mTztwA3nrvboWg84B5vb/4W4Ab+boei8QD89nzgPzPnA//Nzd8DN/B3OywaD8D/6ebvgRv36XZYNB6A//bm7xW4gb/bYdF4AP4723mtx72YeBjPA/w3NrwN55t4GPbAc3624R0+MfEw7IF7Pdjwtv68YuJh2AP49XxgM/Ewzgf+8w1v63Fv42HYA/hf2fAK/s/Ew7AH7v3khlf6fVYTD8MexC/EX4i/8fxK/EL8lfgb8VfiF+KvxN+IvxK/EH8h/kb8lfiF+Avxz/OJfyX+QvxC/JX4V+IvxC/EX4h/Jf6F+IX4C+Nf9DzGvzD+GuN/4mX8C+O/Mf4nXsa/MP4b418UL+NfGP+N8T/PZ/zP8xn/Ey/jf2X8C+N/4mX8r4x/YfyvipfxvzL+xfgb+a8w/1Xmn2L8jfxXmP8q85/1N/JfYf6rzH/V+Bv5rzD/VeY/62/kv8L8N883/kb+W5j/KvOf9Tfy38L8V5j/ivE38t/C/FeY/0b+Z74ddiD/CflHyH9N/U3+a+Q/If819Tf5r5H/hPzX1N/kPyH/Cflvnk/+m+eT/5r6m/wn5L+V/Cfqb/KfkP9W8p+ov8l/K/lvPQr4X/n7+Ap/3yN/R/yLd+k6+eain4/rv/bzX+7PhvMt3xG/EP/I1X/sn93p9v9vtzHsiGvaX2j/ybe0f6P9x5m4F95fvKO0n8B+/+w2OiP/efyv+Rp4Lwx/H5O/I/7FPfE94H2ixx/eseusRz7u8Qe8mu8Y/7MeQvwDr+ZbfK9f126P2u1R+f41zbd8/2Y9hvcPeIEbeG9v70/B9/AZ3p+I/5W/7xn+7niKxkPEv8D/8ebvBc+Pez/BfHyxxb8w/xXmv8L8N84CfubfAtzAj3jSeMDfMf8W5t/K/DvsAvw3N38P3MCPfKjxEPG/8vfxFf5We0T8C/zkn9LjfjHxMOwB/OS/Sv7TeBj2AP4bG95Rd5t4GPbAc5N/K/lX42HYA/jPNryV/KnxMOwR8b/y9/EV/ib+kH+JfyH+lfgL8QvxF+IX4q/E34i/EH8j/kr8jfgL8Tfir8TfiH8hfiH+Qvwt4n/l73uGvy82eww7RPzL+F8UL+N/YfwXxn9RvIz/wvivjP+Jl/FfGP+V8T/xMv4L478y/idexv/C+C8R/xt/I/9N/mb+C/nX+Bv5b2X+E+a/1fhb2P9MPoRfjL8HjzD/NeY/629h/zX5GBiNv0e/w/zXmP8k4n/l7+Mr/E3+k4h/yX9F/U3+W8h/i6132P8K+9/xXpD/qvqb/FfJfwf1Fvvvxv572Jj8V9Xf5L9C/lsi/rd8YftvxNPZ1n9PviN+If5RY0f8HfG/5Uvar9B+o3/P6g979UvE/9pvAS/jZ9YT7L9F8x3jf9ZDiP+IvyP+B17Nl3x/Zj2F9yerP+zVLxH/a/+NeGH+EOYP7b+F+a8w/xXmv2GXiL8j/sezMH+uzJ/C/DnsktUf9uqXiP+Bn/xx0H+rPfB35L9C/tN4GPaI+Dvi/3PTv5M/NR6GPbL6w179EvE/8a8nV/pv4q/EvxC/vg+F+CXi74j/z03/zvqpaD19nfpjRn/Yq18i/tf+W/Ey/teT//ffwvq3sP4trH+HHSL+jvif8b8qXsb/yviXrP6wV79E/G/8Xdg/TD5h/63+FvY/kw+RFyL+jvjf+Hth/zT5FHkhqz/s1S8R/9t6wfbf5D/t94r6m/xXyH9LxN8R/9t6if1zYf88+ves/rBXv0T8H+nnmf5b9WrbfyNXnG/1n6v/R/ODqP6wej31m4P6I+L/SD/P9t94JupXc56B9yfS/6P5QVR/nJr6g/rdnOdo/+fxf6SfZ/tvvBPULwv1yxEPkf4fzQ+i+uPU1B/Ubyv122b4b5f/I/08039Tvz7ov9Uekf4fzQ+i+uOU9cdD1h8mHoY9Iv6P9PNM/835xUH/Tfw6/9jV/6P5QVR/EH8h/nZq6g/khYj/I/08238rXsb/wvgvkf4fzQ+i+uPU1B+c31XO75rWPx7/R/p5tv9m/lutno28EOn/0fwgqj+Mv4Xz26nnq/7j8X+kn2f6b51X2P6b/LdE+n80P4jqDzuv4fz+oP5I8P/kO+IX4l8Nfo//3fl9gv8n3xF/I34x+D3+d/cXEvwvmu8Y/7MeMvHv8b87v0/wf9N8x/if9ZCJf4//3f2FBP8L89/C/FeY/8TkP4//3fl9gv8b819h/qvMf83kP4//3f2FBP9P/Z78p/GwGP7z+N+d3yf4v5H/KvlP46EY/vP4391fSPD/1O9Z/4jWw6b+8fjfnd8n+L+x/qmsf5rWw6b+8fjf3V9I8L+w/l1Y/xbWv2LqX4//3fl9gv8b69/C+rey/m2m/vX4391fSPC/+ntl/zP50PQ/Hv+78/sE/6u/hf3P5EPT/3j87+4vJPh/1jvsf4X972r6X4//3fl9gv9nvcP+t7H/FdP/evzv7i8k9H93fp7Q/6feTf3jgH8T+r+7P5DQ/6febeuHe6wfEvq/Oz9P6P+Tf6l/zXmI0b88/d/dH0jo/031zgtTPxyzfkjo/+78PKH/T/6l/tmof1ajf3r6v7s/kND/G/XPWT9Q/2yqfwb6vzs/T+j/lfp3o/49+dfo357+7+4PJPT/Rv37oH5QeyT0f3d+ntD/K+cfjfOPyb9m/uHp/+7+QEL/b5x/HNQPxB/2/9H8PKH/T/7l/Ktx/lXN/MvT/939gYT+3zj/mvUD519N51+B/u/OzxP6/+Rfzj+nHm7mn57+7+4PJPR/9bdcmPqB+S+c/0fz84T+P+cdnH8f8G9C/3f3BxL6/5x32PqB/Bf2/xF/Wr7b2f9z5/eJ/T+3fsjoD97+QmL/z+XPy3j/z53fJ/b/3Pohqz/s7S8k9v9c/ryM9//c+X1i/8+tH7L6w97+QmL/z+XPy3j/z53fJ/b/3Pohoz94+wuJ/T+XPy/j/T93fp/Y/3Prh4z+4O0vJPb/XP68jPf/3Pl9Yv/PrR+y+sPe/kJi/8/lT+Pvvf0/d36f2P9z64es/rC3v5DY/3P509Y7O/t/7vw+sf/n1g8Z/cHbX4j4P5qfZ/vvPf0+0v+j/YGo/ojmF4nf/7nz82z/vaffR/p/tD8Q1R/R/CLx+z93fp7tv/f0+0j/j/YHovojml8kfv/nzs+z/feefh/p/9H+QFR/RPOLxO//3Pl5tv/e0+8j/T/aH4jqj2h+kfj9nzs/z/bfe/p9pP9H+wNR/RHNLxK//3Pn59n+e0+/j/T/aH8gqj+i+UXi93/u/Dzbf+/p95H+H+0PRPVHNL/4DgTd2gQ="
  nm[-2,-1] dct,idct

  # Input DCT quantization matrix.
  i[Q] (16,11,10,16,24,40,51,61;12,12,14,19,26,58,60,55;14,13,16,24,40,57,69,56;14,17,22,29,51,87,80,62;18,22,37,56,68,109,103,77;24,35,55,64,81,104,113,92;49,64,78,87,103,121,120,101;72,92,95,98,112,100,103,99)
  f. "const S = $1<50?5000/$1:200-2*$1; max(1,round((S*i+50)/100,1,-1))"

  # Process images.
  repeat {$!-3} l[$>,-3--1]

    # Decompose image into luma/chroma
    l[0] w,h={[w,h]} r {w+(-w%16)},{h+(-h%16)},1,100%,0,3 rgb2ycbcr s c r[-2,-1] 50%,50%,1,1,2 round. endl

    repeat 3
      # Compute DCT of image with 8x8 blocs.
      [$>]
      f[$>] "begin(boundary = 2; res = vector64());
        if (!(x%8) && !(y%8),
          src = crop(x,y,8,8);
          for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = sum(src*crop(#"$dct",0,0,off,8,8,1))));
          draw(#-1,res,x,y,0,0,8,8);
        ); i"
      round.

      # Compute DCT quantization.
      +r[Q] {$>,w},100%,1,1,0,2 /.. . round.. *[-2,-1]

      # Compute iDCT of 8x8 blocs.
      f. "begin(boundary = 2; res = vector64());
        if (!(x%8) && !(y%8),
          src = crop(x,y,8,8);
          for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = sum(src*crop(#"$idct",0,0,off,8,8,1))));
          draw(#"$>",res,x,y,0,0,8,8);
        ); i"
      rm.
      round[$>]
    done
    l[^3--1] r ${-max_wh},1,1,1 a c ycbcr2rgb round. r $w,$h,1,3,0 endl

  endl done
  rm[dct,idct,Q]

fx_jpeg_artefacts_preview :
  gui_split_preview "fx_jpeg_artefacts $*",${-3--1}

#@gui Lomo : fx_lomo, fx_lomo_preview(1)
#@gui : Vignette Size = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>J&#233;rome Boulanger</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/06/06</i>.</small>")
fx_lomo :
  remove_opacity repeat $! l[$>] to_rgb
    +gaussian {100-$1}%,{100-$1}% n. 0,1 *
    s c
    f[0] '255*atan((i-128)/128)'
    f[1] '255*tan((i-128)/128)'
    f[2] '255*atan((i-128)/255)'
    a c
    sharpen 1
    normalize 0,255
  endl done

fx_lomo_preview :
  gui_split_preview "fx_lomo $*",${-3--1}

#@gui Mess With Bits : fx_mess_with_bits, fx_mess_with_bits_preview
#@gui : note = note("<small><b>Input processing:</b></small>")
#@gui : Pre-Normalize = bool(1)
#@gui : Smoothness (%) = float(15,0,100)
#@gui : Multiplier = int(1,1,256)
#@gui : sep = separator(), note = note("<small><b>Output processing:</b></small>")
#@gui : Reversing = choice{1,"None","Reverse bits","Reverse bytes"}
#@gui : Bit Masking (Start) = int(0,0,15)
#@gui : Bit Masking (End) = int(15,0,15)
#@gui : Opacity (%) = float(100,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2019/01/16</i>.</small>")
fx_mess_with_bits :
  ac "_fx_mess_with_bits ${1-7}",$8

_fx_mess_with_bits :
  repeat $! +l[$>]
    b {($2/100)^2*100}% if $1 n 0,255 fi * $3 round
    # -> Here, images are 'ushort'-valued.
    if {$4==1} f "for (k = res = 0, k<15, ++k, res|=((i>>k)&1)<<(15-k))"
    elif {$4==2} f "res = ((i>>8)&255) | ((i&255)<<8)"
    fi
    f "begin( mask = (65535>>(15-max($5,$6))) & (65535<<min($5,$6))); i & mask"
    n 0,255
  endl j[$>] .,0,0,0,0,{$7%} rm. done

fx_mess_with_bits_preview :
  gui_split_preview "fx_mess_with_bits $*",${-3--1}

#@gui Noise [Additive] : fx_noise, fx_noise_preview(0)
#@gui : Amplitude = float(10,0,200)
#@gui : Noise Type = choice("Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_noise :
  ac "_fx_noise $1,$2",$3,$4

_fx_noise :
  repeat $! l[$>] split_opacity l[0] noise $1,$2 endl a c endl done

fx_noise_preview :
  gui_split_preview "fx_noise $*",${-3--1}

#@gui Noise [Perlin] : fx_noise_perlin, fx_noise_perlin_preview(1)
#@gui : Random Seed = int(0,0,65536)
#@gui : sep = separator(), note = note("<small><b>1st scale:</b></small>")
#@gui : Amplitude = float(100,0,512)
#@gui : Scale (%) = float(8,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>2nd scale:</b></small>")
#@gui : Amplitude = float(0,0,512)
#@gui : Scale (%) = float(4,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>3rd scale:</b></small>")
#@gui : Amplitude = float(0,0,512)
#@gui : Scale (%) = float(2,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>4th scale:</b></small>")
#@gui : Amplitude = float(0,0,512)
#@gui : Scale (%) = float(1,0,100)
#@gui : X/Y-Ratio = float(0,-4,4)
#@gui : sep = separator(), Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2019/01/24</i>.</small>")
_fx_noise_perlin :
  seedx,seedy={[$1>>8,$1&255]}
  repeat $! l[$>]
    if $2 .,.,1,. noise_perlin. {r=2^$4;s=max(w,h)*$3%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $2 + fi
    if $5 .,.,1,. noise_perlin. {r=2^$7;s=max(w,h)*$6%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $5 + fi
    if $8 .,.,1,. noise_perlin. {r=2^$10;s=max(w,h)*$9%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $8 + fi
    if $11 .,.,1,. noise_perlin. {r=2^$13;s=max(w,h)*$12%;[max(1,s/r),max(1,s*r)]},1,$seedx,$seedy *. $11 + fi
  endl done

fx_noise_perlin :
  ac "_fx_noise_perlin $*",$-4,1

fx_noise_perlin_preview :
  gui_split_preview "fx_noise_perlin $*",${-3--1}

#@gui Noise [Spread] : fx_spread, fx_spread_preview(0)
#@gui : X-Variations = float(4,0,20)
#@gui : Y-Variations = float(4,0,20)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_spread :
  ac "spread $1,$2",$3,$4

fx_spread_preview :
  gui_split_preview "fx_spread $*",${-3--1}

#@gui Old-Movie Stripes : fx_stripes_y, fx_stripes_y_preview(1)
#@gui : Frequency = float(10,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_stripes_y :
  ac "stripes_y $1",$2,$3

fx_stripes_y_preview :
  gui_split_preview "fx_stripes_y $*",${-3--1}

#@gui Oldschool 8bits : fx_8bits, fx_8bits_preview(0)
#@gui : Scale = float(25,1,100)
#@gui : Dithering = float(800,0,10000)
#@gui : Levels = int(16,2,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/02/11</i>.</small>")
fx_8bits :
  remove_opacity repeat $! l[$>]
    w={w} h={h}
    r $1%,$1%,1,100%,2
    +luminance sharpen. $2 otsu. 256 blend[-2,-1] shapeaverage0
    l. s c quantize $3,1,1 a c endl
    r. $w,$h,1,100%,1
  endl done

fx_8bits_preview :
  gui_split_preview "fx_8bits $*",${-3--1}

#@gui Pixel Sort : fx_pixelsort, fx_pixelsort_preview(1)+
#@gui : note = note{"<small><b>Sorting parameters:</b></small>"}
#@gui : Order = choice(1,"Decreasing","Increasing")
#@gui : Axis = choice("X-axis","Y-axis","X-axis Then Y-axis","Y-axis Then X-axis")
#@gui : Sorting Criterion = choice("Red","Green","Blue","Intensity","Luminance","Lightness","Hue","Saturation","Minimum","Maximum","Random")
#@gui : sep = separator()
#@gui : note = note{"<small><b>Masking parameters:</b></small>"}
#@gui : Mask By = choice(1,"Bottom Layer","Criterion","Contours","Random")
#@gui : Lower Mask Threshold (%) = float(0,0,100)
#@gui : Higher Mask Threshold (%) = float(100,0,100)
#@gui : Mask Smoothness (%) = float(0,0,5)
#@gui : Invert Mask = bool(0)
#@gui : Preview Mask = bool(0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter implements one version of the algorithm described here :
#@gui : </small>"}
#@gui : url = link("http://satyarth.me/articles/pixel-sorting/")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/05/09</i>.</small>")
fx_pixelsort :
  _fx_pixelsort ${1-8},0

_fx_pixelsort :
  repeat {$!-($4==0)} l[$>]
    if {$3==0} +to_rgb channels. 0              # Red
    elif {$3==1} +to_rgb channels. 1            # Green
    elif {$3==2} +to_rgb channels. 2            # Blue
    elif {$3==3} +compose_channels +             # Intensity
    elif {$3==4} +luminance                      # Luminance
    elif {$3==5} +to_rgb rgb2hsl. channels. 2  # Lightness
    elif {$3==6} +to_rgb rgb2hsl. channels. 0  # Hue
    elif {$3==7} +to_rgb rgb2hsl. channels. 1  # Saturation
    elif {$3==8} +compose_channels min           # Minimum
    elif {$3==9} +compose_channels max           # Maximum
    else 100%,100%,1,1 rand. 0,100               # Random
    fi
    if {$4==0} pass. 0 norm.
    elif {$4==1} .
    elif {$4==2} +gradient_norm[0]
    else +rand. 0,100
    fi
    b. $7% ir. $5%,{$6+0.01}%
    if $8 ==. 0 fi
    if $9 k. * 255
    else pixelsort[0] {`$1?_'+':_'-'`},{`$2==0?'x':$2==1?'y':$2==2?'xy':'yx'`},[1],[2] k[0]
    fi
  endl done

fx_pixelsort_preview :
  _fx_pixelsort $*

#@gui Rain &amp; Snow : fx_rain, fx_rain_preview(0)
#@gui : Angle = float(65,-180,180)
#@gui : Speed = float(10,0,50)
#@gui : Density (%) = float(50,0,100)
#@gui : Radius = float(0.1,0,3)
#@gui : Gamma = float(1,0,2)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_rain :
  repeat $! l[$<] nm=${-gui_layer_name}
    100%,100% l.
      noise 300 c 0,255 b 1,0
      c {100-$3}%,100%
      +>= 40% blend shapeaverage0
      blur_linear $2,$4,$1
      max n 0,255 apply_gamma $5
      nm name($nm),mode(screen),opacity({$6*100})
    endl
    rv
  endl done

fx_rain_preview :
  gui_split_preview "repeat $! l[$>] fx_rain $* rv blend screen,$6 endl done",${-3--1}

#@gui Random Shade Stripes : fx_shade_stripes, fx_shade_stripes_preview(1)
#@gui : Frequency = float(30,1,100)
#@gui : Orientation = choice(1,"Horizontal","Vertical")
#@gui : Darkness = float(0.8,0,3)
#@gui : Lightness = float(1.3,0,3)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_shade_stripes :
  ac "shade_stripes $1,$2,$3,$4",$5,$6

fx_shade_stripes_preview :
  gui_split_preview "fx_shade_stripes $*",${-3--1}

#@gui Scanlines : fx_scanlines, fx_scanlines_preview(0)
#@gui : Amplitude = float(60,0,255)
#@gui : Bandwidth = float(2,1,300)
#@gui : Shape = choice(0,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,0,360)
#@gui : Offset = float(0,0,500)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/19/11</i>.</small>")
fx_scanlines :
  ac "scanlines ${1-5}",$6,$7

fx_scanlines_preview :
  gui_split_preview "fx_scanlines $*",${-3--1}

#@gui Self Glitching : fx_self_glitching, fx_self_glitching_preview(1)
#@gui : Multiplier = float(0,-5,5)
#@gui : Bias = float(0,-255,255)
#@gui : Negate = bool(0)
#@gui : Operator = choice("Add","Mul","And","Or","Xor","Pow","Reverse Pow","Mod","Reverse Mod")
#@gui : Shift Point = point(50,50,0,1)
#@gui : Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/08/19</i>.</small>")
fx_self_glitching :
  ac "_fx_self_glitching ${1-7}",$8

_fx_self_glitching :
  f "begin(
       shift = ([w,h]-1)*(50-[$5,$6])%;
       const sign = $3?-1:1;
       const boundary = $7;
     );
     val = sign*((2^$1)*j(shift) + $2);
     ($4==0?(val + i):
      $4==1?(val * i):
      $4==2?(val & i):
      $4==3?(val | i):
      $4==4?xor(val,i):
      $4==5?(val^i):
      $4==6?(i^val):
      $4==7?(val%i):
      (i%val)
     )%256;
  "

fx_self_glitching_preview :
  gui_split_preview "fx_self_glitching $*",${-3--1}

#@gui Streak : fx_streak,fx_streak(1)
#@gui : Mask Color = color(255,0,0,255)
#@gui : Step (%) = float(0,0,30)
#@gui : Angle = float(0,0,360)
#@gui : Propagation = choice(3,"Backward","Forward","Bidirectional [Sharp]","Bidirectional [Smooth]")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/12/22</i>.</small>")
fx_streak :
  repeat $! l[$>]
    to_rgba
    if {!$4} R,G,B,A=0 else R,G,B,A=${1-4} fi +select_color 0,$R,$G,$B,$A
    if {$7==3} srgb2rgb.. fi
    f.. "
      const step = max(1,$5%*min(w,h));
      const angle = $6*pi/180;
      const dx = step*cos(angle);
      const dy = step*sin(angle);
      if (!i(#-1),I,
        ixf = xf = x; iyf = yf = y; lf = 0; if ($7>=1, while (i(#-1,ixf=round(xf),iyf=round(yf)), ++lf; xf-=dx; yf-=dy)); # Forward
        ixb = xb = x; iyb = yb = y; lb = 0; if ($7!=1, while (i(#-1,ixb=round(xb),iyb=round(yb)), ++lb; xb+=dx; yb+=dy)); # Backward
        $7==0?I(ixb,iyb):
        $7==1?I(ixf,iyf):
        $7==2?(lf<lb?I(ixf,iyf):I(ixb,iyb)):
        (lb*lb*I(ixf,iyf) + lf*lf*I(ixb,iyb))/(lb^2+lf^2);
      )"
    if {$7==3} rgb2srgb.. fi
    rm.
  endl done

#@gui Visible Watermark : fx_watermark_visible, fx_watermark_visible(0)
#@gui : Text = text{"\\251 G'MIC"}
#@gui : Opacity = float(0.4,0.1,0.9)
#@gui : Size = int(50,13,128)
#@gui : Angle = float(25,0,360)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Lightness = choice(1,"Darker","Brighter")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_watermark_visible : skip "${1= }"
  watermark_visible "$1",$2,$3,$4,$6,$5

#@gui Warp by Intensity : fx_warp_by_intensity, fx_warp_by_intensity_preview(0)
#@gui : X-Factor = float(0.04,-6,6)
#@gui : Y-Factor = float(0.04,-6,6)
#@gui : sep = separator()
#@gui : X-Offset = float(128,0,255)
#@gui : Y-Offset = float(128,0,255)
#@gui : sep = separator()
#@gui : Correlated Channels = bool(0)
#@gui : Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/02/09</i>.</small>")
fx_warp_by_intensity :
  if {!$7} to_a fi
  ac "_fx_warp_by_intensity ${1-7}",$8

_fx_warp_by_intensity :
  if $5 f "ni = norm2(R,G,B); J((ni-$3)*$1,(ni-$4)*$2,0,$6,$7)"
  else f "j((i-$3)*$1,(i-$4)*$2,0,0,$6,$7)"
  fi

fx_warp_by_intensity_preview :
  gui_split_preview "fx_warp_by_intensity $*",${-3--1}

#@gui ____<b>Details</b>
#------------------------

#@gui Details Equalizer : fx_equalize_details, fx_equalize_details_preview(0)
#@gui : Base Scale = float(5,0,15)
#@gui : Detail Scale = float(0.5,0,5)
#@gui : note = note("<small><b>Coarse scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>Medium scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>Small scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), note = note("<small><b>Fine scale:</b></small>")
#@gui : Threshold = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Smoothness Type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gui : Gain = float(0,-4,4)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(32,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/11/11</i>.</small>")
_fx_equalize_details :
  repeat $! l[$>]
    split_details 5,{max(0.1,$1)},{max(0.1,$2)}
    __fx_equalize_details[1] ${3-6},8
    __fx_equalize_details[2] ${7-10},4
    __fx_equalize_details[3] ${11-14},2
    __fx_equalize_details[4] ${15-18},1
    + c 0,255
  endl done

__fx_equalize_details :
  threshold $1,1
  if {$3==0} b {$2*$5/2}
  elif {$3==1}
    if {$2>0}
      m={im} M={iM} n. 0,255
      repeat {int($2/5)} bilateral 15,{5*$5} done
      bilateral 15,{($2%5)*$5}
      *. {($M-$m)/255} +. $m
    fi
  else smooth {$2*50},0.2,0.8,$5,$5 fi
  * {10^$4}

fx_equalize_details :
  ac "gui_parallel_overlap \"_fx_equalize_details ${1-18}\",$21,$22",$19,$20

fx_equalize_details_preview :
  gui_split_preview "fx_equalize_details $*",${-3--1}

#@gui Equalize Local Histograms : fx_equalize_local_histograms, fx_equalize_local_histograms_preview(0)
#@gui : Strength (%) = float(75,0,100)
#@gui : Mode = choice(2,"Raw","Hard","Soft")
#@gui : Radius = int(4,1,16)
#@gui : Sigma = float(100,0,256)
#@gui : Regularization = float(8,0,32)
#@gui : Reduce Halos = bool(1)
#@gui : sep = separator(), Channel(s) = choice(16,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/01/31</i>.</small>")
fx_equalize_local_histograms :
  b0="normal" b1="overlay" b2="softlight"
  repeat $! l[$>]
    +ac "_fx_equalize_local_histograms ${1-6}",$7,1
    blend ${b$2},{$1%}
  endl done

_fx_equalize_local_histograms :
  +n 0,511 round.
  f. "
    begin(
      const boundary = 1;
      const N = $3;
      const sigma = ($6?1:-1)*(0.1+$4);
      weights = vector512();
      for (k = 0, k<size(weights), ++k, # Pre-compute exponentials
        weights[k] = sigma>=0?exp(-sqr(k/sigma)):1 - exp(-sqr(k/sigma))
      );
    );

    bins = vector512(0);

    for (c = 0, c<s, ++c,
      V = crop(x - N,y - N,0,c,2*N+1,2*N+1,1,1);
      for (k = 0, k<size(V), ++k, # Compute local weighted histogram
        val = V[k];
        diff = abs(val - V[size(V)/2]);
        bins[val]+=weights[diff];
      );
    );

    sum = 0;
    for (k = 0, k<size(bins), ++k,
      sum+=bins[k];
      bins[k] = sum;
    );
    bins/=max(1e-5,sum);

    P = I;
    size(P)==1?(P = bins[P[0]]; 0):
    size(P)==2?(P = [ bins[P[0]], bins[P[1]] ]; 0):
    size(P)==3?(P = [ bins[P[0]], bins[P[1]], bins[P[2]] ]; 0):
    size(P)==4?(P = [ bins[P[0]], bins[P[1]], bins[P[2]], bins[P[3]] ]; 0);
    P"
  n. 0,255
  if $5 norm.. bilateral. ..,$5,{2+$5} fi
  k.

fx_equalize_local_histograms_preview :
  gui_split_preview "fx_equalize_local_histograms $*",${-3--1}

#@gui Freaky Details : fx_freaky_details, fx_freaky_details_preview(0)
#@gui : Amplitude = int(2,1,5)
#@gui : Scale = float(10,0,100)
#@gui : Iterations = int(1,1,4)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(32,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Patrick David</i>.      Latest Update: <i>2013/27/02</i>.</small>")
#@gui : sep = separator(), note = note("This effect has been done following:")
#@gui : url = link("This tutorial from Patrick David","http://blog.patdavid.net/2013/02/calvin-hollywood-freaky-details-in-gimp.html")
_fx_freaky_details :
  repeat $! l[$>]
    repeat $3
      . +-. 255 *. -1
      repeat $1 bilateral. $2,{1.5*$2} done
      blend[-2,-1] vividlight blend overlay
    done
  endl done

fx_freaky_details :
  ac "gui_parallel_overlap \"_fx_freaky_details ${1-3}\",$5,$6",$4
  n 0,255

fx_freaky_details_preview :
  gui_split_preview "fx_freaky_details $*",${-3--1}

#@gui Local Normalization : fx_normalize_local, fx_normalize_local_preview(0)
#@gui : Amplitude = float(2,0,60)
#@gui : Radius = int(6,1,64)
#@gui : Neighborhood Smoothness = float(5,0,40)
#@gui : Average Smoothness = float(20,0,40)
#@gui : Constrain Values = bool(1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_normalize_local :
  repeat $! l[$>]
    ac "normalize_local $1,$2,$3,$4,$5,0,255",$6
  endl done

fx_normalize_local_preview :
  gui_split_preview "fx_normalize_local $*",${-3--1}

#@gui Local Processing : fx_local_processing, fx_local_processing_preview(1)
#@gui : Action = choice("Normalize","Equalize")
#@gui : Strength (%) = float(75,0,100)
#@gui : Neighborhood Size (%) = float(10,1,100)
#@gui : Overlap (%) = float(50,0,75)
#@gui : Regularization (%) = float(20,0,100)
#@gui : Process Channels Individually = bool(0)
#@gui : sep = separator(), Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/02/28</i>.</small>")
fx_local_processing :
  com0="n 0,255"
  com1="equalize 256,0,255 n 0,255"
  com=${com$1}
  if $6 com="s c "$com" a c" fi
  repeat $! l[$>]
    size={round(max(8,max(w,h)*$3%))}
    +ac "at \""$com"\","$size","$size",1,$4%,$4%",$7
    if $5 +norm[0] bilateral[1] .,{$5/20}%,{2+$5/4} rm. fi
    blend alpha,{$2%}
  endl done

fx_local_processing_preview :
  gui_split_preview "fx_local_processing $*",${-3--1}

#@gui Magic Details : fx_magic_details,fx_magic_details_preview(0)
#@gui : Amplitude = float(6,0,30)
#@gui : Spatial Scale = float(3,0,10)
#@gui : Value Scale = float(15,0,20)
#@gui : Edges = float(-0.5,-3,3)
#@gui : Smoothness = float(2,0,20)
#@gui : sep = separator(), Channel(s) = choice(27,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/01/10</i>.</small>")
fx_magic_details :
  ac "_fx_magic_details ${1-5}",$6,1

_fx_magic_details :
  repeat $! l[$>]
    +bilateral $2,$3
    +gradient_norm.. +. 1
    pow. {$4>=0?3.1-$4:-3.1-$4}
    b. $5 n. 1,{1+$1}
    -... .. *[-3,-1] + c 0,255
  endl done

fx_magic_details_preview :
  gui_split_preview "fx_magic_details $*",${-3--1}

#@gui Mighty Details : fx_mighty_details, fx_mighty_details_preview(0)
#@gui : Amplitude = float(25,0,100)
#@gui : Details Amount = float(1,0,2)
#@gui : Details Scale = float(25,1,100)
#@gui : Details Smoothness = int(1,0,10)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/08/08</i>.</small>")
_fx_mighty_details :
  +smooth $3,0,1,0.5,0.5 -[1] [0]
  +abs. sign.. M={iM} ^. {2-$2} *. {$M/iM} *[-2,-1]
  +diffusiontensors[0] 0,1,0.5,0.5
  repeat $4 smooth[1] [2],20 done
  *[1] {-$1/5} +

fx_mighty_details :
  ac "_fx_mighty_details ${1-4}",$5,1
  n 0,255

fx_mighty_details_preview :
  gui_split_preview "fx_mighty_details $*",${-3--1}

#@gui Sharpen [Deblur] : fx_deblur, fx_deblur_preview(0)
#@gui : Radius = float(2,0,20)
#@gui : Iterations = int(10,0,100)
#@gui : Time Step = float(20,0,50)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Regularization = choice(1,"Tikhonov","Mean Curvature","Total Variation")
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_deblur :
  ac "gui_parallel_overlap \"deblur ${1-5} c 0,255\",$7,$8",$6,1

fx_deblur_preview :
  gui_split_preview "fx_deblur $*",${-3--1}

#@gui Sharpen [Gold-Meinel] : fx_unsharp_goldmeinel, fx_unsharp_goldmeinel_preview(0)
#@gui : Sigma = float(1,0.5,10)
#@gui : Iterations = int(5,1,15)
#@gui : Acceleration = float(1,1,3)
#@gui : Blur = choice(1,"Exponential","Gaussian")
#@gui : Cut = bool(true)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;r&#244;me Boulanger</i>.      Latest Update: <i>2013/29/03</i>.</small>")
fx_unsharp_goldmeinel:
   ac "gui_parallel_overlap \"_fx_unsharp_goldmeinel $*\",$7,$8",$6,1

_fx_unsharp_goldmeinel :
  deblur_goldmeinel $*
  if $5 c 0,255 else n 0,255 fi

fx_unsharp_goldmeinel_preview:
  gui_split_preview "fx_unsharp_goldmeinel $*",${-3--1}

#@gui Sharpen [Inverse Diffusion] : fx_sharpen_inversediff, fx_sharpen_inversediff_preview(0)
#@gui : Amplitude = float(50,1,300)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sharpen_inversediff :
  ac "gui_parallel_overlap \"repeat $2 sharpen $1 c 0,255 done\",$4,$5",$3,1

fx_sharpen_inversediff_preview :
  gui_split_preview "fx_sharpen_inversediff $*",${-3--1}

#@gui Sharpen [Octave Sharpening] : fx_unsharp_octave, fx_unsharp_octave_preview(0)
#@gui : Scales = int(4,1,10)
#@gui : Maximal Radius = float(5,0,20)
#@gui : Amount = float(3,0,10)
#@gui : Threshold = float(0,0,255)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_unsharp_octave :
  ac "gui_parallel_overlap \"unsharp_octave $1,$2,$3,$4\",$6,$7",$5,1

fx_unsharp_octave_preview :
  gui_split_preview "fx_unsharp_octave $*",${-3--1}

#@gui Sharpen [Richardson-Lucy] : fx_unsharp_richardsonlucy, fx_unsharp_richardsonlucy_preview
#@gui : Sigma = float(1,0.5,10)
#@gui : Iterations = int(10,1,100)
#@gui : Blur = choice(1,"Exponential","Gaussian")
#@gui : Cut = bool(true)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;r&#244;me Boulanger</i>.      Latest Update: <i>2013/29/03</i>.</small>")
fx_unsharp_richardsonlucy :
  deblur_richardsonlucy $*
  if $4 c 0,255 else n 0,255 fi

fx_unsharp_richardsonlucy_preview :
  gui_split_preview "fx_unsharp_richardsonlucy $*",${-3--1}

#@gui Sharpen [Shock Filters] : fx_sharpen_shock, fx_sharpen_shock_preview(0)
#@gui : Amplitude = float(150,1,400)
#@gui : Edge Threshold = float(0.1,0,0.7)
#@gui : Gradient Smoothness = float(0.8,0,10)
#@gui : Tensor Smoothness = float(1.1,0,10)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sharpen_shock :
  ac "gui_parallel_overlap \"repeat $5 sharpen $1,$2,$3,$4 c 0,255 done\",$7,$8",$6,1

fx_sharpen_shock_preview :
  gui_split_preview "fx_sharpen_shock $*",${-3--1}

#@gui Sharpen [Texture] : fx_sharpen_texture, fx_sharpen_texture_preview(0)
#@gui : Strength = float(1,0,4)
#@gui : Radius = float(4,0,32)
#@gui : sep = separator(), Channel(s) = choice(16,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/09</i>.</small>")
fx_sharpen_texture :
  ac "_fx_sharpen_texture ${1-2}",$3,1

_fx_sharpen_texture :
  repeat $! l[$>]
    +rolling_guidance $2,5,0.5 -. [0] *. $1 - c 0,255
  endl done

fx_sharpen_texture_preview :
  gui_split_preview "fx_sharpen_texture $*",${-3--1}

#@gui Sharpen [Unsharp Mask] : fx_unsharp, fx_unsharp_preview(0)
#@gui : Sharpening Type = choice(1,"Gaussian","Bilateral")
#@gui : Spatial Radius = float(1.25,0,20)
#@gui : Bilateral Radius = float(10,0,60)
#@gui : Amount = float(2,0,10)
#@gui : Threshold = float(0,0,20)
#@gui : Darkness Level = float(1,0,4)
#@gui : Lightness Level = float(1,0,4)
#@gui : Iterations = int(1,1,10)
#@gui : Negative Effect = bool(0)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : note = note{"\n\n<small><b>Note: </b>
#@gui : This filter is inspired by the original GIMP <i>Unsharp Mask</i> filter, with additional parameters.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_unsharp :
  repeat $! repeat $8
    if {$1==0} +b. $2 else +bilateral. $2,$3 fi
    -. .. *. -$4
    +norm. >=. $5% r. .. *[-2,-1]
    if $9 *. -1 fi
    +c. 0,100% c.. -100%,0 *.. $6 *. $7 +[-2,-1]
    +[-2,-1] c. 0,255
  done mv. 0 done

fx_unsharp :
  ac "_fx_unsharp $1,$2,$3,$4,$5,$6,$7,$8,$9",$10,1

fx_unsharp_preview :
  gui_split_preview "fx_unsharp $*",${-3--1}

#@gui Split Details [Alpha] : fx_split_details_alpha, fx_split_details_alpha_preview(0)
#@gui : Number of Levels = int(6,2,8)
#@gui : Base Scale = float(10,0,30)
#@gui : Details Scale = float(1,0,20)
#@gui : Opacity Gain = float(5,1,20)
#@gui : sep = separator()
#@gui : Preview Without Alpha = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/22/04</i>.</small>")
fx_split_details_alpha :
  remove_opacity
  repeat $! l[$<]
    repeat {$1-1}
      s={$3+($2-$3)*$>/if($1-2>0,$1-2,1)}
      +_fx_split_details_alpha_blur. $s
      sub_alpha.. .,$4
    done
  endl done

_fx_split_details_alpha_blur :
  if {$1>=0.1} b. $1
  else
    if {$1>=0.05} (1,4,7,4,1;4,16,26,16,4;7,26,41,26,7;4,16,26,16,4;1,4,7,4,1)
    else (1,2,1;2,4,2;1,2,1) fi
    normalize_sum. convolve.. . rm.
  fi

fx_split_details_alpha_preview :
  repeat $! l[$>]
    fx_split_details_alpha ${1-4}
    if $5 remove_opacity[^-1] else to_rgba. fi
    N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
    repeat $! l[$>] 0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0] endl done
    to_rgba frame 1,1,0 frame 3,3,255 append_tiles ,
  endl done

#@gui Split Details [Gaussian] : fx_split_details_gaussian, fx_split_details_gaussian_preview(0)
#@gui : Number of Scales = int(6,3,12)
#@gui : Base Scale = float(10,0,200)
#@gui : Details Scale = float(1,0,20)
#@gui : sep = separator(), Sharpen details in preview = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/22/01</i>.</small>")
fx_split_details_gaussian :
  remove_opacity repeat $! l[$>]
    nm=${-gui_layer_name}
    pos=${-gui_layer_pos}
    split_details $1,$2,$3
    +[^0] 128 c[^0] 0,255 round
    repeat {$!-1} nm[{1+$>}] "mode(grainmerge), name"($nm" [scale ""#"{1+$>}"]), pos("$pos")" done
    nm[0] "name"($nm" [residual]), pos("$pos")"
    rv
  endl done

fx_split_details_gaussian_preview :
  repeat $! l[$>]
    fx_split_details_gaussian $*
    if $4 equalize[^-1] 256 fi n[^-1] 0,255
    N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
    repeat $! l[$>] 0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0] endl done
    to_rgba frame 1,1,0 frame 3,3,255 append_tiles ,
  endl done

#@gui Split Details [Wavelets] : fx_split_details_wavelets, fx_split_details_wavelets_preview(0)
#@gui : Number of Scales = int(6,2,12)
#@gui : Add Alpha Channels to Detail Scale Layers = _bool(0)
#@gui : sep = separator(), Sharpen Details in Preview = bool(0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter decomposes an image into several detail scales, using wavelet atrous.
#@gui : It should provide similar results to the
#@gui : <a href="http://registry.gimp.org/node/11742">Wavelet Decompose Plug-in</a>
#@gui : (by Marco Rossini).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/23/03</i>.</small>")
fx_split_details_wavelets :
  remove_opacity repeat $! l[$>]
    nm=${-gui_layer_name}
    pos=${-gui_layer_pos}
    split_details $1,0,0 rv +[^-1] 128 c[^-1] 0,255 round
    if $2 to_a[^-1] fi
    repeat {$!-1} nm[$>] "mode(grainmerge), name"($nm" [scale ""#"{1+$>}"]), pos("$pos")" done
    nm. "name"($nm" [residual]), pos("$pos")"
  endl done

fx_split_details_wavelets_preview :
  repeat $! l[$>]
    fx_split_details_wavelets $1,0
    if $3 equalize[^-1] 256 fi n[^-1] 0,255
    N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
    repeat $! l[$>] 0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0] endl done
    to_rgba frame 1,1,0 frame 3,3,255 append_tiles ,
  endl done

#@gui Tone Mapping : fx_map_tones, fx_map_tones_preview(0)
#@gui : Threshold = float(0.5,0,1)
#@gui : Gamma = float(0.7,0,1)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Iterations = int(30,0,500)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_map_tones :
  ac "map_tones ${1-4}",$5,1
  n 0,255

fx_map_tones_preview :
  gui_split_preview "fx_map_tones $*",${-3--1}

#@gui Tone Mapping [Fast] : fx_map_tones_fast, fx_map_tones_fast_preview(0)
#@gui : Radius = float(3,0,20)
#@gui : Power = float(0.5,0,1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Paul Nasca</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/10/06</i>.</small>")
fx_map_tones_fast :
  ac "map_tones_fast $1,$2",$3,2

fx_map_tones_fast_preview :
  gui_split_preview "fx_map_tones_fast ${^0}",${-3--1}

#@gui ____<b>Frames</b>
#----------------------

#@gui Droste : fx_droste, fx_droste_preview(1)
#@gui : note = note("<span color=\"red\">Upper-left coordinates :</span>")
#@gui : X0 = float(20,0,100)
#@gui : Y0 = float(20,0,100)
#@gui : sep = separator(), note = note("<span color=\"magenta\">Upper-right coordinates :</span>")
#@gui : X1 = float(80,0,100)
#@gui : Y1 = float(20,0,100)
#@gui : sep = separator(), note = note("<span color=\"blue\">Lower-right coordinates :</span>")
#@gui : X2 = float(80,0,100)
#@gui : Y2 = float(80,0,100)
#@gui : sep = separator(), note = note("<span color=\"cyan\">Lower-left coordinates :</span>")
#@gui : X3 = float(20,0,100)
#@gui : Y3 = float(80,0,100)
#@gui : sep = separator()
#@gui : Iterations = int(1,1,10)
#@gui : X-Shift = float(0,-100,100)
#@gui : Y-Shift = float(0,-100,100)
#@gui : Angle = float(0,0,360)
#@gui : Zoom = float(1,0.1,5)
#@gui : Mirror = choice("None","X-Axis","Y-Axis","XY-Axes")
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui : Drawing Mode = choice{"Replace","Replace (Sharpest)","Behind","Below"}
#@gui : View Outlines Only = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/11/06</i>.</small>")
fx_droste :
  repeat $!
    if {$16==1} 100%,100%,1,1,'x' 100%,100%,1,1,'y' a[-2,-1] c fi
    repeat $9
      x0={round($1*w/100)} y0={round($2*h/100)} x1={round($3*w/100)} y1={round($4*h/100)}
      x2={round($5*w/100)} y2={round($6*h/100)} x3={round($7*w/100)} y3={round($8*h/100)}
      100%,100%,1,2,-32767 polygon. 4,$x0,$y0,$x1,$y1,$x2,$y2,$x3,$y3,1,-65535
      sh. 0 f. 'if(i==-65535,x03=$x0+(y-$y0)/($y3-$y0)*($x3-$x0);x12=$x1+(y-$y1)/($y2-$y1)*($x2-$x1);(x-x03)/(x12-x03)*(w-1),i)' rm.
      sh. 1 f. 'if(i==-65535,y01=$y0+(x-$x0)/($x1-$x0)*($y1-$y0);y32=$y3+(x-$x3)/($x2-$x3)*($y2-$y3);(y-y01)/(y32-y01)*(h-1),i)' rm.
      xshift={w*$10/100} yshift={h*$11/100} alpha={-$12*pi/180} ca={cos($alpha)/$13} sa={sin($alpha)/$13} w2={w/2} h2={h/2}
      f. 'if(i==-32767,i,X=i(x,y,0,0)-$w2;Y=i(x,y,0,1)-$h2;if(c==0,$w2-$xshift+X*$ca-Y*$sa,$h2-$yshift+X*$sa+Y*$ca))'
      if {$14==0} sh. 0 f. 'if(i==-32767,x,i)' rm. sh. 1 f. 'if(i==-32767,y,i)' rm.
      elif {$14==1} sh. 0 f. 'if(i==-32767,x,w-1-i)' rm. sh. 1 f. 'if(i==-32767,y,i)' rm.
      elif {$14==2} sh. 0 f. 'if(i==-32767,x,i)' rm. sh. 1 f. 'if(i==-32767,y,h-1-i)' rm.
      else sh. 0 f. 'if(i==-32767,x,w-1-i)' rm. sh. 1 f. 'if(i==-32767,y,h-1-i)' rm.
      fi
      if {$16<2} warp.. .,0,{$16==0},$15 rm.
      else
        +warp.. .,0,1,$15 rm..
        if {$16==3} rv[-2,-1] fi
        blend[-2,-1] alpha
      fi
    done
    if {$16==1} warp.. .,0,1,1 rm. fi
    mv. 0 done

fx_droste_preview :
  if {!$17} fx_droste $* else polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,0.3,0,0,0,255 fi
  polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,1,0xFFFFFFFF,0,0,0,255
  ellipse $1%,$2%,3,3,0,1,255,0,0,255 ellipse $1%,$2%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  ellipse $3%,$4%,3,3,0,1,255,0,255,255 ellipse $3%,$4%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  ellipse $5%,$6%,3,3,0,1,0,0,255,255 ellipse $5%,$6%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  ellipse $7%,$8%,3,3,0,1,0,255,255,255 ellipse $7%,$8%,3,3,0,1,0xFFFFFFFF,0,0,0,255

#@gui Frame [Blur] : fx_frame_blur, fx_frame_blur(1)
#@gui : Horizontal Size (%) = float(30,0,100)
#@gui : Vertical Size (%) = float(30,0,100)
#@gui : sep = separator()
#@gui : Crop = float(0,0,100)
#@gui : Blur = float(5,0,10)
#@gui : Roundness = float(0,0,1)
#@gui : Apply Color Balance = bool(0)
#@gui : Balance Color = color(128,128,128)
#@gui : Normalization = choice("None","Stretch","Equalize")
#@gui : sep = separator()
#@gui : Outline Size = float(5,0,50)
#@gui : Outline Color = color(255,255,255)
#@gui : X-Shadow = float(2,-10,10)
#@gui : Y-Shadow = float(2,-10,10)
#@gui : Shadow Smoothness = float(1,0,5)
#@gui : Shadow Contrast = float(0,0,100)
#@gui : X-Centering = float(0.5,0,1)
#@gui : Y-Centering = float(0.5,0,1)
#@gui : Angle = float(0,-180,180)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/19/01</i>.</small>")
fx_frame_blur :
  repeat $! l[$>] to_rgb
    sx={$1%*max(w,h)} sy={$2%*max(w,h)}
    +r {w+$sx},{h+$sy},1,100%,3 b[1] $4%

    if $6 balance_gamma[1] ${7-9} fi
    if {$10==1} n[1] 0,255 elif {$10==2} n[1] 0,255 equalize[1] 256 fi
    rv

    z[1] {$3/2}%,{$3/2}%,{100-$3/2}%,{100-$3/2}%
    to_rgba[1]

    if $5 r={1+1/$5} sh[1] 100% f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
      v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
      c. $v,{$v+0.5/max(w,h)} n. 0,255 rm. fi

    s={$11%*max(w,h)}
    r[1] {w+$s},{h+$s},1,4,0,0,0.5,0.5
    i[1] 100%,100%,1,3 fc[1] ${12-14} blend[1,2] alpha to_a.

    if $5 sh[1] 100% f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
      v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
      c. $v,{$v+0.5/max(w,h)} n. 0,255 rm. fi
    rotate[1] $21,1,0
    r[1] [0],[0],1,4,0,0,$19,$20
    +channels[1] 100% b. $17%,0 c. 0,{max(1,100-$18)}% n. 0,255
    shift. {round(w*$15%)},{round(h*$16%)},0,0,0 /. -255 +. 1 *[0,-1]

    blend alpha
  endl done

#@gui Frame [Cube] : frame_cube, frame_cube(1)
#@gui : Depth = float(3,0,30)
#@gui : X-Center = float(0,-2,2)
#@gui : Y-Center = float(0,-2,2)
#@gui : Left Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : Right Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : Upper Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : Lower Side Orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;, Angelo Lama</i>.      Latest Update: <i>2012/29/01</i>.</small>")

#@gui Frame [Fuzzy] : fx_frame_fuzzy, fx_frame_fuzzy(0)
#@gui : Horizontal Size (%) = float(5,0,100)
#@gui : Vertical Size (%) = float(5,0,100)
#@gui : Fuzzyness = float(10,0,40)
#@gui : Smoothness = float(1,0,5)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_frame_fuzzy :
  repeat $! l[$>]
    sx={$1%*max(w,h)/2} sy={$2%*max(w,h)/2}
    frame_fuzzy $sx,$sy,${3-8}
  endl done

#@gui Frame [Mirror] : fx_frame_mirror, fx_frame_mirror_preview(1)
#@gui : note = note("<b>Frame size:</b>")
#@gui : Horizontal (%) = float(10,0,100)
#@gui : Vertical (%) = float(10,0,100)
#@gui : sep = separator(), note = note("<b>Image alignment:</b>")
#@gui : Horizontal (%) = float(50,0,100)
#@gui : Vertical (%) = float(50,0,100)
#@gui : sep = separator(), note = note("<b>Frame dilation/shrinking:</b>")
#@gui : Left = float(0,-5,5)
#@gui : Right = float(0,-5,5)
#@gui : Up = float(0,-5,5)
#@gui : Bottom = float(0,-5,5)
#@gui : sep = separator()
#@gui : Preview Opacity (%) = float(0.75,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/08/20</i>.</small>")
fx_frame_mirror :
  repeat $! l[$>]
    {100+2*$1}%,{100+2*$2}%,1,100%,"
      const boundary = 3;
      const offx = (w - w#-1)*$3%;
      const offy = (h - h#-1)*$4%;
      const f_left = 2^$5;
      const f_right = 2^$6;
      const f_up = 2^$7;
      const f_bottom = 2^$8;
      x = x - offx;
      y = y - offy;
      x<0?(x*=-f_left):
      x>=w#-1?(x = w#-1 - 1 - f_right*(x - w#-1));
      y<0?(y*=-f_up):
      y>=h#-1?(y = h#-1 - 1 - f_bottom*(y - h#-1));
      I(#-1,x,y)"
  k. endl done

fx_frame_mirror_preview :
  repeat $! l[$>]
    ws,hs={[w,h]} fx_frame_mirror $* wd,hd={[w,h]}
    rr2d $_preview_width,$_preview_height wp,hp={[w,h]}
    ws,hs={[$ws,$hs]*[$wp,$hp]/[$wd,$hd]}

    coords={off=([$wp,$hp]-[$ws,$hs])*[$3,$4]%;[off,off+[$ws,$hs]-1]}
    split_opacity 100%,100%,1,1,$9 rectangle. $coords,1,1 *[0,-1] a c
    rectangle $coords,0.75,0xF0F0F0F0,255
    rectangle $coords,0.75,0x0F0F0F0F,0,0,0,255
  endl done

#@gui Frame [Painting] : fx_frame_painting, fx_frame_painting_preview(1)
#@gui : Size (%) = float(10,0,100)
#@gui : Contrast = float(0.4,0,1)
#@gui : Smoothness = float(6,0,30)
#@gui : Color = color(225,200,120)
#@gui : sep = separator()
#@gui : Vignette Size = float(2,0,50)
#@gui : Vignette Contrast = float(400,0,1000)
#@gui : sep = separator()
#@gui : Defects Contrast = float(50,0,512)
#@gui : Defects Density = float(10,0,100)
#@gui : Defects Size = float(1,0,10)
#@gui : Defects Smoothness = float(0.5,0,20)
#@gui : sep = separator()
#@gui : Serial Number = int(123456,0,1000000)
#@gui : Frame as a New Layer = _bool(false)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/07/06</i>.</small>")
fx_frame_painting :
  if $14
    repeat $! 100%,100%,1,4 frame_painting. $1%,$2,$3%,${4-6},$7%,${8-13}
    rv[-2,-1] to_a. r. ..,..,1,4,0,0,0.5,0.5 mv[-2,-1] 0 done
  else frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}
  fi

fx_frame_painting_preview :
  frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}

#@gui Frame [Pattern] : fx_frame_pattern, fx_frame_pattern_preview(1)
#@gui : Tiles = int(10,3,30)
#@gui : Pattern = choice(1,"Top Layer","Self Image")
#@gui : Iterations = int(1,1,10)
#@gui : Constrain Image Size = _bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/01/08</i>.</small>")
fx_frame_pattern :
  if {$2||$!==1} repeat $3 frame_pattern $1,$4 done
  else repeat $3 frame_pattern[^0] $1,[0],$4 done fi

fx_frame_pattern_preview :
  fx_frame_pattern ${1-3},1

#@gui Frame [Regular] : fx_frame, fx_frame(1)
#@gui : note = note("<b>Crop parameters :</b>")
#@gui : X-Start (%) = int(0,0,100)
#@gui : X-End (%) = int(100,0,100)
#@gui : Y-Start (%) = int(0,0,100)
#@gui : Y-End (%) = int(100,0,100)
#@gui : sep = separator(), note = note("<b>Frame parameters :</b>")
#@gui : Width (%) = int(10,0,100)
#@gui : Height (%) = int(10,0,100)
#@gui : Color = color(0,0,0,255)
#@gui : Outline Size = int(1,0,100)
#@gui : Outline Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_frame :
 to_rgba repeat $!
   z. $1%,$3%,$2%,$4%
   frame. $11,$11,${12-15}
    sx={$5%*max(w,h)} sy={$6%*max(w,h)}
   frame. $sx,$sy,${7-10}
 mv. 0 done

#@gui Frame [Round] : fx_frame_round, fx_frame_round(1)
#@gui : Sharpness = float(6,0.1,40)
#@gui : Size (%) = float(20,0,100)
#@gui : Smoothness = float(0.1,0,15)
#@gui : Shade = float(0,0,1)
#@gui : Color = color(255,255,255,255)
#@gui : Blur Frame = float(0,0,100)
#@gui : Blur Shade = float(0.1,0,1)
#@gui : Blur Amplitude = float(3,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_frame_round :
  frame_round ${1-8}
  if $9 frame_blur $1,{min(99,$1+$9)},$3,$10,$11% fi

#@gui Frame [Smooth] : fx_frame_smooth, fx_frame_smooth(1)
#@gui : Width (%) = int(10,0,100)
#@gui : Height (%) = int(10,0,100)
#@gui : Roundness = float(0.25,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/25/04</i>.</small>")
fx_frame_smooth :
  repeat $! l[$>]
     sx={$1%*max(w,h)} sy={$2%*max(w,h)}
     100%,100%,1,1,0
     if $3 r={1+1/$3} f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
       v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))} <=. $v
     fi
     frame $sx,$sy,1
     inpaint_diffusion[0] [1],100%,1,15
     rm.
  endl done c 0,255

#@gui Old Photograph : fx_old_photo, fx_old_photo(1)
#@gui : Vignette Strength = float(200,0,255)
#@gui : Vignette Min Radius = float(50,0,100)
#@gui : Vignette Max Radius = float(85,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_old_photo :
  vignette ${1-3} old_photo

#@gui Polaroid : fx_polaroid, fx_polaroid(1)
#@gui : Frame Size = int(10,0,400)
#@gui : Bottom Size = int(20,0,400)
#@gui : X-Shadow = float(0,-20,20)
#@gui : Y-Shadow = float(0,-20,20)
#@gui : Smoothness = float(3,0,5)
#@gui : Curvature = float(0,0,1)
#@gui : Angle = float(20,-180,180)
#@gui : Vignette Strength = float(50,0,255)
#@gui : Vignette Min Radius = float(70,0,100)
#@gui : Vignette Max Radius = float(95,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_polaroid :
  vignette ${8-10} polaroid $1,$2 drop_shadow $3%,$4%,$5%,$6 rotate $7,1,0

#@gui Tunnel : fx_tunnel, fx_tunnel(1)
#@gui : Depth = int(4,1,100)
#@gui : Factor = float(80,1,99)
#@gui : Center (%) = point(50,50)
#@gui : Opacity = float(0.2,0,1)
#@gui : Angle = float(0,-90,90)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/22/11</i>.</small>")
fx_tunnel :
  tunnel $1,$2%,{[${3,4}]%},${5-6}

#@gui Vignette : fx_vignette, fx_vignette
#@gui : Strength = float(70,0,255)
#@gui : Min Radius = float(70,0,100)
#@gui : Max Radius = float(95,0,100)
#@gui : Color = color(0,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/24/10</i>.</small>")
fx_vignette :
  repeat $! to_rgb l[$>]
    to_rgba split_opacity
    =. 0 vignette. ${1-3} a c +fc ${4-7} rv blend alpha
  endl done

#@gui ____<b>Frequencies</b>
#----------------------------

#@gui Bandpass : fx_bandpass, fx_bandpass_preview(0)
#@gui : Low Frequency = float(0,0,100)
#@gui : High Frequency = float(100,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice(2,"None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_bandpass :
  repeat $! l[$>] split_opacity l[0]
    ac "bandpass $1%,$2%",$3,$4
  endl a c endl done

fx_bandpass_preview :
  gui_split_preview "fx_bandpass $*",${-3--1}

#@gui Fourier Analysis : fx_display_fft, fx_display_fft(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_display_fft :
  to_rgb display_fft

#@gui Fourier Transform : fx_fourier, fx_fourier_preview(1)
#@gui : Magnitude / Phase = choice{1,"One Layer (Horizontal)","One Layer (Vertical)","Two Layers"}
#@gui : Discard Transparency = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Apply this filter once to get the direct FFT, and once again to get the reverse transform.</small>"}
#@gui : url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=3137dDa6P4s")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/06/16</i>.</small>")
fx_fourier : skip ${2=0}
  if $2 remove_opacity fi
  magic="GMICFFT"

  i=0 for {$i<$!} ni={$i+1} nm={$i,n}

    # Detect FFT/iFFT mode.
    is_ifft=0
    +columns[$i] 100% l. mag,m0,M0,m1,M1=${u\ {t}} if {['$mag']=='$magic'} is_ifft=1 fi onfail endl rm.
    if {!$is_ifft} +rows[$i] 100% l. mag,m0,M0,m1,M1=${u\ {t}} if {['$mag']=='$magic'} is_ifft=2 fi onfail endl rm. fi
    if {!$is_ifft}
      +rows[$i] 100% l. mag,m0,M0=${u\ {t}} if {['$mag']=='$magic'} is_ifft=3 fi onfail endl rm.
      if {$is_ifft==3} is_ifft=0 +rows[$ni] 100% l. mag,m1,M1=${u\ {t}} if {['$mag']=='$magic'} is_ifft=3 fi onfail endl rm. fi
    fi

    # Compute the transform.
    if {!$is_ifft} # FFT
      l[$i]
        fftpolar +.. 1 log.. m0,M0,m1,M1={[im#0,iM#0,im#1,iM#1]} n[-2,-1] 0,255
        if {$1==0} ({'$magic,$m0,$M0,$m1,$M1'},0) y. a x
        elif {$1==1} ({'$magic,$m0,$M0,$m1,$M1'},0) a y
        else ({'$magic,$m0,$M0'},0) a[-3,-1] y ({'$magic,$m1,$M1'},0) a[-2,-1] y
        fi
        nm $nm
        endl

    else # iFFT
      if {$is_ifft==1} columns[$i] 0,{$i,w-2} s[$i] x,2
      elif {$is_ifft==2} rows[$i] 0,{$i,h-2} s[$i] y,2
      else rows[$i,$ni] 0,{$i,h-2}
      fi
      l[$i,{$i+1}] n[0] $m0,$M0 n[1] $m1,$M1 exp[0] -[0] 1 ifftpolar c 0,255 endl
    fi
    i+={$1<2" || "$is_ifft>2?1:2}
  done

fx_fourier_preview :
  if $2 remove_opacity fi
  dfft

#@gui Fourier Watermark : fx_watermark_fourier, _none_
#@gui : Text = text{"(c) G'MIC"}
#@gui : Size = int(53,13,128)
#@gui : sep = separator()
#@gui : note = note("<small><b>Note: </b> To make the watermark visible afterwards, use the 'Fourier Analysis' filter. </small>")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_watermark_fourier :
  watermark_fourier "$1",$2 c 0,255

#@gui ____<b>Layers</b>
#-----------------------

#@gui Align Layers : fx_align_layers, fx_align_layers_preview
#@gui : Alignment Type = choice(0,"Rigid","Non-Rigid")
#@gui : Smoothness = float(0.7,0,1)
#@gui : Scales = choice(0,"Auto","1","2","3","4","5","6","7","8")
#@gui : Revert Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_align_layers :
  to_colormode 0
  r ${-max_wh},1,100%,0,0,0.5,0.5
  if ${4=0} _fx_revert_layers fi
  remove_opacity
  if $1 register_nonrigid[^-1] .,$2,0.1,$3
  else register_rigid[^-1] .,{3*$2}
  fi

fx_align_layers_preview :
  fx_align_layers $1,$2,0 blend_edges 0.1

_fx_revert_layers :
  repeat {int($!/2)} rv[{2*$>},{2*$>+1}] done

#@gui Blend [Average All] : fx_blend_average_all, fx_blend_average_all
#@gui : Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter takes multiple layers as input and average them. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/11/08</i>.</small>")
fx_blend_average_all :
  if $! to_rgba
    N=$! r ${-max_wh},1,100%,0,0,0.5,0.5
    _gb_fwd $1
    + / $N
    _gb_bwd $1
  fi

_gb_fwd :
  to_color
  if {$1==1} repeat $! l[$>] sh 0,2 srgb2rgb. rm. endl done
  elif {$1==2} repeat $! l[$>] sh 0,2 srgb2rgb. rgb2lab. rm. endl done
  fi

_gb_bwd :
  to_color
  if {$1==1} repeat $! l[$>] sh 0,2 rgb2srgb. rm. endl done
  elif {$1==2} repeat $! l[$>] sh 0,2 lab2rgb. rgb2srgb. rm. endl done
  fi

#@gui Blend [Edges] : fx_blend_edges, fx_blend_edges(0)
#@gui : Opacity = float(1,0,1)
#@gui : Smoothness = float(0.8,0,5)
#@gui : Revert Layers = bool(0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/21/01</i>.</small>")
fx_blend_edges :
  repeat {int($!/2)} l[$>,{$>+1}] if $3 rv fi +blend_edges[-2,-1] $2 rm... blend[-2,-1] alpha,$1 endl done

#@gui Blend [Fade] : fx_blend_fade, fx_blend_fade(1)
#@gui : Preset = choice{1,"Custom","Linear","Circular","Wave","Keftales"}
#@gui : Offset = float(0,-1,1)
#@gui : Thinness = float(0,0,10)
#@gui : Sharpness = float(5,1,20)
#@gui : Sharpest = bool(0)
#@gui : Revert Layers = bool(0)
#@gui : Colorspace = choice("sRGB","Linear RGB","Lab")
#@gui : note = note{\n<small>
#@gui : The parameters below are used in most presets.
#@gui : </small>}
#@gui : 1st Parameter = float(0,-1,1)
#@gui : 2nd Parameter = float(0,-1,1)
#@gui : 3rd Parameter = float(0,-1,1)
#@gui : note = note{\n<small>
#@gui : The formula below is used for the <i>Custom</i> preset.
#@gui : </small>}
#@gui : Formula = text{"cos(4*pi*x/w) * sin(4*pi*y/h)"}
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/21/01</i>.</small>")
fx_blend_fade :
  if {$!==1} return fi
  to_colormode 4
  _gb_fwd $7
  if {$1==0} [0],[0],1,1,"$11"
  else _fx_blend_fade$1 $8,$9,$10 r. [0],[0],1,1,3
  fi
  n. {-($!-2)*$3},{($!-2)*(1+$3)}
  -. {$2*(1+$3)*($!-2)}
  c. 0,{$!-2}
  if $6 rv[^-1] fi
  if $5 round. 1
  else roundify. $4
  fi
  blend_fade[^-1] . rm.
  _gb_bwd $7
  c 0,255

_fx_blend_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_fx_blend_fade2 : [0],[0],1,1,0 =. 1,{($1+1)*50}%,{($2+1)*50}% distance. 1
_fx_blend_fade3 : [0],[0],1,1,0 =. 1,{($1+1)*50}%,{($2+1)*50}% distance. 1 *. {0.01+$3/2} cos.
_fx_blend_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"

#@gui Blend [Median] : fx_blend_median, fx_blend_median(0)
#@gui : Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Iain Fergusson</i>.      Latest Update: <i>2014/16/12</i>.</small>")
fx_blend_median :
  _gb_fwd $1
  blend_median
  _gb_bwd $1

#@gui Blend [Seamless] : fx_blend_seamless, fx_blend_seamless_preview(1)
#@gui : Mixed Mode = bool(0)
#@gui : Inner Fading = float(0,0,100)
#@gui : Outer Fading = float(25,0,100)
#@gui : Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator()
#@gui : Output as Separate Layers = _bool(0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=10204")
#@gui : url = link("+ Video tutorial 1","http://www.youtube.com/watch?v=Nu-S1HmOCgE")
#@gui : url = link("+ Video tutorial 2","http://www.youtube.com/watch?v=zsHgQY6025I")
#@gui : url = link("+ Video tutorial 3","http://www.youtube.com/watch?v=2e6FikWMkaQ")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/04/05</i>.</small>")
fx_blend_seamless :
  rv
  _gb_fwd $4
  to_a[^0] r[^0] [0],[0],1,100%,0
  repeat $! pos=${gui_layer_pos[$>]} shift[$>] ${u\ $pos},0,0 done
  if $5 # Output as separate layers
    +blend_seamless $1,$2%,$3%
    remove_opacity[0,-1] k[0,-1] rv sub_alpha[0] [1],1
  else
    blend_seamless $1,$2%,$3% # Output as a single layer.
  fi
  _gb_bwd $4

fx_blend_seamless_preview :
  fx_blend_seamless ${1-4},0

#@gui Blend [Standard] : fx_blend, fx_blend_preview
#@gui : Mode = choice{6,"Add","Alpha","And","Average","Blue","Burn","Custom formula","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain Extract","Grain Merge","Green","Hard Light",
#@gui : "Hard Mix","Hue","Interpolation","Lighten","Lightness","Linear Burn","Linear Light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin Light","Red","Reflect","Saturation",
#@gui : "Shape Area Max","Shape Area Max0","Shape Area Min","Shape Area Min0","Shape Average","Shape Average0",
#@gui : "Shape Median","Shape Median0","Shape Min","Shape Min0","Shape Max","Shape Max0",
#@gui : "Soft Burn","Soft Dodge","Soft Light","Screen","Stamp","Subtract","Value","Vivid Light","Xor"}
#@gui : Process As = choice("Two-by-Two","Upper Layer is the Top Layer for All Blends","Lower Layer is the Bottom Layer for All Blends")
#@gui : Opacity (%) = float(100,0,100)
#@gui : Preview All Outputs = bool(1)
#@gui : sep = separator()
#@gui : Custom Formula = text{"1/2 - 1/4*cos(pi*a) - 1/4*cos(pi*b)"}
#@gui : note = note{"<small><b>Note:</b> In custom formulas, <tt>a</tt> and <tt>b</tt> respectively stand for the values of the <i>base layer<i> and the <i>blend layer</i>,
#@gui : and are defined in value range [0,1].</small>"}
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Do not forget to set the <i>Input layers</i> option below to handle multiple input layers.
#@gui : </small>"}
#@gui : url = link("Reference page for G'MIC blending modes","https://github.com/dtschump/gmic-community/wiki/Blending-modes")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/03/08</i>.</small>")
fx_blend :
  mode=${arg\ 1+$1,add,alpha,and,average,blue,burn,custom_formula,darken,difference,\
       divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
       hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
       multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
       shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
       shapeaverage,shapeaverage0,shapemedian,shapemedian0,\
       shapemin,shapemin0,shapemax,shapemax0,\
       softburn,softdodge,softlight,screen,stamp,subtract,value,\
       vividlight,xor}
  m "_blend_custom_formula : f. \"a = i#0/255; b = i#1/255; 255*cut(($5),0,1)\""
  if {$2==0} repeat {int($!/2)} l[$>,{$>+1}] rv blend $mode,{$3%} endl done # Two-by-two.
  elif {$2==1" && "$!>1} blend[^0] [0],$mode,{$3%},0 rm[0]  # Top layer is top for all blends.
  elif {$2==2" && "$!>1} blend[^-1] .,$mode,{$3%},1 rm. # Bottom layer is bottom for all blends.
  fi
  uncommand _blend_custom_formula

fx_blend_preview :
  fx_blend $"*"
  if $4 append_tiles , fi

#@gui Colors to Layers : fx_split_colors, fx_split_colors_preview(1)
#@gui : Color Tolerance = float(50,0,256)
#@gui : Maximum Number of Output Layers = int(16,2,256)
#@gui : Minimal Area (%) = float(1,0,100)
#@gui : Autocrop Output Layers = bool()
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter decomposes an image into several layers each with a single color + a residual layer (if any).
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/11/03</i>.</small>")
fx_split_colors : skip ${2=0}
  to_rgb repeat $! l[$>]
    nm=${-gui_layer_name}
    min_area={max(1,w*h*$3%)}
    split_colors $1,$2,$min_area
    nm name($nm)
    if $4 gui_autocrop_layers fi
  endl done

fx_split_colors_preview :
  repeat $! l[$>]
    +fx_split_colors ${1-4} drgba
    repeat $! l[$>] to ${arg\ {1+!!$>},"Original","#"$>},1,1,43,7,1,255 endl done
    frame 1,1,0 frame 3,3,255 to_rgba append_tiles ,
  endl done

#@gui Fade Layers : fx_fade_layers, fx_fade_layers_preview
#@gui : Inter-Frames = _int(10,2,100)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/04/08</i>.</small>")
fx_fade_layers :
  if {$!<2} return fi
  to_colormode 0
  r ${-max_wh},1,100%,0,0,0.5,0.5
  a z r 100%,100%,{(d-1)*$1+1},100%,3 s z

fx_fade_layers_preview :
  if {$!<2} return fi
  to_colormode 0
  r ${-max_wh},1,100%,0,0,0.5,0.5
  k[0,1] + / 2

#@gui Layers to Tiles : append_tiles, fx_append_tiles_preview(1)
#@gui : X-Tiles = int(0,0,256)
#@gui : Y-Tiles = int(0,0,256)
#@gui : note = note("<small>For both parameters, <i>0</i> means <i>automatic</i>.</small>")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_append_tiles_preview :
  frame 1,1,0,0,0,255 append_tiles $1,$2

#@gui Morph Layers : fx_morph, gui_no_preview
#@gui : Inter-Frames = _int(10,2,100)
#@gui : Smoothness = _float(0.2,0,2)
#@gui : Precision = _float(0.1,0,2)
#@gui : Revert Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_morph :
  if ${4=0} _fx_revert_layers fi
  to_rgb morph $1,$2,$3

#@gui Multiscale Operator : fx_apply_multiscale, fx_apply_multiscale_preview(1)
#@gui : Number of Scales = int(4,2,16)
#@gui : sep = separator()
#@gui : Starting Scale (%) = float(25,0,400)
#@gui : Ending Scale (%) = float(100,0,400)
#@gui : Non-Linearity = float(0,-1,1)
#@gui : Rescaling = choice(3,"Bloc","Linear","Cubic","Lanczsos")
#@gui : sep = separator()
#@gui : X-Centering = float(0.5,0,1)
#@gui : Y-Centering = float(0.5,0,1)
#@gui : Angle = float(0,-180,180)
#@gui : sep = separator()
#@gui : Enable Interpolated Motion = bool(0)
#@gui : Ending X-Centering = float(0.5,0,1)
#@gui : Ending Y-Centering = float(0.5,0,1)
#@gui : Ending Angle = float(0,-180,180)
#@gui : sep = separator()
#@gui : G'MIC Operator = text("")
#@gui : Return Scaling = choice("None","Bloc","Linear","Cubic","Lanczos")
#@gui : Lock Return Scaling to Source Layer = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/30/03</i>.</small>")
fx_apply_multiscale : skip "${13=}"
  repeat $! l[$<]
    w0={w} h0={h}
    apply_scales "$13",$1,$2%,$3%,{10^$4},{arg(1+$5,1,3,5,6)}
    if {$8||($9&&$8!=$12)} to_a N=$! repeat $!
      angle={$9?$8+($12-$8)*$>/max($N-1,1):$8}
      rotate[$>] $angle
    done fi
    if $14
      if $15 siz=$w0,$h0 else siz=${-max_wh} fi
      r $siz,1,100%,{arg($14,1,3,5,6)}
      c 0,255
    fi
    w=${-max_w} h=${-max_h} N=$!
    repeat $!
      cx={$9?$6+($10-$6)*$>/max($N-1,1):$6}
      cy={$9?$7+($11-$7)*$>/max($N-1,1):$7}
      gui_set_layer_pos[$>] {$>,($w-w)*$cx},{$>,($h-h)*$cy}
    done
  endl done

fx_apply_multiscale_preview :
  repeat $! l[$>]
    fx_apply_multiscale $"*"
    N={int(sqrt($!))} N={round($!/$N,1,1)} r2dy {100/$N}%
    to_rgba
    max_wh=${-max_wh}
    N=$! repeat $! l[$>]
      cx={$9?$6+($10-$6)*$>/max($N-1,1):$6}
      cy={$9?$7+($11-$7)*$>/max($N-1,1):$7}
      r $max_wh,1,100%,0,0,$cx,$cy
      0 text. "#"{1+$>}" ",1,1,24,1,255 +dilate. 5 to_rgba[1] j[0] [1],2,0,0,0,1,[2],255 k[0]
    endl done
    frame 1,1,0 frame 3,3,255 append_tiles ,
  endl done

#@gui Pack : fx_pack, fx_pack_preview(1)
#@gui : Order By = choice(2,"Width","Height","Maximum Dimension","Area")
#@gui : Tends to Be Square = bool(0)
#@gui : Force Transparency = bool(1)
#@gui : sep = separator()
#@gui : Output Coordinates File = _bool(0)
#@gui : Output Folder = _folder()
#@gui : sep = separator()
#@gui : note = note{"<small>This filter tries to pack all input layers into a single image, while trying to minimize the empty areas.
#@gui : This problem being NP-hard, the algorithm finds (of course) a <b>non-optimal</b>, but often acceptable solution to this packing problem.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/11/05</i>.</small>")
fx_pack : skip "${5=}"
  if $3 to_a fi
  if $4 repeat $! nm$>=${gui_layer_name[$>]} done fi
  c0="w" c1="h" c2="max(w,h)" c3="w*h"
  pack $2,${c$1} coords=${}
  if $4
    repeat 256 filename "$5/gmic_pack.txt",$> filename=${} if $filename else break fi done
    if {!narg($filename)} filename="$5/gmic_pack.txt" fi
    l[] repeat {narg($coords)/2}
      x={arg(1+2*$>,$coords)} y={arg(2+2*$>,$coords)}
      ({'"Image ""#"{1+$>}" ("${nm$>}"): "$x,$y\n'})
    done a x o raw:$filename,uchar rm endl
  fi
  nm "name(G'MIC packing),pos(0,0),mode(normal)"

fx_pack_preview :
  if {!$!} return fi
  w={w} h={h}
  filled=0 repeat $! filled={$>,$filled+w*h} done
  fx_pack $1,$2,$3,0
  area={w*h}
  to_rgba rr2d $w,$h,0
  i[0] $w,16,1,4,255 t[0] "Filled: "{round(100*$filled/$area)}%,3,1,14,1,0,0,0,255
  a y,0.5

#@gui Stroke : fx_stroke, fx_stroke_preview(0)
#@gui : Thickness (px) = int(3,1,256)
#@gui : Threshold (%) = float(50,0,100)
#@gui : Smoothness (px) = float(0,0,10)
#@gui : Shape = choice(2,"Square","Diamond","Round")
#@gui : Direction = choice(1,"Inward","Outward")
#@gui : sep = separator()
#@gui : Zoom (%) = float(100,1,300)
#@gui : X-Shift (px) = int(0,-256,256)
#@gui : Y-Shift (px) = int(0,-256,256)
#@gui : sep = separator()
#@gui : Starting Color = color(255,255,255,255)
#@gui : Ending Color = color(255,255,255,255)
#@gui : Inside Color = color(0,0,0,0)
#@gui : Outside Color = color(0,0,0,0)
#@gui : sep = separator()
#@gui : Output Stroke Layer On = choice(1,"Bottom","Top")
#@gui : Keep Original Image Size = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/24/06</i>.</small>")
fx_stroke :
  to_a repeat $! l[$<] nm={n}
    if {!$26" && "$5} expand_xy $1,0 is_frame1=0 else expand_xy 1,0 is_frame1=1 fi
    split_opacity +l.
      b $3
      if {$6>=100}
        shift $7,$8
        if {$6!=100} wh={w},{h} r $6%,$6%,1,1,3 r $wh,1,1,0,0,0.5,0.5 fi
      else
        if {$6!=100} wh={w},{h} r $6%,$6%,1,1,3 r $wh,1,1,0,0,0.5,0.5 fi
        shift $7,$8
      fi
      > {99.99-min(99.99,$2)}%
      distance $5,$4
      ($9^$10^$11^$12)
      if {$1>1} ($13^$14^$15^$16) a[-2,-1] x r. $1,1,1,4,3 c. 0,255 fi
      i.. ($21^$22^$23^$24) ($17^$18^$19^$20) if $5 rv[-3,-1] fi
      a[-3--1] x map.. .,1 rm.
      nm $nm
    endl
    a[0,1] c
    if $is_frame1 shrink_xy 1 fi
    if $25 rv fi
  endl done

fx_stroke_preview :
  repeat $! l[$>]
    fx_stroke $*
    nm foo
    gui_merge_layers
  endl done

#@gui Tiles to Layers : split_tiles, fx_tiles2layers_preview(1)
#@gui : X-Tiles = int(3,1,100)
#@gui : Y-Tiles = int(3,1,100)
#@gui : Force Tiles to Have Same Size = _bool(false)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_tiles2layers_preview :
  split_tiles $1,$2,$3 to_rgba frame 1,1,0,0,0,255 frame 3,3,0,0,0,0 append_tiles ,

#@gui Tones to Layers : fx_tones2layers, fx_tones2layers_preview(0)
#@gui : Number of Tones = int(3,2,10)
#@gui : Start of Mid-Tones = int(85,0,255)
#@gui : End of Mid-Tones = int(170,0,255)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Alpha = choice("Binary","Scalar")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/05/04</i>.</small>")
fx_tones2layers :
  sval=$2 eval={max($2,$3)}
  remove_opacity repeat $! l[$<]
    +luminance rv
    repeat {$1-1}
      [1]
      val0={$sval+($eval-$sval)*$>/($1-2)}
      val1={$sval+($eval-$sval)*($>+1)/($1-2)-1}
      +ir[0] $val0,$val1
      if $5 *. [0] b. $4% n. 0,255  # Scalar alpha.
      else b. $4% n. 0,255  # Binary alpha.
      fi
      a[-2,-1] c
    done
    rm[0] rv
  endl done

fx_tones2layers_preview :
  fx_tones2layers $* rv
  r {100/$!}%,{100/$!}%,1,100%,2
  to_rgba frame 1,1,0,0,0,255 frame 3,3,0,0,0,0 append_tiles ,

#@gui ____<b>Lights &amp; Shadows</b>
#------------------------------------

#@gui Burn : fx_burn, fx_burn_preview(1)
#@gui : Amplitude = float(0.5,0,1)
#@gui : Scale = float(30,1,100)
#@gui : Smoothness = float(1,0,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/24/11</i>.</small>")
_fx_burn :
  repeat $! l[$>]
    w={w} h={h}
    +norm
    fx_fourier. 0
    +rows. 0,{$h-1} r. $2%,$2%,1,100%,0,0,0.5,0.5 b. $3%
    j.. .,{($w-w)/2},{($h-h)/2} rm.
    fx_fourier. 1
    blend overlay,$1
  endl done

fx_burn :
  ac "_fx_burn ${1-3}",$4,$5

fx_burn_preview :
 gui_split_preview "fx_burn ${^0}",${-3--1}

#@gui Contrast Swiss Mask : fx_contrast_swm , fx_contrast_swm(0)
#@gui : sep = separator()
#@gui : Blur the Mask = float(2,0.5,10)
#@gui : sep = separator()
#@gui : note = note ("Contrast Mask need the negative of the mask")
#@gui : Skip to Use the Mask to Boost = bool(false)
#@gui : note = note ("Uncheck for Contrast Mask,Check for Contrast Boost")
#@gui : sep = separator()
#@gui : note = note("Merge the Mask")
#@gui : Intensity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest Update: <i>2011/01/01</i>.</small>")
#@gui : url = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=864")
fx_contrast_swm :
  repeat $! l[$>] split_opacity l[0]
   +luminance to_rgb
    blur_xy[1] $1,$1
    if {$2==0} negate[1] fi
    rv blend hardlight,$3
  endl a c endl done

#@gui Drop Shadow : fx_drop_shadow, fx_drop_shadow(1)
#@gui : X-Shadow = float(3,-20,20)
#@gui : Y-Shadow = float(3,-20,20)
#@gui : Smoothness = float(1.8,0,5)
#@gui : Curvature = float(0,0,1)
#@gui : Corner Brightness = float(0,0,1)
#@gui : Angle = float(0,0,360)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/14/11</i>.</small>")
fx_drop_shadow :
  * -1 + 255 vignette {255*$5},80,95 * -1 + 255
  drop_shadow $1%,$2%,$3%,$4 rotate $6,1,0

#@gui Drop Shadow 3D : fx_drop_shadow3d, fx_drop_shadow3d_preview(1)
#@gui : X-Angle = float(0,-90,90)
#@gui : Y-Angle = float(0,-90,90)
#@gui : Z-Angle = float(0,-90,90)
#@gui : Zoom = float(0,-100,100)
#@gui : X-Offset = float(1,-50,50)
#@gui : Y-Offset = float(1,-50,50)
#@gui : Perspective = float(2,0,10)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Color = color(0,0,0,200)
#@gui : Preview Only Shadow = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/02/07</i>.</small>")
fx_drop_shadow3d :
  repeat $! l[$<]
    +_fx_drop_shadow3d $*
  endl done

fx_drop_shadow3d_preview :
  repeat $! l[$<]
    if $13 _fx_drop_shadow3d $*
    else +_fx_drop_shadow3d $* rv blend alpha
    fi
  endl done

_fx_drop_shadow3d :
  point3d 0,0,1 r3d. 1,0,0,$1 r3d. 0,1,0,$2 r3d. 0,0,1,$3
  u={i(0,8)} v={i(0,9)} w={i(0,10)} rm.
  to_a channels 100% if {im==iM} return fi
  +f 'X=x/w-0.5;Y=y/h-0.5;A=($7-$4*$7/100)*$w/(X*$u+Y*$v+$7*$w);if(A<0,1e8,A)'
  +*. 'y/h-0.5' *.. 'x/w-0.5' +.. {0.5-$5/100} +. {0.5-$6/100} *.. {w} *. {h}
  a[-2,-1] c warp[0] .,0,1,0 rm.
  b $8% n 0,$12 i.. ($9^$10^$11) r.. .,.,1,3 a[-2,-1] c

#@gui Equalize Shadow : fx_equalize_shadow, fx_equalize_shadow_preview(1)
#@gui : Amplitude = float(1,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Francois Grassard</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/24/11</i>.</small>")
fx_equalize_shadow :
  repeat $! l[$>] +negate blend softlight,$1 endl done

fx_equalize_shadow_preview :
  gui_split_preview "fx_equalize_shadow $1",${-3--1}

#@gui Illuminate 2D Shape : fx_illuminate_shape2d,fx_illuminate_shape2d_preview(1)+
#@gui : note = note("<small><b>Input / Output:</b></small>)
#@gui : Input Type = choice{"Single Opaque Shapes Over Transp. BG","Multiple Colored Shapes Over Transp. BG","Bump Map","Normal Map"}
#@gui : Output Type = choice{"Illumination","Bump Map","Normal Map"}
#@gui : Input Guide Color = color(255,0,0,255)
#@gui : Keep Base Layer as Input Background = bool(1)
#@gui : Keep Transparency in Output = bool(1)
#@gui : sep = separator(), note = note("<small><b>Shape:</b></small>)
#@gui : Minimal Shape Area = int(4,1,100)
#@gui : note = note{"<small>Parameter <i>Minimal shape area</i> is only active in <i>Multiple colored shapes</i> input mode.</small>"}
#@gui : Preview Detected Shapes = bool(0)
#@gui : Erosion / Dilation = float(0,-10,10)
#@gui : Smoothness = float(3,0,6)
#@gui : Bump Factor = float(1,-5,5)
#@gui : Avg / Max Weight = float(1,0,1)
#@gui : Resolution = choice{4,"Full (Slower)","2048","1024","512","256","128","64 (Faster)"}
#@gui : sep = separator()
#@gui : note = note("<small><b>Illumination:</b></small>)
#@gui : Blending Mode = choice(10,"Normal","Lighten","Screen","Dodge","Add","Darken","Multiply","Burn","Overlay","Soft Light","Hard Light","Grain Merge")
#@gui : Opacity (%) = float(75,0,100)
#@gui : Ambient (%) = float(30,-100,100)
#@gui : Diffuse (%) = float(40,0,200)
#@gui : Specular (%) = float(40,0,300)
#@gui : Shininess = float(80,0,100)
#@gui : Smoothness = float(0.2,0,5)
#@gui : Flatness = float(1,0,3)
#@gui : Linearity = float(0,-100,100)
#@gui : Levels = int(0,0,16)
#@gui : Light-X = float(2,-20,20)
#@gui : Light-Y = float(-2,-20,20)
#@gui : Light-Z = float(2,0,20)
#@gui : Normalize Illumination = bool(0)
#@gui : sep = separator()
#@gui : Open Interactive Preview = button()
#@gui : Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note{"<small><b>Note:</b> This filter automatically adds illumination to an opaque shape defined over a transparent background.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/05/18</i>.</small>")
fx_illuminate_shape2d :
  input_type,\
  output_type,\
  keep_input_bg,\
  preview_shapes,\
  blending_mode,\
  opacity=$1,$2,$7,$10,$16,$17
  blending_mode=${arg\ 1+$blending_mode,normal,lighten,screen,dodge,add,darken,multiply,burn,overlay,softlight,hardlight,grainmerge}
  keep_input_bg&={$!>1}

  if $output_type # Output : bumpmap or normalmap
    repeat {$!-$keep_input_bg} _fx_illuminate_shape2d[$>] $* done

  else # Output : illumination
    repeat {$!-$keep_input_bg} if $keep_input_bg sel=$>,-1 else sel=$> fi l[$sel]
      if {!$keep_input_bg" && "$input_type>=2} # From bumpmap/normalmap w/o background
        _fx_illuminate_shape2d $*
      elif {$keep_input_bg" && "$input_type>=2} # From bumpmap/normalmap w/ background
        _fx_illuminate_shape2d[0] $*
      elif {!$keep_input_bg" && "$input_type<=1} # From shape w/o background
        +_fx_illuminate_shape2d $* rv
      else # From shape w/ background
        _fx_illuminate_shape2d[0] $*
      fi
      if {!$preview_shapes" || "0$_is_preview!=1}
        gui_set_layer_mode[0] $blending_mode
        gui_set_layer_opacity[0] $opacity
        if {$!>1" && "(0$_output_mode==0" || "0$_is_preview==1)}
          if {$keep_input_bg" && "!0$_is_preview} . fi
          gui_merge_layers[0,1]
        else k[0] fi
      fi
    endl done
  fi

fx_illuminate_shape2d_preview :
  _is_preview=1
  input_type,\
  keep_input_bg,\
  preview_interactive=$1,$7,$-2
  keep_input_bg&={$!>1}
  if $preview_interactive fx_illuminate_shape2d_preview_interactive $* fi
  if $keep_input_bg
    repeat {$!-1} l[$>,-1]
      fx_illuminate_shape2d $*
      rv to_colormode 0 a z
      gui_split_preview "slices 50%,100%",$-1
    endl done
  else
    gui_split_preview "fx_illuminate_shape2d $*",$-1
  fi

fx_illuminate_shape2d_preview_interactive :
  _output_mode=0
  input_type,\
  keep_input_bg=$1,$7
  keep_input_bg&={$!>1}
  repeat {$!-$keep_input_bg} if $keep_input_bg sel=$>,-1 else sel=$> fi +l[$sel]
    to_rgba
    +_fx_illuminate_shape2d[0] $1,2,${3-6},0,1,""$9,0,${11-15},""${16-29},""0,0
    if {$!>2} rm[0] elif {$input_type>=2} sh[0] 0,2 f. 128 rm. fi
    siz=${fitscreen\ {w},{h},1,256,640}
    wsiz0=${fitscreen\ $siz,1,30%,100%}
    wsiz=$wsiz0
    r $siz,1,100%,3
    s. c,-3 !=. 0 l.. - 128 / 127 s c,-2 / endl a[-2,-1] c # Gradient map
    rv s. c,-3
    (160,128;128,160) r. 16,16 r. ..,..,1,3,0,2
    30,30,1,1 circle. 50%,50%,15%,1,1 b. 4 n. 0,1
    100%,100%,1,3,[255,255,0]
    nm normal,rgb,alpha,background,light_alpha,light_rgb

    w[] $wsiz,0,0,{rgb,([{*,u},{*,v}]-[$wsiz])/2},"[G'MIC] Illuminate 2D Shape"
    cursor 0
    x0,y0,ox,oy,ob,olightz=-1
    lightz=2 clicked=0

    do
      x,y,b,mw={rgb,[{*,x},{*,y}]*[w,h]/[{*,w},{*,h}]},{*,b},{*,-o}
      lightz={cut($lightz-0.3*sign($mw)+($y0>=0?3*($y-$y0)/h),0.1,4)}
      if {$x<0} x,y={rgb,ang=$|;(1+[cos(1.4*ang),sin(0.85*ang)])*[w,h]/2} fi
      if {!$b" || "($b&1)}
        if {$b" && "!$clicked} x0,y0=$x,$y
        elif {!$b} x0,y0=-1
        fi
        lightx,lighty={rgb,3.5*(2*[$x/w,$y/h]-1)}
        if {[$ox,$oy,$ob,$olightz]!=[$x,$y,$b,$lightz]}
          +fx_illuminate_shape2d[normal,rgb] 4,0,${3-6},1,1,""$9,0,${11-15},""${16-25},$lightx,$lighty,$lightz,$29,""0,0
          +j[background] .,0,0,0,0,1,[alpha],255 rm..
          +r2dx[light_alpha,light_rgb] {light_rgb,8+$lightz*(w-8)} j... .,{[$x,$y]-[w,h]/2},0,0,1,.. rm[-2,-1]
          r. $wsiz,1,100% to. "Light: ("{``{_round([$lightx,$lighty,$lightz],0.1)}}")",2,2,16
          w.  rm. wait 20
        else wait
        fi
        clicked=$b
      elif {$b&2}
        +j[background] [rgb],0,0,0,0,1,[alpha],255
        +r2dx[light_alpha,light_rgb] {light_rgb,8+$lightz*(w-8)} j... .,{[$x,$y]-[w,h]/2},0,0,1,.. rm[-2,-1]
        w. rm. wait
      fi
      if {{*,CTRLLEFT}&&{*,-D}} w[] {1.5*[{*,w},{*,h}]} wsiz={*,w},{*,h}
      elif {{*,CTRLLEFT}&&{*,-C}} w[] {0.75*[{*,w},{*,h}]} wsiz={*,w},{*,h}
      elif {{*,CTRLLEFT}&&{*,-R}} w[] $wsiz0
      fi
      ox,oy,ob=$x,$y,$b

    while {{*}" && "!{*,ESC}" && "!{*,Q}}
    w 0
  rm endl done

_fx_illuminate_shape2d : # Input selection must contains a single image. Output is a single image.
  input_type,\
  output_type,\
  gR,gG,gB,gA,\
  keep_input_bg,\
  keep_output_transparency,\
  min_shape_area,\
  preview_shapes,\
  dilation,\
  shape_smoothness,\
  bump_factor,\
  weight_avg_max,\
  resolution,\
  blending_mode,\
  opacity,\
  ambient,\
  diffuse,\
  specular,\
  shininess,\
  light_smoothness,\
  flatness,\
  linearity,\
  levels,\
  lightx,\
  lighty,\
  lightz,\
  normalize_illumination,\
  preview_interactive,\
  preview_mode=${1-31}

  # Generate 2D binary shape and corresponding bumpmap
  nm={n}
  if {$input_type==0} # Single opaque shape
    to_rgba
    +channels. 100% >. 0 .
    select_color... 0,$gR,$gG,$gB,$gA
    mv... $! -[-2,-1]

  elif {$input_type==1} # Multiple colored shapes
    to_rgba
    +channels. 100% >. 0 *[-2,-1]
    if {$min_shape_area>1} +quantize_area. {$min_shape_area^2} fi
    s. c,-{s-1} >. 0 rv[-2,-1]
    if {s>1} f. "begin(A = resize([ 0,(s-1)/s ],s,3));I+A" norm. round. 0.01 fi
    label. 0,0 f. "j(1)!=i || j(0,1)!=i" thinning. 1 ==. 0 *. ..
    select_color... 0,$gR,$gG,$gB,$gA
    mv... $! -[-2,-1]

  elif {$input_type==2} # Bump map
    to_a
    s c,-{s-1} >. 0 *.. . rv s. c S={$!-1} +[^0] /. $S

  elif {$input_type==3} # Normal map
    +channels 100% >. 0 *.. . rv
    f. "I==vector4(0)?[128,128,255,255]:I"
    channels. 0,2

  else # Gradient map (hidden mode used by interactive preview)
    +channels 100% rv
  fi

  if {0$_is_preview" && "$preview_shapes}
    if {$input_type==3} k[0] else k. fi
    +dilate. 3
    label_fg.. 0 srand 0 {-2,iM+1},1,1,3,'x==0?[0,0,0]:x==1?[255,255,255]:u([255,255,255])' map... . rm.
    *. 255 a c
    return
  fi

  if {$input_type<=1} shape2bump. {arg($resolution,2048,1024,512,256,128,64)},$weight_avg_max,{$dilation%*max(w,h)},{$shape_smoothness*50} fi
  if {$input_type<=2}
    if {$input_type==2" && "$shape_smoothness} mM={[im,iM]} guided. ..,$shape_smoothness%,100 n. $mM fi
    *. $bump_factor
  fi

  # Generate output.
  if {$output_type==1} # Output as a bump map
    if {$input_type<=2}
       if $keep_output_transparency k[-2,-1] n 0,255 rv a c  # With transparency
       else k. n 0,255                                       # Without transparency
       fi
    else
      rm gui_error_preview "Cannot convert a normal map to a bump map." return
    fi

  elif {$output_type==2} # Output as a normal map
    if {$input_type<=2} round 0.0001 bump2normal. f. "i(#-2)?I:[128,128,255]" fi
    if $keep_output_transparency k[-2,-1] rv *. 255 a c # With transparency
    else k.                                             # Without transparency
    fi

  else # Output as illumination layer (phong model)
    if {$input_type<=2} g. xy a[-2,-1] c
    elif {$input_type==3} -. 128 /. 127 s. c,-2 /[-2,-1]
    fi
    f. "*
      begin(
        const flatness = "$flatness";                 # Surface flatness
        const ka = "$ambient"%;                       # Ambient
        const kd = "$diffuse"%;                       # Diffuse
        const ks = "$specular"%;                      # Specular
        const alpha = "$shininess";                   # Specularity
        const m1 = max(1,"$lightz");
        const mwh1 = max(w,h) - 1;
        light = [ "m1*$lightx,m1*$lighty,-$lightz" ]; # Light position
        camera = [ 0,0,-"$lightz" ];                  # Camera position
      );
      res = i#0?(
        P = [ 2*x/mwh1 - 1,2*y/mwh1 - 1,0 ];
        L = light - P;
        L/=norm(L);
        V = camera - P;
        V/=norm(V);
        N = -[ i0,i1,flatness ];
        N/=norm(N);
        R = 2*dot(N,L)*N - L;
        res = ka + kd*dot(L,N) + ks*max(dot(R,V),0)^alpha;
      ):0;
      [ res,0 ]"
    channels. 0 *. 255 c. 0,255
    if {$light_smoothness" || "$linearity}
      mM={[im,iM]}
      if $light_smoothness b. $light_smoothness% fi
      if $linearity n. 0,1 ^. {10^-($linearity%)} fi
      n. $mM
    fi
    if $levels quantize. $levels,1,1 fi
    if $normalize_illumination n. 0,255 fi
    rv[-2,-1] *. 255 a[-2,-1] c
    nm $nm
    if {!$keep_output_transparency} remove_opacity. fi
  fi
  nm $nm

#@gui Light Glow : fx_lightglow, fx_lightglow_preview(0)
#@gui : Density = float(30,0,100)
#@gui : Amplitude = float(0.5,0,2)
#@gui : Mode = choice(8,"Burn","Dodge","Freeze","Grain Merge","Hard Light","Interpolation","Lighten","Multiply","Overlay","Reflect","Soft Light","Stamp","Value")
#@gui : Opacity = float(0.8,0,1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/21/02</i>.</small>")
_fx_lightglow :
  mode=${arg\ 1+$3,burn,dodge,freeze,grainmerge,hardlight,interpolation,lighten,multiply,overlay,reflect,softlight,stamp,value}
  repeat $!
    +gradient_norm. >=. {100-$1}% distance. 1 ^. $2 *. -1 n. 0,255 blend $mode,$4
  mv. 0 done

fx_lightglow :
  ac "_fx_lightglow ${1-4}",$5

fx_lightglow_preview :
  gui_split_preview "fx_lightglow $*",${-3--1}

#@gui Light Leaks : fx_light_leaks, fx_light_leaks_preview(1)
#@gui : Leak Type = int(0,0,70)
#@gui : Angle = float(0,-180,180)
#@gui : X-Scale = float(1,1,10)
#@gui : Y-Scale = float(1,1,10)
#@gui : Hue = float(0,-180,180)
#@gui : Opacity = float(0.85,0,1)
#@gui : Blend Mode = choice(2,"Normal","Lighten","Screen","Dodge","Add","Darken","Multiply","Burn","Overlay","Soft Light","Hard Light","Difference","Subtract","Grain Extract","Grain Merge","Divide","Hue","Saturation","Value")
#@gui : Output as Separate Layers = _bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small>This filter uses the free light leaks dataset available at :</small>"}
#@gui : url = link{"Lomo Light Leaks","http://www.photoshoptutorials.ws/downloads/mockups-graphics/lomo-light-leaks/"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/01/07</i>.</small>")
fx_light_leaks :
  filename=lightleak_${"padint $1",6}.cimgz
  if ${_path_rc}$filename i ${_path_rc}$filename
  else i https://gmic.eu/data_lightleaks/$filename o. ${_path_rc}$filename
  fi
  mode=${arg\ 1+$7,normal,lighten,screen,dodge,add,darken,multiply,burn,overlay,softlight,hardlight,difference,subtract,grainextract,grainmerge,divide,hue,saturation,value}
  mv. 0
  repeat {$!-1} l[0,{1+$<}]
    +r[0] {1,w},{1,h},1,3,5
    rotate. $2,1,1,50%,50%
    if {$3>1" || "$4>1} f. 'w2=w/2;h2=h/2;X=x-w2;Y=y-h2;i(w2+X/$3,h2+Y/$4,0,c,1,0)' fi
    c. 0,255
    if $5 rgb2hsv. sh. 0 +. $5 rm. hsv2rgb. fi
    if $8
      nm=${gui_layer_name[1]}
      nm. name($nm),opacity({$6*100}),mode($mode) rv[-2,-1]
    else blend[1,-1] $mode,$6 fi
  endl done
  rm[0]

fx_light_leaks_preview :
  gui_split_preview "fx_light_leaks ${1--5},0",${-3--1}

_fx_light_leaks :
  u="" repeat 71 if {narg($u)} u=$u, fi u=${u}lightleak_${"padint "$>,6} done
  u $u

#@gui Light Patch : fx_light_patch, fx_light_patch(0)
#@gui : Density = int(5,2,30)
#@gui : Darkness = float(0.7,0,1)
#@gui : Lightness = float(2.5,1,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_light_patch :
  repeat $! l[$>] split_opacity l[0]
    ac "light_patch $1,$2,$3",$4
  endl a c endl done

#@gui Light Rays : fx_lightrays, fx_lightrays(1)
#@gui : Density = float(80,0,100)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Length = float(1,0,1)
#@gui : Attenuation = float(0.5,0,1)
#@gui : Transparency = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/03/01</i>.</small>")
fx_lightrays :
  lightrays $1,$2%,$3%,$4,$5
  if $6 repeat $! r[$>] 100%,100%,1,{{$>,s}+({$>,s}%2)} done fi

#@gui Pop Shadows : fx_pop_shadows, fx_pop_shadows_preview(1)
#@gui : Strength = float(0.75,0,1)
#@gui : Scale = float(5,0,20)
#@gui : Post-Normalize = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Authors: <i>Morgan Hardwood</i> and <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/03/05</i>.</small>")
fx_pop_shadows :
  repeat $! l[$>] split_opacity l[0]
    .x2
    luminance.. negate.. imM={-2,[im,iM]} b.. $2% n.. $imM
    blend[0,1] overlay,$1
    max
    if $3 n 0,255 fi
  endl a c endl done

fx_pop_shadows_preview :
  gui_split_preview "fx_pop_shadows $*",${-3--1}

#@gui Relief Light : fx_light_relief, fx_light_relief(1)
#@gui : Ambient Lightness = float(0.3,0,5)
#@gui : Specular Lightness = float(0.2,0,2)
#@gui : Specular Size = float(0.2,0,1)
#@gui : Darkness = float(0,0,1)
#@gui : Light Smoothness = float(1,0,5)
#@gui : XY-Light = point(50,50,0,1,255,255,128,200,10)
#@gui : Z-Light = float(5,0,20)
#@gui : Z-Scale = float(0.5,0,3)
#@gui : Opacity as Heightmap = bool(0)
#@gui : Image Smoothness = float(0,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_light_relief :
  b $11% light_relief ${1-5},{[$6,$7]%},${8-10}

#@gui Shadow Patch : fx_shadow_patch, fx_shadow_patch(1)
#@gui : Opacity = float(0.7,0,1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_shadow_patch :
  repeat $! l[$>] split_opacity l[0]
    ac "shadow_patch $1",$2
  endl a c endl done

#@gui Slice Luminosity : fx_slice_luminosity, fx_slice_luminosity_preview
#@gui : Luminosity Type = choice(1,"Average RGB","Luminance","Lightness","Value")
#@gui : Output As = _choice(1,"Mask","Masked Image")
#@gui : Preview Type = choice(2,"Mask","Mask + Background","Image","Image + Background")
#@gui : sep = separator(), note = note{"<small><b>Slice 1</b> (shadows):</small>"}
#@gui : Activate Slice 1 = bool(1)
#@gui : Starting Value = int(0,0,255)
#@gui : Ending Value = int(64,0,255)
#@gui : Starting Feathering = int(0,0,255)
#@gui : Ending Feathering = int(0,0,255)
#@gui : sep = separator(), note = note{"<small><b>Slice 2</b> (low midtones):</small>"}
#@gui : Activate Slice 2 = bool(1)
#@gui : Starting Value = int(64,0,255)
#@gui : Ending Value = int(128,0,255)
#@gui : Starting Feathering = int(0,0,255)
#@gui : Ending Feathering = int(0,0,255)
#@gui : sep = separator(), note = note{"<small><b>Slice 3</b> (high midtones):</small>"}
#@gui : Activate Slice 3 = bool()
#@gui : Starting Value = int(128,0,255)
#@gui : Ending Value = int(192,0,255)
#@gui : Starting Feathering = int(0,0,255)
#@gui : Ending Feathering = int(0,0,255)
#@gui : sep = separator(), note = note{"<small><b>Slice 4</b> (highlights):</small>"}
#@gui : Activate Slice 4 = bool()
#@gui : Starting Value = int(192,0,255)
#@gui : Ending Value = int(255,0,255)
#@gui : Starting Feathering = float(0,0,255)
#@gui : Ending Feathering = float(0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/22/09</i>.</small>")
fx_slice_luminosity :
  remove_opacity repeat $! l[$<] to_rgb
    _fx_slice_luminosity $*
    if $2 i[0] [0] a[-2,-1] c fi
    rv
  endl done

fx_slice_luminosity_preview :
  remove_opacity  repeat $! l[$>] to_rgb
    _fx_slice_luminosity $*
    if {$3==0} rm[0] channels {s-1}
    elif {$3==1} 100%,100%,1,1,128 a[0,-1] c r. 100%,100%,1,4 blend alpha
    elif {$3==2} a c
    else +. 96 c. 0,255 a c
    fi
  endl done

_fx_slice_luminosity :
  if {$1==0} +compose_channels + /. 3
  elif {$1==1} +luminance
  elif {$1==2} +srgb2lab8. channels. 0
  else +compose_channels max
  fi
  if $4 +apply_curve[1] 0,{$5-$7-0.1},0,$5,255,$6,255,{$6+$8+0.1},0,512,0 fi
  if $9 +apply_curve[1] 0,{$10-$12-0.1},0,$10,255,$9,255,{$11+$13+0.1},0,512,0 fi
  if $14 +apply_curve[1] 0,{$15-$17-0.1},0,$15,255,$16,255,{$16+$18+0.1},0,512,0 fi
  if $19 +apply_curve[1] 0,{$20-$22-0.1},0,$20,255,$21,255,{$21+$23+0.1},0,512,0 fi
  rm[1] max[^0]

#@gui ____<b>Patterns</b>
#------------------------

#@gui Bayer Filter : rgb2bayer, rgb2bayer(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : Keep Colors = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Box Fitting : fx_boxfitting, fx_boxfitting_preview(0)
#@gui : Minimal Size = int(3,1,32)
#@gui : Maximal Size = int(0,0,32)
#@gui : note = note("<small><b>Note:</b> Set <i>Maximal size</i> to <i>0</i> to allow any size for the squares.</small>")
#@gui : Initial Density = float(0.1,0,1)
#@gui : Transparency = bool(0)
#@gui : sep = separator(), note = note("<small><b>Note:</b> This filter has been highly inspired by the work of Jared Tarbell, described on the page:</small>")
#@gui : url = link("http://www.complexification.net/gallery/machines/boxFittingImg/")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/06/06</i>.</small>")
fx_boxfitting :
  boxfitting ${1-3},3
  if $4 to_rgba replace_color 0,0,0,0,0,255,0,0,0,0 fi

fx_boxfitting_preview :
  boxfitting ${1-3},1
  if $4 to_rgba replace_color 0,0,0,0,0,255,0,0,0,0 fi

#@gui Camouflage : fx_camouflage, fx_camouflage
#@gui : Scale = int(9,2,12)
#@gui : Levels = int(12,2,32)
#@gui : Coherence = float(100,0,1000)
#@gui : Color 1 = color(30,46,33)
#@gui : Color 2 = color(75,90,65)
#@gui : Color 3 = color(179,189,117)
#@gui : Color 4 = color(255,246,158)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/26/10</i>.</small>")
fx_camouflage :
  repeat $! l[$>] split_opacity l[0]
    channels 0 r {w+16},{h+16},1,1,0 rand 0,16
    amp=$3 do smooth {min(50,$amp)},0,1 amp-=50 while {$amp>0}
    shrink_xy. 8 n 1,$2 round
    repeat $1 +area 0,0 <. {1+2^$>} inpaint[0] [1],0,3 rm. done
    +colormap 0 n.. 0,{w-1}
    4,1,1,3,"col=[${4-15}];col[3*x,3]"
    r. ..,..,1,3,3 rm.. map.. . rm.
  endl a c endl done

#@gui Canvas : fx_canvas, fx_canvas_preview(0)
#@gui : note = note{"<b>First direction :</b>"}
#@gui : Amplitude = float(70,0,300)
#@gui : Angle = float(45,0,180)
#@gui : Sharpness = float(400,0,2000)
#@gui : note = note{"\n<b>Second direction : </b>"}
#@gui : Activate Second Direction = bool(true)
#@gui : Amplitude = float(70,0,300)
#@gui : Angle = float(135,0,180)
#@gui : Sharpness = float(400,0,2000)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_canvas :
  repeat $! l.
    if $4
      ({cos($2*pi/180)}^{sin($2*pi/180)}) vector2tensor. r. ..,.. +smooth.. .,$1 rm.. sharpen. $3 c. 0,255
      ({cos($6*pi/180)}^{sin($6*pi/180)}) vector2tensor. r. ..,.. smooth... .,$5 rm. sharpen.. $7 c.. 0,255 +[-2,-1] /. 2
    else
      ({cos($2*pi/180)}^{sin($2*pi/180)}) vector2tensor. r. ..,.. smooth.. .,$1 rm. sharpen. $3 c. 0,255
    fi
  endl mv. 0 done

fx_canvas_preview :
  gui_split_preview "fx_canvas $*",${-3--1}

#@gui Canvas Texture : texturize_canvas, texturize_canvas(0)
#@gui : Amplitude = float(20,0,256)
#@gui : Fibrousness = float(3,0,20)
#@gui : Emboss = float(0.6,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Cracks : fx_cracks, fx_cracks_preview(0)
#@gui : Density (%) = float(30,0,100)
#@gui : Relief = bool(true)
#@gui : Color = color(255,255,255,128)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/07</i>.</small>")
fx_cracks :
  ac "cracks $1,$2,{$6/255},${3-5},255",$7

fx_cracks_preview :
  gui_split_preview "fx_cracks $*",${-3--1}

#@gui Crystal : fx_crystal, fx_crystal_preview(0)
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(0.2,0,2)
#@gui : Edges = float(20,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/19/01</i>.</small>")
fx_crystal :
  repeat $! l[$>] split_opacity l[0]
    s={s}
    +gradient_norm >=. {(100-$3)/5} remove_pixels. {100-max(0.1,$1*$3%)}%,{is} *
    +norm !=. 0 a c
    sigma=0.2
    do
      +b. $sigma sigma*={(1+$2)}
      sh[0,-1] $s max. .. rm[-2,-1]
      f. 'W=i(x,y,z,$s);if(W<0.001||W>=1,0,if(c<$s,i/W,1))'
      if {!iM} rm[1] break fi
      sh. $s
      j[0] [1],0,0,0,0,1,[2] k[0]
    while 1
    channels 0,{$s-1}
  endl a c endl done

fx_crystal_preview :
  gui_split_preview "fx_crystal $*",${-3--1}

#@gui Crystal Background : fx_crystal_background, fx_crystal_background
#@gui : Iterations = int(10,1,32)
#@gui : Density (%) = float(25,0,100)
#@gui : Random Seed = int(0,0,65535)
#@gui : Opacity (%) = float(100,0,100)
#@gui : Color = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/18/10</i>.</small>")
fx_crystal_background :
  repeat $! l[$>] split_opacity l[0]
    N={2*max(3,round((${"is_percent $2"}?4*wh*$2:$2)))}
    if $5 col="u([255,255,255])" else col="u(255)" fi
    srand $3 M={max(w,h)} 2,$N
    repeat $1 rand. {-$M/2},{3*$M/2} polygon.. $N,{^},{-$4%},{$col} done
    rm. n 0,255
  endl a c endl done

#@gui Halftone : fx_halftone, fx_halftone_preview(0)
#@gui : note = note("<b><small>Image parameters :</small></b>")
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Smoothness = float(0,0,10)
#@gui : sep = separator(), note = note("<b><small>Halftone parameters :</small></b>")
#@gui : Number of Tones = int(5,2,32)
#@gui : Size for Dark Tones = int(8,2,256)
#@gui : Size for Bright Tones = int(8,2,256)
#@gui : Shape = choice{5,"Square","Diamond","Circle","Square (Inv.)","Diamond (Inv.)","Circle (Inv.)"}
#@gui : Smoothness = float(0.1,0,32)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/23/07</i>.</small>")
fx_halftone :
  adjust_colors ${1-3},0,0,0,255 b $4
  repeat $! l[$>] split_opacity
    halftone[0] ${5-9}
  a c endl done

fx_halftone_preview :
  gui_split_preview "fx_halftone $*",${-3--1}

#@gui Hearts : fx_hearts, fx_hearts_preview(0)
#@gui : Density = float(2,0,30)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_hearts :
  ac "hearts $1",$2

fx_hearts_preview :
  gui_split_preview "fx_hearts $*",${-3--1}

#@gui Lava : fx_lava, fx_lava_preview(0)
#@gui : Perturbation = int(8,0,15)
#@gui : Smoothness = float(5,0,100)
#@gui : Scale = float(3,0,20)
#@gui : Sharpness = float(0,0,1000)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/26/11</i>.</small>")
fx_lava :
  repeat $! l[$>] split_opacity l[0] norm
    100%,100% plasma. 1,1,{16-$1} smooth. $2,0,1,$3,$3,0.8,90 *
    gradient_norm n 0,255
    equalize map 3
    sharpen $4
  endl a c endl done

fx_lava_preview :
  gui_split_preview "fx_lava $*",${-3--1}

#@gui Marble : fx_marble, fx_marble
#@gui : Image Weight = float(.5,0,30)
#@gui : Pattern Weight = float(1,0,30)
#@gui : Pattern Angle = float(0,0,360)
#@gui : Amplitude = float(0,0,1000)
#@gui : Sharpness = float(.4,0,5)
#@gui : Anisotropy = float(.6,0,1)
#@gui : Alpha = float(.6,0,20)
#@gui : Sigma = float(1.1,0,20)
#@gui : Cut Low = float(0,0,100)
#@gui : Cut High = float(100,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_marble :
  repeat $! l[$>] split_opacity l[0]
    marble $1/10,$2/10,$3,$4,$5,$6,$7,$8,$9%,$10%
  endl a c endl done

#@gui Maze : fx_maze, fx_maze
#@gui : Cell Size = int(24,1,256)
#@gui : Thickness = int(1,1,10)
#@gui : Masking = choice("None","Render on Dark Areas","Render on White Areas")
#@gui : Preserve Image Dimension = bool(1)
#@gui : Maze Type = choice("Dark Walls","White Walls")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/02/09</i>.</small>")
fx_maze :
  repeat $! l[$>]
    w={w} h={h}
    r. {100/$1}%,{100/$1}%,1,100%,2
    if {$3==0} f. 1
    elif {$3==1} negate.
    fi
    maze_mask. $1 dilate. $2 *. 255
    if {!$5} negate. fi
    if $4 r. $w,$h,100%,100% fi
  endl done

#@gui Mineral Mosaic : fx_mineral_mosaic,fx_mineral_mosaic(0)
#@gui : Density = float(1,0,3)
#@gui : Area = float(2,0,32)
#@gui : Smoothness = float(1,0,10)
#@gui : Shade Strength = float(100,0,255)
#@gui : Shade Angle = float(0,0,360)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/01/02</i>.</small>")
fx_mineral_mosaic :
  repeat $! l[$>] to_rgb
    +b $3 segment_watershed. $1 +norm.
    area. 0 +<=. {$2^2} inpaint.. . rm. label.
    +f[0] 'if(c==0,x,y)' rv[-2,-1] +blend[-2,-1] shapeaverage,1,1
    -[-3,-1] rm[0,-2] channels. 0,1
    alpha={$5*pi/180} sh. 0 *. {cos($alpha)} rm. sh. 1 *. {sin($alpha)} rm. compose_channels. +
    normalize_local. 1000 n. -$4,$4
    + c 0,255
  endl done

#@gui Mosaic : fx_mosaic, fx_mosaic_preview(0)
#@gui : Density (%) = float(50,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/19/07</i>.</small>")
fx_mosaic :
  ac "repeat $! l[$>] split_opacity mosaic[0] $1 a c endl done",$2

fx_mosaic_preview :
  gui_split_preview "fx_mosaic $*",${-3--1}

#@gui Op Art : fx_shapes,fx_shapes_preview(0)
#@gui : Shape = choice{1,"Custom Layers","Circles","Squares","Diamonds","Triangles","Horizontal Stripes","Vertical Stripes","Balls","Hearts","Stars","Arrows","Truchet",
#@gui : "Circles (Outline)","Squares (Outline)","Diamonds (Outline)","Triangles (Outline)","Hearts (Outline)","Stars (Outline)","Arrows (Outline)"}
#@gui : Number of Scales = int(16,2,24)
#@gui : Resolution = float(10,1,50)
#@gui : Zoom Factor = _int(2,1,8)
#@gui : Minimal Size = float(5,0,150)
#@gui : Maximal Size = float(90,0,150)
#@gui : Stencil Type = choice(0,"Black &amp; White","RGB","Color")
#@gui : Allow Angle = choice("0 deg.","90 deg.","180 deg.")
#@gui : Negative = bool(1)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : If you set the parameter <i>Shape</i> to <i>Custom layers</i>, the different shapes used to map the pixel intensities will be defined as
#@gui : the <i>Number of scales</i> top layers of your image. Don't forget to set also <i>Input layers</i> to <i>All</i> to be sure
#@gui : these layers are passed to the filter.
#@gui : </small>"}
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/16/12</i>.</small>")
fx_shapes :
  if $1 # Pre-defined shapes.
    remove_opacity repeat $! l[$>]
      if {!$7} _fx_shapes $* * 255
      elif {$7==1} split_opacity to_rgb[0] s[0] c repeat 3 _fx_shapes[$>] $* done *[0-2] 255 a[0-2] c a c
      else +_fx_shapes $* r[0] $3%,$3% r[0] [1],[1] *
      fi
    endl done
  else # Custom shapes.
    if {$!<=$2} error[] "Command '$0': Some layers are missing in 'Custom layers' mode ("{$2+1}" expected at least, "$!" provided)." fi
    to_colormode[0-{$2-1}] ${max_s[0-{$2-1}]} remove_opacity[$2--1]
    repeat {$!-$2} l[0-{$2-1},{$2+$>}]
      norm. w={w} h={h} r. $3%,$3%,1,1,2
      s={$4*max(round($w/w),round($h/h))}
      r0={$s*$5%} r1={$s*$6%}
      repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} if $r +r[$>] $r,$r,1,100%,3 else 1,1 fi done
      r[-$2--1] $s,$s,1,100%,0,0,0.5,0.5
      map_sprites[$2--1] $2,$8
    endl done rm[0-{$2-1}]
  fi

fx_shapes_preview :
  if $1 repeat $! l[$>]
    w={w} h={h}
    gui_split_preview "fx_shapes ${1-3},1,${5--2}",$-1
    r $w,$h,1,100%,0,0,0.5,0.5
    endl done
  else
    if {$!>$2} repeat {$!-$2} l[0-{$2-1},{$2+$>}]
      w={w} h={h}
      +fx_shapes ${1-3},1,${5--2} rm..
      r. $w,$h,1,100%,0,0,0.5,0.5
    endl done rm[0-{$2-1}]
    else gui_warning_preview "Missing input layers!"
    fi
  fi

_fx_shapes :
  norm w={w} h={h} r $3%,$3%,1,1,2
  s={(1+$10)*$4*max(round($w/w),round($h/h))}
  r0={$s*$5%} r1={$s*$6%}
  repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} if $r _fx_shapes{$1-1}[] $r,$s else 1,1 fi done
  r[-$2--1] $s,$s,1,1,0,0,0.5,0.5
  if $9 rv[-$2--1] *[-$2--1] -1 +[-$2--1] 1 fi
  map_sprites $2,$8
  if $10 r 50%,50%,1,1,2 fi

_fx_shapes0 :
  shape_circle $1

_fx_shapes1 :
  $1,$1,1,1,1

_fx_shapes2 :
  $1,$1,1,1 = 1,50%,50% distance 1,1 < {$1/2}

_fx_shapes3 :
  $2,$2,1,1,'x+y<=2*$1-1'

_fx_shapes4 :
  $2,$1,1,1,1

_fx_shapes5 :
  $1,$2,1,1,1

_fx_shapes6 :
  ball $1,200 n 0,1

_fx_shapes7 :
  shape_heart 65 r $1,$1,1,1,2 >= 50%

_fx_shapes8 :
  shape_star $1

_fx_shapes9 :
  arrow3d 0,0,0,1,0,0,15%,40%,30% col3d 1 *3d $1 c3d
  $2,$2 j3d. ..,50%,50%,0,1,2,0,0
  rm.. +mirror y max

_fx_shapes10 :
  S={$2+1-($2%2)}
  $S,$S,1,1,"X=x/(w-1);Y=y/(h-1);r=abs(0.5-sqrt(X^2+Y^2));a=atan2(y,x);r<0.1-0.17*(0.5-$1/$2)*sin(2*a)"
  +mirror xy max

_fx_shapes11 :
  _fx_shapes0 $* expand_xy 1,0 +erode 3 -

_fx_shapes12 :
  _fx_shapes1 $* expand_xy 1,0 +erode 3 -

_fx_shapes13 :
  _fx_shapes2 $* expand_xy 1,0 +erode 3 -

_fx_shapes14 :
  _fx_shapes3 $* expand_xy 1,0 +erode 3 -

_fx_shapes15 :
  _fx_shapes7 $* expand_xy 1,0 +erode 3 -

_fx_shapes16 :
  _fx_shapes8 $* expand_xy 1,0 +erode 3 -

_fx_shapes17 :
  _fx_shapes9 $* expand_xy 1,0 +erode 3 -

#@gui Pack Sprites : fx_pack_sprites, gui_no_preview
#@gui : Number of Scales = int(5,1,16)
#@gui : Minimal Scale (%) = float(25,1,100)
#@gui : Allow Angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gui : Spacing = int(1,-16,16)
#@gui : Precision = int(7,1,32)
#@gui : sep = separator()
#@gui : Masking = choice("No Masking","Mask as Bottom Layer")
#@gui : Width = int(512,32,2048)
#@gui : Height = int(512,32,2048)
#@gui : note = note("<small><b>Notes:</b>\n - Parameters <i>Width</i> and <i>Height</i> are considered only when <i>No masking</i> mode is selected.\n
#@gui : - Set different sprites on different layers to pack multiple sprites at the same time.</small>")
#@gui : url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=bpg7CGH7vCM")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/24/06</i>.</small>")
fx_pack_sprites :
  if $6 # With mask.
    if {$!<2} error[] "Command '$0': Masking requires at least two input layers ! (please check that 'Input Layers' is correctly set)." fi
    repeat {$!-1} l[$>] to_rgba split_opacity +!=[1] 0 *[0] . a c autocrop 0 endl done
    remove_empty[0--2] +channels. 100% channels. -4,0 mv. 0
    pack_sprites[0--2] ${1-5}
  else # No masking
    repeat $! l[$>] to_rgba split_opacity +!=[1] 0 *[0] . a c autocrop 0 endl done
    remove_empty i[0] $7,$8,1,5 pack_sprites ${1-5}
  fi
  channels[0] 0,{0,s-2}

#@gui Paper Texture : fx_paper, fx_paper_preview(0)
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_paper :
  ac "texturize_paper",$1

fx_paper_preview :
  gui_split_preview "fx_paper $*",${-3--1}

#@gui Plaid : fx_plaid_texture,fx_plaid_texture(1)
#@gui : Line = float(50,0,100)
#@gui : Number of Angles = int(2,1,8)
#@gui : Starting Angle = float(0,0,360)
#@gui : Angle Range = float(90,0,360)
#@gui : Smoothness = float(1,0,5)
#@gui : Sharpen = float(300,0,1000)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/16/05</i>.</small>")
fx_plaid_texture :
  repeat $! l[$>]
    w={w} h={h} s={s}
    rows $1%
    b $5% sharpen $6
    r $w,$h,1,$s,2
    +rotate[0] $3,1,2,50%,50%
    repeat {$2-1} +rotate[0] {$3+$4*($>+1)/($2-1)},1,2,50%,50% +[-2,-1] done rm[0]
    / $2
  endl done

#@gui Polka Dots : fx_polka_dots, fx_polka_dots(1)
#@gui : Size = float(80,0,100)
#@gui : Density = float(20,0.1,100)
#@gui : First Offset = float(50,0,100)
#@gui : Second Offset = float(50,0,100)
#@gui : Angle = float(0,0,180)
#@gui : Aliasing = float(0.5,0.1,1)
#@gui : Shading = float(0.1,0.1,1)
#@gui : Opacity = float(1,0,1)
#@gui : Color = color(255,0,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_polka_dots :
  to_rgba polka_dots {$1*$2/100},${2--1}

#@gui Random Color Ellipses : fx_color_ellipses, fx_color_ellipses(1)
#@gui : Density = int(400,0,3000)
#@gui : Radius = float(8,0,30)
#@gui : Opacity = float(0.1,0.01,0.5)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_color_ellipses :
  color_ellipses $1,$2,$3

#@gui Resynthetize Texture [FFT] : syntexturize, fx_syntexturize_preview(1)
#@gui : Width = _int(1024,32,8192)
#@gui : Height = _int(1024,32,8192)
#@gui : Equalize Light = float(0,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter tries to re-synthetize a <b>micro</b>-texture (given as the input image) onto an output (seamless) image with an arbitrary size.
#@gui : It uses a phase randomization technique, as described in:</small>"}
#@gui : url = link("Micro-Texture Synthesis by Phase Randomization","http://www.ipol.im/pub/art/2011/ggm_rpn/")
#@gui : note = note("<small>This filter is based on the work of <i>Bruno Galerne</i>, <i>Yann Gousseau</i> and <i>Jean-Michel Morel</i>.</small>")
#@gui : sep = separator(), url = link("Click here for a detailed description of this filter.","http://gimpchat.com/viewtopic.php?f=28&t=10141")
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>J&#233;rome Boulanger</i>.      Latest Update: <i>2014/09/04</i>.</small>")
fx_syntexturize :
  repeat $! l[$>]
    if $3 +b {20.5-$3/50}% -[0] [1] fc. ${average_colors.} + c 0,255 fi
    syntexturize $1,$2
  endl done

fx_syntexturize_preview :
  gui_split_preview "fx_syntexturize 100%,100%,$3",${-3--1}

#@gui Resynthetize Texture [Patch-Based] : syntexturize_matchpatch, fx_syntexturize_matchpatch_preview(1)
#@gui : Width = _int(512,32,8192)
#@gui : Height = _int(512,32,8192)
#@gui : Number of Scales = int(0,0,16)
#@gui : Patch Size = int(7,1,32)
#@gui : Blending Size = int(5,1,24)
#@gui : Precision = float(1,0,5)
#@gui : Equalize Light = float(0,0,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b> This filter tries to re-synthetize an input texture image onto a bigger output image (with an arbitrary size).
#@gui : Beware, this filter is quite slow to compute!</small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/22/10</i>.</small>")
_fx_syntexturize_matchpatch_preview :
  repeat $! l[$>]
    if $7 +b {20.5-$7/50}% -[0] [1] fc. ${average_colors.} + c 0,255 fi
    w={w} h={h}
    syntexturize_matchpatch 100%,100%,${3--1}
    to_rgba r $w,$h,1,4,0,0,0.5,0.5
  endl done

fx_syntexturize_matchpatch_preview :
  gui_split_preview "_fx_syntexturize_matchpatch_preview ${1--2}",${-3--1}

#@gui Rorschach : fx_rorschach, fx_rorschach
#@gui : Scale = float(3,0,10)
#@gui : Mirror = choice(1,"None","X-Axis","Y-Axis","XY-Axes")
#@gui : Stencil Type = choice(2,"Black &amp; White","RGB","Color")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/12/03</i>.</small>")
fx_rorschach :
  repeat $! remove_opacity l[$>]
    if {$3==0} norm rorschach $1%,$2 * 255
    elif {$3==1} to_rgb rorschach $1%,$2 * 255
    else +norm rorschach. $1%,$2 blend shapeaverage0
    fi
  endl done

#@gui Satin : fx_satin, fx_satin(1)
#@gui : Iterations = int(20,4,128)
#@gui : Smoothness (%) = float(1,0,5)
#@gui : Seed = int(0,0,65535)
#@gui : sep = separator()
#@gui : Dark Color = color(0,0,0,255)
#@gui : Light Color = color(255,255,255,255)
#@gui : Stretch Contrast = bool(0)
#@gui : sep = separator()
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(-50,-100,100)
#@gui : Hue (%) = float(0,-100,100)
#@gui : Saturation (%) = float(0,-100,100)
#@gui : sep = separator(), note = note{"This filter has been inspired by <a href="https://fence-post.deviantart.com/art/Satin-Texture-in-GIMP-46937633">this tutorial</a> from DeviantArt user <i>fence-post</i>."}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/11/27</i>.</small>")
fx_satin :
  ($4,$8^$5,$9^$6,$10^$7,$11) srgb2rgb. r. 256,1,1,4,3 rgb2srgb.
  repeat {$!-1} l[$>]
    srand $3 channels 0 f 0
    repeat $1
      100%,100%,1,1,"begin(
           A = u([0,0],[w,h]-1);
           B = u([0,0],[w,h]-1);
           N = [0,-1,1,0]*(B - A);
           D = A + N;
           C = B + N;
           abc = solve([A,1,B,1,C,1,D,1],[0,255,255,0]);
         );
         dot(abc,[x,y,1])"
      c. 0,255 -- abs
    done
    b $2% gradient_norm negate n 0,255
    if $12 normalize_local , fi
    pass. 1 map.. . rm.
    sh. 0,2 adjust_colors. ${13-17} rm.
  endl done
  rm.

#@gui Seamless Turbulence : fx_seamless_turbulence, fx_seamless_turbulence(0)
#@gui : Amplitude = float(15,0,30)
#@gui : Smoothness = float(20,0,40)
#@gui : Orientation = float(0,0,180)
#@gui : Deviation = float(1,0,1)
#@gui : Contrast = float(3,0,4)
#@gui : Color Rendering = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/02/04</i>.</small>")
fx_seamless_turbulence :
  repeat $! l[$>]
    wh={w},{h} rm
    $wh,1,{if($6,3,1)} rand. 0,255
    $wh rand. {$3*pi/180-$4*10*pi},{$3*pi/180+$4*10*pi} +sin. cos.. a[-2,-1] c
    r[-2,-1] 130%,130%,1,100%,0,2,0.5,0.5 b. $2 orientation.
    vector2tensor.
    smooth.. .,$1,0.5,20 rm.
    r. $wh,1,100%,0,0,0.5,0.5
    if {$5!=1} ia={ia} - $ia * $5 + $ia fi
  endl done
  c 0,255 n 0,255

#@gui Shock Waves : fx_shockwaves, fx_shockwaves_preview
#@gui : Amplitude = float(10,0,100)
#@gui : Low Frequency = float(10,0,100)
#@gui : Frequency Range = float(20,0,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/01/12</i>.</small>")
_fx_shockwaves :
  dct
  100%,100%,1,1,1 circle. 0,0,{$2+$3}%,1,{$1+1} circle. 0,0,$2%,1,1
  * idct c 0,255

fx_shockwaves :
  ac "_fx_shockwaves ${1-3}",$4

fx_shockwaves_preview :
  gui_split_preview "fx_shockwaves $*",${-3--1}

#@gui Sponge : fx_sponge, fx_sponge_preview(0)
#@gui : Size = int(13,3,21)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sponge :
  ac "sponge $1",$2

fx_sponge_preview :
  gui_split_preview "fx_sponge $*",${-3--1}

#@gui Stained Glass : fx_stained_glass, fx_stained_glass_preview(0)
#@gui : Edges = float(20,0,100)
#@gui : Shading = float(0.1,0,0.5)
#@gui : Thin Separators = bool(1)
#@gui : sep = separator()
#@gui : Equalize = bool(1)
#@gui : Colors = float(1,0,3)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/18/03</i>.</small>")
fx_stained_glass :
  repeat $! l[$>] split_opacity l[0] to_rgb
    stained_glass $1,$2,$3
    n 0,255
    if $4 equalize. fi
    rgb2lab. sh. 1,2 *. $5 rm. lab2rgb.
    adjust_colors. ${6-8}
  endl a c endl done

fx_stained_glass_preview :
  gui_split_preview "fx_stained_glass $*",${-3--1}

#@gui Stars : fx_stars, fx_stars(0)
#@gui : Density = float(10,0,200)
#@gui : Depth = float(0,0,5)
#@gui : Size = int(32,8,128)
#@gui : Branches = int(5,3,16)
#@gui : Thickness = float(0.38,0.1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,100,200)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/01/10</i>.</small>")
fx_stars :
  repeat $! l[$>] split_opacity rv
    stars $1%,$2,$3,$4,$5,$6%,${7-9},{$10/255}
  rv a c endl done

#@gui Stencil : fx_stencil, fx_stencil_preview(0)
#@gui : Radius = float(3,0,10)
#@gui : Smoothness = float(0,0,30)
#@gui : Iterations = int(8,1,100)
#@gui : Aliasing = float(0,0,5)
#@gui : Stencil Type = choice(2,"Black &amp; White","RGB","Color")
#@gui : Transparency = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_stencil :
  if {$5==0} norm stencil $1,$2,$3
  elif {$5==1} stencil $1,$2,$3
  else repeat $!
    +norm. stencil. $1,$2,$3 >=. 50% blend[-2,-1] shapeaverage0
  mv. 0 done fi
  if $6 to_rgba replace_color 0,0,0,0,0,255,0,0,0,0 fi
  if $4 smooth {30*$4},0,1,1 fi

fx_stencil_preview :
  gui_split_preview "fx_stencil $*",${-3--1}

#@gui Tetris : fx_tetris, fx_tetris(0)
#@gui : Scale = int(10,1,20)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_tetris :
  tetris $1

#@gui Truchet : fx_truchet, fx_truchet(0)
#@gui : Scale = int(32,1,256)
#@gui : Radius = int(5,1,64)
#@gui : Smoothness = float(1,0,10)
#@gui : Type = choice(1,"Straight","Curved")
#@gui : Color = choice("White on Black","Black on White","White on Transparent","Black on Transparent","Transparent on White","Transparent on Black","Random")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/26/10</i>.</small>")
fx_truchet :
  repeat $! l[$>]
    100%,100% truchet $1,$2,$4 rm..
    if {$5==1} * -1
    elif {$5==2} i[0] 100%,100%,1,1,1
    elif {$5==3} i[0] 100%,100%
    elif {$5==4} * -1 i[0] 100%,100%
    elif {$5==5} * -1 i[0] 100%,100%,1,1,-1
    elif {$5==6} label 0,1 {iM+1},1,1,3 rand. 0,255 map.. . rm.
    fi
    a c b $3 n 0,255
  endl done

#@gui Weave : weave, weave(1)
#@gui : Density = int(6,1,32)
#@gui : Thickness = float(65,0,100)
#@gui : Shadow = float(0,0,100)
#@gui : Shading = float(0.5,0,3)
#@gui : Fibers Amplitude = float(0,0,255)
#@gui : Fibers Smoothness = float(0,0,10)
#@gui : Angle = choice("0 deg.","22.5 deg.","45 deg.","67.5 deg.")
#@gui : X-Curvature = float(0,-1,1)
#@gui : Y-Curvature = float(0,-1,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/18/01</i>.</small>")

#@gui Whirls : fx_whirls, fx_whirls_preview(0)
#@gui : Density = int(7,3,20)
#@gui : Smoothness = float(2,0,10)
#@gui : Darkness = float(0.2,0,1)
#@gui : Lightness = float(1.8,1,3)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_whirls :
  ac "whirls $1,$2,$3,$4",$5

fx_whirls_preview :
  gui_split_preview "fx_whirls ${1-5}",${-3--1}


#@gui ____<b>Repair</b>
#-----------------------

#@gui Bayer Reconstruction : bayer2rgb, gui_no_preview
#@gui : G/M Smoothness = _float(6,0,20)
#@gui : R/B Smoothness (Principal) = _float(6,0,20)
#@gui : R/B Smoothness (Secondary) = _float(4,0,20)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Deinterlace : deinterlace, fx_deinterlace_preview(0)
#@gui : Algorithm = choice("Standard","Motion-Compensated")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_deinterlace :
  deinterlace 0 skip ${^0}

fx_deinterlace_preview :
  gui_split_preview "fx_deinterlace $*",${-3--1}

#@gui Inpaint [Holes] : fx_inpaint_holes, fx_inpaint_holes(0)
#@gui : Maximal Area = float(4,1,512)
#@gui : Tolerance = float(20,0,255)
#@gui : Connectivity = choice(1,"Low","High")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/27/05</i>.</small>")
fx_inpaint_holes :
  inpaint_holes {$1^1.5},$2,$3

#@gui Inpaint [Morphological] : fx_inpaint_morpho, fx_inpaint_morpho_preview(1)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> It is strongly suggested to apply this filter only on a selection around the region to inpaint, to save computation time!</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/25/11</i>.</small>")
fx_inpaint_morpho :
  repeat $! l[$>]
    R=$1 G=$2 B=$3 A=$4
    if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi # Purely transparent color.
    +round select_color. 0,{round([$R,$G,$B,$A])}
    if $5 dilate. {1+2*$5} fi
    inpaint_morpho.. [1]
    rm.
  endl done

fx_inpaint_morpho_preview :
  fx_inpaint_morpho ${1-4},{1+$5}

#@gui Inpaint [Multi-Scale] : fx_inpaint_matchpatch, fx_inpaint_matchpatch_preview(1)
#@gui : Number of Scales = _int(0,0,16)
#@gui : note = note{"<small>(Set <i>Number of scales</i> to <i>0</i> for automatic scale detection)</small>"}
#@gui : Patch Size = _int(9,1,64)
#@gui : Number of Iterations per Scale = _int(10,1,100)
#@gui : Blend Size = _int(5,0,32)
#@gui : Allow Outer Blending = _bool(1)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : sep = separator(), Preview Progression While Running = _bool(0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Preview and final result may strongly differ.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/25/11</i>.</small>")
fx_inpaint_matchpatch :
  repeat $! l[$>]
    R=$6 G=$7 B=$8 A=$9
    if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi # Purely transparent color.
    +round select_color. 0,{round([$R,$G,$B,$A])}
    if $10 dilate. {1+2*$10} fi
    if $11
      visu_size=${fitscreen[]" "{0,w},{0,h},1,25%,50%}
      w1.. $visu_size,0,"[Preview] G'MIC: Inpaint [multi-scale]"
    fi
    srand 0 inpaint_matchpatch.. [1],${1-5}
    rm.
  endl done

fx_inpaint_matchpatch_preview :
  fx_inpaint_matchpatch ${1-9},{1+$10},0

#@gui Inpaint [Patch-Based] : fx_inpaint_patch, fx_inpaint_patch_preview
#@gui : Patch Size = _int(7,1,64)
#@gui : Lookup Size = _float(16,1,32)
#@gui : Lookup Factor = _float(0.1,0,1)
#@gui : Blend Size = _float(1.2,0,5)
#@gui : Blend Threshold = _float(0,0,1)
#@gui : Blend Decay = _float(0.05,0,0.5)
#@gui : Blend Scales = _int(10,1,20)
#@gui : Allow Outer Blending = _bool(1)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : Process by Blocs of Size = _choice("100%","75%","50%","25%","10%","5%","2%","1%")
#@gui : sep = separator(), note = note("<small>A quick tutorial on how to use this filter can be found here:</small>")
#@gui : url = link("G'MIC Inpainting tutorial on Patrick David's blog.","http://blog.patdavid.net/2014/02/getting-around-in-gimp-gmic-inpainting.html")
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Maxime Daisy</i>.      Latest Update: <i>2015/25/11</i>.</small>")
_fx_inpaint_patch :
  repeat $! l[$>]
    R=$9 G=$10 B=$11 A=$12
    if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi # Purely transparent color.
    +round select_color. 0,{round([$R,$G,$B,$A])}
    if $13 dilate. {1+2*$13} fi
    inpaint.. [1],$1,{$1*$2},$3,1,{$4*$1},${5-8}
    rm.
  endl done

fx_inpaint_patch :
  repeat $! l[$>]
    if $14
      bs={max(16,min(w,h)*arg(1+$14,100,75,50,25,10,5,2,1)%)}
      at "_fx_inpaint_patch $*",$bs,$bs,1,25%,25%,0,2
    else _fx_inpaint_patch $*
    fi
  endl done

fx_inpaint_patch_preview :
  fx_inpaint_patch ${1-12},{1+$13},100

#@gui Inpaint [Transport-Diffusion] : fx_inpaint_diffusion, fx_inpaint_diffusion_preview(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-Oriented","Edge-Oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Mask Color = _color(255,0,0,255)
#@gui : Mask Dilation = _int(0,0,32)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/10/04</i>.</small>")
fx_inpaint_diffusion :
  repeat $! l[$>]
    R=$4 G=$5 B=$6 A=$7
    if {!$A" && "(s==2" || "s==4)} split_opacity +!=. 0 *[0,-1] a c R=0 G=0 B=0 fi # Purely transparent color.
    +select_color 0,$R,$G,$B,$A
    if {$8} dilate. {1+2*$8} fi
    inpaint_diffusion.. [1],$1%,$2,$3
    rm.
  endl done c 0,255

fx_inpaint_diffusion_preview :
  fx_inpaint_diffusion ${1-7},{1+$8}

#@gui Red-Eye Attenuation : red_eye, red_eye
#@gui : Threshold = float(75,0,100)
#@gui : Smoothness = float(3.5,0,20)
#@gui : Factor = float(0.1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")

#@gui Remove Hot Pixels : fx_remove_hotpixels, fx_remove_hotpixels_preview(0)
#@gui : Mask Size = int(3,3,20)
#@gui : Threshold = float(10,0,200)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_remove_hotpixels :
  remove_hotpixels $1,$2

fx_remove_hotpixels_preview :
  gui_split_preview "fx_remove_hotpixels $*",${-3--1}

#@gui Solidify : fx_solidify_td, fx_solidify_td_preview(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-Oriented","Edge-Oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Dilation / Erosion = int(0,-20,20)
#@gui : Colorspace = choice(1,"sRGB","Linear RGB")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter reconstructs transparent regions of an image using a transport-diffusion algorithm. Useful only for images having an alpha-channel.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/07/04</i>.</small>")
fx_solidify_td :
  repeat $! l[$>]
    to_rgba sh 0,{s-2} if $5 srgb2rgb. fi rm.
    if $4
      . sh. 100% if {$4>0} erode. {1+2*$4} else dilate. {1-2*$4} fi rm.
      solidify. $1%,$2,$3
      rv blend alpha
    else
      solidify $1%,$2,$3
    fi
    if $5 rgb2srgb. fi
  endl done

fx_solidify_td_preview :
  gui_split_preview "fx_solidify_td $*",${-3--1}

#@gui Smooth [Anisotropic] : fx_smooth_anisotropic, fx_smooth_anisotropic_preview(0)
#@gui : Amplitude = float(60,0,1000)
#@gui : Sharpness = float(0.7,0,2)
#@gui : Anisotropy = float(0.3,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(1.1,0,10)
#@gui : Spatial Precision = float(0.8,0.1,2)
#@gui : Angular Precision = float(30,1,180)
#@gui : Value Precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest Neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/08/27</i>.</small>")
fx_smooth_anisotropic :
  repeat $! l[$>]
    ac "repeat $11 smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 done",$12
  endl done c 0,255

fx_smooth_anisotropic_preview :
  gui_split_preview "fx_smooth_anisotropic $*",${-3--1}

#@gui Smooth [Antialias] : fx_smooth_antialias, fx_smooth_antialias_preview(0)
#@gui : Amplitude = float(5,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/11/13</i>.</small>")
fx_smooth_antialias :
  repeat $! l[$>]
    +diffusiontensors 0,1,1,$3,$3
    +gradient_norm.. >=. $2% *[-2,-1]
    smooth.. .,{$1^1/3},0.5,120,2,1 rm.
  endl done

fx_smooth_antialias_preview :
  gui_split_preview "fx_smooth_antialias $*",${-3--1}

#@gui Smooth [Bilateral] : fx_smooth_bilateral, fx_smooth_bilateral_preview(0)
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_bilateral : skip ${5=0},${6=0}
  ac "repeat $3 bilateral $1,$2 done",$4

fx_smooth_bilateral_preview :
  gui_split_preview "fx_smooth_bilateral $*",${-3--1}

#@gui Smooth [Guided] : fx_smooth_guided, fx_smooth_guided_preview(0)
#@gui : Radius = int(5,1,100)
#@gui : Smoothness = float(30,0,512)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/29/10</i>.</small>")
fx_smooth_guided : skip ${5=0},${6=0}
  ac "repeat $3 guided $1,$2 done",$4

fx_smooth_guided_preview :
  gui_split_preview "fx_smooth_guided $*",${-3--1}

#@gui Smooth [Diffusion] : fx_smooth_diffusion, fx_smooth_diffusion_preview(0)
#@gui : Sharpness = float(0.7,0,2)
#@gui : Anisotropy = float(0.3,0,1)
#@gui : Gradient Smoothness = float(0.6,0,10)
#@gui : Tensor Smoothness = float(1.1,0,10)
#@gui : Time Step = float(15,5,50)
#@gui : Iterations = int(8,1,100)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_diffusion :
  ac "gui_parallel_overlap \"smooth $6,$1,$2,$3,$4,$5,0 c 0,255\",$8,$9",$7

fx_smooth_diffusion_preview :
  gui_split_preview "fx_smooth_diffusion $*",${-3--1}

#@gui Smooth [Mean-Curvature] : fx_smooth_meancurvature, fx_smooth_meancurvature_preview(0)
#@gui : Time Step = float(30,5,50)
#@gui : Iterations = int(4,1,30)
#@gui : Keep Iterations as Different Layers = bool(false)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_meancurvature :
  ac "gui_parallel_overlap \"meancurvature_flow $2,$1,$3 c 0,255\",$5,$6",$4

fx_smooth_meancurvature_preview :
  gui_split_preview "fx_smooth_meancurvature $*",${-3--1}

#@gui Smooth [Median] : fx_smooth_median, fx_smooth_median_preview(0)
#@gui : Radius = int(3,1,20)
#@gui : Threshold = float(255,0,255)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_smooth_median :
  ac "median $1,$2",$3

fx_smooth_median_preview :
  gui_split_preview "fx_smooth_median $*",${-3--1}

#@gui Smooth [NL-Means] : fx_smooth_nlmeans, fx_smooth_nlmeans_preview(0)
#@gui : Patch Size = float(4,0.5,10)
#@gui : Spatial Bandwidth = int(4,3,13)
#@gui : Tonal Bandwidth = float(10,1,50)
#@gui : Patch Measure = choice(3,"Linf-Norm","L1-Norm","L2-Norm","Luminance","Lightness","RGB")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;r&#244;me Boulanger</i>.      Latest Update: <i>2015/01/07</i>.</small>")
fx_smooth_nlmeans:
  repeat $! l[$>]
    if {s==1} nlmeans $1,$2,$3,-_fx_smooth_nlmeans$4 # Handle separately gray scale images.
    else ac "gui_parallel_overlap \"nlmeans $1,$2,$3,-_fx_smooth_nlmeans$4\",$6,$7",$5
    fi
  endl done

_fx_smooth_nlmeans0 : s c abs max
_fx_smooth_nlmeans1 : s c abs +
_fx_smooth_nlmeans2 : norm
_fx_smooth_nlmeans3 : if {s>=3} channels 0,2 luminance else norm fi
_fx_smooth_nlmeans4 : if {s>=3} channels 0,2 srgb2rgb rgb2lab channels 0 else norm fi
_fx_smooth_nlmeans5 :

fx_smooth_nlmeans_preview:
  gui_split_preview "fx_smooth_nlmeans $*",${-3--1}

#@gui Smooth [Patch-Based] : fx_smooth_patch, fx_smooth_patch_preview(0)
#@gui : Spatial Variance = float(10,0.1,200)
#@gui : Patch Variance = float(10,0.1,200)
#@gui : Patch Size = int(3,2,21)
#@gui : Lookup Size = int(5,2,21)
#@gui : Patch Smoothness = float(0,0,4)
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_patch :
  ac "gui_parallel_overlap \"repeat $7 denoise $1,$2,$3,$4,$5,$6 done c 0,255\",$9,$10",$8

fx_smooth_patch_preview :
  gui_split_preview "fx_smooth_patch $*",${-3--1}

#@gui Smooth [Patch-PCA] : fx_smooth_patchpca, fx_smooth_patchpca_preview(0)
#@gui : Strength = float(4,0,16)
#@gui : Patch Size = int(7,2,21)
#@gui : Lookup Size = int(11,2,21)
#@gui : Spatial Sampling = int(7,1,16)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Beware, this filter uses a very computationally intensive algorithm to denoise images. So, do not complain too much if you have less than 8 cores
#@gui : available for the computation :)
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>J&#233;rome Boulanger</i>.      Latest Update: <i>2016/24/03</i>.</small>")
fx_smooth_patchpca :
  ac "denoise_patchpca ${1-4} c 0,255",$5

fx_smooth_patchpca_preview :
  gui_split_preview "fx_smooth_patchpca $*",${-3--1}

#@gui Smooth [Perona-Malik] : fx_smooth_peronamalik, fx_smooth_peronamalik_preview(0)
#@gui : K-Factor = float(20,0,255)
#@gui : Time Step = float(5,5,50)
#@gui : Iterations = int(5,1,30)
#@gui : Keep Iterations as Different Layers = bool(false)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/26/11</i>.</small>")
fx_smooth_peronamalik :
  ac "gui_parallel_overlap \"peronamalik_flow $1,$3,$2,$4 c 0,255\",$6,$7",$5

fx_smooth_peronamalik_preview :
  gui_split_preview "fx_smooth_peronamalik $*",${-3--1}

#@gui Smooth [Selective Gaussian] : fx_smooth_selective, fx_smooth_selective_preview(0)
#@gui : Amplitude = float(5,0,20)
#@gui : Edges = float(0.5,0,2)
#@gui : Scales = int(5,1,10)
#@gui : Iterations = int(1,1,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_selective :
  ac "gui_parallel_overlap \"repeat $4 blur_selective $1,$2,$3 done c 0,255\",$6,$7",$5

fx_smooth_selective_preview :
  gui_split_preview "fx_smooth_selective $*",${-3--1}

#@gui Smooth [Skin] : fx_smooth_skin, fx_smooth_skin_preview(1)
#@gui : note = note("<small><b>Step 1:</b> Skin detection</small>")
#@gui : Skin Estimation = choice(2,"None","Manual","Automatic")
#@gui : Tolerance = float(0.5,0,1)
#@gui : Smoothness = float(1,0,5)
#@gui : Threshold = float(1,0,10)
#@gui : Pre-Normalize Image = bool(1)
#@gui : X-Coordinate [Manual] = float(50,0,100)
#@gui : Y-Coordinate [Manual] = float(50,0,100)
#@gui : Radius [Manual] = float(5,0,25)
#@gui : sep = separator()
#@gui : note = note("<small><b>Step 2:</b> Medium scale smoothing</small>")
#@gui : Base Scale = float(2,0,10)
#@gui : Fine Scale = float(0.2,0,0.8)
#@gui : Smoothness = float(3,0,10)
#@gui : Smoothness Type = choice(1,"Gaussian","Bilateral")
#@gui : sep = separator()
#@gui : note = note("<small><b>Step 3:</b> Details enhancement</small>")
#@gui : Gain = float(0.05,0,0.5)
#@gui : sep = separator()
#@gui : Preview Data = choice{5,"Skin Mask","Base Scale","Medium Scale (Original)","Medium Scale (Smoothed)","Fine Scale","Result Image"}
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), url = link("Click here for a video tutorial","http://www.youtube.com/watch?v=H8pQfq-ybCc")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/20/12</i>.</small>")
fx_smooth_skin :
  repeat $! l[$>] split_opacity l[0] to_rgb

    # Skin detection step.
    if $5 +balance_gamma 128,128,128 else [0] fi
    if {$1==0} channels. 0 f. 1 elif {$1==2} detect_skin. $2 else detect_skin. $2,$6%,$7%,$8% fi
    M={iM} b. $3% *. {$M/iM} *. $4 c. 0,1

    # Details smoothing step.
    split_details[0] 4,$9%,$10%
    +_fx_smooth_skin[2] $12,$11
    j[2] .,0,0,0,0,1,.. rm[-2,-1]
    *. {10^$13} + c 0,255

  endl a c endl done

_fx_smooth_skin :
  if {$1==0} b {$2/8}%
  else
    if {$2>0}
      m={im} M={iM} n 0,255
      repeat {int($2/5)} bilateral 3%,{5*3} done
      bilateral 3%,{($2%5)*3}
      * {($M-$m)/255} + $m
    fi
  fi

fx_smooth_skin_preview :
  if {$-2==0}
    gui_split_preview "if $5 balance_gamma 128,128,128 fi if {$1==0} f 1 elif {$1==2} detect_skin $2 else detect_skin $2,$6%,$7%,$8% fi M={iM} b $3% * {255*$M/iM} * $4 c 0,255",${-3--1}
  elif {$-2==1}
    gui_split_preview "b $9%",${-3--1}
  elif {$-2==2}
    gui_split_preview "split_details 4,$9%,$10% k.. n 0,255",${-3--1}
  elif {$-2==3}
    gui_split_preview "split_details 4,$9%,$10% k.. _fx_smooth_skin $12,$11 n 0,255",${-3--1}
  elif {$-2==4}
    gui_split_preview "split_details 4,$9%,$10% k. n 0,255",${-3--1}
  else
    gui_split_preview "fx_smooth_skin $*",${-3--1}
  fi

  if {$1==1}
    to_rgb
    circle $6%,$7%,$8%,0.2,0,255,0
    circle $6%,$7%,$8%,0.4,0xFFFFFFFF,0,255,0
    line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
    line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
  fi

#@gui Smooth [Thin Brush] : fx_smooth_anisotropic, fx_smooth_anisotropic(0)
#@gui : Amplitude = float(60,0,1000)
#@gui : Sharpness = float(0.9,0,2)
#@gui : Anisotropy = float(0.64,0,1)
#@gui : Gradient Smoothness = float(3.1,0,10)
#@gui : Tensor Smoothness = float(1.10,0,10)
#@gui : Spatial Precision = float(0.8,0.1,2)
#@gui : Angular Precision = float(30,1,180)
#@gui : Value Precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest Neighbor","Linear","Runge-Kutta")
#@gui : Fast Approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui : Channel(s) = choice("RGB","Luminance","Blue &amp; Red chrominances","Blue chrominance","Red chrominance")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : note = note{"\n<small><b>Note: </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest Update: <i>2010/26/12</i>.</small>")

#@gui Smooth [Total Variation] : fx_smooth_tv, fx_smooth_tv_preview(0)
#@gui : Time Step = float(30,5,100)
#@gui : Iterations = int(10,1,40)
#@gui : Keep Iterations as Different Layers = bool(false)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_tv :
  ac "gui_parallel_overlap \"tv_flow $2,$1,$3 c 0,255\",$5,$6",$4

fx_smooth_tv_preview :
  gui_split_preview "fx_smooth_tv $*",${-3--1}

#@gui Smooth [Wavelets] : fx_smooth_haar, fx_smooth_haar_preview(0)
#@gui : Threshold = float(1,0,10)
#@gui : Iterations = int(10,1,32)
#@gui : Scales = int(10,2,10)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), Parallel Processing = choice("Auto","One Thread","Two Threads","Four Threads","Eight Threads","Sixteen Threads"), Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger and David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/08</i>.</small>")
fx_smooth_haar :
  remove_opacity
  ac "gui_parallel_overlap \"denoise_haar $1,$3,$2 c 0,255\",$5,$6",$4

fx_smooth_haar_preview :
  gui_split_preview "fx_smooth_haar $*",${-3--1}

#@gui Upscale [Diffusion] : fx_upscale_smart, fx_upscale_smart_preview(0)
#@gui : Width = text("200%")
#@gui : Height = text("200%")
#@gui : Smoothness = float(2,0,20)
#@gui : Anisotropy = float(0.4,0,1)
#@gui : Sharpness = float(50,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_upscale_smart :
  to_rgb upscale_smart $1,$2,1,$3,$4,$5 c 0,255

fx_upscale_smart_preview :
  repeat $!
    +r. $1,$2,1,1,0
    if {w<{-2,w}||h<{-2,h}}  # Test for downscaling
      rm. /. 4
      0 t. "Downscaling is\nnot allowed!",5,5,20,1,255 r. ..,..,1,1,0,0,0.5,0.5
      -|[-2,-1]
    else
      z.. {50-50*{-2,w}/w}%,{50-50*{-2,h}/h}%,{50+50*{-2,w}/w}%,{50+50*{-2,h}/h}%
      rm. fx_upscale_smart. $1,$2,$3,$4,$5 c. 0,255
    fi
  mv. 0 done

#@gui Upscale [Scale2x] : fx_scalenx, fx_scalenx_preview(0)
#@gui : Scaling Factor = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gui : Colorbase = choice(0,"RGB","YCbCr","Lab")
#@gui : note = note{"\n<small><b>Note: </b>
#@gui : This filter re-implements the scaling algorithm described at :
#@gui : </small>"}
#@gui : url = link("http://scale2x.sourceforge.net")
#@gui : note = note{"<small>
#@gui : This filter is useful for resizing images that have very few colors
#@gui : (e.g. indexed images). It is generally useless for true colors images.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_scalenx :
  repeat $! l[$>] split_opacity
    if {$2==1} rgb2ycbcr[0] round[0]
    elif {$2==2} rgb2lab8[0] round[0]
    fi
    if {$1==0} scale2x
    elif {$1==1} scale3x
    elif {$1==2} scale2x scale2x
    elif {$1==3} scale3x scale2x
    elif {$1==4} scale2x scale2x scale2x
    elif {$1==5} scale3x scale3x
    elif {$1==6} scale3x scale2x scale2x
    elif {$1==7} scale2x scale2x scale2x scale2x
    elif {$1==8} scale3x scale3x scale2x
    elif {$1==9} scale3x scale3x scale3x
    fi
    if {$2==1} ycbcr2rgb[0]
    elif {$2==2} lab82rgb[0]
    fi
  a c endl done

fx_scalenx_preview :
  z 40%,40%,60%,60%
  fx_scalenx $1,$2

#@gui Upscale [DCCI2x]: fx_scale_dcci2x, fx_scale_dcci2x_preview(0)
#@gui : note = note("<i>Directional Cubic Convolution Interpolation</i>"), sep = separator()
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>Garagecoder</i>.      Latest Update : <i>2015/11/07</i>.</small>")
#@gui : note = note{"\n<small><b>Note: </b>
#@gui : This filter re-implements the scaling algorithm described at :
#@gui : </small>"}
#@gui : url = link("wikipedia.org","https://en.wikipedia.org/wiki/Directional_Cubic_Convolution_Interpolation")
#@gui : note = note("<small>The algorithm is intended for enlarging images while avoiding</small>")
#@gui : note = note("<small>artifacts, e.g. staircase artifacts.</small>")
#@gui : note = note("\n<small>Threshold controls edge[lower] to texture[higher] balance.</small>")
#@gui : note = note("<small>Exponent controls texture edge sharpness[higher].</small>")
#@gui : note = note("<small>Warning: highly experimental...</small>")
fx_scale_dcci2x : skip ${1=1.15},${2=5},${3=0}
  repeat $! l[$>]
    split_opacity scale_dcci2x ${1-3} a c c 0,255
  endl done

fx_scale_dcci2x_preview :
  z 25%,25%,75%,75% fx_scale_dcci2x $*

#@gui ____<b>Rendering</b>
#-------------------------

# Generic function to render a 3D image, with usual rendering parameters :
# $1 = Width
# $2 = Height
# $3 = Object size
# $4 = X-angle
# $5 = Y-angle
# $6 = Z-angle
# $7 = FOV
# $8 = X-light
# $9 = Y-light
# $10 = Z-light
# $11 = Specular lightness
# $12 = Specular shininess
# $13 = Rendering mode.
# $14 = Antialiasing (0 | 1)
fx_render3d : skip ${14=1}
  width={(1+$14)*$1} height={(1+$14)*$2}
  n3d c3d m3d {round($13)} f3d={0.5*max($width,$height)/tan($7*pi/360)}
  f3d $f3d l3d {$8*$f3d},{$9*$f3d},{$10*$f3d} sl3d $11 ss3d $12
  repeat $! l[$>]
    *3d {$3*max($width,$height)} r3d 0,0,1,{-$6} r3d 0,1,0,{-$5} r3d 1,0,0,{-$4}
    $width,$height,1,3,-1
    j3d. ..,50%,50% rm..
    to_rgba replace_color 0,0,-1,-1,-1,255,0,0,0,0
    if $14
      r $1,$2,1,100%,2 s c,-3 +. 1e-5 /[0] [1] *[0] 255 a c
    fi
  endl done

#@gui 3D Blocks : fx_blocks3d, fx_blocks3d(1)
#@gui : Resolution = int(32,1,128)
#@gui : Smoothness = float(0,0,40)
#@gui : Elevation = float(4,-10,10)
#@gui : Size = float(1.5,0,3)
#@gui : Angle = float(30,0,360)
#@gui : Tilt = float(60,0,90)
#@gui : FOV = float(45,1,90)
#@gui : Centering (%) = point(50,50)
#@gui : sep = separator()
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(-50,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Use Light = bool(1)
#@gui : Antialiasing = bool(1)
#@gui : Outline Color = color(0,0,0,128)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/10/02</i>.</small>")
fx_blocks3d :
  repeat $! l[$>]
    nm=${"gui_layer_name"}
    W={w} H={h} M={max(w,h)}
    if {w>h} r2dx $1 else r2dy $1 fi
    w={w} h={h} m={max(w,h)}
    if {$3>0} mirror y fi
    imageblocks3d $3,$2%
    -3d. {$w/2},{$h/2} f={$4*$M/($m*(2-$16))} *3d $f,$f,{$f*abs($3*$1/100)}
    if {$3>0} r3d 1,0,0,180 fi
    r3d 0,0,1,$5 r3d 1,0,0,-$6

    # Render object.
    if $16 {2*$M},{2*$M},1,4,-1 else $M,$M,1,4,-1 fi
    f3d={0.5*w/tan($7*pi/360)} f3d $f3d
    l3d {$10*$f3d},{$11*$f3d},{$12*$f3d} sl3d $13 ss3d $14
    j3d. [0],$8%,$9%,0,1,{if($15,3,2)},0,1
    sh. 100% +. 1 *. 255 rm.

    # Render object outline
    if $20
      .,.,1,3,-1
      j3d. [0],$8%,$9%,0,1,3,0,1 rm[0]
      g. xy,1 +[-2,-1] norm. !=. 0
      +r. 100%,100%,1,3
      sh. 0 *. $17 rm.
      sh. 1 *. $18 rm.
      sh. 2 *. $19 rm.
      j[0] .,0,0,0,0,{$20/255},.. rm[-2,-1]
    else rm[0]
    fi

    replace_color 0,0,-1,-1,-1,0,0,0,0,0
    if $16 r 50%,50%,1,4,2 fi
    c 0,255 nm name($nm)
  endl done

#@gui 3D Colored Object : fx_coloredobject3d, fx_coloredobject3d_preview(1)
#@gui : Type = choice{1,"Plane","Box","Pyramid","Ellipsoid","Torus","Gyroid","Weird","Cup"}
#@gui : Color = color(128,128,128,255)
#@gui : sep = separator()
#@gui : Size-1 = float(0.5,0,3)
#@gui : Size-2 = float(0.5,0,3)
#@gui : Size-3 = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/16/05</i>.</small>")
_fx_coloredobject3d :
  to_rgb _fx_coloredobject3d$1$2 ${6-8} col3d. ${3-5}
  db3d 0

fx_coloredobject3d :
  _fx_coloredobject3d "_",${1-4,6-8}
  repeat {$!-1}
    +fx_render3d. {$>,w},{$>,h},$6,${9--1}
    sh. 3 *. {$5/255} rm.
    blend[$>,-1] alpha
  done
  rm.

fx_coloredobject3d_preview :
  _fx_coloredobject3d "_preview_",${1-4,6-8}
  repeat {$!-1}
    +fx_render3d. {$>,w},{$>,h},$6,${9--1}
    sh. 3 *. {$5/255} rm.
    blend[$>,-1] alpha
  done rm.

_fx_coloredobject3d_0 : plane3d 1 *3d. $1,$2,1
_fx_coloredobject3d_1 : box3d 1 *3d. $1,$2,$3
_fx_coloredobject3d_2 : pyramid3d 1,1 *3d. $1,$2,$3
_fx_coloredobject3d_3 : sphere3d 1 *3d. 1,{2*$2},{2*$3}
_fx_coloredobject3d_4 : torus3d $1,{$2/2},100,50 *3d. $3,0.5,0.5
_fx_coloredobject3d_5 : gyroid3d 24 *3d. $1,$2,$3
_fx_coloredobject3d_6 : weird3d 32 *3d. $1,$2,$3
_fx_coloredobject3d_7 : cup3d 128 *3d. $1,$2,$3
_fx_coloredobject3d_preview_0 : plane3d 1 *3d. $1,$2,1
_fx_coloredobject3d_preview_1 : box3d 1 *3d. $1,$2,$3
_fx_coloredobject3d_preview_2 : pyramid3d 1,1 *3d. $1,$2,$3
_fx_coloredobject3d_preview_3 : sphere3d 1 *3d. 1,{2*$2},{2*$3}
_fx_coloredobject3d_preview_4 : torus3d $1,{$2/2},100,50 *3d. $3,0.5,0.5
_fx_coloredobject3d_preview_5 : gyroid3d 8 *3d. $1,$2,$3
_fx_coloredobject3d_preview_6 : weird3d 12 *3d. $1,$2,$3
_fx_coloredobject3d_preview_7 : cup3d 64 *3d. $1,$2,$3

#@gui 3D Elevation : fx_elevation3d, fx_elevation3d_preview(1)
#@gui : Factor = float(100,-1000,1000)
#@gui : Smoothness = float(1,0,10)
#@gui : sep = separator()
#@gui : Width = _int(1024,8,4096)
#@gui : Height = _int(1024,8,4096)
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(25,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(2,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_elevation3d :
  repeat {$!/2} l[$>,{min($>+1,$!-1)}]
    if {$!==1} +norm else r[1] [0],3 fi
    n[1] 0,{abs($1)} *[1] {sign($1)} b[1] $2
    elevation3d[0] [1] rm[1]
  endl done
  db3d

fx_elevation3d :
  _fx_elevation3d ${1-2} fx_render3d ${3--1}

fx_elevation3d_preview :
  fx_elevation3d ${1-2},{w},{h},${5--1}

#@gui 3D Extrusion : fx_extrude3d, fx_extrude3d_preview(1)
#@gui : Depth = float(10,1,1024)
#@gui : Resolution = int(512,1,1024)
#@gui : Smoothness = float(0.6,0,3)
#@gui : sep = separator()
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_extrude3d :
  repeat {$!/2} l[$>,{min($>+1,$!-1)}]
    extrude3d. $1,$2,$3%
    if {$!==2} t3d. .. rm.. fi
  endl done
  db3d 0

fx_extrude3d :
  _fx_extrude3d ${1-3} fx_render3d ${4--1}

fx_extrude3d_preview :
  fx_extrude3d ${1-3},{w},{h},${6--1}

#@gui 3D Image Object : fx_imageobject3d, fx_imageobject3d_preview(1)
#@gui : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gui : sep = separator()
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_imageobject3d :
  to_rgb repeat $! l[$>] _fx_imageobject3d$1$2 endl done
  db3d 0

fx_imageobject3d :
  _fx_imageobject3d "_",$1 fx_render3d ${2--1}

fx_imageobject3d_preview :
  w={w} h={h} _fx_imageobject3d "_preview_",$1 fx_render3d $w,$h,${4--1}

_fx_imageobject3d_0 : imageplane3d
_fx_imageobject3d_1 : imagecube3d
_fx_imageobject3d_2 : imagepyramid3d
_fx_imageobject3d_3 : imagesphere3d 64,32
_fx_imageobject3d_4 : torus3d 100,30,100,50 t3d. .. rm..
_fx_imageobject3d_5 : gyroid3d 24 t3d. .. rm..
_fx_imageobject3d_6 : weird3d 32 t3d. .. rm..
_fx_imageobject3d_7 : cup3d 128 t3d. .. rm..
_fx_imageobject3d_8 : imagerubik3d 5,5
_fx_imageobject3d_preview_0 : imageplane3d
_fx_imageobject3d_preview_1 : imagecube3d
_fx_imageobject3d_preview_2 : imagepyramid3d
_fx_imageobject3d_preview_3 : imagesphere3d 16,8
_fx_imageobject3d_preview_4 : torus3d 100,30,100,50 t3d. .. rm..
_fx_imageobject3d_preview_5 : gyroid3d 8 c3d. n3d. t3d. .. rm..
_fx_imageobject3d_preview_6 : weird3d 12 t3d. .. rm..
_fx_imageobject3d_preview_7 : cup3d 64 t3d. .. rm..
_fx_imageobject3d_preview_8 : imagerubik3d 3,3,5,5

#@gui 3D Lathing : fx_lathing3d, fx_lathing3d_preview(1)
#@gui : Resolution = int(76,1,1024)
#@gui : Smoothness = float(2,0,5)
#@gui : Max Angle = float(361,0,361)
#@gui : sep = separator()
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
_fx_lathing3d :
  repeat {$!/2} l[$>,{min($>+1,$!-1)}]
    lathe3d. $1,$2%,$3
    if {$!==2} t3d. .. rm.. fi
  endl done
  db3d 0

fx_lathing3d :
  _fx_lathing3d ${1-3} fx_render3d ${4--1}
  nm name("[3D lathing]"),pos(0,0),mode(alpha)

fx_lathing3d_preview :
  fx_lathing3d ${1-3},{w},{h},${6--1}

#@gui 3D Random Objects : fx_random3d, fx_random3d(1)
#@gui : Type = choice("Cube","Cone","Cylinder","Sphere","Torus")
#@gui : Density = int(50,1,300)
#@gui : Size = float(3,1,20)
#@gui : Z-Range = float(100,0,300)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : Rendering = choice(3,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_random3d :
  repeat $! l[$>]
    f3d={0.5*max(w,h)/tan($5*pi/360)} f3d $f3d l3d {$6*$f3d},{$7*$f3d},{$8*$f3d} sl3d $9 ss3d $10
    to_rgb ({w},{h},{d},{s}) /. 2 repeat $2
    ({1,@0}) +. {1,@1} *. $3 /. 100 _fx_random3d$1 {^} rm..
    r3d. 1,1,0,{u(0,360)}
    ({u(-1,1)}) *. {1,@0} ({u(-1,1)}) *. {1,@1}
    +3d... {-2,^},{^},{u(-$4,$4)} rm[-2,-1]
    col3d. {u(255)},{u(255)},{u(255)} done +3d[2--1] j3d[0] .,50%,50%,0,$12,$11,0,1
    k[0]
  endl done

_fx_random3d0 : box3d $1
_fx_random3d1 : ($1) /. 2 cone3d {^},$1 rm..
_fx_random3d2 : ($1) /. 2 cylinder3d {^},$1 rm..
_fx_random3d3 : sphere3d $1,2
_fx_random3d4 : ($1) /. 3 torus3d $1,{^} rm..

#@gui Ball : fx_ball, fx_ball_preview(0)
#@gui : Radius = int(128,1,1024)
#@gui : Specular Light = float(0.8,0,8)
#@gui : Specular Size = float(1,0,8)
#@gui : Shadow = float(1.5,0,4)
#@gui : Color = color(255,0,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/27/11</i>.</small>")
fx_ball :
  ball $1,${5-7},${2-4}
  if {$!>1} mv. 0 nm[0] "name(Ball),pos("{0,0.5*([${-max_wh}]-[w,h])}")" else nm[0] "name(Ball)" fi

fx_ball_preview :
  fx_ball $*
  if {$!>1} rv[-2,-1] blend[-2,-1] alpha fi

#@gui Circle Art : fx_circle_art, fx_circle_art
#@gui : Type = choice(1,"Random","Lissajous spiral")
#@gui : Density = float(15,0,100)
#@gui : Radius = float(0.5,0,1)
#@gui : Modulo = int(8,2,16)
#@gui : Anti-Aliasing = bool(1)
#@gui : Random Colors = bool(1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Lissajous parameters:</b></small>")
#@gui : Curve Length = float(15,0,50)
#@gui : Curve Angle = float(0,0,360)
#@gui : Minimal Radius = float(0,-5,5)
#@gui : Maximal Radius = float(0.5,-5,5)
#@gui : X-Dispersion = float(1,0,4)
#@gui : Y-Dispersion = float(1,0,4)
#@gui : X-Factor = int(1,0,16)
#@gui : Y-Factor = int(1,0,16)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/22/08</i>.</small>")
fx_circle_art :
  if {!$2} f 0 return fi
  # Generate object coordinates.
  if {$1==0} # Random.
    {round(2*($2^1.5))}
    rand. -1,1 +rand. -1,1 +rand. -$3,$3 a[-3--1] y
  else # Spiral.
    {max(1,round($2*$7))}
    t0={$8*2*pi/180}
    rows. 0,2 f. 'r=x/(w-1);t=2*pi*x/$2;if(y==0,(r^$11)*cos($t0+$13*t),if(y==1,(r^$12)*sin($t0+$14*t),max(0,$3*($9+($10-$9)*r))))'
  fi

  # Convert to 3D object.
  l.
    transpose s x,-1 h={h}
    i[0] ({'CImg3d'},{2*$h},$h)  # Header.
    ++... . -[-4,-2] i .. i[-3,-1] 1,100% a[-6--1] x  # Vertices.
    1,$h,1,1,5 1,$h,1,1,2*y ++. 1 a[-3--1] x z. 0,5 # Primitives.
    3,$h,1,1,1 1,$h,1,1,-1 y a y # Colors + Opacities.
  endl

  # Render object on selected images.
  repeat {$!-1} l[$>,-1]
    s={0,max(w,h)} rm[0]
    if $5 {2*$s},{2*$s} +*3d[0] $s # Anti-aliasing.
    else $s,$s +*3d[0] {$s/2} # No anti-aliasing.
    fi
    j3d[1] [2],50%,50%,0,1,2,0,0 rm[2]
    %. $4
    if $6 i.. 100%,100%,1,3 rand.. 0,255 plasma.. 1,1 equalize.. 256 n.. 0,255 blend[-2,-1] shapeaverage fi
    rv
  endl done
  rm.
  n 0,255
  if $5 r 50%,50%,1,100%,2 fi

#@gui Equation Plot [Parametric] : fx_equation_parametric, fx_equation_parametric
#@gui : X(t) = text{"sin(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gui : Y(t) = text{"cos(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gui : Min-t = float(0,-1000,1000)
#@gui : Max-t = float(100,-1000,1000)
#@gui : Resolution = int(4096,2,32768)
#@gui : Outline Opacity = float(1,0,1)
#@gui : Dot Size = int(0,0,16)
#@gui : Start Color = color(64,0,0)
#@gui : End Color = color(128,0,0)
#@gui : Colored Outline = bool(1)
#@gui : Antialiasing = bool(1)
#@gui : Decoration = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/13/11</i>.</small>")
fx_equation_parametric :
  repeat $! l[$>]
    w={w} h={h} rm
    $5,1,1,2,'"t=$3+x*($4-$3)/($5-1);if(c==0,$1,$2)"'
    channels. 0,2
    ($8,$11^$9,$12^$10,$13) r. {-2,w},1,1,3,3 a c
    display_parametric $w,$h,{$6+$14*1.001},$7,$15,$16
  endl done

#@gui Equation Plot [Y=f(X)] : fx_equation_plot, fx_equation_plot
#@gui : F(X) = text{"X*c+10*cos(X+c+u)"}
#@gui : X-Min = float(-10,-100,100)
#@gui : X-Max = float(10,-100,100)
#@gui : Resolution = int(100,2,1024)
#@gui : Channels = int(3,1,32)
#@gui : Plot Type = choice(2,"None","Lines","Splines","Bars")
#@gui : Vertex Type = choice(0,"None","Points","Crosses 1","Crosses 2","Circles 1","Circles 2","Square 1","Square 2")
#@gui : sep = separator()
#@gui : note = note("<small><b>Note</b> :
#@gui : Use variable <b>X</b> instead of <b>x</b> in the above equation to take care of the X-min/max settings.
#@gui : Variable <b>c</b> refers to the current channel number.
#@gui : Variable <b>u</b> refers to a uniformly distributed random value in [0,1].
#@gui : Reduce resolution to be able to view
#@gui : separate graph vertices.</small>")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_equation_plot :
  repeat $! l[$>]
    w={w} h={h} rm
    $4,1,1,$5,"X=$2+($3-$2)*x/($4-1);$1"
    dg $w,$h,$6,$7,$2,$3
  endl done

#@gui Gradient [Corners] : fx_corner_gradient, fx_corner_gradient
#@gui : Color 1 (Up/Left Corner) = color(255,255,255,128)
#@gui : Color 2 (Up/Right Corner) = color(255,0,0,255)
#@gui : Color 3 (Bottom/Left Corner) = color(0,255,0,255)
#@gui : Color 4 (Bottom/Right Corner) = color(0,0,255,255)
#@gui : sep = separator(), Colorspace = choice(1,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_corner_gradient : skip ${17=0}
  repeat $! l[$>]
    wh={w},{h} rm
    ($1,$5;$9,$13^$2,$6;$10,$14^$3,$7;$11,$15^$4,$8;$12,$16)
    _gb_fwd $17
    r. $wh,1,100%,3
    _gb_bwd $17
  endl done

#@gui Gradient [Custom Shape] : fx_custom_gradient, fx_custom_gradient_preview(1)
#@gui : note = note("<small><b>Shape selection:</b></small>")
#@gui : Select By = choice("Auto","Dark Pixels","Bright Pixels","Opaque Pixels")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(0,0,100)
#@gui : Preview Shape = bool(1)
#@gui : note = note("<small><b>Note:</b> Shapes with small strokes may lead to incorrect previews.</small>")
#@gui : sep = separator()
#@gui : note = note("<small><b>Gradient parameters:</b></small>")
#@gui : Number of Colors = int(4,2,10)
#@gui : Cycles = float(1,1,16)
#@gui : Offset = float(0,0,100)
#@gui : Shading = float(128,1,256)
#@gui : Inner Length = float(100,0,100)
#@gui : Outer Length = float(100,0,100)
#@gui : Spatial Metric = choice(2,"Chebyshev","Manhattan","Euclidean")
#@gui : Color Metric = choice("RGB","HSV","Lab")
#@gui : Shade Back to First Color = bool(1)
#@gui : Preview Gradient = bool(0)
#@gui : Save Gradient As = _text("")
#@gui : sep = separator()
#@gui : note = note("<small><b>Color definitions:</b></small>")
#@gui : Colormap Type = choice(1,"Pre-Defined","User-Defined")
#@gui : Pre-Defined Colormap = int(0,0,65535)
#@gui : 1st Color = color(0,0,0,255)
#@gui : 2nd Color = color(255,0,0,255)
#@gui : 3rd Color = color(255,255,0,255)
#@gui : 4th Color = color(255,255,255,255)
#@gui : 5th Color = color(0,255,255,255)
#@gui : 6th Color = color(0,255,0,255)
#@gui : 7th Color = color(0,0,255,255)
#@gui : 8th Color = color(128,128,128,255)
#@gui : 9th Color = color(255,0,255,255)
#@gui : 10th Color = color(0,0,0,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2013/03/10</i>.</small>")
fx_custom_gradient_preview : skip "${15=}"
  repeat $! l[$>]
    if $4
      +_fx_custom_gradient1 ${1-14},"$15",${16--1} +erode. 3 -[-2,-1] +dilate. 5 a[-2,-1] c n. 0,255
      fx_custom_gradient[0] ${1-14},"$15",${16--1},-1 blend alpha
    else fx_custom_gradient ${1-14},"$15",${16--1},-1
    fi
    if $14
      +_fx_custom_gradient0[] ${1-14},"$15",${16--1} r. {{0,w}-16},16,1,4 frame. 1,1,0 j[0] .,8,{0,h-25} rm.
    fi
  endl done

fx_custom_gradient : skip "${15=}"
  _fx_custom_gradient0 ${1-14},"$15",${16--1}
  if {$-1>=0&&narg("$15")}
    dir_ggr=${-path_gimp}gradients
    0 nm. ${"normalize_filename \"$15\""} name_ggr={b} rm. output_ggr. $dir_ggr/$name_ggr.ggr,"$15"
  fi
  i.. (0^0^0^0) a[-2,-1] x
  repeat {$!-1} l[$>,-1]
    _fx_custom_gradient1[0] ${1-14},"$15",${16--1}
    +distance[0] 1,$11 +distance[0] 0,$11 *. -1 +[0] 1 +[0,-2,-1]  # Signed distance function.
    m={$9%*{0,im}} M={$10%*{0,iM}}
    -[0] $m *[0] {1,(w-2)/($M-$m)} +[0] 1
    round[0] map[0] .
  endl done
  rm.

# Create colormap.
_fx_custom_gradient0 :
  if $16 4,8,1,1,${18-56} permute. yzcx
  else 8,1,1,3 srand $17 rand. 0,255 to_rgba.
  fi
  z. 0,{$5-1}
  if $13
    r. {200*$6}%,1,1,4,0,2
    __fx_custom_gradient0. $12,$8
    shift. {-round(w*0.5*$7%)},0,0,0,2 z. 0,{w/2-1}
  else
    __fx_custom_gradient0. $12,$8
    r. {100*$6}%,1,1,4,0,2 shift. {-round(w*$7%)},0,0,0,2
    fi

__fx_custom_gradient0 :
  if {$1==1} sh. 0,2 rgb2hsv. rm.
  elif {$1==2} sh. 0,2 srgb2rgb. rgb2lab. rm.
  fi
  r. {$2*w},1,1,4,3
  if {$1==1} sh. 0,2 hsv2rgb. rm.
  elif {$1==2} sh. 0,2 lab2rgb. rgb2srgb. rm.
  fi

# Extract shape from image.
_fx_custom_gradient1 :
  b $2%
  if {$1==0} # Auto-mode.
    to_a split_opacity
    if {iM>im+32}
      rm.. >=[0] {100-$3}%
    else
      rm. norm n 0,1
      if {ia>0.5} <=[0] $3% else >=[0] {100-$3}% fi
    fi
  elif {$1==1} # Dark pixels.
    remove_opacity norm <= $3%
  elif {$1==2} # Bright pixels.
    remove_opacity norm >= {100-$3}%
  else # Opaque pixels.
    to_a channels 100% >= {100-$3}%
  fi

#@gui Gradient [from Line] : fx_line_gradient, fx_line_gradient_preview(1)
#@gui : Starting Point (%) = point(0,0,0,1,255,0,0)
#@gui : Ending Point (%) = point(100,100,0,1,64,128,255)
#@gui : Sampling = float(100,0,100)
#@gui : Length = int(0,0,4096)
#@gui : note = note("<small><b>Note:</b> Set length to <i>0</i> to release gradient length constraints.</small>")
#@gui : Sort Colors = choice("Don't Sort","By Red Component","By Green Component","By Blue Component","By Luminance","By Blue Chrominance","By Red Chrominance","By Lightness")
#@gui : Reverse Gradient = bool(0)
#@gui : sep = separator()
#@gui : Preview Gradient = bool(1)
#@gui : Save Gradient As = _text("")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_line_gradient : skip "${10=}"
  _fx_line_gradient $*
  if {narg("$10")}
    dir_ggr=${-path_gimp}gradients
    0 nm. ${"normalize_filename \"$10\""} name_ggr={b} rm. output_ggr. $dir_ggr/$name_ggr.ggr,"$10"
  fi
  repeat $! r[$>] 100%,64,1,100% done

fx_line_gradient_preview :
  repeat $! l[$>]
    to_rgba
    if $9 +_fx_line_gradient $* fi
    l[0]
      line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,255,255,255,255
      line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,0,0,0,255
    endl
    if {$!>1} r. {{0,w}-32},32,1,4,1 frame. 1,1,0,0,0,255 j[0] [1],16,{{0,h}-48} rm. fi
  endl done

_fx_line_gradient :
  at_line $1%,$2%,0,$3%,$4%,0 r {max(0.1,$5)}%,1,1,100%,1
  m "feature1 : channels 0"
  m "feature2 : channels 1"
  m "feature3 : channels 2"
  m "feature4 : to_rgb luminance"
  m "feature5 : to_rgb rgb2ycbcr channels 1"
  m "feature6 : to_rgb rgb2ycbcr channels 2"
  m "feature7 : to_rgb srgb2rgb rgb2lab channels 0"
  if $7 repeat $! l[$>] +feature$7 rv a y sort +,x rows 1 endl done fi
  if $6 r $6,1,1,100%,3 fi
  if $8 mirror x fi

#@gui Gradient [Linear] : fx_linear_gradient, fx_linear_gradient
#@gui : Starting Color = color(0,0,0,255)
#@gui : Ending Color = color(255,255,255,255)
#@gui : Swap Colors = bool(0)
#@gui : Angle = float(45,0,360)
#@gui : Fade Start = float(0,0,100)
#@gui : Fade End = float(100,0,100)
#@gui : sep = separator(), Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_linear_gradient : skip ${13=0}
  repeat $! l[$>]
    wh={w},{h} rm
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    if $9 rv[-2,-1] fi
    r $wh
    _gb_fwd $13
    fade_linear $10,$11,$12
    _gb_bwd $13
  endl done

#@gui Gradient [Radial] : fx_radial_gradient, fx_radial_gradient
#@gui : Starting Color = color(0,0,0,255)
#@gui : Ending Color = color(255,255,255,255)
#@gui : Swap Colors = bool(0)
#@gui : Fade Start = float(0,0,100)
#@gui : Fade End = float(100,0,100)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : sep = separator(), Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/29/06</i>.</small>")
fx_radial_gradient : skip ${14=0}
  repeat $! l[$>]
    wh={w},{h} rm
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    if $9 rv[-2,-1] fi
    r $wh
    _gb_fwd $14
    100%,100% =. 1,$12%,$13% distance. 1 _fade $10,$11
    _gb_bwd $14
  endl done

#@gui Gradient [Random] : fx_random_gradient, fx_random_gradient
#@gui : Density = int(32,1,1024)
#@gui : Seed = int(0,0,65535)
#@gui : Smoothness = float(0,0,10)
#@gui : Color Balance = color(128,128,128)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/08/04</i>.</small>")
fx_random_gradient :
  repeat $! l[$>]
    to_rgba 100%,100% srand $2
    eval "for (n=0, n<$1, ++n,
            x = round(u(w-1));
            y = round(u(h-1));
            i(x,y) = 1;
            i(#0,x,y,0,0) = round(u(255));
            i(#0,x,y,0,1) = round(u(255));
            i(#0,x,y,0,2) = round(u(255));
            i(#0,x,y,0,3) = $7*255 + (1-$7)*round(u(255));
          )"
    if {$7!=1} sh.. 100% n. 0,255 rm. fi
    ==. 0
    sh.. 0,2 srgb2rgb. rm.
    inpaint_diffusion.. [1],100%,1 rm.
    b $3% n 0,255
    sh 0,2 rgb2srgb. balance_gamma. ${4-6} rm.
  endl done

#@gui Lightning : fx_lightning, fx_lightning_preview
#@gui : note = note{"<small><b>Global parameters:</b></small>"}
#@gui : Number of Streaks = int(20,1,1024)
#@gui : Size (%) = float(90,0,150)
#@gui : Resolution = int(256,2,4096)
#@gui : Randomness = float(3,0,16)
#@gui : Smoothness = float(1.5,0,10)
#@gui : Balance = float(0.75,0,1)
#@gui : Color = color(255,255,255,255)
#@gui : Seed = int(0,0,65535)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Initial streak:</b></small>"}
#@gui : XY-Coordinates (%) = point(50,5,0,1)
#@gui : Angle (deg) = float(0,-180,180)
#@gui : Thickness (px) = int(6,1,64)
#@gui : Blur = float(0.2,0,3)
#@gui : sep = separator()
#@gui : note = note{"<small><b>Auxiliary streaks:</b></small>"}
#@gui : Min Offset (%) = float(25,0,100)
#@gui : Max Offset (%) = float(60,0,100)
#@gui : Min Length (%) = float(95,0,200)
#@gui : Max Length (%) = float(100,0,200)
#@gui : Min Angle Deviation (deg) = float(30,0,180)
#@gui : Max Angle Deviation (deg) = float(40,0,180)
#@gui : Thickness Factor = float(-0.25,-1,1)
#@gui : Blur Factor = float(-0.1,-1,1)
#@gui : Opacity Factor = float(-0.20,-1,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/27/11</i>.</small>")
fx_lightning :
  repeat $! l[$<]
    100%,100% l. fact={max(w,h)/$3*$2%} srand $11
    repeat $1
      if {$!<=1}
        i=0
        new_level=1
        new_length=$3
        new_x=0
        new_y=0
        new_angle=$14
      else
        i={round(u(1,max(1,($!-1)*$6)))}
        level={$i,@-2}
        angle={$i,@-1}
        nb_points={$i,i[6]}
        p={round(($nb_points-2)*u($17%,$18%))}
        new_level={$level+1}
        new_length={max(2,round(($nb_points-$p)*u($19%,$20%)))}
        new_x={$i,i[8+3*$p]}
        new_y={$i,i[9+3*$p]}
        new_angle={$angle+u($21,$22)*if(u>0.5,1,-1)}
      fi

      _fx_lightning $new_length,$4,$5
      r3d. 0,0,1,$new_angle
      +3d. $new_x,$new_y
      +*3d. $fact [0],[0] j3d. ..,$12%,$13%,0,1,1,0,0 rm..

      dilation={$15*(if($23>0,1.5,10)^($23*($new_level-1)))}
      blur={max(0,-1+(1+$16)*(if($24>0,2,5)^($24*($new_level-1))))}
      opacity={min(1,$10/255*(2^($25*($new_level-1))))}

      dilate. $dilation b. $blur% n. 0,1 *. $opacity max[0,-1]
      ($new_level;$new_angle) a[-2,-1] y
      progress {($>*100)/($1-1)}
    done
    k[0] * 255 i[0] 100%,100%,1,3 fc[0] ${7-9} a c
    endl
    rv
  endl done

fx_lightning_preview :
  repeat $! l[$>]
    fx_lightning $* rv blend alpha
  endl done

_fx_lightning :
  l[]
    ({'CImg3d'},$1,{$1-1})
    1,$1 noise. $2,1 cumulate. b. $3 shift. 0,1 1,100%,1,1,y 1,100% a[-3--1] x
    1,{h-1},1,1,2 +f. y ++. 1 a[-3--1] x
    4,100%,1,1,1
    y a y
  endl

#@gui Lissajous : fx_lissajous, fx_lissajous(1)
#@gui : Resolution = int(4096,2,8192)
#@gui : sep = separator()
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : Z-Size = float(3,1,10)
#@gui : sep = separator()
#@gui : X-Multiplier = float(8,0,32)
#@gui : Y-Multiplier = float(7,0,32)
#@gui : Z-Multiplier = float(0,0,32)
#@gui : sep = separator()
#@gui : X-Offset = float(0,0,1)
#@gui : Y-Offset = float(0,0,1)
#@gui : Z-Offset = float(0,0,1)
#@gui : sep = separator()
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : sep = separator()
#@gui : Thickness = float(0,0,50)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/18/04</i>.</small>")
fx_lissajous :
  repeat $! l[$>] to_rgba
    {w},{h}
    f3d {0.5*max(w,h)/tan($4*pi/360)}
    lissajous3d $1,$5,$8,$6,$9,$7,$10
    r3d. 0,0,1,$13 r3d. 0,1,0,$12 r3d. 1,0,0,$11
    *3d. {0.5*$2*{-2,w}},{0.5*$3*{-2,h}},{0.5*$4*max({-2,w},{-2,h})}
    col3d. 1 j3d.. .,50%,50%,0,1,1,0,0 rm.
    distance. 1 >. $14% *.. . ==. 0
    r. 100%,100%,1,4
    sh. 0 *. $15 rm.
    sh. 1 *. $16 rm.
    sh. 2 *. $17 rm.
    sh. 3 *. $18 rm.
    +[-2,-1]
  endl done

#@gui Mandelbrot - Julia Sets : fx_mandelbrot, fx_mandelbrot_preview
#@gui : X0 = value(-2)
#@gui : Y0 = value(-2)
#@gui : X1 = value(2)
#@gui : Y1 = value(2)
#@gui : note = note{"<small><b>Fractal Type:</b></small>"}
#@gui : Fractal Set = choice("Mandelbrot","Julia")
#@gui : Iterations = int(1024,16,65535)
#@gui : X-Seed (Julia) = float(0.317,-2,2)
#@gui : Y-Seed (Julia) = float(0.03,-2,2)
#@gui : sep = separator(), note = note{"<small><b>Colormap:</b></small>"}
#@gui : Number of Colors = int(16,2,2048)
#@gui : Smoothness = int(8,1,256)
#@gui : Seed = int(255,0,65536)
#@gui : sep = separator(), note = note{"<small><b>Navigation:</b></small>"}
#@gui : Zoom Center = point(50,50,0,0,255,255,255,200)
#@gui : Zoom Factor = float(0.25,0,1)
#@gui : Zoom In = button()
#@gui : Center = button()
#@gui : Zoom Out = button()
#@gui : Display Coordinates = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/06/27</i>.</small>")
fx_mandelbrot :
  if {!narg($_size)} _size={max(w,h)} fi
  rm $_size,$_size
  mandelbrot ${1-4},$6,{$5?[1,$7,$8]:[0,0,0]}
  srand $11 $9,1,1,3 rand. 0,255 r. {$9*$10},1,1,3,3 point. 0 map.. .,3 rm.

fx_mandelbrot_preview :
  _size={min(${-gui_preview_wh})}
  if {"$15 || $16 || $17"}
    x0,y0,x1,y1={"P0 = [${1,2}]; dP = [${3,4}] - P0; C = P0 + [${12,13}]%*dP; zfact = $14*($15?1:$16?0:-2); dC = 0.5*dP*(1 - 0.98*zfact); [C - dC,C + dC]"}
    status=\{$x0\}\{$y0\}\{$x1\}\{$y1\}\{$5\}\{$6\}\{$7\}\{$8\}\{$9\}\{$10\}\{$11\}\{50,50\}\{$14\}\{0\}\{0\}\{0\}\{$18\}
    px,py=50
  else
    x0,y0,x1,y1=${1-4}
    status=
    px,py=${12,13}
  fi
  fx_mandelbrot $x0,$y0,$x1,$y1,${5--1}

  x0r,y0r,x1r,y1r={"C = ["$px,$py"]%*w; dC = 0.5*w*(1 - 0.98*$14); round([C - dC, C + dC - 1])"}
  rectangle $x0r,$y0r,$x1r,$y1r,0.7,0xF0F0F0F0,255,255,255,255
  rectangle $x0r,$y0r,$x1r,$y1r,0.7,0x0F0F0F0F,0,0,0,255
  if $18 to "C0 = ( "$x0" , "$y0" )\nC1 = ( "$x1" , "$y1" )",2,2,16 fi
  u $status

#@gui Neon Lightning : fx_neon_lightning, fx_neon_lightning(1)
#@gui : Source (%) = point(50,50)
#@gui : R0 = float(0,0,100)
#@gui : Destination (%) = point(50,50)
#@gui : R1 = float(100,0,100)
#@gui : sep = separator()
#@gui : Density = int(50,1,512)
#@gui : Glow = float(0.7,0,5)
#@gui : Thickness = float(3,0,20)
#@gui : sep = separator()
#@gui : Color = color(130,80,50)
#@gui : Color Dispersion = float(0.25,0,1)
#@gui : Transparency = float(0,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/30/06</i>.</small>")
fx_neon_lightning :
  d={$13*255}
  repeat $! l[$>]
    100%,100%,1,4 rm[0]
    repeat $7
      x0={max(0,min(w,$1+u(-$3,$3)))} y0={max(0,min(h,$2+u(-$3,$3)))}
      x1={max(0,min(w,$4+u(-$6,$6)))} y1={max(0,min(h,$5+u(-$6,$6)))}
      u0={u(0,100)} v0={u(0,100)} u1={u(0,100)} v1={u(0,100)}
      R={max(0,min(255,u($10-$d,$10+$d)))}
      G={max(0,min(255,u($11-$d,$11+$d)))}
      B={max(0,min(255,u($12-$d,$12+$d)))}
      spline $x0%,$y0%,$u0%,$v0%,$x1%,$y1%,$u1%,$v1%,1,$R,$G,$B,1
    done
    s c,-3
    b[0] 3%
    distance. 1 *. -1 c. -{$9+1e-5},0 n. 0,1 sqrt.
    +b. $8%,1 n. 0,1 sqrt. n[-2,-1] 0,255 max[-2,-1]
    . blend[0,1] value
    smooth 5,0,1,0.5,2,10,0
    /. 255 ^. $14 *. 255
    a c c 0,255
  endl done

#@gui Plasma : fx_plasma, fx_plasma(0)
#@gui : Alpha = float(0.5,0,5)
#@gui : Beta = float(0,0,100)
#@gui : Scale = int(8,2,10)
#@gui : Randomize = bool(0)
#@gui : Transparency = bool(0)
#@gui : Color Balance = color(128,128,128)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/20/03</i>.</small>")
fx_plasma :  skip ${4=0},${5=0}
  if $5 to_rgba else to_rgb fi
  if $4 rand 0,255 fi
  plasma $1,$2,$3 n 0,255
  balance_gamma ${6-8}

#@gui Quick Copyright : fx_quick_copyright, fx_quick_copyright(0)
#@gui : Text = text{"\\251 G'MIC"}
#@gui : Size = int(27,13,128)
#@gui : Color = color(255,255,255,128)
#@gui : Outline = int(1,0,4)
#@gui : Position = choice(3,"Up-Left","Up-Right","Bottom-Left","Bottom-Right")
#@gui : Offset = int(5,0,40)
#@gui : Orientation = choice(1,"-90 deg.","0 deg.","+90 deg.","+180 deg.")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_quick_copyright :
  i[0] 0 t[0] "$1",0,0,$2,1,$3,$4,$5 autocrop[0] 0 r[0] {{0,w}+2*$7},{{0,h}+2*$7},1,3,0,0,0.5,0.5
  i[1] 0 t[1] "$1",0,0,$2,1,1 autocrop[1] 0 r[1] {{1,w}+2*$7},{{1,h}+2*$7},1,1,0,0,0.5,0.5 dilate[1] {1+2*$7}
  rotate[0,1] {90*($10-1)}
  repeat {$!-2}
  if {$8==0} j. [0],$9,$9,0,0,{$6/255},[1]
  elif {$8==1} j. [0],{w-1-{0,w}-$9},$9,0,0,{$6/255},[1]
  elif {$8==2} j. [0],$9,{h-1-{0,h}-$9},0,0,{$6/255},[1]
  else j. [0],{w-1-{0,w}-$9},{h-1-{0,h}-$9},0,0,{$6/255},[1]
  fi
  mv. 2 done
  rm[0,1]

#@gui Rainbow : fx_rainbow, fx_rainbow
#@gui : Left Position = float(80,0,100)
#@gui : Right Position = float(80,0,100)
#@gui : Left Slope = float(175,0,400)
#@gui : Right Slope = float(175,0,400)
#@gui : Thinness = float(3,0.1,8)
#@gui : Opacity = float(80,0,199)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_rainbow :
  repeat $! l[$>]
    100%,100% spline. 0,$1%,100,{-$3}%,100%,$2%,100,$4%,1,1
    flood. 0,0,0,0,0,1,1 flood. {w-1},0,0,0,0,1,1
    distance. 0 c. 0,255 n. 0,{$5*255}
    rainbow_lut +luminance. c. 0,{min(100,200-$6)}% n. 0,255 a[-2,-1] c
    map.. . rm.
    if {$6<100} sh. 3 *. {$6/100} rm. fi
    blend alpha
  endl done

#@gui Shade Bobs : fx_shadebobs, fx_shadebobs
#@gui : note = note("<small>Bobs parameters :</small>")
#@gui : Density = int(50,1,200)
#@gui : Radius = int(5,1,100)
#@gui : Duration = int(200,1,500)
#@gui : Velocity = float(1,0,10)
#@gui : sep = separator()
#@gui : note = note("<small>Curve parameters :</small>")
#@gui : Rx = float(-1,-3,3)
#@gui : Ry = float(2,-3,3)
#@gui : Rz = float(1,-3,3)
#@gui : Rt = float(0.8,-3,3)
#@gui : Rcx = float(0,-3,3)
#@gui : Colormap = choice(8,"Grayscale","Standard","HSV","Lines","Hot","Cool","Jet","Flag","Cube")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/18/04</i>.</small>")
fx_shadebobs :
  channels 0 f 0
  repeat $! l[$>]
    t=0
    repeat $3
      repeat $1
        r={$6+$5*cos(6*$7*$t)+(1-$5)*sin(6*$8*$t)}
        a={(360*sin($7*$t)+30*$6*$>)*pi/180}
        ax={2*$>*pi/$1+$t}
        cx={(1+$9*cos($ax)+$r*cos($a))*w/2}
        cy={(1+$9*sin($ax)+$r*sin($a))*h/2}
        ellipse. $cx,$cy,$2%,$2%,0,-1,1
      done
      t+={$4%}
    done
  endl done
  & 255 if $10 map {$10-1} fi

#@gui Superformula : fx_superformula, fx_superformula(1)
#@gui : Resolution = int(4096,2,8192)
#@gui : sep = separator()
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : sep = separator()
#@gui : M = int(8,1,32)
#@gui : N1 = float(1,-32,32)
#@gui : N2 = float(5,-32,32)
#@gui : N3 = float(8,-32,32)
#@gui : sep = separator()
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : sep = separator()
#@gui : Thickness = float(3,0,50)
#@gui : Color = color(128,255,128,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/18/04</i>.</small>")
fx_superformula :
  repeat $! l[$>] to_rgba
    {w},{h}
    f3d {0.5*max(w,h)/tan($4*pi/360)}
    superformula3d $1,${4-7}
    r3d. 0,0,1,$10 r3d. 0,1,0,$9 r3d. 1,0,0,$8
    *3d. {0.5*$2*{-2,w}},{0.5*$3*{-2,h}}
    col3d. 1 j3d.. .,50%,50%,0,1,1,0,0 rm.
    distance. 1 >. $11% *.. . ==. 0
    r. 100%,100%,1,4
    sh. 0 *. $12 rm.
    sh. 1 *. $13 rm.
    sh. 2 *. $14 rm.
    sh. 3 *. $15 rm.
    +[-2,-1]
  endl done

#@gui Turbulence : fx_turbulence, fx_turbulence
#@gui : Radius = float(128,1,1024)
#@gui : Octaves = int(6,1,12)
#@gui : Damping per Octave = float(4,1,10)
#@gui : Difference Mixing = float(0,-10,10)
#@gui : Mode = choice("Turbulence","Turbulence 2","Fractal Noise","Fractured Clouds","Stardust","Pea Soup")
#@gui : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_turbulence :
  remove_opacity turbulence ${^0}


#@gui ____<b>Sequences</b>
#-------------------------

# fx_animate_preview : _command,_parameters1,_parameters2,_compute_half={ 0 | 1 },_width>=0,_height>=0
# Generate a preview with start/end rendering of an animation.
fx_animate_preview : skip ${4=1},${5=0},${6=$5}
  repeat $!
    if $5 width=$5 else width={w} fi
    if $6 height=$6 else height={h} fi
    if $4 s. x,2 else . fi
    -$1.. $2 -$1. $3   # Assume this is a 1->1 filter.
    r[-2,-1] {max(w,{-2,w})},{max(h,{-2,h})},1,100%,3
    if {!$4} columns.. 0,50% columns. 50%,100% fi
    a[-2,-1] x r. $width,$height,1,100%,2 drgba.
    line. 50%,0,50%,100%,1,0,0,0,255
    to. "Start",3,-1,13,2,1,255 to. "End",{w-24},{h-18},13,2,1,255
  mv. 0 done

#@gui 3D Elevation [Animated] : fx_animate_elevation3d, fx_animate_elevation3d_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global parameters :</b>"}
#@gui : Factor = float(100,-1000,1000)
#@gui : Smoothness = float(1,0,10)
#@gui : Width = _int(1024,8,4096)
#@gui : Height = _int(1024,8,4096)
#@gui : Rendering = choice(2,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,1440)
#@gui : Y-Angle = float(0,0,1440)
#@gui : Z-Angle = float(360,0,1440)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_elevation3d : skip "${4=}"
  if $3 filename="$4/gmic_elevation3d.png" else filename="" fi
  _fx_elevation3d ${5-6}
  animate fx_render3d,"${7-8},${10-19},$9",\
                      "${7-8},${20-29},$9",$1,$2,{``$filename}

fx_animate_elevation3d_preview : skip "${4=}"
  w={w} h={h}
  _fx_elevation3d ${5-6}
  fx_animate_preview fx_render3d,$w","$h",${10-19},$9",\
                                      $w","$h",${20-29},$9",0,$w,$h

#@gui 3D Extrusion [Animated] : fx_animate_extrude3d, fx_animate_extrude3d_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global parameters :</b>"}
#@gui : Depth = float(10,1,256)
#@gui : Resolution = int(512,1,1024)
#@gui : Smoothness = float(0.6,0,3)
#@gui : Width = _int(1024,8,4096)
#@gui : Height = _int(1024,8,4096)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Size = float(0.8,0,3)
#@gui : X-Angle = float(35,0,1440)
#@gui : Y-Angle = float(360,0,1440)
#@gui : Z-Angle = float(0,0,1440)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_extrude3d : skip "${4=}"
  if $3 filename="$4/gmic_extrude3d.png" else filename="" fi
  _fx_extrude3d ${5-7}
  animate fx_render3d,"${8-9},${11-20},$10",\
                      "${8-9},${21-30},$10",$1,$2,{``$filename}

fx_animate_extrude3d_preview : skip "${4=}"
  w={w} h={h}
  _fx_extrude3d ${5-7}
  fx_animate_preview fx_render3d,$w","$h",${11-20},$10",\
                                      $w","$h",${21-30},$10",0,$w,$h

#@gui 3D Image Object [Animated] : fx_animate_imageobject3d, fx_animate_imageobject3d_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global parameters :</b>"}
#@gui : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gui : Width = _int(1024,1,4096)
#@gui : Height = _int(1024,1,4096)
#@gui : Rendering = choice(4,"Dots","Wireframe","Flat","Flat-Shaded","Gouraud","Phong")
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,360)
#@gui : Y-Angle = float(41,0,360)
#@gui : Z-Angle = float(21,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Size = float(0.5,0,3)
#@gui : X-Angle = float(57,0,1440)
#@gui : Y-Angle = float(401,0,1440)
#@gui : Z-Angle = float(21,0,1440)
#@gui : FOV = float(45,1,90)
#@gui : X-Light = float(0,-100,100)
#@gui : Y-Light = float(0,-100,100)
#@gui : Z-Light = float(-100,-100,0)
#@gui : Specular Lightness = float(0.5,0,1)
#@gui : Specular Shininess = float(0.7,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_imageobject3d : skip "${4=}"
  if $3 filename="$4/gmic_imageobject3d.png" else filename="" fi
  _fx_imageobject3d "_",$5
  animate fx_render3d,"${6-7},${9-18},$8",\
                      "${6-7},${19-28},$8",$1,$2,{``$filename}

fx_animate_imageobject3d_preview : skip "${4=}"
  w={w} h={h}
  _fx_imageobject3d "_preview_",$5
  fx_animate_preview fx_render3d,$w","$h",${9-18},$8",\
                                      $w","$h",${19-28},$8",0,$w,$h

#@gui 3D Text Pointcloud : fx_text_pointcloud3d, fx_text_pointcloud3d_preview
#@gui : Frames = _int(64,1,256)
#@gui : 1st Text = text("G'MIC")
#@gui : 2nd Text = text("Rocks!")
#@gui : Smoothness = float(1,0,5)
#@gui : Color = color(200,220,255)
#@gui : Background = color(255,255,255,255)
#@gui : X-Shadow= float(2,0,10)
#@gui : Y-Shadow= float(2,0,10)
#@gui : Shadow Smoothness = float(1,0,5)
#@gui : Stationary Frames = _int(19,1,32)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/01/09</i>.</small>")
fx_text_pointcloud3d :
  W={w} H={h} M={round(1.5*max(w,h))} rm
  text_pointcloud3d "$2","$3",$4
  col3d. ${5-7} *3d. {0.7*$M}
  f3d 4000 db3d 0 m3d
  repeat $1
    rprogress {60*$>/$1}
    angle={$>*360/$1}
    +r3d[0] 1,0,1,$angle
    $M,$M,1,3,-1 j3d. ..,50%,50%,0,1 rm..
  done
  rm[0] a z autocrop -1 to_rgba s z replace_color 0,0,-1,-1,-1,255,0,0,0,0
  if $11 N=$! repeat $! l[$>] rprogress {60+40*$>/$N}
    i[0] 100%,100%,1,4 fc[0] ${8-11} +channels. 3,3 +negate. b[-2,-1] $14% to_rgba.
    j[0] .,$12%,$13%,0,0,1,..,255 rm[-2,-1] blend alpha
  endl done fi
  if {$W>$H} r2dx $W else r2dy $H fi
  if {$15>1}
    i[{int($1/2)}] [{int($1/2)}]x{$15-1}
    i[0] [0]x{$15-1}
  fi

fx_text_pointcloud3d_preview :
  fx_text_pointcloud3d 4,"$2","$3",$4,${5-7},${8-11},${12-14},1 drgba
  frame 1,1,0 append_tiles 2,2

#@gui 3D Tiles : fx_transition3d, fx_transition3d_preview(0)
#@gui : Inter-Frames = _int(10,3,100)
#@gui : X-Tiles = int(8,1,64)
#@gui : Y-Tiles = int(8,1,64)
#@gui : X-Rotation = text("1")
#@gui : Y-Rotation = text("1")
#@gui : Z-Rotation = text("0")
#@gui : Focale = float(800,100,2000)
#@gui : Enable Antialiasing = bool(1)
#@gui : sep = separator(), note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2012/13/08</i>.</small>")
fx_transition3d :
  f3d $7
  transition3d $1,$2,$3,"$4","$5","$6",$8

fx_transition3d_preview :
  if {$!==1} gui_warning_preview "Missing input layer" return fi
  f3d $7
  k[0,1] transition3d 4,$2,$3,"$4","$5","$6",$8
  k[1,2]
  r[0] 50%,100%,1,100%,0
  r[1] 50%,100%,1,100%,0,0,1
  a x
  line 50%,0,50%,100%,1,0,0,0,255

#@gui B&amp;W Pencil [Animated] : fx_animate_pencilbw, fx_animate_pencilbw_preview(0)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Pencil Type = float(2.3,0,5)
#@gui : Amplitude = float(100,0,200)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Pencil Type = float(0.3,0,5)
#@gui : Amplitude = float(60,0,200)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_pencilbw : skip "${4=}"
  if $3 filename="$4/gmic_pencilbw.png" else filename="" fi
  animate pencilbw,"${5-6}",\
                   "${7-8}",$1,$2,{``$filename}

fx_animate_pencilbw_preview : skip "${4=}"
  fx_animate_preview pencilbw,"${5-6}",\
                                 "${7-8}"

#@gui B&amp;W Stencil [Animated] : fx_animate_stencilbw, fx_animate_stencilbw_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Edge Threshold = float(10,0,30)
#@gui : Smoothness = float(10,0,30)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Edge Threshold = float(10,0,30)
#@gui : Smoothness = float(20,0,30)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_stencilbw : skip "${4=}"
  if $3 filename="$4/gmic_stencilbw.png" else filename="" fi
  animate stencilbw,"${5-6}",\
                    "${7-8}",$1,$2,{``$filename}

fx_animate_stencilbw_preview : skip "${4=}"
  fx_animate_preview stencilbw,"${5-6}",\
                                  "${7-8}"

#@gui Cartoon [Animated] : fx_animate_cartoon, fx_animate_cartoon_preview(0)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global Parameters :</b>"}
#@gui : Color Quantization = int(4,2,256)
#@gui : note = note{"\n<b>Starting parameters :</b>"}
#@gui : Smoothness = float(0.5,0,2)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge Threshold = float(10,1,30)
#@gui : Edge Thickness = float(0.1,0,1)
#@gui : Color Strength = float(1.5,0,3)
#@gui : note = note{"\n<b>Ending parameters :</b>"}
#@gui : Smoothness = float(3,0,2)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge Threshold = float(10,1,30)
#@gui : Edge Thickness = float(0.1,0,1)
#@gui : Color Strength = float(1.5,0,3)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_cartoon : skip "${4=}"
  if $3 filename="$4/gmic_cartoon.png" else filename="" fi
  animate cartoon,"${6-10},$5",\
                  "${11-15},$5",$1,$2,{``$filename}

fx_animate_cartoon_preview : skip "${4=}"
  fx_animate_preview cartoon,"${6-10},$5",\
                                "${11-15},$5"

#@gui Edges [Animated] : fx_animate_edges, fx_animate_edges_preview(0)
#@gui : Frames = _int(10,2,100)
#@gui : Output Frames = _bool(1)
#@gui : Output Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Global Parameters :</b>"}
#@gui : Negative Colors = bool(0)
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Smoothness = float(0,0,10)
#@gui : Edge Threshold = float(10,0,30)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Smoothness = float(0,0,10)
#@gui : Edge Threshold = float(30,0,30)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_edges : skip "${4=}"
  if $3 filename="$4/gmic_edges.png" else filename="" fi
  animate fx_edges,"${6-7},$5",\
                   "${8-9},$5",$1,$2,{``$filename}

fx_animate_edges_preview : skip "${4=}"
  fx_animate_preview fx_edges,"${6-7},$5",\
                                   "${8-9},$5"

#@gui Edges on Fire : fx_fire_edges, fx_fire_edges_preview(0)
#@gui : Edges = float(0.7,0,3)
#@gui : Attenuation = float(0.25,0,1)
#@gui : Smoothness = float(0.5,0,5)
#@gui : Threshold = float(25,0,100)
#@gui : sep = separator()
#@gui : Number of Frames = _int(20,1,999)
#@gui : Starting Frame = int(20,0,199)
#@gui : Frame Skip = _int(0,0,20)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/06/07</i>.</small>")
fx_fire_edges :
  fire_edges ${1-7} rv

fx_fire_edges_preview :
  gui_split_preview "fire_edges $1,$2,$3,$4,1,$6,0",${-3--1}

#@gui Lava Lamp : fx_lavalampbw, fx_lavalampbw_preview(0)
#@gui : Number of Key-Frames = _int(3,2,50)
#@gui : Number of Inter-Frames = _int(30,2,100)
#@gui : Smooth Looping = _bool(1)
#@gui : sep = separator()
#@gui : Resolution = float(20,1,100)
#@gui : Size = float(2,0,30)
#@gui : Smoothness = _float(0.01,0,1)
#@gui : Transparent Background = bool(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/06/07</i>.</small>")
fx_lavalampbw :
  if {!$!} (255;100^64;16^128;0) r. 512,512,1,3,3 fi
  repeat $! l[$<] remove_opacity
    w={w} h={h}
    +r $4%,$4%,1,1,0 [-1]x{$1-1} rand[^0] 0,1 stencil[^0] $5,0
    if $3 [1] fi
    morph[^0] $2,$6,0
    stencil[^0] $5,0
    r[^0] $w,$h,1,1,3 b[^0] 10 >=[^0] 50% *[^0] 255
    r[^0] 100%,100%,1,4 j[^0] [0] rm[0]
    if $3 rm. fi
  endl done
  if {!$7} repeat $! l[$>] split_opacity n. 0,1 *[^-1] . rm. endl done fi

fx_lavalampbw_preview :
  fx_lavalampbw 2,2,1,$4,$5,$6,$7 k[0]

#@gui Lissajous [Animated] : fx_animate_lissajous, fx_animate_lissajous_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : sep = separator()
#@gui : note = note{"<b>Starting parameters :</b>"}
#@gui : Resolution = int(4096,2,8192)
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : Z-Size = float(3,1,10)
#@gui : X-Multiplier = float(8,0,32)
#@gui : Y-Multiplier = float(7,0,32)
#@gui : Z-Multiplier = float(0,0,32)
#@gui : X-Offset = float(0,0,1)
#@gui : Y-Offset = float(0,0,1)
#@gui : Z-Offset = float(0,0,1)
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : Thickness = float(0,0,50)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator()
#@gui : note = note{"<b>Ending parameters :</b>"}
#@gui : Resolution = int(4096,2,8192)
#@gui : X-Size = float(0.9,0,2)
#@gui : Y-Size = float(0.9,0,2)
#@gui : Z-Size = float(3,1,10)
#@gui : X-Multiplier = float(8,0,32)
#@gui : Y-Multiplier = float(7,0,32)
#@gui : Z-Multiplier = float(0,0,32)
#@gui : X-Offset = float(0,0,1)
#@gui : Y-Offset = float(0,0,1)
#@gui : Z-Offset = float(0,0,1)
#@gui : X-Angle = float(0,0,360)
#@gui : Y-Angle = float(0,0,360)
#@gui : Z-Angle = float(0,0,360)
#@gui : Thickness = float(0,0,50)
#@gui : Color = color(255,255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/18/04</i>.</small>")
fx_animate_lissajous : skip "${4=}"
  if $3 filename="$4/gmic_lissajous.png" else filename="" fi
  animate fx_lissajous,"${5-22}",\
                       "${23-40}",$1,$2,{``$filename}

fx_animate_lissajous_preview : skip "${4=}"
  fx_animate_preview fx_lissajous,"${5-22}",\
                                  "${23-40}",0

#@gui Rodilius [Animated] : fx_animate_rodilius, fx_animate_rodilius_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : Color Mode = choice(1,"Darker","Lighter")
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(5,2,20)
#@gui : Offset = float(0,0,180)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(5,2,20)
#@gui : Offset = float(180,0,180)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_rodilius : skip "${4=}"
  if $3 filename="$4/gmic_rodilius.png" else filename="" fi
  animate rodilius,"${6-10},$5",\
                   "${11-15},$5",$1,$2,{``$filename}

fx_animate_rodilius_preview : skip "${4=}"
  fx_animate_preview rodilius,"${6-10},$5",\
                              "${11-15},$5"

#@gui Soft Glow [Animated] : fx_animate_glow, fx_animate_glow_preview(1)
#@gui : Frames = _int(10,2,100)
#@gui : Output as Frames = _bool(1)
#@gui : Output as Files = _bool(0)
#@gui : Output Folder = _folder()
#@gui : note = note{"\n<b>Starting Parameters :</b>"}
#@gui : Amplitude = float(0,0,8)
#@gui : note = note{"\n<b>Ending Parameters :</b>"}
#@gui : Amplitude = float(3,0,8)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_animate_glow : skip "${4=}"
  if $3 filename="$4/gmic_glow.png" else filename="" fi
  animate glow,"$5",\
               "$6",$1,$2,{``$filename}

fx_animate_glow_preview : skip "${4=}"
  fx_animate_preview glow,"$5",\
                          "$6"

#@gui Spatial Transition : fx_spatial_transition, fx_spatial_transition_preview(1)
#@gui : Number of Added Frames = _int(10,1,256)
#@gui : Shading (%) = float(0,0,100)
#@gui : Transition Shape = choice(7,"Bottom Layer","Top Layer","Custom Formula","Horizontal","Vertical","Angular","Radial","Plasma")
#@gui : Custom Formula = text{"cos(x*y/(16+32*A))"}
#@gui : A-Value = float(0,0,1)
#@gui : sep = separator()
#@gui : Preview Type = choice(1,"Transition Map","Timed Image","Sequence x4","Sequence x6","Sequence x8")
#@gui : Preview Time = float(0.5,0,1)
#@gui : Preview = value(0)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/10/04</i>.</small>")
fx_spatial_transition :
  to_rgba r ${-max_wh},1,100%,0,0,0.5,0.5
  shape=-1 formula=
  if {$3==0} # Do nothing.
  elif {$3==1} shape=0
  elif {$3==2} formula="$4"
  elif {$3==3} formula="sin(x*0.5*pi/w*(1+100*A))"
  elif {$3==4} formula="sin(y*0.5*pi/h*(1+100*A))"
  elif {$3==5} formula="atan2(y-h/2,x-w/2)%((1-A)*2*pi+0.001)"
  elif {$3==6} formula="R=0.5*sqrt(w*w+h*h);sqrt((y-h/2)^2+(x-w/2)^2)%(0.001+R*(1-A))"
  elif {$3==7} 100%,100% plasma. 1,1,{8/(1+$5)} equalize. 1024
  fi
  if {narg($formula)}
    {w},{h},1,1,"A=$5;"$formula fi
  if $-1 # Preview mode.
    if {$6==0} k[$shape] norm n 0,255
    elif {$6==1" && "$7==0} rm[$shape] rm.
    elif {$6==1" && "$7==1} rm[$shape] rm[0]
    elif {$6==1}
      transition[^$shape] [$shape],$1,$2,$7*($1-1) rm[$shape] rm[0--1:2]
    else
      transition[^$shape] [$shape],{$6*2},$2 rm[$shape] to_rgba
    fi
    if {$!>1} to_rgba frame 2%,2%,0,0,0,0 append_tiles , fi
  else # Apply mode.
    transition[^$shape] [$shape],$1,$2
    rm.
  fi
  nm name(transition),pos(0,0)
  if {narg($formula)} u "{$1}{$2}{$3}{\""$formula"\"}{$5}{$6}{$7}{0}" fi

fx_spatial_transition_preview :
  if {($3<=1" && "$!<3)" || "($3>1" && "$!<2)} gui_print_preview "Warning:",,"This filter requires more input layers to work properly." return fi
  fx_spatial_transition ${1-3},"$4",${5-7},1


#@gui ____<b>Silhouettes</b>
#---------------------------

#@gui <i>Misc</i>

#@gui Cupid : fx_cupid, fx_cupid_preview
#@gui : Size (%) = float(75,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/01/08</i>.</small>")
fx_cupid :
  max_wh={$!>0?[${-max_wh}]:[512,512]}
  w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
  l[]
    shape_cupid {($7?2:1)*min($w,$h)}
    if $7 r2dx 50% fi
    frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
    100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
    gui_set_layer_name "Heart"
    gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
  endl
  mv. 0

fx_cupid_preview :
  fx_cupid $* blend[^0] [0],alpha rm[0]

#@gui Gear : fx_gear, fx_gear_preview
#@gui : Size (%) = float(75,0,100)
#@gui : Number of Teeth = int(12,1,96)
#@gui : Elevation (%) = float(15,0,100)
#@gui : Angle (%) = float(0,0,100)
#@gui : Inner Radius (%) = float(40,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/01/08</i>.</small>")
fx_gear :
  max_wh={$!>0?[${-max_wh}]:[512,512]}
  w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
  l[]
    shape_gear {($11?2:1)*min($w,$h)},${2-5}
    if $11 r2dx 50% fi
    frame {2.5*$6}%,{2.5*$6}%,0 b $6% * $10 round c 0,255 autocrop
    100%,100%,1,3 fc. ${7-9} rv[-2,-1] a c
    gui_set_layer_name "Gear"
    gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
  endl
  mv. 0

fx_gear_preview :
  fx_gear $* blend[^0] [0],alpha rm[0]

#@gui Heart : fx_heart, fx_heart_preview
#@gui : Size (%) = float(75,0,100)
#@gui : Smoothness = float(0,0,10)
#@gui : Color = color(255,255,255,255)
#@gui : Antialiasing = bool(1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2018/01/08</i>.</small>")
fx_heart :
  max_wh={$!>0?[${-max_wh}]:[512,512]}
  w,h={S=[$max_wh]*$1%;[max(S[0],1),max(S[1],1)]}
  l[]
    shape_heart {($7?2:1)*min($w,$h)}
    if $7 r2dx 50% fi
    frame {2.5*$2}%,{2.5*$2}%,0 b $2% * $6 round c 0,255 autocrop
    100%,100%,1,3 fc. ${3-5} rv[-2,-1] a c
    gui_set_layer_name "Heart"
    gui_set_layer_pos {0.5*([$max_wh]-[w,h])}
  endl
  mv. 0

fx_heart_preview :
  fx_heart $* blend[^0] [0],alpha rm[0]

#@gui Sierpinski Triangle : fx_sierpinski, fx_sierpinski(1)
#@gui : Recursions = int(6,0,10)
#@gui : 1st X-Coord = float(50,0,100)
#@gui : 1st Y-Coord = float(0,0,100)
#@gui : 2nd X-Coord = float(0,0,100)
#@gui : 2nd Y-Coord = float(100,0,100)
#@gui : 3rd X-Coord = float(100,0,100)
#@gui : 3rd Y-Coord = float(100,0,100)
#@gui : Color = color(255,255,255)
#@gui : Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_sierpinski :
  repeat $! l[$>] split_opacity l[0]
    100%,100% sierpinski. ${1-7}
    +fc.. $8,$9,$10 j[0] .,0,0,0,0,$11,..,255 rm[-2,-1]
  endl a c endl done

#@gui _<i>Nature</i>

#@gui Barnsley Fern : fx_barnsley_fern, fx_barnsley_fern_preview(1)
#@gui : Type = choice("Asplenium Adiantum-Nigrum","Thelypteridaceae")
#@gui : Density (%) = float(100,0,300)
#@gui : Angle = float(30,-180,180)
#@gui : Opacity (%) = float(40,0,100)
#@gui : Color = color(10,178,0,255)
#@gui : Add as a New Layer = _bool(1)
#@gui : sep = separator()
#@gui : note = note("This filter renders the Barnsley fern fractal, described here:")
#@gui : url = link("https://en.wikipedia.org/wiki/Barnsley_fern")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/18/10</i>.</small>")
fx_barnsley_fern :
  repeat $! l[$<]
    shape_fern {min(w,h)},$2%,$3,{$4%},$1 *. 255
    100%,100%,1,3,[${5-7}]
    rv[-2,-1] a[-2,-1] c
    if {!$9} blend alpha,{$8/255}
    else nm. "name(Barnsley Fern),opacity("{round($8*100/255)})")" rv[-2,-1]
    fi
  endl done

fx_barnsley_fern_preview :
  fx_barnsley_fern ${1-8},0

#@gui Snowflake : fx_snowflake, fx_snowflake(1)
#@gui : Recursions = int(5,0,6)
#@gui : Opacity = float(1,0,1)
#@gui : Color = color(255,255,255)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_snowflake :
  repeat $! l[$>] to_color split_opacity l[0]
    shape_snowflake {min(w,h)},$1 100%,100%,1,3,[${3-5}]
    j[0] .,{([w#0,h#0]-[w#1,h#1])/2},0,0,$2,.. k[0]
  endl a c endl done

#@gui ____<b>Various</b>
#------------------------

#@gui Custom Code [Local] : fx_custom_code, fx_custom_code_preview(0)
#@gui : Code = text(1,"repeat $! l[$>]\n\n  to_rgb\n  +deform 20\n  blend_edges 3\n\n-endl done\n\n\n")
#@gui : sep = separator()
#@gui : sep = separator(), Channel(s) = choice{"None (Allows Multi-layers)","All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]"}
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : Display Debug Info on Preview = bool(0)
#@gui : Debug Font Size = choice(2,"Tiny","Small","Normal","Large")
#@gui : sep = separator(), Preview Type = choice{"Full (Allows Multi-Layers)","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"}, Preview Split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note: </b>
#@gui : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gui : Here, you can then test some commands before creating your own G'MIC custom commands and plug-in menu entries.\n\n
#@gui : Please look at the documentation reference web page :</small>"}
#@gui : url = link("https://gmic.eu/reference.shtml")
#@gui : note = note{"<small>
#@gui : to learn more about available <b>G'MIC</b> commands.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/03/10</i>.</small>")

#@gui Custom Code [Global] : fx_custom_code, fx_custom_code_preview(1)
#@gui : Code = text(1,"repeat $! l[$>]\n\n  to_rgb\n  +deform 20\n  blend_edges 3\n\n-endl done\n\n\n")
#@gui : sep = separator(), Channel(s) = choice{"None (Allows Multi-layers)","All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]"}
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : Display Debug Info on Preview = bool(0)
#@gui : Debug Font Size = choice(2,"Tiny","Small","Normal","Large")
#@gui : sep = separator(), Preview Type = choice{"Full (Allows Multi-Layers)","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"}, Preview Split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note{"<small><b>Note: </b>
#@gui : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gui : Here, you can then test some commands before creating your own G'MIC custom commands and plug-in menu entries.\n\n
#@gui : Please look at the documentation reference web page :</small>"}
#@gui : url = link("https://gmic.eu/reference.shtml")
#@gui : note = note{"<small>
#@gui : to learn more about available <b>G'MIC</b> commands.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/03/10</i>.</small>")
fx_custom_code : skip "${1=-skip ,}"
  m "_fx_custom_code_start : $1"
  if $4
    _nb_in=$!
    _dim_in="" sep="" repeat $! l[$>] _dim_in=$_dim_in$sep"["$>"] = "{w}x{h}x{d}x{s}", in ["{_round([im,iM],0.1)}"]" sep="\n" endl done
  fi
  if $2
    ac "_fx_custom_code_start _status_out=${}",{$2-1},$3
  else
    _fx_custom_code_start _status_out=${}
    if {$3==1} c 0,255 elif {$3==2} n 0,255 fi
  fi
  if $4
    _nb_out=$!
    _dim_out="" sep="" repeat $! l[$>]
      _dim_out=$_dim_out$sep"["$>"] = "{w}x{h}x{d}x{s}", in ["{_round([im,iM],0.1)}"]" sep="\n" endl done
  fi
  uncommand _fx_custom_code_start

fx_custom_code_preview : skip "${1=-skip ,}"
  w={w} h={h}
  l
    _gcp_arg="$1"
     if $6 gui_split_preview "fx_custom_code $_gcp_arg,${2--2}",${-3--1}
     else fx_custom_code $_gcp_arg,${2--2}
     fi
  onfail
    error_msg=${}
    rr2d $w,$h,2,1
    gui_print_preview "Syntax error:",,{``$error_msg},20,40
  endl
  if $4 # Display debug infos on preview
    if {!$3} % 256 fi
    if {$_preview_mode>=4} gui_preview fi
    siz0=13 siz1=17 siz2=19 siz3=22
    if {['$_status_out']==0} _status_out=(empty) fi
    info="Input images: "#$_nb_in"\n"\
         $_dim_in"\n\n"\
         "Output images: "#$_nb_out"\n"\
         $_dim_out"\n\n"\
         "Output status: "$_status_out
    0 t. {``$info},0,0,${siz$5},1,255 expand_xy. 5,0 +dilate. 3 a[-2,-1] c
    rr2d[^-1] ${-max_wh},2,2
    r. ..,..,1,100%,0 drgba[^-1]
    /[^-1] 2 blend[^-1] .,alpha rm.
  fi

#@gui Games &amp; Demos : fx_gmic_demos, fx_gmic_demos_preview
#@gui : Selection = choice("2048","Blobs Editor","Bouncing Balls","Connect-Four","Fire Effect","Fireworks","Fish-Eye Effect","Fourier Filtering","Hanoi Tower",
#@gui : "Histogram","Hough Transform","Jawbreaker","Virtual Landscape","The Game of Life","Light Effect","Mandelbrot Explorer","3D Metaballs","Minesweeper",
#@gui : "Minimal Path","Pacman","Paint","Plasma Effect","RGB Quantization","3D Reflection","3D Rubber Object","Shadebobs","Spline Editor",
#@gui : "3D Starfield","Tetris","Tic-Tac-Toe","3D Waves","Fractal Whirl")
#@gui : sep = separator()
#@gui : note = note("<small><b>Note:</b> This filter proposes a showcase of some interactive demos, all written as G'MIC scripts.
#@gui : </small>")
#@gui : note = note{"<small>On most demos, you can use the keyboard shortcut <b>CTRL+D</b> to double the window size (and <b>CTRL+C</b> to go back to the original size).
#@gui : Also, feel free to use the mouse buttons, as they are often used to perform an action.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2014/10/09</i>.</small>")
fx_gmic_demos :
  coms=2048,blobs,bouncing,connect4,fire,fireworks,fisheye,fourier,hanoi,histogram,hough,jawbreaker,landscape,life,light,\
       mandelbrot,metaballs3d,minesweeper,minimal_path,pacman,paint,plasma,quantize_rgb,reflection3d,\
       rubber3d,shadebobs,spline,starfield3d,tetris,tictactoe,waves,whirl
  com=${arg\ {1+$1},$coms}
  if {$!>0} sel=0 else sel= fi
  +l[$sel] m "foo : x_"$com foo rm uncommand foo endl

fx_gmic_demos_preview :
  rm filename=${-path_tmp}gmic_demos.cimgz
  if $filename $filename
  else l[] https://gmic.eu/img/gmic_demos.cimgz o $filename endl
  fi
  k[$1,-1] rows. $1 map[0] [1] k[0]

#@gui Histogram Analysis : _none_, fx_display_histogram(1)
#@gui : Number of Clusters = int(256,2,1024)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2016/20/06</i>.</small>")
fx_display_histogram :
  mode=${arg\ 1+$2,all,rgba,rgb,rgb_r,rgb_g,rgb_b,rgba_a,\
             lrgb,lrgb_r,lrgb_g,lrgb_b,\
             ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
             lab_l,lab_ab,lab_a,lab_b,\
             lch_ch,lch_c,lch_h,\
             hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
             cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
             yiq_y,yiq_iq}
  _ac_$mode m "_ac_precond : "$_p m "_ac_forward : "$_f m "_ac_backward : "$_b
  repeat $! l[$>]
    _ac_precond _ac_forward[0] channels $_s
    display_histogram {w},{h},$1,0,255
    if {s==2" || "s==4} channels 0,2 fi
  endl done

#@gui Import Data : fx_import_image, gui_no_preview
#@gui : Filename = filein()
#@gui : Normalize = bool(1)
#@gui : note = note{"\n<small><b>Note: </b>
#@gui : This filter can import any image data read by the <b>G'MIC</b> language interpreter.
#@gui : It includes exotic formats as : <i>Pandore, CImg, Inrimage, AVI/MPEG (requires FFMPEG installed), ...</i>
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_import_image : skip "${1=}"
  rm i "$1" s z if $2 n 0,255 else c 0,255 fi

#@gui Intarsia : fx_intarsia, fx_intarsia_preview
#@gui : note = note{"<small><b>Note:</b>
#@gui : Intarsia is a method of Crochet/Knitting with a number of colours, in which a separate ball of yarn
#@gui : is used for each area of colour.
#@gui : This filter creates a HTML version of a graph chart which is solely used for this purpose
#@gui : </small>"}
#@gui : sep = separator()
#@gui : Output Directory = _folder("")
#@gui : Output HTML File = _text("intarsia.html")
#@gui : sep = separator()
#@gui : Maximum Image Size = int(512,2,1024)
#@gui : Maximum Number of Image Colors = _int(12,2,64)
#@gui : Starting Point = choice(1,"Top Left","Top Right","Bottom Left","Bottom Right")
#@gui : Loop Method = choice("Row by Row","Column by Column")
#@gui : sep = separator()
#@gui : Add Comment Area in HTML Page = _bool(1)
#@gui : Preview Progress (%) = float(100,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2015/09/07</i>.</small>")
fx_intarsia :
  to_rgb repeat $! nm=${gui_layer_name[$>]} +l[$>]

    # Constrain image for size and number of colors, and index it with colormap.
    if {max(w,h)>$3} rr2d $3,$3,0 fi
    +colormap 0
    if {w>$4} rm. +colormap $4,1 fi
    round[1] index[0] [1]

    # Output header and title.
    0 nm. $nm ({'{b}'}) f. 'if(x,i,if(i>=97&&i<=122,i-32,i))' image_basename={t} rm[-2,-1]
    ({'"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\
        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\
        <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n\
        <head></head><body bgcolor=\"#FFFDFF\"><center><font size=\"-1\">\n\
        <h2>"$image_basename" ("{0,w}x{0,h}")</h2>\n\
        <table border=\"0\" cellpadding=\"8\"><tr><td>\n\
        <table border=\"0\" cellpadding=\"4\">\n"'})

    # Render image of colors.
    0 nm. "$2" image_name={b} rm.
    nb_cols={1,w}
    repeat $nb_cols
      color={1,I($>)}
      R={arg(1,$color)} G={arg(2,$color)} B={arg(3,$color)}
      ({'${dec2hex\ {$R*65536+$G*256+$B}}'}) -. {'0'} r. 6,1,1,1,0,0,1,0 +. {'0'}
      f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
      hcolor={t} rm.
      48,32,1,4 fc. $color,255 frame. 1,1,0,0,0,255 o. "$1/"${image_name}_$>.png rm.
      ({'"<tr><td><b>Colour "$>"</b></td><td><img src=\""${image_name}_$>.png"\" /></td><td>#"$hcolor"</td></tr>\n"'})
    done
    ({'"</table>\n</td><td>"'})

    # Render result and overview images.
    starting=${"arg {1+$5},\"Top left\",\"Top right\",\"Bottom left\",\"Bottom right\""}
    label=${"arg {1+$6},Row,Column"}
    if $6 dir0="T &#8594; B" dir1="B &#8594; T" else dir0="L &#8594; R" dir1="R &#8594; L" fi
    dir={arg(1+2*$5+$6,0,0,1,0,0,1,1,1)}

    +map[0] [1]
    +fx_intarsia_preview. ${1-7},63 drgba.
    rr2d.. 200,200,1,1
    to_rgba[-2,-1] frame[-2,-1] 1,1,0,0,0,255 frame[-2,-1] 0,20,0,0,0,0
    t.. "Result",0,0,16,1,0,0,0,255
    t. "Ordering overview",0,0,16,1,0,0,0,255
    frame[-2,-1] 20,20,0,0,0,0

    o.. "$1/"${image_name}_A.png
    o. "$1/"${image_name}_B.png
    rm[-2,-1]

    ({'"<table border=\"0\"><tr><td><img src=\""${image_name}_A.png"\" /></td></tr><tr><td><img src=\""${image_name}_B.png"\" /></td></tr></table></td></tr></table>\n"'})
    if $7 ({'"<p><b>Additional comments:</b><br/><textarea cols=\"80\" rows=\"10\" placeholder=\"Enter comments here...\"></textarea></p>\n"'}) fi
    ({'"<p><b>Starting point:</b> "$starting"\
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Orientation:</b> "$label" by "$label"</p>\n"'})
    rm[1]

    # Output geometry.
    ({'"<table cellspacing=\"0\" cellpadding=\"4\" border=\"1\">\n"'})

    _fx_intarsia[0] $5,$6,0
    +l[0]
      s y
      repeat $! l[$>]
        if {$>%2} mirror. x fi
        im={im} compress_rle 0,0 rows 6,100%
        ({'"<tr><td valign=\"top\"><b>"$label" "{1+$>}"</b></td><td valign=\"top\">"${dir$dir}"</td><td>\n"'})
        i=0 n=0 do
          val={0,i[$i]} i+=1
          if {$val>=0} occ=1
          else
            occ={-$val}
            val={0,i[$i]}
            if {$val<0} val=0 else i+=1 fi
          fi
          val+=$im
          ({'"colour:<b>"$val"</b> "$occ'})
          if {0,$i<h} ({'", "'}) fi
          n+=1
          if {!($n%8)} ({'"<br/>\n"'}) fi
        while {0,$i<h}
        ({'"</td></tr>\n"'})
        rm[0] a x
        dir={!$dir}
      endl done
      a x
    endl
    rm[0]

    ({'"</table>\n</font></center>\n</body>"'})
    a x o raw:"$1/$2",uchar
    rm
  endl done

fx_intarsia_preview :
  to_rgb repeat $! l[$>]
    if {max(w,h)>$3} rr2d $3,$3,0 fi
    to_rgba
    _fx_intarsia $5,$6,0
    100%,100%,1,1,'if(y%2,y*w+w-1-x,y*w+x)<$8*wh/100' *
    if {min(w,h)<140} rr2d 140,140,1,1 fi
    expand_xy 16,0

    100%,100% circle. 16,16,1%,1,1
    arrow3d. 0,0,0,{w/4},0,0,2%,15%,10% col3d. 1 j3d.. .,16,16,0,1,2,0,0 rm.
    +dilate. 3 r.. 100%,100%,1,3,0,0,0,0,0,0.5 a[-2,-1] c *. 255
    blend alpha

    _fx_intarsia $5,$6,1
  endl done

_fx_intarsia :
  if {$3" && "$2} transpose fi
  if {$1==0} # Start from top left.
  elif {$1==1} # Start from top right.
    mirror x
  elif {$1==2} # Start from bottom left.
    mirror y
  elif {$1==3} # Start from bottom right.
    mirror xy
  fi
  if {!$3" && "$2} transpose fi

#@gui Sample Image : fx_image_sample, fx_image_sample_preview
#@gui : Input = choice{"Random","Apples","Barbara","Boats","Bottles","Butterfly","Cameraman","Car","Cat","Cliff","Colorful",
#@gui : "David","Dog","Duck","Eagle","Elephant","Earth","Flower","Fruits","Gmicky (Deevad)","Gmicky (Mahvin)","Gmicky & Wilber",
#@gui : "Greece","Gummy","House","Inside","Landscape","Leaf","Lena","Leno","Lion","Mandrill","Mona Lisa","Monkey","Parrots",
#@gui : "Pencils","Peppers","Roddy","Rooster","Rose","Square","Teddy","Tiger","Tulips","Wall","Waterfall","Zelda"}
#@gui : note = note("<small>Choosing <b>0</b> for parameters <i>Width</i> or <i>Height</i> means <i>Automatic</i>.</small>")
#@gui : Width = _int(0,0,1024)
#@gui : Height = _int(0,0,1024)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2017/16/01</i>.</small>")
fx_image_sample :
  if $1 sp {$1-1},$2,$3 else sp ?,$2,$3 fi
  mv. 0

fx_image_sample_preview :
  w={w} h={h} rm
  fx_image_sample $1,{$w>$h?$w:0},{$h>$w?$h:0}

#@gui Solve Maze : fx_solve_maze, fx_solve_maze_preview(1)
#@gui : Starting Point (%) = point(5,5)
#@gui : Ending Point (%) = point(95,95)
#@gui : Smoothness = float(0.1,0,1)
#@gui : Thickness = int(3,1,10)
#@gui : Color = color(255,0,0)
#@gui : Maze Type = choice("Dark Walls","White Walls")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest Update: <i>2011/01/09</i>.</small>")
fx_solve_maze :
  repeat $!
    +norm. >=. 50%
    if {!$10} negate. fi
    *. 255 +b. $5% *.. 1e10 +[-2,-1]
    minimal_path. $1%,$2%,0,$3%,$4%,0
    pointcloud. 0 dilate. $6 r. ..,..,1,1,0
    to_rgba.
    replace_color. 0,0,1,1,1,255,${7-9},255
    replace_color. 0,0,0,0,0,255,0,0,0,0
    ellipse. $1%,$2%,5,5,0,1,${7-9},255
    ellipse. $3%,$4%,5,5,0,1,${7-9},255
    rv[-2,-1]
  mv[-2,-1] 0 done

fx_solve_maze_preview :
  drgba
  line $1%,$2%,$3%,$4%,1,0xCCCCCCCC,${7-9}
  ellipse $1%,$2%,3,3,0,1,${7-9}
  ellipse $1%,$2%,3,3,0,1,0x1,0
  ellipse $3%,$4%,3,3,0,1,${7-9}
  ellipse $3%,$4%,3,3,0,1,0x1,0


#---------------------------------
#
#@cli :: Additional Gallery Images
#
#---------------------------------
#@cli gallery_arrays
#@cli : This entry defines some examples of array filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_frame_blur 30,30,0,5,0,0,128,128,128,0,5,255,255,255,2,2,1,0,0.5,0.5,0 _label="Frame~[blur]"
#@cli : $ sample tiger,leno,monkey,duck,eagle frame 3,3,0 frame 3,3,255 montage A _label="Montage"
#@cli : $ image.jpg fx_puzzle 5,5,0.5,0,0,0.3,100,0.2,255,100,0,0,0,0,0,0 _label="Puzzle"

#@cli gallery_artistic
#@cli : This entry defines some examples of artistic filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_engrave 0.5,4,0,7.68,15.2,0,0,1,10,1,0,0,0,1,0 gui_merge_layers _label="Engrave"
#@cli : $ image.jpg fx_bokeh 3,8,0,30,8,4,0.3,0.2,210,210,80,160,0.7,30,20,20,1,2,170,130,20,110,0.15,0 _label="Bokeh"
#@cli : $ image.jpg fx_8bits 25,800,16,0 _label="Oldschool~8bits"
#@cli : $ image.jpg fire_edges 0.7,0.25,0.5,25,20 _fps=6 _label="Edges~on~fire"
#@cli : $ image.jpg fx_diffusiontensors 10,5,3,1,0.15,1,0,3,0 _label="Diffusion~tensors"
#@cli : $ image.jpg fx_dreamsmooth 3,1,1,0.8,0,0.8,1,24,0 _label="Dream~smoothing"
#@cli : $ image.jpg fx_feltpen 300,50,1,0.1,20,5,0 _label="Felt~pen"
#@cli : $ image.jpg gtutor_fpaint 0.5,0.5,0,0,45,0.5,0.5,0.5,0 _label="Finger~paint"
#@cli : $ image.jpg fx_graphic_novelfxl 0,2,6,5,20,0,0.62,14,0,1,0.5,0.78,1.92,0,0,0,1,1,1,0.5,0.8,1.28 _label="Novel~FX"
#@cli : $ image.jpg fx_illustration_look 100,0,0,0,0 _label="Illustration~look"
#@cli : $ image.jpg fx_lylejk_painting 10,2,4,10,0 _label="Lylejk~painting"
#@cli : $ image.jpg fx_painting 5,2.5,1.5,50,1,0 _label="Painting"
##@cli : $ image.jpg fx_delaunay 5,75,1,3,0,0,0,128,1,1,0 _label="Polygonize~[delaunay]"
#@cli : $ image.jpg fx_posterize 150,30,1,6,0,0,1,0 _label="Posterize"
#@cli : $ image.jpg fx_quadtree 2,1024,1.05,0,2.33,0.68,0.39,1,0 _label="Quadtree~variations"
#@cli : $ image.jpg fx_vector_painting 9.37,0 _label="Vector~painting"

#@cli gallery_blackandwhite
#@cli : This entry defines some examples of black-and-white filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_freaky_bw 90,20,0,0,0,0 _label="Freaky~B&amp;W"
#@cli : $ image.jpg fx_engrave 0.5,50,0,8,40,0,0,0,10,1,0,0,0,1,0 _label="Engrave"
#@cli : $ image.jpg fx_gcd_layeretch 11,4,12,0.12,100,8.5,5,0,0,3,1,1,0 _label="Multi-layer~etch"
#@cli : $ image.jpg fx_pencil_portraitbw 30,120,1,0.5,144,79,21,0 _label="Pencil~portrait"
#@cli : $ image.jpg fx_gcd_etch 125,153,171,185,0.1,50,80,50,10,15,12,20,0,1,0.3,1,0,0 _label="Threshold~etch"

#@cli gallery_colors
#@cli : This entry defines some examples of color filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_color_abstraction 1,10,0.2,0 _label="Color~abstraction"
#@cli : $ image.jpg fx_boost_chroma 90,0,0 _label="Boost~chromaticity"
#@cli : $ image.jpg fx_retrofade 20,6,40,0 _label="Retro~fade"
#@cli : $ image.jpg fx_tk_vintage 2,0.85,0.7,80,200,5,147,26,161,0.3,235,220,176,0.4,190,181,108,0.2,0,0,100,0,0.3,25,0,0 _label="Vintage~style"

#@cli gallery_deformations
#@cli : This entry defines some examples of deformation filters for the G'MIC gallery page.
#@cli : $ image.jpg animate "flower","30,10,0,0","30,10,0,360",10 rm. _fps=6 _label="flower"
#@cli : $ image.jpg fx_conformal_maps 8,1,0,"((1.1 + i*z/6)/(1.04 - i*z/6))^6.2",0,0,0,0,0,3,0,0,"1024","1024" _label="Conformal~maps"
#@cli : $ image.jpg souphead_droste10 40,100,1,1,1,0,0,0,0,0,1,10,1,0,90,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0 _label="Continuous~droste"
#@cli : $ image.jpg fx_crease 30,10,3 _label="Crease"
#@cli : $ image.jpg fx_distort_lens 0.29,0,0.23,50,50,0,0 _label="Distort~lens"
#@cli : $ image.jpg fx_drop_water 0,20,2,80,0,3,35,10,1,0.5,0.25,0.5,0.75,0.05,0.15,1 gui_merge_layers _label="Drop~water"
#@cli : $ image.jpg fx_reflect 50,1,110,160,190,64,0,1.5,0,-3.3,7,1.5 _label="Reflection"
#@cli : $ image.jpg fx_square_circle 0,1,0,0,0,0,0,0 _label="Square~to~circle"
#@cli : $ image.jpg fx_textured_glass 40,40,1,1,0,2,0,0 _label="Textured~glass"
#@cli : $ sample lena,leno,320 morph 40 _fps=5 _label="morph"

#@cli gallery_filtering
#@cli : This entry defines some examples of filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_gcd_crt 1.8,1.8,0,0 equalize 256 _label="CRT~sub-pixels"
#@cli : $ image.jpg fx_dirty 30,1,0,0,0 _label="Dirty"
#@cli : $ image.jpg fx_freaky_details 2,10,1,11,0,32,0 _label="Freaky~details"
#@cli : $ image.jpg jeje_normalize_local_variance 50,5,5,1,0,0 _label="Local~variance~normalization"
#@cli : $ image.jpg fx_mighty_details 25,1,25,1,11,0 _label="Mighty~details"

#@cli gallery_patterns
#@cli : This entry defines some examples of pattern filters for the G'MIC gallery page.
#@cli : $ image.jpg fx_rain 65,10,50,0.1,1,1,0 gui_merge_layers _label="Rain~&amp;~snow"
#@cli : $ 400,400,1,3 fx_camouflage 9,12,100,30,46,33,75,90,65,179,189,117,255,246,158 _label="Camouflage"
#@cli : $ image.jpg jeje_clouds 50,0.5 _label="Clouds"
#@cli : $ image.jpg fx_crystal 50,0.2,20,0 _label="Crystal"
#@cli : $ 400,400,1,3 fx_crystal_background 10,25,0,100,1 _label="Crystal~background"
#@cli : $ image.jpg fx_marble 0.5,1,0,0,0.4,0.6,0.6,1.1,0,100 _label="Marble"
#@cli : $ image.jpg fx_mineral_mosaic 1,2,1,100,0 _label="Mineral~mosaic"
#@cli : $ image.jpg fx_shapes 1,16,10,2,5,106.8,2,0,0,1,0 _label="Op~art"
#@cli : $ 400,400,1,3 fx_satin 20,1,0,0,0,0,255,255,255,255,255,0,0,0,-50,0,0 _label="Satin"
#@cli : $ 400,400,1,3 fx_seamless_turbulence 15,20,0,1,3,1 _label="Seamless~turbulence"
#@cli : $ image.jpg fx_shockwaves 10,10,20,0,0 _label="Shock~waves"
#@cli : $ 400,400,1,3 fx_equation_parametric "sin(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)","cos(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)",0,100,4096,1,0,64,0,0,128,0,0,1,1,1 _label="Equation~plot~[parametric]"
#@cli : $ 400,400,1,3 KittyRings 30,8,0,1,113,0,113,0,255,0 _label="Kitaoka~spin~illusion"
#@cli : $ 400,400,1,3 fx_neon_lightning 50,50,0,50,50,100,50,0.7,3,130,80,50,0.25,0 _label="Neon~lighting"
#@cli : $ image.jpg fx_lava 8,5,3,0,0 _label="Lava"
#@cli : $ sample monkey,lion,monkey 100%,100% plasma. equalize. 256 transition[0,1,2] [3],10 rm. _fps=10 _label="transition"
#@cli : $ image.jpg fx_shapeism 2,7,0.38,0,1,5,32,8,3,1,5,0.5,1,0,0,0,255 _label="Shapeism"

#@cli gallery_3drendering
#@cli : This entry defines some examples of 3D rendering filters for the G'MIC gallery page.
#@cli : $ sample leno,lion,leno resize 400,400 transition3d 20,5,5 rm. _fps=10 _label="transition3d"
#@cli : $ 256,192 fx_text_pointcloud3d 64,"G'MIC","Rocks!",1,200,220,255,255,255,255,255,2,2,1,19 _fps=10 _label="3D~text~pointcloud"

#@cli gallery_stylization
#@cli : This entry defines some examples of image stylization for the G'MIC gallery page.
#@cli : $ sample car _fx_stylize starrynight _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Starry~Night"
#@cli : $ sample car _fx_stylize graytree _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Mondrian:~Gray~Tree"
#@cli : $ sample car _fx_stylize yellowredblue _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Kandinsky:~Yellow-Red-Blue"
#@cli : $ sample car _fx_stylize littlebayatlaciotat _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~Little~Bay~at~La~Ciotat"
#@cli : $ sample car _fx_stylize leviaducalestaque _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~Le~Viaduc~a~l'Estaque"
#@cli : $ sample car _fx_stylize greatwave _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Hokusai:~The~Great~Wave"
#@cli : $ sample elephant input ../img/hatching.png _output_mode=1 +fx_stylize 1,4,0,0,1,2,3,0.5,0.1,2,5,0,0.7,0,0,1,0,5,5,7,1,30,10,2,1.85,0 _label="from~Hatch Drawing"
#@cli : $ sample cat input ../img/hatching.png _output_mode=1 +fx_stylize 1,4,0,0,1,2,3,0.5,0.1,2,5,0,0.7,0,0,1,0,5,5,7,1,30,10,2,1.85,0 _label="from~Hatch Drawing"
#@cli : $ sample bottles _fx_stylize starrynight _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,1,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Starry~Night"
#@cli : $ sample cat _fx_stylize summertime9a _output_mode=1 +fx_stylize 1,6,0,0,2,0,1,0.5,0.1,2,5,0,0.7,0,2,1,0,5,5,7,1,130,1000,2,1.85,0 _label="from~Pollock:~Summertime~No~9A"
#@cli : $ sample cat _fx_stylize greatwave _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Hokusai:~The~Great~Wave"
#@cli : $ sample dog _fx_stylize convergence _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Pollock:~Convergence"
#@cli : $ sample dog _fx_stylize irises _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,1,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Irises"
#@cli : $ sample mandrill _fx_stylize themandola _output_mode=1 +fx_stylize 1,5,0,0,0,3,1,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~The~Mandola"
#@cli : $ sample square _fx_stylize orientalpleasuregardenanagoria _output_mode=1 +fx_stylize 1,6,0,0,0.52,0.5,3,0.14,0.1,2,5,0,0.7,3.39,0,1,0,5,5,7,5,30,100,2,1.85,0 _label="from~Klee:~Oriental~Pleasure~Garden~Anagoria"
#@cli : $ sample monalisa _fx_stylize squareswithconcentriccircles _output_mode=1 +fx_stylize 1,4,0,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Kandisnky:~Squares~with~Concentric~Circles"
#@cli : $ sample monalisa _fx_stylize inthestyleofkairouan _output_mode=1 +fx_stylize 1,4,2,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Klee:~In~the~Style~of~Kairouan"
#@cli : $ sample square _fx_stylize polyphony2 _output_mode=1 +fx_stylize 1,6,0,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Klee:~Polyphony~2"
#@cli : $ sample square _fx_stylize wheatstacksendofsummer _output_mode=1 +fx_stylize 1,6,0,0,0.15,3,2,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Monet:~Wheatstacks~-~End~of~Summer"
#@cli : $ sample square _fx_stylize portraitdemetzinger _output_mode=1 +fx_stylize 1,5,0,0,0.1,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Delaunay:~Portrait~de~Metzinger"
#@cli : $ sample monalisa input ../img/mandelbrot.jpg _output_mode=1 +fx_stylize 1,3,3,0,0.15,4,3,0.5,0.1,0,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Mandelbrot Fractal~Set"
#@cli : $ sample bottles _fx_stylize redtree _output_mode=1 +fx_stylize 1,5,0,0,2.12,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Mondrian:~Evening;~Red~Tree"
#@cli : $ sample bottles _fx_stylize redwaistcoat _output_mode=1 +fx_stylize 1,4,0,0,0.67,3.17,3,0.5,0.06,2,1,0,0.7,5,0,2,0,5,5,7,1,30,1090,2.05,1.85,0 _label="from~Klee:~Red~Waistcoat"
#@cli : $ sample bottles _fx_stylize reservoirhortadeebro _output_mode=1 +fx_stylize 1,6,0,0,0.5,2,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Picasso:~The~Reservoir"
#@cli : $ sample bottles _fx_stylize almondblossom _output_mode=1 +fx_stylize 1,6,0,0,0,3,3,0.5,0.1,2,5,0,0.7,5,0,2,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Van~Gogh:~Almond~Blossom"
#@cli : $ sample bottles _fx_stylize landscapenearantwerp _output_mode=1 +fx_stylize 1,6,0,0,2.17,3.65,3,0.5,0.1,2,5,0,0.7,1,0,1,0,5,5,7,1,30,1000,2,1.85,0 _label="from~Braque:~Landscape~near~Antwerp"
#@cli : $ sample bottles _fx_stylize wheatfieldwithcrows _output_mode=1 +fx_stylize 1,6,0,0,3.86,2,3,0.5,0.1,1,5,0,0.7,3.35,1,1,0,5,5,7,1,30,1000,5,1.85,0 _label="from~Van~Gogh:~Wheat~Field~with~Crows"

#@cli gallery_codesamples
#@cli : This entry defines some examples of coding-fun filters for the G'MIC gallery page.
#@cli : $ https://gmic.eu/samples/lissajous.gmic go _fps=10 _label="Lissajous"
#@cli : $ https://gmic.eu/samples/torus3d.gmic go _fps=10 _label="3D~torus"
#@cli : $ https://gmic.eu/samples/pacman.gmic go _fps=25 _label="Pacman"
#@cli : $ https://gmic.eu/samples/scrolling.gmic go _fps=25 _label="Scrolling"
#@cli : $ https://gmic.eu/samples/landscape.gmic go _fps=12 _label="Landscape"
#@cli : $ https://gmic.eu/samples/mandelbrot.gmic go _fps=8 _label="Mandelbrot"

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
